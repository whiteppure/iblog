---
title: "Java内部类"
date: 2025-08-20
draft: false
tags: ["Java", "Java基础"]
slug: "rookie-inner-class"
---



## 概述
内部类顾名思义是定义在另一个类内部的类，与之相对，包含内部类的类称为外部类。
内部类允许你将逻辑上相关的类组织在一起，并可以访问外部类的所有成员，从而提供了一种更彻底的封装方式。

内部类优点：
1. 直接访问外部类成员（包括私有字段），实现紧密数据交互。
2. 增强封装性，将仅服务于外部类的逻辑隐藏内部，减少代码暴露。
3. 简化回调机制（如事件监听），避免创建大量独立类文件。
4. 灵活组织代码，如迭代器、构建器模式等可内聚实现。

内部类缺点：
1. 内存泄漏风险：非静态内部类隐式持有外部类引用，若被长生命周期对象引用，会导致外部类无法回收。
2. 增加复杂度：多层嵌套降低可读性，反射/序列化更困难。
3. 限制性：局部和匿名内部类只能访问`final`的局部变量。

内部类与修饰符：

| 类型  |   可用修饰符|   说明|
|-----|---|---|
| 成员内部类 |   `public`, `protected`, `private`, `abstract`, `final`|   可以定义在类的成员位置，可以访问外部类的所有成员，不能有静态成员（除静态常量外）|
| 静态内部类 |   `public`, `protected`, `private`, `static`, `abstract`, `final`|   使用`static`修饰，不持有外部类引用，只能访问外部类的静态成员|
| 局部内部类 |   `abstract`, `final`|   定义在方法或代码块内，不能使用访问修饰符，可以访问`final`的局部变量|
| 匿名内部类 |   无显式修饰符|   没有类名，隐式`final`，不能使用任何显式修饰符，用于一次性实现接口或继承类|

## 静态内部类


## 成员内部类

## 局部内部类

## 匿名内部类
匿名内部类是一种没有名字的内部类。它被设计用于**只需使用一次的场景**：你需要定义一个类并立即创建它的一个实例，而这个类不需要有名字。
它的核心目的就是**简洁和即时，避免了为仅使用一次的类单独命名的麻烦**，可以理解为匿名内部类是没有名字的局部内部类。

它融合了类的继承/实现和实例的创建，经常用它来创建线程。
```java
public class Demo {
    public static void main(String[] args) {
        // 将定义类和创建实例合二为一
        Thread thread = new Thread(new Runnable() { // 这里是匿名内部类
            @Override
            public void run() { // 在此直接实现 run 方法
                System.out.println("线程运行了！（来自匿名内部类）");
            }
        }); // 注意这里的括号和分号
        thread.start();
    }
}
```

匿名内部类特点：
1. 它可以访问外部类的所有成员，包括 `private` 成员。
2. 如果匿名内部类定义在方法里，它还可以访问所在方法的 `final`的局部变量。这是因为它的生命周期可能比方法更长，Java通过复制的方式来保证数据一致性。
3. 生成`.class`文件：编译后，编译器会为每个匿名内部类生成一个独立的`.class`文件，命名格式通常为`外部类名$数字.class`如 `Demo$1.class`。

Lambda表达式与匿名内部类有着密切的“血缘关系”，那你有没有思考过，Lambda表达式是否属于内部类？
```java
// 传统匿名内部类方式
Thread thread = new Thread(new Runnable() {
    @Override
    public void run() {
        System.out.println("线程正在运行 (匿名内部类)");
    }
});

// Lambda 表达式方式
Thread lambdaThread = new Thread(
        () -> {
            System.out.println("线程正在运行 (Lambda)");
        }
);
```
其实Lambda表达式既不属于内部类，它是一种独立的、全新的语法结构，用于表示一个函数式接口的实例。
Lambda表达式其本质上是一个函数，不会生成单独的`.class`文件，由JVM在运行时动态生成，而匿名内部类一个类，会生成`.class`文件。

Lambda 表达式可以看作是匿名内部类的一种语法糖和优化，但仅限于函数式接口的场景。当你需要实现一个函数式接口时，应优先使用 Lambda 表达式，因为它更简洁、高效。



## 内部类与内存泄漏