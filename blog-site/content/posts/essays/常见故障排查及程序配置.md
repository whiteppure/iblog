---
title: "常见故障排查及程序配置"
date: 2021-09-08
draft: false
tags: ["技巧"]
slug: "eye-beam"
---

## 故障排查基础
收录Linux常用命令，以下命令来自[https://www.bilibili.com/video/BV14A411378a](https://www.bilibili.com/video/BV14A411378a)


### 关机/重启/注销

| 常用命令          | 作用                     |
| ----------------- | ------------------------ |
| shutdown -h now   | 即刻关机                 |
| shutdown -h 10    | 10分钟后关机             |
| shutdown -h 11:00 | 11：00关机               |
| shutdown -h +10   | 预定时间关机（10分钟后） |
| shutdown -c       | 取消指定时间关机         |
| shutdown -r now   | 重启                     |
| shutdown -r 10    | 10分钟之后重启           |
| shutdown -r 11:00 | 定时重启                 |
| reboot            | 重启                     |
| init 6            | 重启                     |
| init 0            | ⽴刻关机                 |
| telinit 0         | 关机                     |
| poweroff          | ⽴刻关机                 |
| halt              | 关机                     |
| sync              | buff数据同步到磁盘       |
| logout            | 退出登录Shell            |

### 系统信息和性能查看

| 常用命令                    | 作用                               |
| --------------------------- | ---------------------------------- |
| uname -a                    | 查看内核/OS/CPU信息                |
| uname -r                    | 查看内核版本                       |
| uname -m                    | 查看处理器架构                     |
| arch                        | 查看处理器架构                     |
| hostname                    | 查看计算机名                       |
| who                         | 显示当前登录系统的⽤户             |
| who am i                    | 显示登录时的⽤户名                 |
| whoami                      | 显示当前⽤户名                     |
| cat /proc/version           | 查看linux版本信息                  |
| cat /proc/cpuinfo           | 查看CPU信息                        |
| cat /proc/interrupts        | 查看中断                           |
| cat /proc/loadavg           | 查看系统负载                       |
| uptime                      | 查看系统运⾏时间、⽤户数、负载     |
| env                         | 查看系统的环境变量                 |
| lsusb -tv                   | 查看系统USB设备信息                |
| lspci -tv                   | 查看系统PCI设备信息                |
| lsmod                       | 查看已加载的系统模块               |
| grep MemTotal /proc/meminfo | 查看内存总量                       |
| grep MemFree /proc/meminfo  | 查看空闲内存量                     |
| free -m                     | 查看内存⽤量和交换区⽤量           |
| date                        | 显示系统⽇期时间                   |
| cal 2021                    | 显示2021⽇历表                     |
| top                         | 动态显示cpu/内存/进程等情况        |
| vmstat 1 20                 | 每1秒采⼀次系统状态，采20次        |
| iostat                      | 查看io读写/cpu使⽤情况             |
| 查看io读写/cpu使⽤情况      | 查询cpu使⽤情况（1秒⼀次，共10次） |
| sar -d 1 10                 | 查询磁盘性能                       |

### 磁盘和分区

| 常用命令                            | 作用                           |
| ----------------------------------- | ------------------------------ |
| fdisk -l                            | 查看所有磁盘分区               |
| swapon -s                           | 查看所有交换分区               |
| df -h                               | 查看磁盘使⽤情况及挂载点       |
| df -hl                              | 同上                           |
| du -sh /dir                         | 查看指定某个⽬录的⼤⼩         |
| du -sk * \| sort -rn                | 从⾼到低依次显示⽂件和⽬录⼤⼩ |
| mount /dev/hda2 /mnt/hda2           | 挂载hda2盘                     |
| mount -t ntfs /dev/sdc1 /mnt/usbhd1 | 指定⽂件系统类型挂载（如ntfs） |
| mount -o loop xxx.iso /mnt/cdrom    | 挂 载 iso ⽂ 件                |
| umount -v /dev/sda1                 | 通过设备名卸载                 |
| umount -v /mnt/mymnt                | 通过挂载点卸载                 |
| fuser -km /mnt/hda1                 | 强制卸载(慎⽤)                 |

### ⽤户和⽤户组

| 常用命令                                              | 作用                                           |
| ----------------------------------------------------- | ---------------------------------------------- |
| useradd codesheep                                     | 创建⽤户                                       |
| userdel -r codesheep                                  | 删除⽤户                                       |
| usermod -g group_name user_name                       | 修改⽤户的组                                   |
| usermod -aG group_name user_name                      | 将⽤户添加到组                                 |
| usermod -s /bin/ksh -d /home/codepig –g dev codesheep | 修改⽤户codesheep的登录Shell、主⽬录以及⽤户组 |
| groups test                                           | 查看test⽤户所在的组                           |
| groupadd group_name                                   | 创建⽤户组                                     |
| groupdel group_name                                   | 删除⽤户组                                     |
| groupmod -n new_name old_name                         | 重命名⽤户组                                   |
| su - user_name                                        | su - user_name                                 |
| passwd                                                | 修改⼝令                                       |
| passwd codesheep                                      | 修改某⽤户的⼝令                               |
| w                                                     | 查看活动⽤户                                   |
| id codesheep                                          | 查看指定⽤户codesheep信息                      |
| last                                                  | 查看⽤户登录⽇志                               |
| crontab -l                                            | 查看当前⽤户的计划任务                         |
| cut -d: -f1 /etc/passwd                               | 查看系统所有⽤户                               |
| cut -d: -f1 /etc/group                                | 查看系统所有组                                 |

### ⽹络和进程管理

| 常用命令                                                     | 作用                                 |
| ------------------------------------------------------------ | ------------------------------------ |
| ifconfig                                                     | 查看⽹络接⼝属性                     |
| ifconfig eth0                                                | 查看某⽹卡的配置                     |
| route -n                                                     | 查看路由表                           |
| netstat -lntp                                                | 查看所有监听端⼝                     |
| netstat -antp                                                | 查看已经建⽴的TCP连接                |
| netstat -lutp                                                | 查看TCP/UDP的状态信息                |
| ifup eth0                                                    | 启⽤eth0⽹络设备                     |
| ifdown eth0                                                  | 禁⽤eth0⽹络设备                     |
| iptables -L                                                  | 查看iptables规则                     |
| ifconfig eth0 192.168.1.1 netmask 255.255.255.0              | 配置ip地址                           |
| dhclient eth0                                                | 以dhcp模式启⽤eth0                   |
| route add -net 0/0 gw Gateway_IP                             | 配置默认⽹关                         |
| route add -net 192.168.0.0 netmask 255.255.0.0 gw 192.168.1.1 | 配置静态路由到达⽹络'192.168.0.0/16' |
| route del 0/0 gw Gateway_IP                                  | 删除静态路由                         |
| hostname                                                     | 查看主机名                           |
| host [www.baidu.com](http://www.baidu.com)                   | 解析主机名                           |
| nslookup [www.baidu.com](http://www.baidu.com)               | 查询DNS记录，查看域名解析是否正常    |
| ps -ef                                                       | 查看所有进程                         |
| ps -ef \| grep codesheep                                     | 过滤出你需要的进程                   |
| kill -s name                                                 | kill指定名称的进程                   |
| kill -s pid                                                  | kill指定pid的进程                    |
| top                                                          | 实时显示进程状态                     |
| vmstat 1 20                                                  | 每1秒采⼀次系统状态，采20次          |
| iostat                                                       | iostat                               |
| sar -u 1 10                                                  | 查询cpu使⽤情况（1秒⼀次，共10次）   |
| sar -d 1 10                                                  | 查询磁盘性能                         |

### 常⻅系统服务命令

| 常用命令                   | 作用         |
| -------------------------- | ------------ |
| chkconfig --list           | 列出系统服务 |
| service <服务名> status    | 查看某个服务 |
| service <服务名> start     | 启动某个服务 |
| service <服务名> stop      | 终⽌某个服务 |
| service <服务名> restart   | 重启某个服务 |
| systemctl status <服务名>  | 查看某个服务 |
| systemctl start <服务名>   | 启动某个服务 |
| systemctl stop <服务名>    | 终⽌某个服务 |
| systemctl restart <服务名> | 重启某个服务 |
| systemctl enable <服务名>  | 关闭⾃启动   |
| systemctl disable <服务名> | 关闭⾃启动   |

### ⽂件和⽬录操作

| 常用命令                 | 作用                                                         |
| ------------------------ | ------------------------------------------------------------ |
| cd <⽬录名>              | 进⼊某个⽬录                                                 |
| cd ..                    | 回上级⽬录                                                   |
| cd ../..                 | 回上两级⽬录                                                 |
| cd                       | 进个⼈主⽬录                                                 |
| cd -                     | 回上⼀步所在⽬录                                             |
| pwd                      | 显示当前路径                                                 |
| ls                       | 查看⽂件⽬录列表                                             |
| ls -F                    | 查看⽬录中内容（显示是⽂件还是⽬录）                         |
| ls -l                    | 查看⽂件和⽬录的详情列表                                     |
| ls -a                    | 查看隐藏⽂件                                                 |
| ls -lh                   | 查看⽂件和⽬录的详情列表（增强⽂件⼤⼩易读性）               |
| ls -lSr                  | 查看⽂件和⽬录列表（以⽂件⼤⼩升序查看）                     |
| tree                     | 查看⽂件和⽬录的树形结构                                     |
| mkdir <⽬录名>           | 创建⽬录                                                     |
| mkdir dir1 dir2          | 同时创建两个⽬录                                             |
| mkdir -p /tmp/dir1/dir2  | 创建⽬录树                                                   |
| rm -f file1              | 删除'file1'⽂件                                              |
| rmdir dir1               | 删除'dir1'⽬录                                               |
| rm -rf dir1              | 删除'dir1'⽬录和其内容                                       |
| rm -rf dir1 dir2         | 同时删除两个⽬录及其内容                                     |
| mv old_dir new_dir       | 重命名/移动⽬录                                              |
| cp file1 file2           | 复制⽂件                                                     |
| cp dir/* .               | 复制某⽬录下的所有⽂件⾄当前⽬录                             |
| cp -a dir1 dir2          | 复制⽬录                                                     |
| cp -a /tmp/dir1 .        | 复制⼀个⽬录⾄当前⽬录                                       |
| ln -s file1 link1        | 创建指向⽂件/⽬录的软链接                                    |
| ln file1 lnk1            | 创建指向⽂件/⽬录的物理链接                                  |
| find / -name file1       | 从跟⽬录开始搜索⽂件/⽬录                                    |
| find / -user user1       | 搜索⽤户user1的⽂件/⽬录                                     |
| find /dir -name *.bin    | 在⽬录/dir中搜带有.bin后缀的⽂件                             |
| locate <关键词>          | 快速定位⽂件                                                 |
| locate *.mp4             | 寻找.mp4结尾的⽂件                                           |
| whereis <关键词>         | 显示某⼆进制⽂件/可执⾏⽂件的路径                            |
| which <关键词>           | 查找系统⽬录下某的⼆进制⽂件                                 |
| chmod ugo+rwx dir1       | 设置⽬录所有者(u)、群组(g)及其他⼈(o)的读（r）写(w)执⾏(x)权限 |
| chmod go-rwx dir1        | 移除群组(g)与其他⼈(o)对⽬录的读写执⾏权限                   |
| chown user1 file1        | 改变⽂件的所有者属性                                         |
| chown -R user1 dir1      | 改变⽬录的所有者属性                                         |
| chgrp group1 file1       | 改变⽂件群组                                                 |
| chown user1:group1 file1 | 改变⽂件的所有⼈和群组                                       |

### ⽂件查看和处理

| 常用命令                      | 作用                                    |
| ----------------------------- | --------------------------------------- |
| cat file1                     | 查看⽂件内容                            |
| cat -n file1                  | 查看内容并标示⾏数                      |
| tac file1                     | 从最后⼀⾏开始反看⽂件内容              |
| more file1                    | more file1                              |
| less file1                    | 类似more命令，但允许反向操作            |
| head -2 file1                 | 查看⽂件前两⾏                          |
| tail -2 file1                 | 查看⽂件后两⾏                          |
| tail -f /log/msg              | 实时查看添加到⽂件中的内容              |
| grep codesheep hello.txt      | 在⽂件hello.txt中查找关键词codesheep    |
| grep ^sheep hello.txt         | 在⽂件hello.txt中查找以sheep开头的内容  |
| grep [0-9] hello.txt          | 选择hello.txt⽂件中所有包含数字的⾏     |
| sed 's/s1/s2/g' hello.txt     | 将hello.txt⽂件中的s1替换成s2           |
| sed '/^$/d' hello.txt         | 从hello.txt⽂件中删除所有空⽩⾏         |
| sed '/ *#/d; /^$/d' hello.txt | 从hello.txt⽂件中删除所有注释和空⽩⾏   |
| sed -e '1d' hello.txt         | 从⽂件hello.txt 中排除第⼀⾏            |
| sed -n '/s1/p' hello.txt      | 查看只包含关键词"s1"的⾏                |
| sed -e 's/ *$//' hello.txt    | 删除每⼀⾏最后的空⽩字符                |
| sed -e 's/s1//g' hello.txt    | 从⽂档中只删除词汇s1并保留剩余全部      |
| sed -n '1,5p;5q' hello.txt    | 查看从第⼀⾏到第5⾏内容                 |
| sed -n '5p;5q' hello.txt      | 查看第5⾏                               |
| paste file1 file2             | 合并两个⽂件或两栏的内容                |
| paste -d '+' file1 file2      | 合并两个⽂件或两栏的内容，中间⽤"+"区分 |
| sort file1 file2              | 排序两个⽂件的内容                      |
| comm -1 file1 file2           | ⽐较两个⽂件的内容(去除'file1'所含内容) |
| comm -2 file1 file2           | ⽐较两个⽂件的内容(去除'file2'所含内容  |
| comm -3 file1 file2           | ⽐较两个⽂件的内容(去除两⽂件共有部分)  |

### 打包和解压

| 常用命令                          | 作用                     |
| --------------------------------- | ------------------------ |
| zip xxx.zip file                  | 压缩⾄zip包              |
| zip -r xxx.zip file1 file2 dir1   | 将多个⽂件+⽬录压成zip包 |
| unzip xxx.zip                     | 解压zip包                |
| tar -cvf xxx.tar file             | 创建⾮压缩tar包          |
| tar -cvf xxx.tar file1 file2 dir1 | 将多个⽂件+⽬录打tar包   |
| tar -tf xxx.tar                   | 查看tar包的内容          |
| tar -xvf xxx.tar                  | 解压tar包                |
| tar -xvf xxx.tar -C /dir          | 将tar包解压⾄指定⽬录    |
| tar -cvfj xxx.tar.bz2 dir         | 创建bz2压缩包            |
| tar -jxvf xxx.tar.bz2             | 解压bz2压缩包            |
| tar -cvfz xxx.tar.gz dir          | 创建gzip压缩包           |
| tar -zxvf xxx.tar.gz              | 解压gzip压缩包           |
| bunzip2 xxx.bz2                   | 解压bz2压缩包            |
| bzip2 filename                    | 压缩⽂件                 |
| gunzip xxx.gz                     | 解压gzip压缩包           |
| gzip filename                     | 压缩⽂件                 |
| gzip -9 filename                  | 最⼤程度压缩             |

### RPM包管理命令

| 常用命令                  | 作用                          |
| ------------------------- | ----------------------------- |
| rpm -qa                   | 查看已安装的rpm包             |
| rpm -q pkg_name           | 查询某个rpm包                 |
| rpm -q --whatprovides xxx | 显示xxx功能是由哪个包提供的   |
| rpm -q --whatrequires xxx | 显示xxx功能被哪个程序包依赖的 |
| rpm -q --changelog xxx    | 显示xxx包的更改记录           |
| rpm -qi pkg_name          | 查看⼀个包的详细信息          |
| rpm -qd pkg_name          | 查询⼀个包所提供的⽂档        |
| rpm -qc pkg_name          | 查看已安装rpm包提供的配置⽂件 |
| rpm -ql pkg_name          | 查看⼀个包安装了哪些⽂件      |
| rpm -qf filename          | 查看某个⽂件属于哪个包        |
| rpm -qR pkg_name          | 查询包的依赖关系              |
| rpm -ivh xxx.rpm          | 安装rpm包                     |
| rpm -ivh --test xxx.rpm   | 测试安装rpm包                 |
| rpm -ivh --nodeps xxx.rpm | 安装rpm包时忽略依赖关系       |
| rpm -e xxx                | 卸载程序包                    |
| rpm -Fvh pkg_name         | 升级确定已安装的rpm包         |
| rpm -Uvh pkg_name         | 升级rpm包(若未安装则会安装)   |
| rpm -V pkg_name           | RPM包详细信息校验             |

### YUM包管理命令

| 常用命令                            | 作用                 |
| ----------------------------------- | -------------------- |
| yum repolist enabled                | 显示可⽤的源仓库     |
| yum search pkg_name                 | 搜索软件包           |
| yum install pkg_name                | 下载并安装软件包     |
| yum install --downloadonly pkg_name | 只下载不安装    |
| yum list                            | 显示所有程序包       |
| yum list installed                  | 查看当前系统已安装包 |
| yum list updates                    | 查看可以更新的包列表 |
| yum check-update                    | 查看可升级的软件包   |
| yum update                          | 更新所有软件包       |
| yum update pkg_name                 | 升级指定软件包       |
| yum deplist pkg_name                | 列出软件包依赖关系   |
| yum remove pkg_name                 | 删除软件包           |
| yum clean all                       | 清除缓存             |
| yum clean packages                  | 清除缓存的软件包     |
| yum clean headers                   | 清除缓存的header     |

### DPKG包管理命令

| 常用命令             | 作用                  |
| -------------------- | --------------------- |
| dpkg -c xxx.deb      | 列出deb包的内容       |
| dpkg -i xxx.deb      | 安装/更新deb包        |
| dpkg -r pkg_name     | 移除deb包             |
| dpkg -P pkg_name     | 移除deb包(不保留配置) |
| dpkg -l              | 查看系统中已安装deb包 |
| dpkg -l pkg_name     | 显示包的⼤致信息      |
| dpkg -L pkg_name     | 查看deb包安装的⽂件   |
| dpkg -s pkg_name     | 查看包的详细信息      |
| dpkg –unpack xxx.deb | 解开deb包的内容       |

### APT软件⼯具

| 常用命令                  | 作用                   |
| ------------------------- | ---------------------- |
| apt-cache search pkg_name | 搜索程序包             |
| apt-cache show pkg_name   | 获取包的概览信息       |
| apt-get install pkg_name  | 安装/升级软件包        |
| apt-get purge pkg_name    | 卸载软件（包括配置）   |
| apt-get remove pkg_name   | 卸载软件（不包括配置） |
| apt-get update            | 更新包索引信息         |
| apt-get upgrade           | 更新已安装软件包       |
| apt-get clean             | 清理缓存               |

## 分析工具
### JDK自带分析工具
参考文章：
- [https://segmentfault.com/a/1190000038209665](https://segmentfault.com/a/1190000038209665)
- [https://www.cnblogs.com/kongzhongqijing/articles/5534624.html](https://www.cnblogs.com/kongzhongqijing/articles/5534624.html)

#### jps
jps查询系统内所有HotSpot进程，它位于java的bin目录下。

| 命令   | 含义                           |
| ------ | ------------------------------ |
| jps    | 输出当前运行主类名称，进程ID   |
| jps -q | 只列出进程ID                   |
| jps -l | 输出当前运行主类的全称，进程ID |
| jps -v | 输出虚拟机进程启动时`JVM`参数  |


#### jstat
jstat是JDK自带的一个轻量级小工具。全称“Java Virtual Machine statistics monitoring tool”，和jps一样，都在bin目录下。

| 命令                       | 含义                                                         |
| -------------------------- | ------------------------------------------------------------ |
| jstat -gc vmid 1000 10   | 查看进程`pid`的`GC`信息，每1000毫秒 输出一次，输出10次 |
| jstat -gccause vmid 1000 10 | 查看进程`pid`的`GC`发生的原因,每一秒（1000毫秒）输出一次，输出10次 |
| jstat -class vmid     | 查看`pid`的加载类信息 |
| jstat -gcutil vmid | 对`java`垃圾回收信息的统计 |
| jstat -gcnew vmid | 显示新生代`GC`的情况 |
| jstat -gcold vmid | 显示老年代`GC`的情况 |

#### jinfo
jinfo查看虚拟机参数信息，也可用于调整虚拟机配置参数。我们通过`jinfo --help`能看到相应的参数。

| 命令                     | 含义                                 |
| ------------------------ | ------------------------------------ |
| jinfo pid                | 输出关于`pid`的一堆相关信息          |
| jinfo -flags pid         | 查看当前进程曾经赋过值的一些参数              |
| jinfo -flag name pid     | 查看指定进程的`JVM`参数名称的参数的值       |
| jinfo -flag [+-]name pid | 开启或者关闭指定进程对应名称的`JVM`参数      |
| jinfo -sysprops pid      | 来输出当前 `JVM`进行的全部的系统属性 |

当使用jinfo进行修改对应进程JVM参数时，有一定的局限性。并不是所有的参数都支持修改，只有参数被标记为manageable的参数才可以被实时修改。

可以使用命令查看被标记为manageable的参数：`java -XX:+PrintFlagsFinal -version | grep manageable`

#### jmap
jmap全称：Java Memory Map，主要用于打印指定Java进程(或核心文件、远程调试服务器)的共享对象内存映射或堆内存细节。jmap以生成 java程序的dump文件， 也可以查看堆内对象示例的统计信息、查看ClassLoader 的信息以及 finalizer 队列。

jmap命令可以获得运行中的JVM的堆的快照，从而可以离线分析堆，以检查内存泄漏，检查一些严重影响性能的大对象的创建，检查系统中什么对象最多，各种对象所占内存的大小等等。可以使用jmap生成Heap Dump。

| 命令                    | 含义                                                         |
| ----------------------- | ------------------------------------------------------------ |
| jmap -heap pid       | 输出整个堆详细信息，包括GC的使用、堆的配置信息，以及内存的使用信息            |
| jmap -histo:live pid | 输出堆中对象的相关统计信息；第一列是序号，第二列是对象个数，第三列是对象大小`byte`，第四列是`class name` |
| jmap -finalizerinfo pid | 输出等待终结的对象信息                                       |
| jmap -clstats pid    | 输出类加载器信息                                             |
| jmap -dump:[live],format=b,file=filename.hprof pid | 把进程堆内存使用情况生成到堆转储`dump`文件中,`live`子选项是可选的，假如指定`live`选项,那么只输出活的对象到文件。`dump`文件主要作用，如果发生溢出可以使用`dump`文件分析是哪些数据导致的 |

> Heap Dump又叫堆转储文件，指一个java进程在某一个时间点的内存快照文件。Heap Dump在触发内存快照的时候会保存以下信息：
>- 所有的对象
>- 所有的class
>- GC Roots
>- 本地方法栈和本地变量
>
> 通常在写Dump文件前会触发一次Full GC，所以Heap Dump文件里保存的对象都是Full GC后保留的对象信息。
> 由于生成dump文件比较耗时，所以请耐心等待，尤其是大内存镜像生成的dump文件，则需要更长的时间来完成。

可以通过参数配置当发生OOM时自动生成dump文件：`-XX:+HeapDumpOnOutOfMemeryError -XX:+HeapDumpPath=<filename.hprof>`,当然此种方式获取dump文件较大，如果想要获取dump文件较小可以手动获取dump文件并指定只获取存活的对象。


#### jhat
JVM Heap Analysis Tool命令是与jmap搭配使用，用来分析jmap生成的dump文件，jhat内置了一个微型的HTTP/HTML服务器，生成dump的分析结果后，可以在浏览器中查看。在此要注意，一般不会直接在服务器上进行分析，因为jhat是一个耗时并且耗费硬件资源的过程，一般把服务器生成的dump文件复制到本地或其他机器上进行分析。

注意，jhat在jdk9中已经移除，官方对贱使用visualvm来配置jmap进行分析。

| 命令                                   | 含义                                                         |
| -------------------------------------- | ------------------------------------------------------------ |
| jhat -port 9998 /tmp/dump.dat          | 配合`jmap`命令使用，查看导出的`/tmp/dump.dat`文件，端口为9998；注意如果`dump`文件太大，可能需要加上`-J-Xmx512m`这种参数指定最大堆内存，即`jhat -J-Xmx512m -port 9998 /tmp/dump.dat` |
| jhat -baseline dump2.phrof dump1.phrof | 对比`dump2.phrof `与`dump1.phrof`文件                        |
| jhat heapDump                          | 分析`dump`文件,默认端口为7000     |


#### jstack
jstack，全称JVM Stack Trace栈空间追踪，用于生成虚拟机指定进程当前线程快照；主要分析堆栈空间，也就是分析线程的情况，可以分析出死锁问题，以及cpu100%的问题。jstack可以定位到线程堆栈，根据堆栈信息我们可以定位到具体代码，所以它在JVM性能调优中使用得非常多。

> jstack主要用于生成java虚拟机当前时刻的线程快照。线程快照是当前java虚拟机内每一条线程正在执行的方法堆栈的集合，生成线程快照的主要目的是定位线程出现长时间停顿的原因，
  如线程间死锁、死循环、请求外部资源导致的长时间等待等。

| 命令                | 含义                                                    |
| ------------------- | ------------------------------------------------------- |
| jstack pid          | 打印出所有的线程，包括用户自己启动的线程和`JVM`后台线程 |
| jstack 13324 >1.txt | 将13324进程中线程信息写入到`1.txt`文件中                |
| jstack 21711｜grep 54ee | 在进程21711中查找线程ID为54ee(16进制)的信息 |
| jstack -l pid | 除了堆栈信息外`-l`参数会显示线程锁的附加信息 |

除了可以使用jstack打印栈的信息，在java层面也可以使用`Thread.getAllStackTraces()`方法获取堆栈信息。

#### jcmd
在JDK1.7之后，新增了一个命令行工具jcmd。

它是一个多功能的工具，可以实现前面除了jstat之外的所有功能。例如，导出dump文件、查看线程信息、导出线程信息、执行GC，JVM运行时间等。

jcmd拥有jmap的大部分功能，并且在官方网站上也推荐使用jcmd代替jmap。

| 命令                | 含义                                                    |
| ------------------- | ------------------------------------------------------- |
| jcmd -l | 列出所有`JVM`的进程 |
| jcmd pid help       | 针对指定进程罗列出可执行的命令 |
| jcmd pid <具体命令> | 显示指定进程的指令命令的数据   |

### GUI分析工具
#### jconsole
JConsole 是一个内置 Java 性能分析器，可以从命令行（直接输入jconsole）或在 GUI shell （jdk\bin下打开）中运行。

它用于对JVM中内存，线程和类等的监控。这款工具的好处在于，占用系统资源少，而且结合Jstat，可以有效监控到java内存的变动情况，以及引起变动的原因。在项目追踪内存泄露问题时，很实用。

![常见故障排查及程序配置-002](/iblog/posts/annex/images/essays/常见故障排查及程序配置-002.png)

![常见故障排查及程序配置-001](/iblog/posts/annex/images/essays/常见故障排查及程序配置-001.png)

![常见故障排查及程序配置-003](/iblog/posts/annex/images/essays/常见故障排查及程序配置-003.png)

#### visual vm
visual vm 是一个功能强大的多合一故障诊断和性能监控的可视化工具。它集成了多个JDK命令行工具，使用visual vm可用于显示虚拟机进程及进程的配置和环境信息，监视应用程序的CPU、GC、堆、方法区及线程的信息等，甚至代替jconsole。

在JDK7，visual vm便作为JDK的一部分发布，在JDK的bin目录下，即：它完全免费。此外，visual vm也可以作为独立软件进行安装。

主要功能：
- 生成读取dump文件
- 查看JVM参数和系统属性
- 查看运行中虚拟机进程
- 生成读取线程快照
- 程序资源的实时监控

visual vm 支持插件扩展，可以在visual vm上安装插件，也可以将visual vm安装在idea上：

![常见故障排查及程序配置-006](/iblog/posts/annex/images/essays/常见故障排查及程序配置-006.png)

![常见故障排查及程序配置-007](/iblog/posts/annex/images/essays/常见故障排查及程序配置-007.png)

visual vm可以生成dump文件，生成的dump文件是临时的，如果想要保留该文件需要右键另存为即可：

![常见故障排查及程序配置-004](/iblog/posts/annex/images/essays/常见故障排查及程序配置-004.png)

![常见故障排查及程序配置-005](/iblog/posts/annex/images/essays/常见故障排查及程序配置-005.png)

如果堆文件数据较大，排查起来很困难，可以使用OQL语句进行筛选。
> OQL:全称，Object Query Language 类似于SQL查询的一种语言，OQL使用SQL语法，可以在堆中进行对象的筛选。
>
> 基本语法：
> ```
> select <JavaScript expression to select> 
> [ from (instanceof) <class name> <identifier>
> ( where <JavaScript boolean expression to filter> ) ]
> ```
> 1.class name是java类的完全限定名
> 2.instanceof表示也查询某一个类的子类
> 3.from和where子句都是可选的 
> 4.可以使用obj.field_name语法访问Java字段
> 
> 例如
>```
>-- 查询长度大于等于100的字符串
>select s from java.lang.String s where s.value.length >= 100
>
>-- 显示所有File对象的文件路径 
>select file.path.value.toString() from java.io.File file
>
>-- 显示由给定id字符串标识的Class的实例
>select o from instanceof 0x741012748 o
>```

visual vm也可以将两个dump文件进行比较：

![常见故障排查及程序配置-008](/iblog/posts/annex/images/essays/常见故障排查及程序配置-008.png)

visual vm不但可以生成堆的dump文件，也可以对线程dump：

![常见故障排查及程序配置-009](/iblog/posts/annex/images/essays/常见故障排查及程序配置-009.png)

#### eclipse MAT
MAT全称，Memory Analyzer Tool 是一款功能强大的Java堆内存分析器。可以用于查找内存泄漏以及查看内存消耗情况。

MAT是eclipse开发的，不仅可以单独使用，还可以作为插件嵌入在eclipse中使用。是一款免费的性能分析工具，使用起来很方便。

MAT的主要功能就是分析dump文件。分析dump最终目的是为了找出内存泄漏的疑点，防止内存泄漏。

JVM内存包含信息：
- 所有对象信息，包括对象实例、成员变量、存储于栈中的基本数据类型和存储于堆中的其他对象的引用值；
- 所有的类信息，包括classloader、类名称、父类的信息、静态变量等；
- GCRoot到所有的这些对象的引用路径;
- 线程信息，包括线程的调用栈及线程的局部变量;

常见获取dump文件方式：
- 通过jmap或jcmd命令行方式获取；
- 通过配置JVM参数"-XX:+HeapDumpOnOutOfMemoryError"或"-XX:+HeapDumpBeforeFullGC"
- 使用第三方工具生成dump文件，如：visual vm

---
**MAT介绍**

导入dump文件：

在生成可疑泄漏报告后，会在对应的堆转储文件目录下生成一个zip文件。

![常见故障排查及程序配置-010](/iblog/posts/annex/images/essays/常见故障排查及程序配置-010.png)

![常见故障排查及程序配置-011](/iblog/posts/annex/images/essays/常见故障排查及程序配置-011.png)

![常见故障排查及程序配置-012](/iblog/posts/annex/images/essays/常见故障排查及程序配置-012.png)

![常见故障排查及程序配置-013](/iblog/posts/annex/images/essays/常见故障排查及程序配置-013.png)

![常见故障排查及程序配置-016](/iblog/posts/annex/images/essays/常见故障排查及程序配置-016.png)

MAT最主要的功能是分析dump文件，其中比较重要的功能就是histogram(直方图)和dominator tree(支配树)

---
**直方图**

![常见故障排查及程序配置-015](/iblog/posts/annex/images/essays/常见故障排查及程序配置-015.png)

- 浅堆：一个对象结构所占用的大小，即对象头+实例数据+对齐填充，不包括内部引用对象大小；
- 深堆：一个对象被 GC 回收后，可以真实释放的内存大小；
- 对象的实际大小：一个对象所能触及的所有对象的浅堆大小之和；

![常见故障排查及程序配置-017](/iblog/posts/annex/images/essays/常见故障排查及程序配置-017.png)

如上图所示：（浅堆<= 深堆 <= 实际大小）
- Object2浅堆大小：为Object2本身；
- Object2深堆大小：Object2本身加上Object6；
- Object2实际大小：Object2本身加上Object6加上Object5；

![常见故障排查及程序配置-014](/iblog/posts/annex/images/essays/常见故障排查及程序配置-014.png)

---
**支配树对象图**

![常见故障排查及程序配置-018](/iblog/posts/annex/images/essays/常见故障排查及程序配置-018.png)

支配树概念源自图论。它体现了对象实例之间的支配关系。在对象的引用图中，所有指向对象B的路径都要经过对象A，则认为对象A支配对象B。如果对象A是离对象B最近的一个支配对象，则认为对象A为对象B的直接支配者。

支配树是基于对象间的引用图建立的，它有以下性质：
- 对象A的子树，即所有被对象A支配的对象集合，表示对象A的保留集，即深堆；
- 如果对象A支配对象B，那么对象A直接支配者也支配对象B；
- 支配树的边与对象引用图的边不相对应；

分配树能直观的体现对象能否被回收的情况，如图所示，左为对象的引用图，右为对象的支配图。
- C与E的关系为，C支配E，C是E的直接支配者，G和E为C的保留集；
- C与H不是支配关系，因为H被F引用；

![常见故障排查及程序配置-019](/iblog/posts/annex/images/essays/常见故障排查及程序配置-019.png)

## Java应用程序配置
### JVM常用参数
官方：
- https://www.oracle.com/java/technologies/javase/vmoptions-jsp.html
- https://www.oracle.com/java/technologies/javase/gc-tuning-6.html

理想的情况下，一个Java程序使用JVM的默认设置也可以运行得很好，所以一般来说，没有必要设置任何JVM参数。然而，由于一些性能问题，我们需要设置合理的JVM参数。

可以通过`java -XX:+PrintFlagsInitial` 命令查看JVM所有参数。

常用参数：

| 参数                            | 含义                                      | 描述                                                         |
| ------------------------------- | ----------------------------------------- | ------------------------------------------------------------ |
| -Xms                            | 堆初始值                                  | Xmx和Xms设置为老年代存活对象的3-4倍，即FullGC之后的老年代内存占用的3-4倍 |
| -Xmx                            | 堆最大值                                  | 为了防止自动扩容降低性能，建议将-Xms和-Xmx的值设置为相同值   |
| -XX:MaxHeapFreeRatio            | 最大堆内存使用率                          | 默认70，当超过该比例会进行扩容堆，Xms=Xmx时该参数无效        |
| -XX:MinHeapFreeRatio            | 最小堆内存使用率                          | 默认40，当低于该比例会缩减堆，Xms=Xmx时该参数无效            |
| -Xmn                            | 年轻代内存最大值                          | 年轻代设置的越大，老年代区域就会减少。一般不允许年轻代比老年代还大，因为要考虑GC时最坏情况，所有对象都晋升到老年代。建议设置为老年代存活对象的1-1.5倍，最大可以设置为-Xmx/2 。考虑性能，一般会通过参数 -XX:NewSize 设置年轻代初始大小。如果知道了年轻代初始分配的对象大小，可以节省新生代自动扩展的消耗。 |
| -XX:SurvivorRatio               | 年轻代中两个Survivor区和Eden区大小比率    | 例如： -XX:SurvivorRatio=10 表示伊甸园区是幸存者其中一个区大小的10倍，所以,伊甸园区占新生代大小的10/12, 幸存区From和幸存区To 每个占新生代的1/12 |
| -XX:NewRatio                    | 年轻生代和老年代的比率                    | 例如：-XX:NewRatio=3 指定老年代/新生代为3/1. 老年代占堆大小的 3/4 ，新生代占 1/4 。如果针对新生代,同时定义绝对值和相对值,绝对值将起作用，建议将年轻代的大小为整个堆的3/8左右。 |
| -XX:+HeapDumpOnOutOfMemoryError | 让JVM在发生内存溢出时自动的生成堆内存快照 | 可以通过-XX:HeapDumpPath=path参数将生成的快照放到指定路径下  |
| -XX:OnOutOfMemoryError          | 当内存溢发生时可以执行一些指令            | 比如发个E-mail通知管理员或者执行一些清理工作，执行脚本       |
| -XX:ThreadStackSize             | 每个线程栈最大值                          | 栈设置太大，会导致线程创建减少，栈设置小，会导致深入不够，深度的递归会导致栈溢出，建议栈深度设置在3000-5000k。 |
| -XX:MetaspaceSize               | 初始化的元空间大小                        | 如果元空间大小达到了这个值，就会触发Full GC为了避免频繁的Full GC，建议将- XX：MetaspaceSize设置较大值。如果释放了空间之后，元空间还是不足，那么就会自动增加MetaspaceSize的大小 |
| -XX:MaxMetaspaceSize            | 元空间最大值                              | 默认情况下，元空间最大的大小是系统内存的大小，元空间一直扩大，虚拟机可能会消耗完所有的可用系统内存。 |

### JVM调优
JVM优化是到最后不得已才采用的手段，对JVM内存的系统级的调优主要的目的是减少GC的频率和Full GC的次数。

何时调优：
1. Full GC 次数频繁
2. GC 停顿时间过长
3. 应用出现OutOfMemory 等内存异常
4. 堆内存持续上涨达到设置的最大内存值

调优原则：
1. 多数导致GC问题的Java应用，都不是因为我们参数设置错误，而是代码问题
2. 在实际使用中，分析GC情况优化代码比优化JVM参数更好
3. 减少创建对象的数量、减少使用全局变量和大对象

调优思路：
1. 分析GC日志及dump文件，判断是否需要优化，确定瓶颈问题点。如果各项参数设置合理，系统没有超时日志出现，GC频率不高，GC耗时不高，那么没有必要进行GC优化，如果GC时间超过1-3秒，或者频繁GC，则必须优化。
2. 确定JVM调优目标。如果内存分配过大或过小，或者采用的GC收集器比较慢，则应该优先调整这些参数，并且先找1台或几台机器进行测试，然后比较优化过的机器和没有优化的机器的性能对比，并有针对性的做出最后选择。
3. 不断的分析和调整，直到找到合适的JVM参数配置。

### Java程序shell脚本示例
```
#!/bin/sh

#非特殊应用下面内存分配已经够用
HEAP_MEMORY=1024M
METASPACE_SIZE=256M

SERVER_HOME="$( cd "$( dirname "$0"  )" && pwd  )"
APP_NAME=${@: -1}

#使用说明，用来提示输入参数  
help() {
    echo "Usage: start.sh {start|stop|restart|status|help} APP_NAME.jar" >&2
    echo "Examples:"
    echo "  sh start.sh start APP_NAME.jar"
    echo "  sh start.sh stop APP_NAME.jar"
    echo "  sh start.sh start -Heap 1024M -MetaspaceSize 256M APP_NAME.jar"
}

#检查程序是否在运行  
is_exist() {
    pid=`ps -ef | grep ${SERVER_HOME} | grep ${APP_NAME} | grep -v grep | awk '{print $2}' `
    #如果不存在返回1，存在返回0  
    if [ -z "${pid}" ]; then
      return 1
    else
      return 0
    fi
}

#启动方法  
start() {
   is_exist
   if [ $? -eq "0" ]; then
      echo "${APP_NAME} is already running. pid=${pid} ."  
   else
      echo "${APP_NAME} running..."
      JAVA_OPTS="-server -XX:+UseG1GC -XX:+HeapDumpOnOutOfMemoryError"
      JAVA_OPTS="${JAVA_OPTS} -Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremote.ssl=false"
      #JAVA_OPTS="${JAVA_OPTS} -Djava.rmi.server.hostname=${LOCAL_IP} -Dcom.sun.management.jmxremote.port=${JMX_PORT} -Dcom.sun.management.jmxremote.rmi.port=${JMX_PORT}"

      shift
      ARGS=($*)
      for ((i=0; i<${#ARGS[@]}; i++)); do
          case "${ARGS[$i]}" in
          -D*)    JAVA_OPTS="${JAVA_OPTS} ${ARGS[$i]}" ;;
          -Heap*) HEAP_MEMORY="${ARGS[$i+1]}" ;;
          -MetaspaceSize*) METASPACE_SIZE="${ARGS[$i+1]}" ;;
          esac
      done

      JAVA_OPTS="${JAVA_OPTS} -Xms${HEAP_MEMORY} -Xmx${HEAP_MEMORY} -XX:MaxMetaspaceSize=${METASPACE_SIZE} -XX:MetaspaceSize=${METASPACE_SIZE}"
      #生产环境加上下面这个配置 服务启动的时候真实的分配物理内存给jvm
      #JAVA_OPTS="${JAVA_OPTS} -XX:+AlwaysPreTouch" 
      JAVA_OPTS="${JAVA_OPTS} -Duser.dir=${SERVER_HOME}"
      #下面两段根据需要酌情配置
      #JAVA_OPTS="${JAVA_OPTS} -Xloggc:${APP_NAME}.gc.log"
      #JAVA_OPTS="${JAVA_OPTS} -Dapp.name=${SERVER_NAME} -Dlogging.config=${SERVER_HOME}/logback-spring.xml -Dspring.profiles.active=dev"
      echo "jvm args: ${JAVA_OPTS}"
      java ${JAVA_OPTS} -jar ${APP_NAME} >/dev/null 2>&1 &
   fi
}

#停止方法  
stop() {
   is_exist
   if [ $? -eq "0" ]; then
     echo "${APP_NAME} is stopping..."
     kill -9 $pid
   else
     echo "${APP_NAME} is not running"  
   fi
}

#输出运行状态  
status() {
   is_exist
   if [ $? -eq "0" ]; then
     echo "${APP_NAME} is running. Pid is ${pid}"  
   else
     echo "${APP_NAME} is not running."  
   fi
}

#根据输入参数，选择执行对应方法，不输入则执行使用说明  
case "$1" in
   "start")
     start $@;
     ;;
   "stop")
     stop $@;
     ;;
   "status")
     status $@;
     ;;
   "restart")
     stop $@;
     start $@;
     ;;
   *)
     help
     ;;
esac
```
## 常见故障排查

### CPU使用过高定位分析
一般在生产环境排查程序故障，都会查看日志什么的，但是有些故障日志是看不出来的，就比如：CPU使用过高。

那应该怎么办呢？我们需要结合linux命令和JDK相关命令来排查程序故障。

步骤：
- 首先使用top命令，找出CPU占比最高的Java进程；然后进一步定位后台程序，如果发现使用过高的进程ID,记录下来方便排查；
- 定位到具体的线程；使用`ps -mp 进程ID -o THREAD,tid,time`命令可以找到有问题的线程ID；
   > ps -mp 进程ID -o THREAD,tid,time 说明：
   >-m：显示所有线程
   >-p：pid进程使用CPU的时间
   >-o：该参数后是用户自定义参数  
- 获取到线程ID后，将线程ID转化为16进制格式，如果有英文要小写格式；可以用命令`printf "%x\n" 线程ID`,当然也可以使用工具从10进制转16进制。
    ```
    printf "%x\n" 16
    ```
- 线程ID转成16进制后，执行最后一个命令：`jstack 进程ID | grep 16进制线程ID -A50`,就能看到有问题的代码。

### 内存使用过高定位分析
与CPU使用过高同样的，内存如果占用过大，查看程序日志也看不出来。

步骤：
- 使用top命令查看应用程序内存占用情况，查看内存使用情况,如果发现使用过高的进程ID,记录下来；
- 根据进程ID查询具体线程ID: `ps p进程ID -L -o pcpu,pmem,pid,tid,time,tname,cmd`,记下使用内存异常的记下线程ID；
- 将内存使用较高的线程的堆栈信息写入文件：`jstack -l 进程ID > 文件名`,写入文件后将文件中的线程ID转换为16进制,在文件中搜索16进制线程ID即可；

### 死锁编码及定位分析
死锁经常表现为程序的停顿，或者不再响应用户的请求。从操作系统上观察，对应进程的CPU占用率为零，很快会从top或prstat的输出中消失。

死锁示例代码：
```
public class MainTest {

    public static void main(String[] args) {
         String lockA = "lockA";
         String lockB = "lockB";
        new Thread(new ThreadHolderLock(lockA,lockB),"线程AAA").start();
        new Thread(new ThreadHolderLock(lockB,lockA),"线程BBB").start();
    }
}

class ThreadHolderLock implements Runnable{

    private String lockA;
    private String lockB;

    public ThreadHolderLock(String lockA, String lockB){
        this.lockA = lockA;
        this.lockB = lockB;
    }

    @Override
    public void run() {
        synchronized (lockA){
            System.out.println(Thread.currentThread().getName() + "\t 持有锁 "+ lockA+", 尝试获得"+ lockB);

            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

            synchronized (lockB){
                System.out.println(Thread.currentThread().getName() + "\t 持有锁 "+ lockB+", 尝试获得"+ lockA);
            }
        }
    }
}
```

步骤：
- 使用`jps -l`命令找到程序进程；
- 使用`jstack pid`命令打印堆栈信息；

上面死锁示例代码使用`jstack pid`后的一些信息：
```
Found one Java-level deadlock:
=============================
"线程BBB":
  waiting to lock monitor 0x00007feb0d80b018 (object 0x000000076af2d588, a java.lang.String),
  which is held by "线程AAA"
"线程AAA":
  waiting to lock monitor 0x00007feb0d80d8a8 (object 0x000000076af2d5c0, a java.lang.String),
  which is held by "线程BBB"

Java stack information for the threads listed above:
===================================================
"线程BBB":
	at com.github.springcloud.service.ThreadHolderLock.run(MainTest.java:35)
	- waiting to lock <0x000000076af2d588> (a java.lang.String)
	- locked <0x000000076af2d5c0> (a java.lang.String)
	at java.lang.Thread.run(Thread.java:748)
"线程AAA":
	at com.github.springcloud.service.ThreadHolderLock.run(MainTest.java:35)
	- waiting to lock <0x000000076af2d5c0> (a java.lang.String)
	- locked <0x000000076af2d588> (a java.lang.String)
	at java.lang.Thread.run(Thread.java:748)

Found 1 deadlock.
```
### 内存泄露排查分析
Java虚拟机是使用引用计数法和可达性分析来判断对象是否可回收，本质是判断一个对象是否还被引用，如果没有引用则回收。在开发的过程中，由于代码的实现不同就会出现很多种内存泄漏问题，让gc误以为此对象还在引用中，无法回收，造成内存泄漏。

当内存泄露时，如果不是JVM参数中的内存分配太小了，那么从根本上解决Java内存泄露的唯一方法就是修改程序。

内存泄露主要原因：
- 在内存中加载过大的数据，例如，从数据库取出过多数据；
- 资源未关闭造成的内存泄漏；
- 变量不合理的作用域，使用完毕，如果没有及时的赋值为null，则会造成内存泄露；
- 长生命周期的对象中引用短生命周期对象，很可能会出现内存泄露；

内存泄漏排查：
1. 内存泄漏的主要表象就是内存不足，所以首先要看一下JVM启动参数中内存空间分配是否过小，如果是这种问题调整该参数即可；
2. 从代码层面找问题，如果之前从未出现过此类问题，新增接口或者引入新第三包的时候后出现该问题，则可能是新增的部分代码存在问题；
3. 使用jdk相关命令进行排查分析：
    - 使用jstat -gc <vmid> 查看GC垃圾回收统计信息，看Full GC后堆空间使用内存还持续增长，且有增长到Xmx设定值的趋势基本可以肯定存在内存泄露，如果当前完全垃圾回收后内存增长到一个值之后，又能回落，总体上处于一个动态平衡，那么内存泄漏基本可以排除；也可以隔断时间抽取老年代占用内存情况，如果老年代占用情况持续上升也很有可能存在内存泄露的情况；
    - 把堆dump下来再用工具进行分析，但dump堆要花较长的时间，并且文件巨大，不建议这样；可以使用jmap -histo:live <pid>在线进行分析,查看输出的对象数量如果过大就需要额外注意；

使用MAT找到内存泄漏的代码思路：
- https://blog.csdn.net/lnkToKing/article/details/103533995
1. 打开MAT中histogram，找到堆内存中占用最大的对象（内存泄漏很有可能就是由大对象导致的）；
2. 由大对象找被哪些线程引用，查看内存占用最大的线程；
3. 从线程中的堆栈信息找到项目中自定义的包和对象，从而可定位到具体的代码；