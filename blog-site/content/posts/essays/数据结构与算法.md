---
title: "数据结构与算法"
date: 2021-12-10
draft: false
tags: ["Java","算法"]
slug: "data-structures-algorithms"
---

## 数据结构
数据结构是一门研究组织数据方式的学科，有了编程语言也就有了数据结构，学好数据结构可以编写出更有效率的代码。数据结构是算法的基础，想要学好算法，就必须把数据结构学到位。

数据结构包括：线性结构、非线性结构。

线性结构作为最常用的数据结构，其特点是数据元素之间存在一对一的线性存储关系。线性结构有两种不同的存储结构，即顺序存储和链式存储。顺序存储的线性表被称为顺序表，顺序表中存储元素的地址是连续的；链式存储的线性表被称为链表，链表中存储元素的地址不一定是连续的，元素结点中存放数据元素以及相邻元素地址信息。

常见的线性结构有：数组、链表、队列、栈；常见非线性结构有：多维数组、广义表、树结构、图结构。

### 稀疏数组
使用稀疏数组可以用来压缩数据。稀疏数组的第一行依次记录原数组一共有几行几列，有多少个不为零的值，之后的每行记录原数组中不为零的值所在的行数、列数以及数组中元素该值。如图所示：

![数据结构与算法-001](/iblog/posts/images/essays/数据结构与算法-001.png)

二维数组转稀疏数组
```
    // 将二维数组转换为稀疏数组
    public static int[][] twoDimensionArrayToSparseArray(int[][] array) {
        // 记录棋盘中有效值的数量
        int sum = 0;
        int row = array.length;
        int column = 0;
        for (int[] ints : array) {
            column = ints.length;
            for (int item : ints) {
                if (item != 0) {
                    sum++;
                }
            }
        }

        // 创建稀疏数组
        int[][] sparseArray = new int[sum + 1][3];
        sparseArray[0][0] = row;
        sparseArray[0][1] = column;
        sparseArray[0][2] = sum;

        // 给稀疏数组赋值
        int count = 0;
        for (int i = 0; i < array.length; i++) {
            for (int j = 0; j < array[i].length; j++){
                if (array[i][j] != 0){
                    count++;
                    sparseArray[count][0] = i;
                    sparseArray[count][1] = j;
                    sparseArray[count][2] = array[i][j];
                }
            }
        }

        System.out.println("稀疏数组====》");
        for (int i = 0; i < sparseArray.length; i++) {
            System.out.printf("%d\t%d\t%d\t\n",sparseArray[i][0],sparseArray[i][1],sparseArray[i][2]);
        }
        return sparseArray;
    }
```

稀疏数组转二维数组
```
    // 稀疏数组转二维数组
    public static int[][] sparseArrayToTwoDimensionArray(int[][] sparseArray) {
        int[][] toTwoDimensionArray = new int[sparseArray[0][0]][sparseArray[0][1]];
        // 给二维数组赋值
        for (int i = 1; i < sparseArray.length; i++) {
            toTwoDimensionArray[sparseArray[i][0]][sparseArray[i][1]] = sparseArray[i][2];
        }

        System.out.println("二维数组====》");
        for (int[] row : toTwoDimensionArray) {
            for (int data : row) {
                System.out.printf("%d\t", data);
            }
            System.out.println();
        }
        return toTwoDimensionArray;
    }
```

### 队列
队列是一个有序列表，可以使用数组或链表来实现。队列遵循先入先出的原则。即，先存入队列的数据，要先取出。后存入的要后取出。

使用数组模拟队列示意图：

![数据结构与算法-002](/iblog/posts/images/essays/数据结构与算法-002.png)

数组模拟单向队列
```
    public class ArrayQueue{

        // 队列容量
        private int capacity;

        // 保存队列中的数据
        private int[] arr;

        // 头部指针
        private int front;

        // 尾部指针
        private int rear;

        public ArrayQueue(int capacity) {
            this.capacity = capacity;
            arr = new int[capacity];
            front = -1;
            rear = -1;
        }

        public boolean isEmpty() {
            return front == rear;
        }

        public boolean isFull() {
            return capacity - 1 == rear;
        }

        public void add(int data) {
            if (isFull()) {
                System.out.println("队列已经满了，不能在继续添加");
                return;
            }
            arr[++rear] = data;
        }

        public int get() {
            if (isEmpty()) {
                System.out.println("队列为空，不能获取元素");
                return -1;
            }
            return arr[++front];
        }

        // 显示队列的所有数据
        public void show() {
            if (isEmpty()) {
                System.out.println("队列空的，没有数据~~");
                return;
            }
            System.out.println("开始遍历队列：");
            for (int i = front + 1; i <= rear; i++) {
                System.out.printf("arr[%d]=%d\n", i, arr[i]);
            }
        }


        // 显示队列的头数据， 注意不是取出数据
        public int peek() {
            if (isEmpty()) {
                throw new RuntimeException("队列空的，没有数据~~");
            }
            return arr[front + 1];
        }

    }
```

数组模拟环形队列
```
    public  class CircleArrayQueue{

        // 队列容量
        private int capacity;

        // 保存队列中的数据
        private int[] arr;

        // 头部指针
        private int front;

        // 尾部指针
        private int rear;

        public CircleArrayQueue(int capacity) {
            this.capacity = capacity;
            arr = new int[capacity];
        }

        public boolean isEmpty() {
            return front == rear;
        }

        public boolean isFull() {
            // 此处+1 是因为存储元素从0算起
            return (rear + 1) % capacity  == front;
        }

        public void add(int data) {
            if (isFull()) {
                System.out.println("队列已经满了，不能在继续添加");
                return;
            }
            arr[rear] = data;
            rear = (rear + 1) % capacity;
        }

        public int get() {
            if (isEmpty()) {
                System.out.println("队列为空，不能获取元素");
                return -1;
            }
            int value = arr[front];
            front = (front + 1) % capacity;
            return value;
        }

        // 显示队列的所有数据
        public void show() {
            if (isEmpty()) {
                System.out.println("队列空的，没有数据~~");
                return;
            }
            System.out.println("开始遍历队列：");
            for (int i = front % capacity; i < front + ((rear + capacity - front) % capacity); i++) {
                System.out.printf("arr[%d]=%d\n", i, arr[i]);
            }
        }

        // 显示队列的头数据， 注意不是取出数据
        public int peek() {
            if (isEmpty()) {
                throw new RuntimeException("队列空的，没有数据~~");
            }
            return arr[front];
        }

    }
```
### 链表
链表属于线性结构，存储空间不连续。

链表特点：
- 链表是以节点的方式来存储，是链式存储；data 域存放数据，next 域指向下一个节点；
- 链表分带头节点的链表和没有头节点的链表，根据实际的需求来确定；

![数据结构与算法-003](/iblog/posts/images/essays/数据结构与算法-003.png)

#### 单向链表
操作单向链表：对于插入、删除操作，只能定位至待操作节点的前一个节点，如果定位至当前节点，那么其上一个节点的信息便会丢失。

单向链表，链表的增、删、查、改
```
class SingleLinkedList{

    // 头结点
    private Node headNode = new Node(0,"");

    // 添加方法
    public  void add(Node node){
        Node tmpNode = headNode;

        while (tmpNode.next != null){
            // 指向下一个结点
            tmpNode = tmpNode.next;
        }
        // 退出循环意味着tmpNode.next == null 即找到最后一个结点了
        tmpNode.next = node;
    }

    // 顺序添加
    public void addByOrder(Node node){
        boolean flag = false;
        Node tmp = headNode;
        while (true){
            if (tmp.next == null) {
                break;
            }

            // 将新插入的结点num跟链表中已经存在的num进行比较，如果 < 链表中的结点 则说明找到了该位置
            if (node.num < tmp.next.num){
                break;
            }
            // 如果num相同则不能添加
            if (node.num == tmp.next.num){
                flag = true;
                break;
            }
            tmp = tmp.next;
        }

        if (!flag){
            node.next = tmp.next;
            tmp.next = node;
            return;
        }
        System.out.printf("需要添加的结点编号：%d已经存在了",node.num);
    }

    // 遍历链表
    public void list() {
        // 遍历除了头结点外的所有结点
        Node tmpNode = headNode.next;
        if (tmpNode == null){
            System.out.println("链表为空！");
            return;
        }

        while (tmpNode != null){
            System.out.println(tmpNode);
            // 指向下一个结点
            tmpNode = tmpNode.next;
        }
    }


}


class Node {

    int num;
    String name;
    Node next;

    public Node(int num,String name){
        this.num = num;
        this.name = name;
    }

    @Override
    public String toString() {
        return "Node{" +
                "num=" + num +
                ", name='" + name + '\'' +
                '}';
    }
}
```

反转单向链表

![数据结构与算法-004](/iblog/posts/images/essays/数据结构与算法-004.png)

```
    // 反转链表
    public void reserve(Node head) {
        if (head.next == null || head.next.next == null){
            return ;
        }

        Node reserve = new Node(0, "");
        Node cur = head.next;
        Node next = null;
        // 遍历链表
        // 遍历原来的链表，每遍历一个节点，就将其取出，并放在新的链表reverseHead 的最前端
        while (cur != null){

            // 保存当前结点的下一个结点
            next = cur.next;

            // 将cur的下一个节点指向新的链表的最前端（覆盖掉）保证将最新的结点放到reseve的最前面
            cur.next = reserve.next;

            // 将cur 连接到新的链表上
            reserve.next = cur;

            // 将之前保存好的结点赋值给当前结点
            cur = next;
        }
```

利用栈逆序打印单向链表
```
    public void reservePrint(Node head) {
        if (head.next == null || head.next.next == null){
            return;
        }

        Stack<Node> nodes = new Stack<>();
        Node tmp = head.next;
        while (tmp != null){
            nodes.push(tmp);
            tmp = tmp.next;
        }

        // 从stack中取出结点
        while (nodes.size() > 0){
            System.out.println(nodes.pop());
        }
    }
```

#### 双向链表

对比单向链表：
- 单向链表，查找的方向只能是一个方向，而双向链表可以向前或者向后查找；
- 单向链表不能自我删除，需要靠辅助节点，而双向链表，则可以自我删除；

![数据结构与算法-005](/iblog/posts/images/essays/数据结构与算法-005.png)

双向链表，增、删、改、查
```
class DoubleLinkedList{

    // 头结点
    private Node headNode = new Node(0,"");


    public Node getHeadNode() {
        return headNode;
    }


    // 添加方法
    public  void add(Node node){
        Node tmpNode = headNode;

        while (tmpNode.next != null){
            // 指向下一个结点
            tmpNode = tmpNode.next;
        }
        // 退出循环意味着tmpNode.next == null 即找到最后一个结点了
        tmpNode.next = node;
        node.prev = tmpNode;
    }


    // 双向链表修改
    public void update(Node node){
        if (headNode == null) {
            return;
        }

        Node tmp = headNode.next;
        while (true){
            if (tmp == null){
                break;
            }
            if (node.num == tmp.num){
                tmp.name = node.name;
                break;
            }
            tmp = tmp.next;
        }
    }

    // 双向链表删除
    public void remove(int num){
        if (headNode.next == null){
            System.out.println("链表为空，无法删除！");
            return;
        }
        Node tmp = headNode.next;
        while (tmp != null){
            if (num == tmp.num){
                tmp.prev.next = tmp.next;

                // 最后一个结点的next 为null null.pre会出现空指针异常
                if(tmp.next != null) {
                    tmp.next.prev = tmp.prev;
                }
                break;
            }
            tmp = tmp.next;
        }
    }

    // 遍历链表
    public void list() {
        // 遍历除了头结点外的所有结点
        Node tmpNode = headNode.next;
        if (tmpNode == null){
            System.out.println("链表为空！");
            return;
        }

        while (tmpNode != null){
            System.out.println(tmpNode);
            // 指向下一个结点
            tmpNode = tmpNode.next;
        }
    }


}


class Node {

    int num;
    String name;
    Node next;
    Node prev;

    public Node(int num,String name){
        this.num = num;
        this.name = name;
    }

    @Override
    public String toString() {
        return "Node{" +
                "num=" + num +
                ", name='" + name + '\'' +
                '}';
    }
}
```

#### 约瑟夫问题

> 约瑟夫问题为：设编号为 1，2，…n的n个人围坐一圈，约定编号为 k（1<=k<=n） 的人从 1 开始报数,数到 m 的那个人出列，它的下一位又从 1 开始报数，数到 m 的那个人又出列， 依次类推，直到所有人出列为止，由此产生一个出队编号的序列。

用一个不带头结点的循环链表来处理约瑟夫问题：先构成一个有 n 个结点的单循环链表，然后由 k 结点起从 1 开始计数，计到 m 时，对应结点从链表中删除，然后再从被删除结点的下一个结点又从 1 开始计数，直到最后一个结点从链表中删除算法结束。

![数据结构与算法-006](/iblog/posts/images/essays/数据结构与算法-006.png)

```
class JoesphSingletonLinkedList {

    private Node first = null;


    // 向单向链表添加数据
    public void add(int nums) {
        if (nums < 1) {
            System.out.println("nums的值不正确");
            return;
        }
        Node cur = null;
        for (int i = 1; i <= nums; i++) {
            Node node = new Node(i);
            if (i == 1) {
                first = node;
                first.next = first;
                cur = first;
            } else {
                cur.next = node;
                node.next = first;
                cur = node;
            }
        }
    }


    // 遍历单向循环链表
    public void list() {
        Node tmp = first;
        while (true){
            System.out.printf("当前结点为：%d\n",tmp.num);
            if (tmp.next == first){
                break;
            }
            tmp = tmp.next;
        }
    }


    // 约瑟夫问题
    public void joseph(int startNum,int countNum,int sum){
        if (startNum > sum || startNum < 0 || countNum < 0) {
            System.out.println("输入的参数不正确！");
            return;
        }
        // 创建辅助指针，将该指针指向 first 的前一个
        Node helper = first;
        while (helper.next != first) {
            helper = helper.next;
        }

        // 将first 和 help指针循环 （startNum - 1）次；因为从startNum开始，需要减一
        for (int i = 0; i < startNum - 1; i++) {
            first = first.next;
            helper = helper.next;
        }

        while (true){
            // 当环形链表中只存在一个结点
            if (first == helper){
                break;
            }

            // 因为是环形链表，所以需要循环挨个出链表
            for (int i = 0; i < countNum - 1; i++) {
                first = first.next;
                helper = helper.next;
            }

            // 当前 first 就是出圈的结点
            System.out.printf("当前出队列的结点编号为：%d\n",first.num);
            first = first.next;
            helper.next = first;
        }
        System.out.printf("最后的结点为：%d\n",first.num);
    }

}


class Node {

    int num;
    Node next;

    public Node(int num){
        this.num = num;
    }

    @Override
    public String toString() {
        return "Node{" +
                "num=" + num +
                '}';
    }
}
```
### 栈
栈的英文为stack，是一个先入后出(FILO-First In Last Out)的有序列表，最先放入栈中元素在栈底，最后放入的元素在栈顶，而删除元素刚好相反，最后放入的元素最先删除，最先放入的元素最后删除。

栈是限制线性表中元素的插入和删除只能在线性表的同一端进行的一种特殊线性表。允许插入和删除的一端，为变化的一端，称为栈顶(Top)，另一端为固定的一端，称为栈底(Bottom)。

下图是出栈和入栈

![数据结构与算法-007](/iblog/posts/images/essays/数据结构与算法-007.png)

栈的应用场景：
- 子程序的调用： 在跳往子程序前， 会先将下个指令的地址存到堆栈中， 直到子程序执行完后再将地址取出， 以回到原来的程序中；
- 处理递归调用： 和子程序的调用类似， 只是除了储存下一个指令的地址外， 也将参数、 区域变量等数据存入栈中；
- 表达式的转换：中缀表达式转后缀表达式与求值；
- 二叉树的遍历；
- 图形的深度优先(depth 一 first)搜索法；


数组模拟栈
```
class ArrayStack<T>{

    private int size;
    private int top;
    private Object[] stack;

    public ArrayStack(int size) {
        this.size = size;
        this.stack = new String[size];
        top = -1;
    }

    public boolean isFull(){
        return top == size -1;
    }

    public boolean isEmpty() {
        return top == -1;
    }

    // 入栈
    public void push(T item) {
        if (isFull()) {
            System.out.println("栈已经满了，不能继续添加！");
            return;
        }
        top++;
        this.stack[top] = item;
    }

    // 出栈操作
    public T pop() {
        if (isEmpty()) {
            throw new RuntimeException("栈已经为空，不能继续pop");
        }
        T val = (T)this.stack[top];
        top--;
        return val;
    }

    // 遍历栈
    public void list() {
        if (isEmpty()) {
            System.out.println("栈为空不能继续遍历！");
            return;
        }

        System.out.println("遍历栈==》");
        for (int i = top; i >=0; i--){
            System.out.println(this.stack[i]);
        }
    }

}
```

#### 栈实现中缀表达式

![数据结构与算法-008](/iblog/posts/images/essays/数据结构与算法-008.png)

```
class CalcInfixExpressions {


    public int calcInfixExpressions(String expression) {
        // 定义变量
        char[] chars = expression.toCharArray();
        int len = chars.length;
        Stack<Integer> numStack = new Stack<>();
        Stack<Character> oprStack = new Stack<>();
        int index = 0;

        for (int j = 0; j < len; j++) {

            char ch = chars[j];

            index++;

            // 判断字符是否为数字,如果是数字就放入数栈中
            if (Character.isDigit(ch)) {

                // 接收多位数
                int num = ch;
                boolean flag = false;

                // 从当前字符开始遍历，如果下一位字符不是数字，则将该数字压入栈中并退出循环，如果是数字，则需要拼接起来
                for (int i = index; i < len; i++) {
                    if (Character.isDigit(expression.charAt(i))) {
                        String strNum = String.valueOf(ch) + expression.charAt(i);
                        num = Integer.parseInt(strNum);
                        flag = true;
                        index++;
                        j++;
                    }else {
                        break;
                    }
                }
                if (!flag) {
                    num -= 48;
                }
                numStack.push(num);
                continue;
            }

            // 非数字，即运算符,如果为空直接加入栈中
            if (oprStack.isEmpty()) {
                oprStack.push(ch);
                continue;
            }

            // 如果运算符栈不为空，需要比较运算符的优先级，如果当前运算符的优先级 <= 栈顶的运算符的优先级，需要计算在压入栈中
            if (oprPriority(oprStack.peek()) >= oprPriority(ch)) {
                numStack.push(calc(numStack.pop(), numStack.pop(), oprStack.pop()));
            }

            // 将字符压入操作符栈中
            oprStack.push(ch);
        }


        // 将处理好的数据按照顺序弹出，进行计算，得到数栈中最后一个数就是最终的结果
        while (!oprStack.isEmpty()){
            numStack.push(calc(numStack.pop(), numStack.pop(), oprStack.pop()));
        }

        return numStack.pop();
    }


    // 获取字符的优先级
    private int oprPriority(int ch) {
        if (ch == '*' || ch == '/') {
            return 2;
        }
        if (ch == '+' || ch == '-') {
            return 1;
        }
        return -1;
    }


    // 计算
    private int calc(int num1, int num2, int opr) {
        int res = 0;
        switch (opr) {
            case '+':
                res = num1 + num2;
                break;
            case '-':
                res = num2 - num1;
                break;
            case '*':
                res = num1 * num2;
                break;
            case '/':
                res = num2 / num1;
                break;
        }
        return res;
    }

}
```

#### 栈实现后缀表达式
后缀表达式又称逆波兰表达式，与前缀表达式相似，只是运算符位于操作数之后。例如： (3+4)×5-6 对应的后缀表达式就是 3 4 + 5 × 6 –

思路：从左至右扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算（次顶元素 和 栈顶元素），并将结果入栈；重复上述过程直到表达式最右端，最后运算得出的值即为表达式的结果。

```
class PolandNotation{

    // 计算后缀表达式
    public int calcSuffixExceptions(String suffixExpres) {
        char[] chars = suffixExpres.toCharArray();
        Stack<Integer> stack = new Stack<>();
        int res =0;

        for (int i = 0; i < chars.length; i++) {
            char ch = suffixExpres.charAt(i);
            if (!Character.isDigit(ch)) {
                res = calc(stack.pop(),stack.pop(),ch);
                stack.push(res);
            }else {
                stack.push(ch - 48);
            }
        }
        return res;
    }

    // 计算
    private int calc(int num1, int num2, int opr) {
        int res = 0;
        switch (opr) {
            case '+':
                res = num1 + num2;
                break;
            case '-':
                res = num2 - num1;
                break;
            case '*':
                res = num1 * num2;
                break;
            case '/':
                res = num2 / num1;
                break;
            default:
                throw new RuntimeException("运算符有误");
        }
        return res;
    }

}
```
#### 中缀表达式转后缀表达式

![数据结构与算法-009](/iblog/posts/images/essays/数据结构与算法-009.png)

中缀表达式转后缀表达式代码实现
```
class InfixToPolandNotation{

    // 根据ASCII 判断是否为数字
    private boolean isNumber(char ch){
        return ch >=48 && ch <= 57;
    }

    // 获取字符的优先级
    private int oprPriority(String opr) {
        if (opr.equals("*") || opr.equals("/")) {
            return 2;
        }
        if (opr.equals("+") || opr.equals("-")) {
            return 2;
        }
        return -1;
    }

    // 将中缀表达式字符串转成中缀表达式集合
    public List<String> toInfixExceptionList(String str) {
        ArrayList<String> list = new ArrayList<>();
        int index = 0;
        StringBuilder number;
        char c;

        while (index < str.length()){
            if (!isNumber((c = str.charAt(index)))){
                list.add(String.valueOf(c));
                index++;
            }else {
                number = new StringBuilder();
                while (index < str.length() && isNumber((c = str.charAt(index)))){
                    index++;
                    number.append(c);
                }
                list.add(number.toString());
            }
        }
        return list;
    }


    // 将中缀表达式转为后缀表达式
    public List<String> infixExpressionToSuffixExpress(List<String> list) {
        Stack<String> stack = new Stack<>();
        ArrayList<String> finalList = new ArrayList<>();

        for (String item : list) {
            // 如果是数字或者为（ 将该值压入栈中
            if (item.matches("\\d+")){
                finalList.add(item);
                continue;
            }

            if (item.equals("(")){
                stack.push(item);
                continue;
            }

            // 如果是 ）则将 ()中间的数重新压入list中，最后将 ） 移除掉
            if (item.equals(")")){
                while (!stack.peek().equals("(")) {
                    finalList.add(stack.pop());
                }
                stack.pop();
            }else {
                // 如果不是 ）则判断运算符的优先级，如果符号栈栈顶的优先级 >= 当前的优先级，则将该运算符加入数字栈中
                while (stack.size() > 0 && oprPriority(stack.peek()) >= oprPriority(item)){
                    finalList.add(stack.pop());
                }
                stack.push(item);
            }
        }

        // 将operStack中剩余的运算符依次弹出并加入tempList
        while (stack.size() != 0) {
            finalList.add(stack.pop());
        }
        return finalList;
    }

}
```

完整逆波兰表达式代码，支持小数、支持消除空格
```
public class ReversePolishMultiCalc {

	 /**
     * 匹配 + - * / ( ) 运算符
     */
    static final String SYMBOL = "\\+|-|\\*|/|\\(|\\)";

    static final String LEFT = "(";
    static final String RIGHT = ")";
    static final String ADD = "+";
    static final String MINUS= "-";
    static final String TIMES = "*";
    static final String DIVISION = "/";

    /**
     * 加減 + -
     */
    static final int LEVEL_01 = 1;
    /**
     * 乘除 * /
     */
    static final int LEVEL_02 = 2;

    /**
     * 括号
     */
    static final int LEVEL_HIGH = Integer.MAX_VALUE;


    static Stack<String> stack = new Stack<>();
    static List<String> data = Collections.synchronizedList(new ArrayList<String>());

    /**
     * 去除所有空白符
     * @param s
     * @return
     */
    public static String replaceAllBlank(String s ){
        // \\s+ 匹配任何空白字符，包括空格、制表符、换页符等等, 等价于[ \f\n\r\t\v]
        return s.replaceAll("\\s+","");
    }

    /**
     * 判断是不是数字 int double long float
     * @param s
     * @return
     */
    public static boolean isNumber(String s){
        Pattern pattern = Pattern.compile("^[-\\+]?[.\\d]*$");
        return pattern.matcher(s).matches();
    }

    /**
     * 判断是不是运算符
     * @param s
     * @return
     */
    public static boolean isSymbol(String s){
        return s.matches(SYMBOL);
    }

    /**
     * 匹配运算等级
     * @param s
     * @return
     */
    public static int calcLevel(String s){
        if("+".equals(s) || "-".equals(s)){
            return LEVEL_01;
        } else if("*".equals(s) || "/".equals(s)){
            return LEVEL_02;
        }
        return LEVEL_HIGH;
    }

    /**
     * 匹配
     * @param s
     * @throws Exception
     */
    public static List<String> doMatch (String s) throws Exception{
        if(s == null || "".equals(s.trim())) throw new RuntimeException("data is empty");
        if(!isNumber(s.charAt(0)+"")) throw new RuntimeException("data illeagle,start not with a number");

        s = replaceAllBlank(s);

        String each;
        int start = 0;

        for (int i = 0; i < s.length(); i++) {
            if(isSymbol(s.charAt(i)+"")){
                each = s.charAt(i)+"";
                //栈为空，(操作符，或者 操作符优先级大于栈顶优先级 && 操作符优先级不是( )的优先级 及是 ) 不能直接入栈
                if(stack.isEmpty() || LEFT.equals(each)
                        || ((calcLevel(each) > calcLevel(stack.peek())) && calcLevel(each) < LEVEL_HIGH)){
                    stack.push(each);
                }else if( !stack.isEmpty() && calcLevel(each) <= calcLevel(stack.peek())){
                    //栈非空，操作符优先级小于等于栈顶优先级时出栈入列，直到栈为空，或者遇到了(，最后操作符入栈
                    while (!stack.isEmpty() && calcLevel(each) <= calcLevel(stack.peek()) ){
                        if(calcLevel(stack.peek()) == LEVEL_HIGH){
                            break;
                        }
                        data.add(stack.pop());
                    }
                    stack.push(each);
                }else if(RIGHT.equals(each)){
                    // ) 操作符，依次出栈入列直到空栈或者遇到了第一个)操作符，此时)出栈
                    while (!stack.isEmpty() && LEVEL_HIGH >= calcLevel(stack.peek())){
                        if(LEVEL_HIGH == calcLevel(stack.peek())){
                            stack.pop();
                            break;
                        }
                        data.add(stack.pop());
                    }
                }
                start = i ;    //前一个运算符的位置
            }else if( i == s.length()-1 || isSymbol(s.charAt(i+1)+"") ){
                each = start == 0 ? s.substring(start,i+1) : s.substring(start+1,i+1);
                if(isNumber(each)) {
                    data.add(each);
                    continue;
                }
                throw new RuntimeException("data not match number");
            }
        }
        //如果栈里还有元素，此时元素需要依次出栈入列，可以想象栈里剩下栈顶为/，栈底为+，应该依次出栈入列，可以直接翻转整个stack 添加到队列
        Collections.reverse(stack);
        data.addAll(new ArrayList<>(stack));

        System.out.println(data);
        return data;
    }

    /**
     * 算出结果
     * @param list
     * @return
     */
    public static Double doCalc(List<String> list){
        Double d = 0d;
        if(list == null || list.isEmpty()){
            return null;
        }
        if (list.size() == 1){
            System.out.println(list);
            d = Double.valueOf(list.get(0));
            return d;
        }
        ArrayList<String> list1 = new ArrayList<>();
        for (int i = 0; i < list.size(); i++) {
            list1.add(list.get(i));
            if(isSymbol(list.get(i))){
                Double d1 = doTheMath(list.get(i - 2), list.get(i - 1), list.get(i));
                list1.remove(i);
                list1.remove(i-1);
                list1.set(i-2,d1+"");
                list1.addAll(list.subList(i+1,list.size()));
                break;
            }
        }
        doCalc(list1);
        return d;
    }

    /**
     * 运算
     * @param s1
     * @param s2
     * @param symbol
     * @return
     */
    public static Double doTheMath(String s1,String s2,String symbol){
        Double result ;
        switch (symbol){
            case ADD : result = Double.valueOf(s1) + Double.valueOf(s2); break;
            case MINUS : result = Double.valueOf(s1) - Double.valueOf(s2); break;
            case TIMES : result = Double.valueOf(s1) * Double.valueOf(s2); break;
            case DIVISION : result = Double.valueOf(s1) / Double.valueOf(s2); break;
            default : result = null;
        }
        return result;

    }

    public static void main(String[] args) {
        //String math = "9+(3-1)*3+10/2";
        String math = "12.8 + (2 - 3.55)*4+10/5.0";
        try {
            doCalc(doMatch(math));
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

}

```
### 哈希表
哈希表也叫散列表，是根据关键码值(Key value)而直接进行访问的数据结构。

它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。

手写模拟哈希表
```
public class HashTableDemo {

    public static void main(String[] args) {
        HashTab hashTab = new HashTab(3);
        Node node1 = new Node(1, "zs");
        Node node2 = new Node(2, "lx");
        Node node3 = new Node(3, "ex");
        Node node4 = new Node(4, "as");
        Node node5 = new Node(7, "we");

        hashTab.put(node1);
        hashTab.put(node2);
        hashTab.put(node3);
        hashTab.put(node4);
        hashTab.put(node5);

        System.out.println("添加元素后===》");
        System.out.println(hashTab.toString());

        System.out.println("删除后===》");
        hashTab.remove(4);
        System.out.println(hashTab.toString());
    }
}

class HashTab {

    private NodeList[] nodes;
    private int size;

    public HashTab(int size) {
        this.size = size;
        nodes = new NodeList[size];
        for (int i = 0; i < size; i++) {
            nodes[i] = new NodeList();
        }
    }

    public void put(Node node) {
        // 放入hash表的位置
        nodes[getPosition(node.id)].add(node);
    }

    public void remove(int id) {
        nodes[getPosition(id)].delete(id);
    }


    private int getPosition(int id) {
        return id % size;
    }

    @Override
    public String toString() {
        return "HashTab{" +
                "nodes=\n" + Arrays.toString(nodes) +
                "}";
    }
}

class NodeList {
    // 头结点
    Node head = null;

    // 添加结点方法
    public void add(Node node) {
        if (head == null) {
            head = node;
            return;
        }

        // 头结点不要动，将添加的结点放到链表的最后一个位置
        Node tmp = head;
        // 当下一个结点等于null时，找到最后一个结点
        while (tmp.next != null) {
            tmp = tmp.next;
        }
        tmp.next = node;
    }


    // 展示当前链表
    public void list() {
        if (head == null) {
            System.out.println("当前链表为空");
            return;
        }
        // 辅助结点
        Node tmp = head;
        while (true) {
            System.out.println(tmp);
            if (tmp.next == null) {
                break;
            }
            tmp = tmp.next;
        }
    }

    // 根据ID删除链表中的某个结点
    public void delete(int id) {
        if (head == null) {
            System.out.println("当前链表为空");
            return;
        }
        // 判断删除的是否是头结点
        if (head.id == id) {
            head = head.next;
            return;
        }

        Node preNode = head;
        Node curNode = preNode.next;
        while (curNode != null) {
            if (curNode.id == id) {
                preNode.next = curNode.next;
                System.out.println("删除成功，删除的是: " + curNode.id + "," + curNode.name);
                curNode = null;
                return;
            }
            preNode = preNode.next;
            curNode = curNode.next;
        }
        System.out.println("删除失败，节点不存在");
    }


    @Override
    public String toString() {
        return "NodeList{" +
                "head=" + head +
                "}\n";
    }
}

class Node {
    int id;
    String name;
    Node next;

    public Node(int id, String name) {
        this.id = id;
        this.name = name;
    }

    @Override
    public String toString() {
        return "Node{" +
                "id=" + id +
                ", name='" + name + '\'' +
                ", next=" + next +
                "}";
    }
}
```
### 二叉树
> 二叉树（Binary tree）是树形结构的一个重要类型。许多实际问题抽象出来的数据结构往往是二叉树形式，即使是一般的树也能简单地转换为二叉树，而且二叉树的存储结构及其算法都较为简单，因此二叉树显得特别重要。二叉树特点是每个结点最多只能有两棵子树，且有左右之分。

二叉树是n个有限元素的集合，该集合或者为空、或者由一个称为根的元素及两个不相交的、被分别称为左子树和右子树的二叉树组成，是有序树。当集合为空时，称该二叉树为空二叉树。在二叉树中，一个元素也称作一个结点。

如果该二叉树的所有叶子节点都在最后一层，并且结点总数为 2^n -1， n 为层数，则称为满二叉树。

如果该二叉树的所有叶子节点都在最后一层或者倒数第二层，而且最后一层的叶子节点在左边连续，倒数第二层的叶子节点在右边连续，我们称为完全二叉树。

> PS: 二叉树中结点等价于节点

![数据结构与算法-022](/iblog/posts/images/essays/数据结构与算法-022.png)

#### 二叉树的遍历
对于二叉树来讲最主要、最基本的运算是遍历。遍历二叉树 是指以一定的次序访问二叉树中的每个结点。所谓访问结点是指对结点进行各种操作的简称。例如，查询结点数据域的内容，或输出它的值，或找出结点位置，或是执行对结点的其他操作。遍历二叉树的过程实质是把二叉树的结点进行线性排列的过程。




## 算法
英文对应的单词是Algorithm，它的本意为：解决问题的方法，所以算法的直接理解就是解决问题的方法。在计算机领域定义的话就是：一系列解决问题的、清晰、可执行的计算机指令。

一个算法的优劣可以用空间复杂度与时间复杂度来衡量。

### 算法复杂度

#### 时间复杂度
度量一个算法执行时间的两种方法：
- 事后统计法：即直接运行程序，统计需要的时间和空间。但是，这种方法有两个问题：
    1. 结果非常依赖于测试环境。比如，用 Core i3 和用 Core i8 运行程序所需的时间是不同的;
    2. 结果受测试规模的影响特别大。比如，对有序数组进行排序的时间比对逆序数组排序的时间短；对于小规模数据而言，插入排序所需时间比快速排序要短;

    所以，就需要有一种不用具体测试数据，也能估计算法执行效率的方法，就是算法复杂度分析，包括时间、空间复杂度分析。

- 事前估算法：通过分析某个算法的时间复杂度来判断那个算法更优;

一般情况下，算法中的基本操作语句的重复执行次数是问题规模 n 的某个函数， 用`T(n)`表示，若有某个辅助函数`f(n)`，使得当 n 趋近于无穷大时，`T(n)/f(n)`的极限值为不等于零的常数，则称`f(n)`是`T(n)`的同数量级函数。记作 `T(n)=Ｏ(f(n))`， 称`Ｏ(f(n))`为算法的渐进时间复杂度，简称时间复杂度。

例如，T(n) = n + 1 与 T(n) = n 就是同数量级函数，因为 n+1/n 的极限值为不等于零的常数。
T(n) 不同，但时间复杂度可能相同: T(n)=n²+7n+6 与 T(n)=3n²+2n+2 它们的 T(n) 不同， 但时间复杂度相同，都为 O(n²)。

计算时间复杂度的方法：
- 用常数 1 代替运行时间中的所有加法常数： T(n)=n²+7n+6 => T(n)=n²+7n+1
- 修改后的运行次数函数中，只保留最高阶项： T(n)=n²+7n+1 => T(n) = n²
- 去除最高阶项的系数：T(n) = n² => T(n) = n² => O(n²)

---
**时间频度**

一个算法花费的时间与算法中的语句的执行次数成正比例,哪个算法执行次数多,他花费的时间就多.一个算法中的语句执行次数称为语句频度或时间频度.记为T(n)。

随着时间的推移，一些复杂度花费时间无限接近：
1. 忽略常数项:
- 2n+20 和 2n 随着 n 变大，执行曲线无限接近,20 可以忽略
- 3n+10 和 3n 随着 n 变大，执行曲线无限接近,10 可以忽略

2. 忽略低次项:
- 2n²+3n+10 和 2n² 随着 n 变大, 执行曲线无限接近,可以忽略 3n+10
- n²+5n+20 和 n² 随着 n 变大,执行曲线无限接近,可以忽略 5n+20

3. 忽略系数:
- 随着 n 值变大， 5n²+7n 和 3n² + 2n ，执行曲线重合, 说明这种情况下, 5 和 3 可以忽略
- 对于 n^3+5n 和 6n^3+4n，执行曲线分离，不能忽略系数，说明多少次方是关键

--- 
**常见的时间复杂度**

- 常数阶 O(1): 无论代码执行了多少行，只要是没有循环等复杂结构，这个代码的时间复杂度就都是O(1)；
    ```
    int i = 1;
    int j = 2;
    ++i;
    j++;
    int m = i + j;
    ```
- 对数阶 O(log2n)

    ![数据结构与算法-012](/iblog/posts/images/essays/数据结构与算法-012.png)

    ```
    int i = 1;
    while(i<n){
        i = i*2;
    }
    ```
- 线性阶 O(n): 它消耗的时间是随着n的变化而变化的,与n成正比或反比；
    ```
    for(int i=1; i<=n; ++i){
        j = i;
        j++;
    }
    ```
- 线性对数阶 O(nlog2n): 将时间复杂度为O(logn)的代码循环n遍，那么它的时间复杂度就是 n * O(logN)，也就是了O(nlogN);
    ```
    for(int m=1; m<=n; ++m){
        int i = 1;
        while(i<n){
            i = i*2;
        }
    }
    ```
- 平方阶 O(n^2): 如果把 O(n) 的代码再嵌套循环一遍，它的时间复杂度就是 O(n²)，这段代码其实就是嵌套了2层n循环，它的时间复杂度就是 `O(n*n)`，即 O(n²) 如果将其中一层循环的n改成m，那它的时间复杂度就变成了 `O(m*n)`;
    ```
    for(int i=1; i<=n; ++i){
        for(int j=1; j<=n; ++j){
            j=i;
        }
    }
    ```
- 立方阶 O(n^3)
    ```
    for(int i=1; i<=n; ++i){
        for(int j=1; j<=n; ++j){
            for(int x=1; x<=n; ++x){
                int m = 0;
                i = x+j;
            }
        }
    }
    ```
- k 次方阶 O(n^k)
- 指数阶 O(2^n)

常见的算法时间复杂度由小到大依次为： 
```
Ο (1)＜Ο (log2n)＜Ο (n)＜Ο (nlog2n)＜Ο (n2)＜Ο (n3)＜ Ο (nk) ＜ Ο (2n)
```
随着问题规模 n 的不断增大，上述时间复杂度不断增大，算法的执行效率越低。

#### 空间复杂度
类似于时间复杂度的讨论，一个算法的空间复杂度(Space Complexity)定义为该算法所耗费的存储空间，它也是问题规模 n 的函数。

空间复杂度全称为渐进空间复杂度，是对一个算法在运行过程中临时占用存储空间大小的量度。 有的算法需要占用的临时工作单元数与解决问题的规模 n 有关， 它随着 n 的增大而增大， 当 n 较大时， 将占用较多的存储单元， 例如快速排序和归并排序算法, 基数排序就属于这种情况
在做算法分析时， 主要讨论的是时间复杂度。 从用户使用体验上看， 更看重的程序执行的速度。 一些缓存产品(redis, memcache)和算法(基数排序)本质就是用空间换时间

空间复杂度较为简单，常见的空间复杂度为 O(1)，O(n) 和 O(n ^ 2)。

### 递归
递归就是方法自己调用自己，每次调用时传入不同的变量，递归有助于编程者解决复杂的问题，同时可以让代码变得简洁。

**递归能解决什么问题？**
- 各种数学问题如: 8 皇后问题，汉诺塔，阶乘问题，迷宫问题，球和篮子的问题(google 编程大赛)；
- 各种算法中也会使用到递归， 比如快排， 归并排序， 二分查找， 分治算法等；
- 用栈解决的问题，使用递归替换代码更佳简洁；

使用递归遵守的规则：
- 执行一个方法时，就创建一个新的受保护的独立空间(一个线程有自己独立的一个栈空间，每个方法调用对应着一个栈帧)；
- 方法的局部变量是独立的，不会相互影响；
- 如果方法中使用的是引用类型变量，就会共享该引用类型的数据，比如数组；
- 递归必须向退出递归的条件逼近，否则就是无限递归，出现 StackOverflowError；
- 当一个方法执行完毕，或者遇到return，就会返回，遵守谁调用，就将结果返回给谁，同时当方法执行完毕或者返回时，该方法也就执行完毕；

#### 迷宫回溯
迷宫回溯问题，寻找最短路径可以通过改变策略，将每个策略都经过的路保存在集合中，最后看哪个集合最小即最小路径。

```
public class MyTest {

    public static void main(String[] args) {
        Mazeback mazeback = new Mazeback();

        int[][] map = mazeback.createMap();
        mazeback.list(map);

        System.out.println("自动寻找路线：");

        mazeback.setWay(map, 1, 1);
        mazeback.list(map);
    }

}


class Mazeback {

    // 创建地图
    public int[][] createMap() {
        // 地图
        int[][] map = new int[7][8];

        for (int i = 0; i < 7; i++) {
            map[i][0] = 1;
            map[i][7] = 1;
            map[6][i] = 1;
            map[0][i] = 1;
        }
        map[3][1] = 1;
        map[3][2] = 1;
        return map;
    }

    // 遍历地图
    public void list(int[][] map) {
        for (int i = 0; i < map.length; i++) {
            for (int j = 0; j < map[i].length; j++) {
                System.out.print(map[i][j] + "");
            }
            System.out.println();
        }
    }

    // 寻找路径
    // 1：墙；2：通路，3：死路
    public boolean setWay(int[][] map, int row, int column) {
        if (map[5][6] == 2) {
            return true;
        }
        if (map[row][column] == 0) {

            // 先假设是通路
            map[row][column] = 2;

            // 寻找路径顺序：下，右，上，左
            if (setWay(map, row + 1, column)) {
                return true;
            } else if (setWay(map, row, column + 1)) {
                return true;
            } else if (setWay(map, row - 1, column)) {
                return true;
            } else if (setWay(map, row, column - 1)) {
                return true;
            } else {
                // 当标记为3时，说明是死路走不通
                map[row][column] = 3;
                return false;
            }
        }
        return false;
    }

}
```
#### 八皇后问题
八皇后问题，是一个古老而著名的问题，是回溯算法的典型案例。该问题是国际西洋棋棋手马克斯·贝瑟尔于1848 年提出：在 8 × 8 格的国际象棋上摆放八个皇后，使其不能互相攻击， 即： 任意两个皇后都不能处于同一行、同一列或同一斜线上，问有多少种摆法。

> 八皇后问题共92中解法

![数据结构与算法-010](/iblog/posts/images/essays/数据结构与算法-010.png)

```
public class MyTest {

    public static void main(String[] args) {
        EightQueens eightQueens = new EightQueens();
        eightQueens.exec(0);
    }

}


class EightQueens {

    private int[] arr;

    private int max;

    public EightQueens() {
        this.max = 8;
        this.arr = new int[max];
    }


    // 算法
    public void exec(int position) {
        // 如果当前位置等于max说明解法成立，需要回溯
        if (position == max) {
            print();
            return;
        }
        for (int i = 0; i < max; i++) {
            arr[position] = i;
            if (check(position)){
                exec(position + 1);
            }
        }
    }


    // 判断皇后位置是否冲突
    private boolean check(int position) {
        for (int j = 0; j < position; j++) {
            // 判断是否在同一列或在同一斜线上
            if (arr[position] == arr[j] || Math.abs(position - j) == Math.abs(arr[position] - arr[j])) {
               return false;
            }
        }
        return true;
    }


    // 打印数组
    private void print() {
        for (int i = 0; i < arr.length; i++) {
            System.out.print(arr[i] + "");
        }
        System.out.println();
    }

}
```

### 排序算法
排序也称排序算法，是将一组数据，依指定的顺序进行排列的过程。

排序算法分类：
- 内部排序：指将需要处理的所有数据都加载到内部存储器(内存)中进行排序；
- 外部排序法：数据量过大，无法全部加载到内存中，需要借助外部存储(文件等)进行排序；

![数据结构与算法-011](/iblog/posts/images/essays/数据结构与算法-011.png)

常见内排序算法复杂度比较

![数据结构与算法-013](/iblog/posts/images/essays/数据结构与算法-013.png)

名词解释：
- n：数据规模
- k："桶"的个数
- In-place：占用常数内存，不占用额外内存
- Out-place：占用额外内存
- 稳定性：排序后两个相等键值的顺序和排序之前它们的顺序相同，不稳定性则相反
- 时间复杂度：一个算法执行所耗费的时间
- 空间复杂度：运行完一个程序所需内存的大小

#### 冒泡排序
冒泡排序的基本思想是：通过对待排序序列从前向后（从下标较小的元素开始），依次比较相邻元素的值，若发现逆序（当前值大于比较的值）则交换，使值较大的元素逐渐从前移向后部，就像水底下的气泡一样逐渐向上冒。

![数据结构与算法-014](/iblog/posts/images/essays/数据结构与算法-014.gif)

优化：因为排序的过程中， 各元素不断接近自己的位置，如果一趟比较下来没有进行过交换，就说明序列有序，因此要在排序过程中设置一个标志 flag 判断元素是否进行过交换。 从而减少不必要的比较。


```
class BubbleSorting {

    public int[] sort(int[] data) {
        int len = data.length - 1;
        int tmp;
        boolean flag = false;

        for (int i = 0; i <len; i++){
            for (int j = 0; j < len - i; j++) {
                // 将当前值与next值进行比较，如果当前值大于next值则交换两者之间的位置
                if (data[j] > data[j+1]){
                    flag = true;
                    tmp = data[j];
                    data[j] = data[j+1];
                    data[j+1] = tmp;
                }
            }

            // 加入标志为进行判断，如果整个循环下啦都没有交换位置，说明该数组是有序的，所以直接退出循环
            if (!flag){
                break;
            }else {
                flag = false;
            }
        }
        return data;
    }
}
```

#### 选择排序
选择式排序也属于内部排序法，是从欲排序的数据中，按指定的规则选出某一元素，再依规定交换位置后达到排序的目的。

首先在未排序序列中找到最小元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小元素，然后放到排序序列末尾。以此类推，直到所有元素均排序完毕。

![数据结构与算法-015](/iblog/posts/images/essays/数据结构与算法-015.gif)
 
```
class SelectSorting{

    public int[] sort(int[] data) {
        for (int i = 0; i < data.length; i++){

            int min = i;

            for (int j = i+1; j < data.length; j++) {
                // 如果next值大于当前值，则记录该值和该值的位置，等全部比较完毕后，将最大的一个与数据的末尾进行替换
                if (data[i] > data[j]){
                    min = j;
                }
            }

            // 将每次循环中的最小的值，调整到最前面
            if (min != i){
                int tmp = data[i];
                data[i] = data[min];
                data[min] = tmp;
            }
        }
        return data;
    }
}
```
#### 插入排序

插入排序（Insertion Sorting） 的基本思想是：把 n 个待排序的元素看成为一个有序表和一个无序表;

开始时有序表中只包含一个元素，无序表中包含有 n-1 个元素，排序过程中每次从无序表中取出第一个元素，把它的排序码依次与有序表元素的排序码进行比较， 将它插入到有序表中的适当位置，使之成为新的有序表。

对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。

![数据结构与算法-016](/iblog/posts/images/essays/数据结构与算法-016.gif)

```
class InsertSorting{

    public int[] sort(int[] data) {
        for (int i = 1; i < data.length; i++){
            // 如果当前要插入的值 data[i] > 有序队列中最后一个，则将其直接插入到最后一个
            if (data[i] > data[i - 1]){
                continue;
            }

            int tmp = data[i];
            int index = i - 1;
            // 如果当前位置的值【tmp】小于 上一个位置的值【data[index]】说明当前值需要插入到有序队列中
            while (index >= 0 && tmp < data[index]){
                data[index + 1] = data[index];
                index--;
            }
            data[index + 1] = tmp;
        }
        return data;
    }

}
```

#### 希尔排序
希尔排序是希尔（Donald Shell） 于1959年提出的一种排序算法。希尔排序也是一种插入排序，它是简单插入排序经过改进之后的一个更高效的版本，也称为缩小增量排序。

希尔排序按照增量将数组进行分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。

![数据结构与算法-017](/iblog/posts/images/essays/数据结构与算法-017.gif)

```

class ShellSorting{

    // 希尔排序，交换法
    public void sortSwap(int[] data){
        int size = data.length;
        int tmp = 0;

        // 将数据分组，分组数量：data.length/2
        for (int gap = size >> 1; gap > 0; gap >>= 1){

            for (int i = gap; i < size; i++) {
                // 遍历每组中的元素
                for (int j = i - gap; j >= 0; j -= gap) {
                    // 将每组中的元素进行排序（交换元素）
                    if (data[j] > data[j + gap]){
                        tmp = data[j];
                        data[j] = data[j+gap];
                        data[j+gap] = tmp;
                    }
                }
            }
        }
    }

    // 插入法，融入 插入排序 思想
    public void sort(int[] data){
        int size = data.length;
        int tmp = 0;

        // 将数据分组，分组数量：data.length/2
        for (int gap = size >> 1; gap > 0; gap >>= 1) {
            for (int i = gap; i < size; i++) {

                tmp = data[i];
                int index = i;

                // 如果当前位置的值【tmp】小于 上一个位置的值【data[index]】说明当前值需要插入到有序队列中
                while (index - gap >= 0 && tmp < data[index - gap]){
                    data[index] = data[index - gap];
                    index -= gap;
                }
                data[index] = tmp;
            }
        }
    }
    
}
```
#### 快速排序
快速排序是由东尼·霍尔所发展的一种排序算法。在平均状况下，排序n个项目要 Ο(nlogn) 次比较。在最坏状况下则需要 Ο(n2) 次比较，但这种状况并不常见。事实上，快速排序通常明显比其他 Ο(nlogn) 算法更快，因为它的内部循环可以在大部分的架构上很有效率地被实现出来。

快速排序又是一种分而治之思想在排序算法上的典型应用。本质上来看，快速排序应该算是在冒泡排序基础上的递归分治法。快速排序思路：
- 选定pivot基准数
- 将大于pivot基准数放在基准数右边
- 将小于pivot基准数放在基准数左边

![数据结构与算法-018](/iblog/posts/images/essays/数据结构与算法-018.gif)

```
class QuickSorting {

    public void sort(int[] data, int l, int r) {

        // 如果开始的位置大于等于结束的位置则不用进行比较直接退出
        if (l >= r){
            return;
        }

        int left = l;
        int right = r;

        // 基准数值，将小于该数值的放在该数字的左边，大于该数值的放在右边
        int pivot = data[left];

        while (left < right) {

            // 从右向左开始比较，如果此数大于等于基准数则将right索引向前移动，否则，将该值覆盖到对应的 data[left] 中
            while (left < right && data[right] >= pivot) {
                --right;
            }
            data[left] = data[right];

            // 从左向右开始比较，如果此数小于等于基准数则将left索引向后移动，否则，将该值覆盖到对应的 data[right] 中
            while (left < right && data[left] <= pivot) {
                ++left;
            }
            data[right] = data[left];
        }

        // 此时left与right指向重合的位置为基准所在的位置，需要将该位置覆盖掉为基准的值
        data[left] = pivot;

        // 递归排序
        sort(data, l, left);
        sort(data, right+1,r);
    }
} 
```
#### 归并排序
归并排序是利用归并的思想实现的排序方法， 该算法采用经典的分治（divide-and-conquer）策略；分治法将问题分成一些小的问题然后递归求解， 而治的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之。

归并排序算法思路：采用分治算法思想，首先将序列使用递归进行拆分，然后进行合并；合并思路，将两个有序队列中的元素分别按顺序进行比较，将结果保存在一个临时数组中，最后将临时数组合并到最后的队列中。

![数据结构与算法-019](/iblog/posts/images/essays/数据结构与算法-019.gif)

```
class MergeSorting {

    // 递归拆分算法
    public void divide(int[] arr, int start, int end, int[] tmpArr) {
        if (start >= end) {
            return;
        }
        int mid = (start + end) >> 1;

        // 分别向左向右递归
        divide(arr, start, mid, tmpArr);
        divide(arr, mid + 1, end, tmpArr);

        // 拆分一次合并一次
        merge(arr, start, mid, end, tmpArr);

    }

    // 合并算法
    public void merge(int[] arr, int start, int mid, int end, int[] tmpArr) {
        int leftIndex = start;
        int rightIndex = mid + 1;
        int tmpArrIndex = 0;

        // 判断是否超出范围
        while (leftIndex <= mid && rightIndex <= end) {

            // 将两组数据进行比较，按照从小到大的顺序将两组数据填入 tmpArr 中
            if (arr[leftIndex] <= arr[rightIndex]) {
                tmpArr[tmpArrIndex] = arr[leftIndex];
                ++leftIndex;
            } else {
                tmpArr[tmpArrIndex] = arr[rightIndex];
                ++rightIndex;
            }
            ++tmpArrIndex;
        }

        // 判断两组数据是否还有剩余，如果有剩余数据，则直接将数据追加到 tmpArr 数组后边
        while (leftIndex <= mid) {
            tmpArr[tmpArrIndex] = arr[leftIndex];
            ++leftIndex;
            ++tmpArrIndex;
        }

        while (rightIndex <= end) {
            tmpArr[tmpArrIndex] = arr[rightIndex];
            ++rightIndex;
            ++tmpArrIndex;
        }

        // 将两组数据进行合并
        tmpArrIndex = 0;
        int tmpLeftIndex = leftIndex;
        while (tmpLeftIndex <= end) {
            arr[tmpLeftIndex] = tmpArr[tmpArrIndex];
            ++tmpLeftIndex;
            ++tmpArrIndex;
        }
    }
    
}
```
#### 基数排序

基数排序是 1887 年赫尔曼·何乐礼发明的。基数排序属于“分配式排序”，又称“桶子法”或 bin sort，顾名思义，它是通过键值的各个位的值，将要排序的元素分配至某些“桶”中，达到排序的作用,基数排序法是属于稳定性的排序， 基数排序法的是效率高的稳定性排序法。

基数排序是桶排序的扩展，它是这样实现的： 将所有待比较数值统一为同样的数位长度，数位较短的数前面补零；然后， 从最低位开始， 依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。

![数据结构与算法-020](/iblog/posts/images/essays/数据结构与算法-020.gif)

```
class BucketSorting {

    public void sort(int[] arr) {
        // 求数组中最大数的长度
        int maxNum = arr[0];
        for (int i = 0; i < arr.length; i++) {
            if (arr[i] > maxNum) {
                maxNum = arr[i];
            }
        }
        int maxNumLen = String.valueOf(maxNum).length();

        // 桶，用于保存数据
        int[][] buckets = new int[10][arr.length];

        // 存放每个桶的保存数据的索引
        int[] bucketElementIndex = new int[10];

        // 将数组中的元素 按照 个、十、百、千 …… 的顺序依次放入桶中
        for (int i = 0, n = 1; i < maxNumLen; i++, n *= 10) {

            // 遍历二维数组
            for (int j = 0; j < arr.length; j++) {
                // 计算放入的桶的下标
                int index = arr[j] / n % 10;
                buckets[index][bucketElementIndex[index]] = arr[j];
                bucketElementIndex[index]++;
            }

            // 从桶中依次取出元素并放入原数组中
            int index = 0;
            for (int f = 0; f < bucketElementIndex.length; f++) {
                // 判断桶中是否保存数据
                if (bucketElementIndex[f] == 0) {
                    continue;
                }
                for (int h = 0; h < bucketElementIndex[f]; h++) {
                    arr[index] = buckets[f][h];
                    index++;
                }
                bucketElementIndex[f] = 0;
            }
        }

    }

}
```
### 查找算法
#### 线性查找
线性查找又称顺序查找，是一种最简单的查找方法，它的基本思想是从第一个记录开始，逐个比较记录的关键字，直到和给定的K值相等，则查找成功；若比较结果与文件中n个记录的关键字都不等，则查找失败。

```
class LinearSearch{

    public int search(int[] arr, int value){
        for (int i = 0; i < arr.length; i++){
            if (arr[i] == value) {
                return i;
            }
        }
        return - 1;
    }

}
```
#### 二分查找
二分查找也称折半查找，它是一种效率较高的查找方法。但是，折半查找要求线性表必须采用顺序存储结构，而且表中元素按关键字有序排列。

**二分查找算法的前提，数组必须是有序数组，如果没有有序列表，请使用[排序算法](/iblog/posts/essays/data-structures-algorithms/#排序算法)对列表进行排序。**

```
class BinarySearch {

    // 使用二分查找时，arr必须为有序列表
    public int search(int start, int end, int[] arr, int value) {
        // 在 {@param arr} 中 没有查到 {@param value}
        if (start > end || value > arr[end] || value < arr[start]) {
            return -1;
        }

        // 获取中间值，用于分割列表
        int mid = (start + end) >> 1;
        int midVal = arr[mid];

        // 如果 查找的值< 中间值，说明该值可能在mid的左边
        if (value < midVal) {
            return search(start, mid - 1, arr, value);
        }

        // 相反如果 查找的值 > 中间值，说明该值可能在mid的右边
        if (value > midVal) {
            return search(mid + 1, end, arr, value);
        }

        // 使用递归不停的向下细分，当 value == arr[mid] 时 返回该值，说明此时已经找到了
        return mid;
    }
}
```
#### 插值查找
插值查找算法类似于二分查找，与二分查找不同的是插值查找每次从自适应 mid 处开始查找，而不是像二分查找那样每次都从中间开始找。

![数据结构与算法-021](/iblog/posts/images/essays/数据结构与算法-021.png)

注意：对于数据量较大，关键字分布比较均匀（最好是线性分布）的查找表来说，采用插值查找，速度较快；对于关键字分布不均匀的情况下，该方法不一定比二分查找要好。

```
class InsertValueSearch {

    // 与二分查找基本相同，只是查找 mid 值发生了变动
    public int search(int start, int end, int[] arr, int value) {
        // 在 {@param arr} 中 没有查到 {@param value}
        if (start > end || value > arr[end] || value < arr[start]) {
            return -1;
        }

        int mid = start + (value - arr[start]) / (arr[end] - arr[start]) * (end - start);
        int midVal = arr[mid];

        if (value < midVal) {
            return search(start, mid - 1, arr, value);
        }

        if (value > midVal) {
            return search(mid + 1, end, arr, value);
        }
        return mid;
    }

}
```
#### 斐波那契查找

斐波那契查找是基于【黄金分割】的二分查找。即在斐波那契队列中，将二分查找中的分割点替换为黄金分割点，来查找。

> 黄金分割是指将整体一分为二，较大部分与整体部分的比值等于较小部分与较大部分的比值，其 比值 约为 0.618。这个比例被公认为是最能引起美感的 比例，因此被称为黄金分割。

斐波那契查找特点：
- 平均性能「斐波那契查找」好于「二分查找」；
- 「斐波那契查找」计算 mid 的时候 使用加减法而不是除法，会微弱提升效率；

```
class FibonacciSearch{
    // lookupTable,需要传入斐波那契数列,例如：{1,1,2,3,5,8,13,21,34,55};
    public static int search(int[] lookupTable,int[] f,int target){

        int low = 0;
        int high = lookupTable.length - 1;

        // k 是 Fibonacci 分割数组下标
        int k = 0;
        int middle = 0;

        while (f[k] < high){
            k ++;
        }

        //利用 java 工具类构造 f[k] 长度的查找表，解决原有查找表元素不够的问题
        int[] temp = Arrays.copyOf(lookupTable,f[k]);
        while (low <= high){
            middle = low + f[k - 1];
            if (target < lookupTable[middle]){
                high = middle -1;
                k --;
            }else if (target > lookupTable[middle]){
                low = middle + 1;
                k -= 2;
            }else{
                return middle < high ? middle : high;
            }
        }
        return -1;
    }
}
```

### 分治算法
### 动态规划算法
### KMP算法
### 贪心算法
### 普里姆算法
### 克鲁斯卡尔算法
### 迪杰斯特拉算法
### 弗洛伊德算法
### 马踏棋盘算法



