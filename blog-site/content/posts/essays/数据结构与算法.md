---
title: "数据结构与算法"
date: 2021-12-10
draft: false
tags: ["Java","算法"]
slug: "data-structures-algorithms"
---

## 数据结构
数据结构是一门研究组织数据方式的学科，有了编程语言也就有了数据结构，学好数据结构可以编写出更有效率的代码。数据结构是算法的基础，想要学好算法，就必须把数据结构学到位。

数据结构包括：线性结构、非线性结构。

线性结构作为最常用的数据结构，其特点是数据元素之间存在一对一的线性存储关系。线性结构有两种不同的存储结构，即顺序存储和链式存储。顺序存储的线性表被称为顺序表，顺序表中存储元素的地址是连续的；链式存储的线性表被称为链表，链表中存储元素的地址不一定是连续的，元素结点中存放数据元素以及相邻元素地址信息。

常见的线性结构有：数组、链表、队列、栈；常见非线性结构有：多维数组、广义表、树结构、图结构。

### 稀疏数组
使用稀疏数组可以用来压缩数据。稀疏数组的第一行依次记录原数组一共有几行几列，有多少个不为零的值，之后的每行记录原数组中不为零的值所在的行数、列数以及数组中元素该值。如图所示：

![数据结构与算法-001](/iblog/posts/images/essays/数据结构与算法-001.png)

二维数组转稀疏数组
```
    // 将二维数组转换为稀疏数组
    public static int[][] twoDimensionArrayToSparseArray(int[][] array) {
        // 记录棋盘中有效值的数量
        int sum = 0;
        int row = array.length;
        int column = 0;
        for (int[] ints : array) {
            column = ints.length;
            for (int item : ints) {
                if (item != 0) {
                    sum++;
                }
            }
        }

        // 创建稀疏数组
        int[][] sparseArray = new int[sum + 1][3];
        sparseArray[0][0] = row;
        sparseArray[0][1] = column;
        sparseArray[0][2] = sum;

        // 给稀疏数组赋值
        int count = 0;
        for (int i = 0; i < array.length; i++) {
            for (int j = 0; j < array[i].length; j++){
                if (array[i][j] != 0){
                    count++;
                    sparseArray[count][0] = i;
                    sparseArray[count][1] = j;
                    sparseArray[count][2] = array[i][j];
                }
            }
        }

        System.out.println("稀疏数组====》");
        for (int i = 0; i < sparseArray.length; i++) {
            System.out.printf("%d\t%d\t%d\t\n",sparseArray[i][0],sparseArray[i][1],sparseArray[i][2]);
        }
        return sparseArray;
    }
```

稀疏数组转二维数组
```
    // 稀疏数组转二维数组
    public static int[][] sparseArrayToTwoDimensionArray(int[][] sparseArray) {
        int[][] toTwoDimensionArray = new int[sparseArray[0][0]][sparseArray[0][1]];
        // 给二维数组赋值
        for (int i = 1; i < sparseArray.length; i++) {
            toTwoDimensionArray[sparseArray[i][0]][sparseArray[i][1]] = sparseArray[i][2];
        }

        System.out.println("二维数组====》");
        for (int[] row : toTwoDimensionArray) {
            for (int data : row) {
                System.out.printf("%d\t", data);
            }
            System.out.println();
        }
        return toTwoDimensionArray;
    }
```

### 队列
队列是一个有序列表，可以使用数组或链表来实现。队列遵循先入先出的原则。即，先存入队列的数据，要先取出。后存入的要后取出。

使用数组模拟队列示意图：

![数据结构与算法-002](/iblog/posts/images/essays/数据结构与算法-002.png)

数组模拟单向队列
```
    public class ArrayQueue{

        // 队列容量
        private int capacity;

        // 保存队列中的数据
        private int[] arr;

        // 头部指针
        private int front;

        // 尾部指针
        private int rear;

        public ArrayQueue(int capacity) {
            this.capacity = capacity;
            arr = new int[capacity];
            front = -1;
            rear = -1;
        }

        public boolean isEmpty() {
            return front == rear;
        }

        public boolean isFull() {
            return capacity - 1 == rear;
        }

        public void add(int data) {
            if (isFull()) {
                System.out.println("队列已经满了，不能在继续添加");
                return;
            }
            arr[++rear] = data;
        }

        public int get() {
            if (isEmpty()) {
                System.out.println("队列为空，不能获取元素");
                return -1;
            }
            return arr[++front];
        }

        // 显示队列的所有数据
        public void show() {
            if (isEmpty()) {
                System.out.println("队列空的，没有数据~~");
                return;
            }
            System.out.println("开始遍历队列：");
            for (int i = front + 1; i <= rear; i++) {
                System.out.printf("arr[%d]=%d\n", i, arr[i]);
            }
        }


        // 显示队列的头数据， 注意不是取出数据
        public int peek() {
            if (isEmpty()) {
                throw new RuntimeException("队列空的，没有数据~~");
            }
            return arr[front + 1];
        }

    }
```

数组模拟环形队列
```
    public  class CircleArrayQueue{

        // 队列容量
        private int capacity;

        // 保存队列中的数据
        private int[] arr;

        // 头部指针
        private int front;

        // 尾部指针
        private int rear;

        public CircleArrayQueue(int capacity) {
            this.capacity = capacity;
            arr = new int[capacity];
        }

        public boolean isEmpty() {
            return front == rear;
        }

        public boolean isFull() {
            // 此处+1 是因为存储元素从0算起
            return (rear + 1) % capacity  == front;
        }

        public void add(int data) {
            if (isFull()) {
                System.out.println("队列已经满了，不能在继续添加");
                return;
            }
            arr[rear] = data;
            rear = (rear + 1) % capacity;
        }

        public int get() {
            if (isEmpty()) {
                System.out.println("队列为空，不能获取元素");
                return -1;
            }
            int value = arr[front];
            front = (front + 1) % capacity;
            return value;
        }

        // 显示队列的所有数据
        public void show() {
            if (isEmpty()) {
                System.out.println("队列空的，没有数据~~");
                return;
            }
            System.out.println("开始遍历队列：");
            for (int i = front % capacity; i < front + ((rear + capacity - front) % capacity); i++) {
                System.out.printf("arr[%d]=%d\n", i, arr[i]);
            }
        }

        // 显示队列的头数据， 注意不是取出数据
        public int peek() {
            if (isEmpty()) {
                throw new RuntimeException("队列空的，没有数据~~");
            }
            return arr[front];
        }

    }
```
### 链表
链表属于线性结构，存储空间不连续。

链表特点：
- 链表是以节点的方式来存储，是链式存储；data 域存放数据，next 域指向下一个节点；
- 链表分带头节点的链表和没有头节点的链表，根据实际的需求来确定；

![数据结构与算法-003](/iblog/posts/images/essays/数据结构与算法-003.png)

#### 单向链表
操作单向链表：对于插入、删除操作，只能定位至待操作节点的前一个节点，如果定位至当前节点，那么其上一个节点的信息便会丢失。

单向链表，链表的增、删、查、改
```
class SingleLinkedList{

    // 头结点
    private Node headNode = new Node(0,"");

    // 添加方法
    public  void add(Node node){
        Node tmpNode = headNode;

        while (tmpNode.next != null){
            // 指向下一个结点
            tmpNode = tmpNode.next;
        }
        // 退出循环意味着tmpNode.next == null 即找到最后一个结点了
        tmpNode.next = node;
    }

    // 顺序添加
    public void addByOrder(Node node){
        boolean flag = false;
        Node tmp = headNode;
        while (true){
            if (tmp.next == null) {
                break;
            }

            // 将新插入的结点num跟链表中已经存在的num进行比较，如果 < 链表中的结点 则说明找到了该位置
            if (node.num < tmp.next.num){
                break;
            }
            // 如果num相同则不能添加
            if (node.num == tmp.next.num){
                flag = true;
                break;
            }
            tmp = tmp.next;
        }

        if (!flag){
            node.next = tmp.next;
            tmp.next = node;
            return;
        }
        System.out.printf("需要添加的结点编号：%d已经存在了",node.num);
    }

    // 遍历链表
    public void list() {
        // 遍历除了头结点外的所有结点
        Node tmpNode = headNode.next;
        if (tmpNode == null){
            System.out.println("链表为空！");
            return;
        }

        while (tmpNode != null){
            System.out.println(tmpNode);
            // 指向下一个结点
            tmpNode = tmpNode.next;
        }
    }


}


class Node {

    int num;
    String name;
    Node next;

    public Node(int num,String name){
        this.num = num;
        this.name = name;
    }

    @Override
    public String toString() {
        return "Node{" +
                "num=" + num +
                ", name='" + name + '\'' +
                '}';
    }
}
```

反转单向链表

![数据结构与算法-004](/iblog/posts/images/essays/数据结构与算法-004.png)

```
    // 反转链表
    public void reserve(Node head) {
        if (head.next == null || head.next.next == null){
            return ;
        }

        Node reserve = new Node(0, "");
        Node cur = head.next;
        Node next = null;
        // 遍历链表
        // 遍历原来的链表，每遍历一个节点，就将其取出，并放在新的链表reverseHead 的最前端
        while (cur != null){

            // 保存当前结点的下一个结点
            next = cur.next;

            // 将cur的下一个节点指向新的链表的最前端（覆盖掉）保证将最新的结点放到reseve的最前面
            cur.next = reserve.next;

            // 将cur 连接到新的链表上
            reserve.next = cur;

            // 将之前保存好的结点赋值给当前结点
            cur = next;
        }
```

利用栈逆序打印单向链表
```
    public void reservePrint(Node head) {
        if (head.next == null || head.next.next == null){
            return;
        }

        Stack<Node> nodes = new Stack<>();
        Node tmp = head.next;
        while (tmp != null){
            nodes.push(tmp);
            tmp = tmp.next;
        }

        // 从stack中取出结点
        while (nodes.size() > 0){
            System.out.println(nodes.pop());
        }
    }
```

#### 双向链表

对比单向链表：
- 单向链表，查找的方向只能是一个方向，而双向链表可以向前或者向后查找；
- 单向链表不能自我删除，需要靠辅助节点，而双向链表，则可以自我删除；

![数据结构与算法-005](/iblog/posts/images/essays/数据结构与算法-005.png)

双向链表，增、删、改、查
```
class DoubleLinkedList{

    // 头结点
    private Node headNode = new Node(0,"");


    public Node getHeadNode() {
        return headNode;
    }


    // 添加方法
    public  void add(Node node){
        Node tmpNode = headNode;

        while (tmpNode.next != null){
            // 指向下一个结点
            tmpNode = tmpNode.next;
        }
        // 退出循环意味着tmpNode.next == null 即找到最后一个结点了
        tmpNode.next = node;
        node.prev = tmpNode;
    }


    // 双向链表修改
    public void update(Node node){
        if (headNode == null) {
            return;
        }

        Node tmp = headNode.next;
        while (true){
            if (tmp == null){
                break;
            }
            if (node.num == tmp.num){
                tmp.name = node.name;
                break;
            }
            tmp = tmp.next;
        }
    }

    // 双向链表删除
    public void remove(int num){
        if (headNode.next == null){
            System.out.println("链表为空，无法删除！");
            return;
        }
        Node tmp = headNode.next;
        while (tmp != null){
            if (num == tmp.num){
                tmp.prev.next = tmp.next;

                // 最后一个结点的next 为null null.pre会出现空指针异常
                if(tmp.next != null) {
                    tmp.next.prev = tmp.prev;
                }
                break;
            }
            tmp = tmp.next;
        }
    }

    // 遍历链表
    public void list() {
        // 遍历除了头结点外的所有结点
        Node tmpNode = headNode.next;
        if (tmpNode == null){
            System.out.println("链表为空！");
            return;
        }

        while (tmpNode != null){
            System.out.println(tmpNode);
            // 指向下一个结点
            tmpNode = tmpNode.next;
        }
    }


}


class Node {

    int num;
    String name;
    Node next;
    Node prev;

    public Node(int num,String name){
        this.num = num;
        this.name = name;
    }

    @Override
    public String toString() {
        return "Node{" +
                "num=" + num +
                ", name='" + name + '\'' +
                '}';
    }
}
```

#### 约瑟夫问题

> 约瑟夫问题为：设编号为 1，2，…n的n个人围坐一圈，约定编号为 k（1<=k<=n） 的人从 1 开始报数,数到 m 的那个人出列，它的下一位又从 1 开始报数，数到 m 的那个人又出列， 依次类推，直到所有人出列为止，由此产生一个出队编号的序列。

用一个不带头结点的循环链表来处理约瑟夫问题：先构成一个有 n 个结点的单循环链表，然后由 k 结点起从 1 开始计数，计到 m 时，对应结点从链表中删除，然后再从被删除结点的下一个结点又从 1 开始计数，直到最后一个结点从链表中删除算法结束。

![数据结构与算法-006](/iblog/posts/images/essays/数据结构与算法-006.png)

```
class JoesphSingletonLinkedList {

    private Node first = null;


    // 向单向链表添加数据
    public void add(int nums) {
        if (nums < 1) {
            System.out.println("nums的值不正确");
            return;
        }
        Node cur = null;
        for (int i = 1; i <= nums; i++) {
            Node node = new Node(i);
            if (i == 1) {
                first = node;
                first.next = first;
                cur = first;
            } else {
                cur.next = node;
                node.next = first;
                cur = node;
            }
        }
    }


    // 遍历单向循环链表
    public void list() {
        Node tmp = first;
        while (true){
            System.out.printf("当前结点为：%d\n",tmp.num);
            if (tmp.next == first){
                break;
            }
            tmp = tmp.next;
        }
    }


    // 约瑟夫问题
    public void joseph(int startNum,int countNum,int sum){
        if (startNum > sum || startNum < 0 || countNum < 0) {
            System.out.println("输入的参数不正确！");
            return;
        }
        // 创建辅助指针，将该指针指向 first 的前一个
        Node helper = first;
        while (helper.next != first) {
            helper = helper.next;
        }

        // 将first 和 help指针循环 （startNum - 1）次；因为从startNum开始，需要减一
        for (int i = 0; i < startNum - 1; i++) {
            first = first.next;
            helper = helper.next;
        }

        while (true){
            // 当环形链表中只存在一个结点
            if (first == helper){
                break;
            }

            // 因为是环形链表，所以需要循环挨个出链表
            for (int i = 0; i < countNum - 1; i++) {
                first = first.next;
                helper = helper.next;
            }

            // 当前 first 就是出圈的结点
            System.out.printf("当前出队列的结点编号为：%d\n",first.num);
            first = first.next;
            helper.next = first;
        }
        System.out.printf("最后的结点为：%d\n",first.num);
    }

}


class Node {

    int num;
    Node next;

    public Node(int num){
        this.num = num;
    }

    @Override
    public String toString() {
        return "Node{" +
                "num=" + num +
                '}';
    }
}
```
### 栈
栈的英文为stack，是一个先入后出(FILO-First In Last Out)的有序列表，最先放入栈中元素在栈底，最后放入的元素在栈顶，而删除元素刚好相反，最后放入的元素最先删除，最先放入的元素最后删除。

栈是限制线性表中元素的插入和删除只能在线性表的同一端进行的一种特殊线性表。允许插入和删除的一端，为变化的一端，称为栈顶(Top)，另一端为固定的一端，称为栈底(Bottom)。

下图是出栈和入栈

![数据结构与算法-007](/iblog/posts/images/essays/数据结构与算法-007.png)

栈的应用场景：
- 子程序的调用： 在跳往子程序前， 会先将下个指令的地址存到堆栈中， 直到子程序执行完后再将地址取出， 以回到原来的程序中；
- 处理递归调用： 和子程序的调用类似， 只是除了储存下一个指令的地址外， 也将参数、 区域变量等数据存入栈中；
- 表达式的转换：中缀表达式转后缀表达式与求值；
- 二叉树的遍历；
- 图形的深度优先(depth 一 first)搜索法；


数组模拟栈
```
class ArrayStack<T>{

    private int size;
    private int top;
    private Object[] stack;

    public ArrayStack(int size) {
        this.size = size;
        this.stack = new String[size];
        top = -1;
    }

    public boolean isFull(){
        return top == size -1;
    }

    public boolean isEmpty() {
        return top == -1;
    }

    // 入栈
    public void push(String item) {
        if (isFull()) {
            System.out.println("栈已经满了，不能继续添加！");
            return;
        }
        top++;
        this.stack[top] = item;
    }

    // 出栈操作
    public T pop() {
        if (isEmpty()) {
            throw new RuntimeException("栈已经为空，不能继续pop");
        }
        T val = (T)this.stack[top];
        top--;
        return val;
    }

    // 遍历栈
    public void list() {
        if (isEmpty()) {
            System.out.println("栈为空不能继续遍历！");
            return;
        }

        System.out.println("遍历栈==》");
        for (int i = top; i >=0; i--){
            System.out.println(this.stack[i]);
        }
    }

}
```



## 算法
### 排序算法
### 二分查找
### 分治算法
### 动态规划算法
### KMP算法
### 贪心算法
### 普里姆算法
### 克鲁斯卡尔算法
### 迪杰斯特拉算法
### 弗洛伊德算法
### 马踏棋盘算法



