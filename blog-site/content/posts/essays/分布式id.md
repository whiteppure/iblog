---
title: "分布式id"
date: 2023-03-13
draft: false
tags: ["分布式"]
slug: "distributed-id"
---


## 分布式id
在我们业务数据量不大的时候，单库单表完全可以支撑现有业务，数据再大一点搞个MySQL主从同步读写分离也能对付。
但随着数据日渐增长，主从同步也扛不住了，就需要对数据库进行分库分表。在分库之后， 数据遍布在不同服务器上的数据库，数据库的自增主键已经没办法满足生成的主键唯一了，这个时候就需要生成分布式 ID了。

分布式ID一般都需要满足这些条件：
- 全局唯一：必须保证ID是全局性唯一的，基本要求；
- 高性能：高可用低延时，ID生成响应要块，否则反倒会成为业务瓶颈；
- 高可用：100%的可用性是骗人的，但是也要无限接近于100%的可用性；
- 趋势递增：如果要把 ID 存放在数据库的话，ID 的有序性可以提升数据库写入速度。并且，很多时候 ，我们还很有可能会直接通过 ID 来进行排序；
- 安全：ID 中不包含敏感信息；

常见分布式id解决方案如下：

### 利用数据库自增id
往一个库的一个表里插入一条没什么业务含义的数据，获取一个数据库自增的一个 id，拿到这个 id 之后再往对应的分库分表里去写入。缺点是高并发存在瓶颈；优点是简单方便；适用于并发不高，但是数据量太大导致的分库分表扩容，可能每秒最高并发最多就几百，那么就走单独的一个库和表生成自增主键即可。

### 利用Redis自增
基于对数据库自增的改进，原理就是利用redis的incr命令实现ID的原子性自增。不依赖于数据库，灵活方便，且性能优于数据库，但是如果系统中没有Redis，还需要引入新的组件，会增加系统复杂度。

### 利用UUID作为主键
UUID一般不会作为主键使用，因为UUID 太长了、占用空间大，作为主键性能太差了，且UUID 不具有有序性，会导致 B+ 树索引在写的时候有过多的随机写操作，总之就是无序的性能开销大；适合于随机生成个什么文件名、编号之类的。

### 利用系统当前时间
一般如果用这个方案，是将当前时间跟很多其他的业务字段拼接起来，作为一个 id，如果业务上你觉得可以接受，那么也是可以的。你可以将别的业务字段值跟当前时间拼接起来，组成一个全局唯一的编号。

### 雪花算法
算法思路是是把一个 64 位的 long 型的 id，1 个 bit 是不用的，用其中的 41 bits 作为毫秒数，用 10 bits 作为工作机器 id，12 bits 作为序列号。
- 1 bit：不用，为啥呢？因为二进制里第一个 bit 为如果是 1，那么都是负数，但是我们生成的 id 都是正数，所以第一个 bit 统一都是 0；
- 41 bits：表示的是时间戳，单位是毫秒。41 bits 可以表示的数字多达 2^41 - 1 ，也就是可以标识 2^41 - 1 个毫秒值，换算成年就是表示 69 年的时间；
- 10 bits：记录工作机器 id，代表的是这个服务最多可以部署在 2^10 台机器上，也就是 1024 台机器。但是 10 bits 里 5 个 bits 代表机房 id，5 个 bits 代表机器 id。意思就是最多代表 2^5 个机房（32 个机房），每个机房里可以代表 2^5 个机器（32 台机器）；
- 12 bits：这个是用来记录同一个毫秒内产生的不同 id，12 bits 可以代表的最大正整数是 2^12 - 1 = 4096 ，也就是说可以用这个 12 bits 代表的数字来区分同一个毫秒内的 4096 个不同的 id；

雪花算法相对来说还是比较靠谱的，毫秒数在高位，自增序列在低位，整个ID都是趋势递增的。不依赖数据库等第三方系统，以服务的方式部署，稳定性更高，生成ID的性能也是非常高的，能达到百万计QPS。但是雪花算法强依赖时钟，如果机器上时钟回拨，会导致发号重复或者服务会处于不可用状态。

为了规避雪花算法的缺点，一些国内的大厂做了改进，像美团的[Leaf](https://github.com/Meituan-Dianping/Leaf)，百度的[uid-generator](https://github.com/baidu/uid-generator)，都是基于雪花算法来实现的。

所以你要真是搞分布式 id 生成，如果是高并发啥的，那么用这个应该性能比较好，一般每秒几万并发的场景，也足够用了。


