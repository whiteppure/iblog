---
title: "内存泄漏详解"
date: 2024-07-22
draft: false
tags: ["Java", "JVM","详解"]
slug: "java-jvm-memoryleak"
---

## 什么是内存泄漏
内存泄漏是指不使用的对象持续占有内存使得内存得不到释放，从而造成内存空间的浪费。严格来说，只有对象不会再被程序用到了，但是GC又不能回收他们的情况，才叫内存泄漏。
但实际情况很多时候一些不太好的实践会导致对象的生命周期变得很长，甚至导致`00M`，也可以叫做宽泛意义上的“内存泄漏”。

举个例子，创建的连接不再使用时，需要调用`close`方法关闭连接，只有连接被关闭后，GC才会回收对应的对象。忘记关闭这些资源会导致持续占有内存，无法被GC回收。这样就会导致内存泄露，最终导致内存溢出。
```java
public class MemoryLeak {
    public static void main(String[] args) {
      try{
          Connection conn =null;
          Class.forName("com.mysql.jdbc.Driver");
          conn =DriverManager.getConnection("url","","");
          Statement stmt =conn.createStatement();
          ResultSet rs =stmt.executeQuery("....");
      } catch(Exception e){//异常日志
      } finally {
        // 1．关闭结果集 Statement
        // 2．关闭声明的对象 ResultSet
        // 3．关闭连接 Connection
    }
  }
}
```
内存泄漏最明显的问题是频繁GC，从而`STW`次数增加，导致用户体验变差。如果内存泄露问题严重，会导致`OOM`，直接导致程序不能正常运行。
尽管内存泄漏并不会立刻引起程序崩溃，但是一旦发生内存泄漏，程序中的可用内存就会被逐步蚕食，直至耗尽所有内存，最终出现`OutOfMemory`异常，导致程序崩溃。

## 内存泄漏的原因
Java使用可达性分析算法来标记垃圾对象。在这个过程中，算法会标记那些仍然可以从根对象（如栈、静态变量等）直接访问到的对象为“可达”，而那些无法从根对象访问到的对象则标记为“不可达”。
不可达的对象是候选垃圾，可以被回收。有时候即使某些对象不再使用，它们的引用链可能仍然存在，导致这些对象没有被标记为不可达，从而造成内存泄漏。
在这种情况下，虽然这些对象已经不再被实际使用，但由于引用链未断开，它们仍然占用内存。

大多数内存泄露的原因是，长生命周期的对象引用了短生命周期的对象。例如，A对象引用B对象，A对象的生命周期（t1-t4）比B对象的生命周期（t2-t3）长的多。
当B对象没有被应用程序使用之后，A对象仍然在引用着B对象。这样，垃圾回收器就没办法将B对象从内存中移除，从而导致内存泄露问题。

所以减少长生命周期对象持有短生命周期对象的强引用是解决内存泄漏的一个关键点。利用弱引用或者软引用可以让垃圾回收器更容易回收不再需要的对象。对于外部资源，如数据库连接、文件、网络连接，用完后应该及时关闭。`try-with-resources`语句是管理这些资源的有效工具，同时移除不再需要的事件监听器也能防止内存泄漏。
管理集合时，设定大小限制并定期清理过期数据可以避免无限增长。使用有界数据结构能帮助控制缓存的大小。静态集合要特别留意，避免它们占用过多内存，通过定期清理来管理数据的存储。
通过这些措施，可以减少内存泄漏的风险。

## 排查内存泄漏
根据运维之前收集到的内存数据、GC日志尝试判断哪里出现了问题。结果发现老年代的内存使用就算是发生GC也一直居高不下，而且随着时间推移也越来越高。

![内存泄漏问题-01](/iblog/posts/annex/images/essays/内存泄漏问题-01.png)

使用`jstat -gc <vmid>` 查看GC垃圾回收统计信息，看`Full GC`后堆空间使用内存还持续增长，且有增长到`Xmx`设定值的趋势，基本可以肯定存在内存泄露。
如果当前完全垃圾回收后内存增长到一个值之后，又能回落，总体上处于一个动态平衡，那么内存泄漏基本可以排除；也可以隔断时间抽取老年代占用内存情况，如果老年代占用情况持续上升也很有可能存在内存泄露的情况。

排查内存泄漏，最经典的就是用MAT工具分析`dump`文件，但如果`dump`文件巨大就不建议这样，可以使用其他方案，例如：重启、本地复现、`jmap -histo:live <pid>`在线进行分析等其他方案解决。
使用MAT定位内存泄漏思路：
1. 打开MAT中`histogram`，找到堆内存中占用最大的对象，内存泄漏很有可能就是由大对象导致的；

   ![MAT-01](/iblog/posts/annex/images/essays/MAT-01.png)
2. 由大对象找被哪些线程引用，查看内存占用最大的线程；

   ![MAT-02](/iblog/posts/annex/images/essays/MAT-02.png)
   ![MAT-03](/iblog/posts/annex/images/essays/MAT-03.png)
3. 从线程中的堆栈信息找到项目中自定义的包和对象，从而可定位到具体的代码；

   ![MAT-04](/iblog/posts/annex/images/essays/MAT-04.png)
   ![MAT-05](/iblog/posts/annex/images/essays/MAT-05.png)

## 解决内存泄漏


## 从代码层面避免内存泄漏


