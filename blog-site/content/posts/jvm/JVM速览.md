---
title: "JVM速览"
date: 2024-05-26
draft: false
tags: ["Java", "JVM","详解"]
slug: "java-memory-divide"
---

## JVM整体结构
Java虚拟机有很多，HotSpot VM是目前市面上高性能虚拟机的代表作之一。HotSpot 的技术优势就在于热点代码探测技术（名字就从这来的）和准确式内存管理技术。

热点代码探测，指的是，通过执行计数器找出最具有编译价值的代码，然后通知即时编译器以方法为单位进行编译，解释器就可以不再逐行的将字节码翻译成机器码，而是将一整个方法的所有字节码翻译成机器码再执行

JVM 大致可以划分为三个区域，分别是类加载子系统（Class Loader）、运行时数据区（Runtime Data Areas）和执行引擎（Excution Engine）。下图为 HotSport 虚拟机结构图

![Jvm内存模型](/iblog/posts/annex/images/essays/Jvm内存模型.png)

- 类加载子系统：将class文件加载到内存中。具体分为三个步骤：装载，链接，初始化。
- 运行时数据区：JVM 定义了 Java 程序运行期间需要使用到的内存区域，简单来说，这块内存区域存放了字节码信息以及程序执行过程的数据，垃圾收集器也会针对运行时数据区进行对象回收的工作。
包括方法区、堆、Java栈（虚拟机栈）、本地方法栈、程序计数器。其中线程共享，堆和方法区；Java栈、本地方法栈和程序计数器为每个线程独有一份的。
- 执行引擎：将字节码指令解释/编译为对应平台上的本地机器指令才可以，简单来说，JVM 中的执行引擎充当了将高级语言翻译为机器语言的译者。包括：解释器、JIT及时编译器、GC垃圾回收器。

## [Java类加载机制](/iblog/posts/jvm/jvm-classloader/)
在Java中，类加载器把一个class装入JVM中，要经过以下步骤： 加载、验证、准备、解析和初始化。其中验证，准备，解析统称为连接。
这5个阶段一般是顺序发生的，但在动态绑定的情况下，解析阶段发生在初始化阶段之后。

![类加载过程](/iblog/posts/annex/images/essays/类加载过程.png)

![类加载过程详细](/iblog/posts/annex/images/essays/类加载过程详细.png)

类加载器只负责class文件的加载，至于它是否可以运行，则由执行引擎(Execution Engine)决定。
被加载的类信息存放于一块称为方法区的内存空间。除了类的信息外，方法区中还会存放运行时常量池信息，可能还包括字符串字面量和数字常量。

### 加载
加载阶段是类加载过程的第一个阶段。在这个阶段，JVM 的主要目的是将字节码从各个位置（网络、磁盘等）转化为二进制字节流加载到内存中，接着会为这个类在 JVM 的方法区创建一个对应的 Class 对象，这个 Class 对象就是这个类各种数据的访问入口。

类的加载指的是将类的`.class`文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个`java.lang.Class`对象，用来封装类在方法区内的数据结构。
简单来说，加载指的是把从各个来源的class字节码文件，通过类加载器装载入内存中。

类加载器并不需要等到某个类被“首次主动使用”时再加载它，JVM规范允许类加载器在预料某个类将要被使用时就预先加载它，如果在预先加载的过程中遇到了`.class`文件缺失或存在错误，类加载器必须在程序首次主动使用该类时才报告错误（`LinkageError`错误）如果这个类一直没有被程序主动使用，那么类加载器就不会报告错误。

类加载器并不是一开始就把所有的类都加载进内存中，而是只有第一次遇到某个需要运行的类时才会加载，且只加载一次。

类加载阶段的作用：
- 通过类的全限定名获取该类的二进制字节流；
- 将字节流所代表的存储结构转化为方法区的运行时的数据结构；
- 在内存中生成一个该类的`java.lang.Class`对象作为方法区的这个类的各种数据访问入口；

加载阶段与连接阶段的部分动作(如一部分字节码文件格式验证动作)是交叉进行的，加载阶段尚未结束，连接阶段可能就已经开始了。

### 验证
验证是连接阶段的第一步，这一阶段的目的是确保 Class 文件的字节流中包含的信息符合《Java 虚拟机规范》的全部约束要求，保证这些信息被当作代码运行后不会危害虚拟机自身的安全。

验证阶段这一步在整个类加载过程中耗费的资源还是相对较多的，但很有必要，可以有效防止恶意代码的执行。任何时候，程序安全都是第一位。
不过，验证阶段也不是必须要执行的阶段。如果程序运行的全部代码(包括自己编写的、第三方包中的、从外部加载的、动态生成的等所有代码)都已经被反复使用和验证过，在生产环境的实施阶段就可以考虑使用 `-Xverify:none` 参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。

大致都会完成以下四个阶段的验证：
- 文件格式验证；
- 元数据验证,是否符合java语言的规范；
- 字节码验证,确保程序语义合法,符合逻辑；
- 符号引用验证,确保下一步解析能正常执行；

### 准备
准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这个过程将在方法区中进行分配。

举个例子:
```
public String var1 = "var1";
public static String var2 = "var2";
public static final String var3 = "var3";
```

变量`var1`不会被分配内存，但是`var2`会被分配。`var2`会被分配初始值为`null`而不是`var2`。
这里所设置的初始值通常情况下是数据类型默认的零值（如`0、0L、null、false`等），而不是被在Java代码中被显式地赋予的值。

这时候进行内存分配的仅包括类变量（ Class Variables ，即静态变量，被 static 关键字修饰的变量，只与类相关，因此被称为类变量），而不包括实例变量。
实例变量会在对象实例化时随着对象一块分配在Java堆中。

这里不包含`final`修饰的`static`，因为`final`在编译的时候就已经分配了，也就是说`var3`被分配的值为`var3`。

### 解析
解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。 解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用限定符 7 类符号引用进行。
对应常量池中的CONSTANT Class info、CONSTANT Fieldref info、CONSTANT Methodref info等。

符号引用：
符号引用是编译原理中的概念，是相对于直接引用来说的。主要包括了以下三类常量： 类和接口的全限定名 字段的名称和描述符 方法的名称和描述符。
符号引用以一组符号来描述所引用的目标。符号引用可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可，符号引用和虚拟机的布局无关。

直接引用：
直接引用和虚拟机的布局是相关的，不同的虚拟机对于相同的符号引用所翻译出来的直接引用一般是不同的。
如果有了直接引用，那么直接引用的目标一定被加载到了内存中。直接引用通过对符号引用进行解析，找到引用的实际内存地址。

在编译的时候每个java类都会被编译成一个class文件，但在编译的时候虚拟机并不知道所引用类的地址，所以就用符号引用来代替，而在这个解析阶段就是为了把这个符号引用转化成为真正的地址的阶段。

### 初始化
初始化阶段是执行初始化方法 `<clinit> ()`方法的过程，是类加载的最后一步，这一步 JVM 才开始真正执行类中定义的 Java 程序代码(字节码)。

对于<clinit> () 方法的调用，虚拟机会自己确保其在多线程环境中的安全性。因为 <clinit> () 方法是带锁线程安全，所以在多线程环境下进行类初始化的话可能会引起多个线程阻塞，并且这种阻塞很难被发现。

<clinit>() 方法不需定义，是javac编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并而来。
也就是说，当我们代码中包含static变量的时候，就会有`<clinit>()`方法。

在准备阶段，静态变量已经被赋过默认初始值，而在初始化阶段，静态变量将被赋值为代码期望赋的值。

举个例子
```
public static String var2 = "var2";
```
在准备阶段变量`var2`的值为`null`，在初始化阶段赋值为`var2`。

何时初始化：
- 创建类的实例，也就是`new`一个对象需要初始化
- 读取或者设置静态字段的时候需要初始化(但被`final`修饰的字段,在编译时就被放入静态常量池的字段除外.)
- 调用类的静态方法
- 使用反射`Class.forName("");`对类反射调用的时候,该类需要初始化
- 初始化一个类的时候,有父类,先初始化父类
  - 接口除外,父接口在调用的时候才会被初始化;
  - 子类引用父类的静态字段,只会引发父类的初始化;
- 被标明为启动类的类(即包含`main()`方法),需要初始化

### 类加载器
类加载器是一个负责加载类的对象。ClassLoader 是一个抽象类。给定类的二进制名称，类加载器应尝试定位或生成构成类定义的数据。
典型的策略是将名称转换为文件名，然后从文件系统中读取该名称的“类文件”。
每个 Java 类都有一个引用指向加载它的 ClassLoader。不过，数组类不是通过 ClassLoader 创建的，而是 JVM 在需要的时候自动创建的，数组类通过getClassLoader()方法获取 ClassLoader 的时候和该数组的元素类型的 ClassLoader 是一致的。

简单来说，类加载器的主要作用就是加载 Java 类的字节码（ .class 文件）到 JVM 中（在内存中生成一个代表该类的 Class 对象）。
字节码可以是 Java 源程序（.java文件）经过 javac 编译得来，也可以是通过工具动态生成或者通过网络下载得来。
其实除了加载类之外，类加载器还可以加载 Java 应用所需的资源如文本、图像、配置文件、视频等等文件资源。

从虚拟机的角度来说，只存在两种不同的类加载器：一种是启动类加载器(`Bootstrap ClassLoader`)，该类加载器使用C++语言实现(这里仅限于`Hotspot`，也就是JDK1.5之后默认的虚拟机，有很多其他的虚拟机是用Java语言实现的)，属于虚拟机自身的一部分。
另外一种就是自定义类加载器，这些类加载器是由Java语言实现，独立于JVM外部，并且全部继承自抽象类`java.lang.ClassLoader`。

JVM 启动的时候，并不会一次性加载所有的类，而是根据需要去动态加载。也就是说，大部分类在具体用到的时候才会去加载，这样对内存更加友好。
对于已经加载的类会被放在 ClassLoader 中。在类加载的时候，系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载。
也就是说，对于一个类加载器来说，相同二进制名称的类只会被加载一次。


#### 常见类加载器
>rt.jar：rt 代表“RunTime”，rt.jar是 Java 基础类库，包含 Java doc 里面看到的所有的类的类文件。
我们常用内置库 `java.xxx.*`都在里面，比如`java.util.*`、`java.io.*`、`java.nio.*`、`java.lang.*`、`java.sql.*`、`java.math.*`。

1. 启动类加载器(引导类加载器、Bootstrap ClassLoader)：
  - 该类加载器使用C/C++语言实现的，嵌套在JVM内部,可理解为就是JVM的一部分；
  - 它用来加载Java的核心库（`JAVAHOME/jre/1ib/rt.jar、resources.jar`或`sun.boot.class.path`路径下的内容），用于提供JVM自身需要的类；
  - 并不继承自`java.lang.ClassLoader`，没有父加载器；
  - 加载扩展类和应用程序类加载器，并指定为他们的父类加载器；
  - 出于安全考虑，Bootstrap启动类加载器只加载包名为java、javax、sun等开头的类；
2. 扩展类加载器：
  - Java语言编写，由`sun.misc.Launcher$ExtClassLoader`实现；
  - 派生于`ClassLoader`类；
  - 父类加载器为启动类加载器；
  - 从`java.ext.dirs`系统属性所指定的目录中加载类库，或从JDK的安装目录的`jre/1ib/ext`子目录（扩展目录）下加载类库。如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载；
3. 应用程序类加载器(系统类加载器、AppClassLoader)：
  - java语言编写，由`sun.misc.LaunchersAppClassLoader`实现；
  - 派生于ClassLoader类；
  - 父类加载器为扩展类加载器；
  - 它负责加载环境变量`classpath`或系统属性`java.class.path`指定路径下的类库；
  - 该类加载是程序中默认的类加载器，一般来说，Java应用的类都是由它来完成加载；
  - 通过`classLoader#getSystemclassLoader()`方法可以获取到该类加载器；

#### 自定义类加载器
除了这三种类加载器之外，用户还可以加入自定义的类加载器来进行拓展，以满足自己的特殊需求。
就比如说，我们可以对 Java 类的字节码（ .class 文件）进行加密，加载时再利用自定义的类加载器对其解密。

自定义加载器使用场景：
1. 隔离加载类
2. 修改类加载的方式
3. 扩展加载源
4. 防止源码泄漏

若要实现自定义类加载器，只需要继承`java.lang.ClassLoader`类，按需重写相关方法即可。
- 如果不想打破双亲委派模型，那么只需要重写`findClass`方法
- 如果想打破双亲委派模型，那么就重写整个`loadClass`方法

> 在JDK1.2之前，类加载尚未引入双亲委派模式，因此实现自定义类加载器时常常重写`loadClass`方法，提供双亲委派逻辑，从JDK1.2之后，双亲委派模式已经被引入到类加载体系中，自定义类加载器时不需要在自己写双亲委派的逻辑，因此不鼓励重写`loadClass`方法，而推荐重写`findClass`方法。
>
>在Java中，任意一个类都需要由加载它的类加载器和这个类本身一同确定其在java虚拟机中的唯一性，即比较两个类是否相等，只有在这两个类是由同一个类加载器加载的前提之下才有意义，否则，即使这两个类来源于同一个Class类文件，只要加载它的类加载器不相同，那么这两个类必定不相等(这里的相等包括代表类的Class对象的`equals()`方法、`isAssignableFrom()`方法、`isInstance()`方法和`instanceof`关键字的结果)。

### 双亲委派模型
![双亲委派模型](/iblog/posts/annex/images/essays/双亲委派模型.png)

ClassLoader 类使用委托模型来搜索类和资源。每个 ClassLoader 实例都有一个相关的父类加载器。需要查找类或资源时，ClassLoader 实例会在试图亲自查找类或资源之前，将搜索类或资源的任务委托给其父类加载器。
这种层次关系称为**类加载器的双亲委派模型。** 我们把每一层上面的类加载器叫做当前层类加载器的父加载器，当然，它们之间的父子关系并不是通过继承关系来实现的，而是使用组合关系来复用父加载器中的代码。
该模型在JDK1.2期间被引入并广泛应用于之后几乎所有的Java程序中，但它并不是一个**强制性的约束模型**，而是Java设计者们推荐给开发者的一种类的加载器实现方式。

双亲委派模型工作流程：
- 如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行；
- 如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器；
- 如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载；
- 如果子类加载器也无法加载这个类，那么它会抛出一个`ClassNotFoundException`异常；

**为什么使用双亲委派模型？**

双亲委派模型保证了 Java 程序的稳定运行，可以避免类的重复加载（JVM 区分不同类的方式不仅仅根据类名，相同的类文件被不同的类加载器加载产生的是两个不同的类），也保证了 Java 的核心 API 不被篡改。
比如我们编写一个称为 java.lang.Object 类的话，那么程序运行的时候，系统就会出现两个不同的 Object 类。

双亲委派模型可以保证加载的是 JRE 里的那个 Object 类，而不是你写的 Object 类。这是因为 AppClassLoader 在加载你的 Object 类时，会委托给 ExtClassLoader 去加载，而 ExtClassLoader 又会委托给 BootstrapClassLoader，BootstrapClassLoader 发现自己已经加载过了 Object 类，会直接返回，不会去加载你写的 Object 类。


**如何打破双亲委派模型？**

自定义加载器的话，需要继承 ClassLoader 。如果我们不想打破双亲委派模型，就重写 ClassLoader 类中的 findClass() 方法即可，无法被父类加载器加载的类最终会通过这个方法被加载。但是，如果想打破双亲委派模型则需要重写 loadClass() 方法。

类加载器在进行类加载的时候，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，调用父加载器 loadClass()方法来加载类。
重写 loadClass()方法之后，我们就可以改变传统双亲委派模型的执行流程。
例如，子类加载器可以在委派给父类加载器之前，先自己尝试加载这个类，或者在父类加载器返回之后，再尝试从其他地方加载这个类。具体的规则由我们自己实现，根据项目需求定制化。

## Java内存区域划分
Java 虚拟机在执行 Java 程序的过程中会把它管理的内存划分成若干个不同的数据区域。

![运行时数据区](/iblog/posts/annex/images/essays/运行时数据区.png)

Java内存主要就是对运行时数据区域进行划分：
- 程序计数寄存器
- 虚拟机栈
- 本地方法栈
- 堆
- 方法区

![hotspot-JVM内存详细划分](/iblog/posts/annex/images/essays/hotspot-JVM内存详细划分.png)

其中：方法区、堆、直接内存（非运行时数据区的一部分）为线程共享。程序计数寄存器、虚拟机栈、本地方法栈 为线程私有。

JDK 1.8 和之前的版本略有不同，这里以 JDK 1.7 和 JDK 1.8 这两个版本为例介绍。
<div style="width: 48%;display: inline-block">
    <img src="/iblog/posts/annex/images/essays/jvm1.8之前.png" alt="jvm1.8之前">
</div>
<div style="width: 48%;display: inline-block">
    <img src="/iblog/posts/annex/images/essays/jvm1.8.png" alt="jvm1.8">
</div>

### [程序计数器](/iblog/posts/jvm/jvm-pc-register/)
JVM中的程序计数寄存器（Program Counter Register）中，Register的命名源于CPU的寄存器，寄存器存储指令相关的现场信息。CPU只有把数据装载到寄存器才能够运行。
这里，并非是广义上所指的物理寄存器，或许将其翻译为PC计数器（或指令计数器）会更加贴切（也称为程序钩子），并且也不容易引起一些不必要的误会。
JVM中的PC寄存器是对物理PC寄存器的一种抽象模拟。

特点：
- 它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。
  字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。
- 它是一块很小的内存空间，几乎可以忽略不记。也是运行速度最快的存储区域。
- 它是唯一一个在Java虚拟机规范中没有规定任何`outOfMemoryError`情况的区域。

**程序计数器中既不存在GC又不存在OOM，所以不存在垃圾回收问题。**

作用：
- PC寄存器用来存储指向下一条指令的地址，也即将要执行的指令代码。由执行引擎读取下一条指令。

由于Java的多线程是通过线程轮流切换完成的，一个线程没有执行完时就需要一个东西记录它执行到哪了，下次抢占到了CPU资源时再从这开始，
这个东西就是程序计数器，正是因为这样，所以它也是“线程私有”的内存。

**代码演示**
```
public class MainTest {
    public static void main(String[] args) {
        int i = 10;
        int j = 20;
        int k = i + j;

        String str = "abc";
        System.out.println(str);
        System.out.println(k);
    }
}

```
通过`javap -verbose MainTest.class`命令反编译`.class`文件，得到如下
```
// ...
 public static void main(java.lang.String[]);
    descriptor: ([Ljava/lang/String;)V
    flags: ACC_PUBLIC, ACC_STATIC
    Code:
      stack=2, locals=5, args_size=1
         0: bipush        10
         2: istore_1
         3: bipush        20
         5: istore_2
         6: iload_1
         7: iload_2
         8: iadd
         9: istore_3
        10: ldc           #2                  // String abc
        12: astore        4
        14: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;
        17: aload         4
        19: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
        22: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;
        25: iload_3
        26: invokevirtual #5                  // Method java/io/PrintStream.println:(I)V
        29: return
// ...

```
通过PC寄存器，我们就可以知道当前程序执行到哪一步了。
![PC寄存器保存指令示意](/iblog/posts/annex/images/essays/PC寄存器保存指令示意.png)

### [虚拟机栈](/iblog/posts/jvm/jvm-stack/)
Java虚拟机栈（Java Virtual Machine Stack），早期也叫Java栈，每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧（Stack Frame），对应着一次次的Java方法调用。
与程序计数器一样，Java 虚拟机栈（后文简称栈）也是线程私有的，它的生命周期和线程相同，随着线程的创建而创建，随着线程的死亡而死亡。

栈绝对算的上是 JVM 运行时数据区域的一个核心，除了一些 Native 方法调用是通过本地方法栈实现的，其他所有的 Java 方法调用都是通过栈来实现的，当然也需要和其他运行时数据区域比如程序计数器配合。

方法调用的数据需要通过栈进行传递，每一次方法调用都会有一个对应的栈帧被压入栈中，每一个方法调用结束后，都会有一个栈帧被弹出。
栈由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法返回地址。和数据结构上的栈类似，两者都是先进后出的数据结构，只支持出栈和入栈两种操作。

![栈桢的结构](/iblog/posts/annex/images/essays/栈桢的结构.png)

- 局部变量表：Local Variables，被称之为局部变量数组或本地变量表。定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量这些数据类型包括各类基本数据类型、对象引用（reference），以及returnAddress类型。
- 操作数栈：主要作为方法调用的中转站使用，用于存放方法执行过程中产生的中间计算结果。另外，计算过程中产生的临时变量也会放在操作数栈中。
- 动态链接：主要服务一个方法需要调用其他方法的场景。Class 文件的常量池里保存有大量的符号引用比如方法引用的符号引用。
当一个方法要调用其他方法，需要将常量池中指向方法的符号引用转化为其在内存地址中的直接引用。动态链接的作用就是为了将符号引用转换为调用方法的直接引用，这个过程也被称为动态连接。

栈空间虽然不是无限的，但一般正常调用的情况下是不会出现问题的。
不过，如果函数调用陷入无限循环的话，就会导致栈中被压入太多栈帧而占用太多空间，导致栈空间过深。那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 StackOverFlowError 错误。

Java 方法有两种返回方式，一种是 return 语句正常返回，一种是抛出异常。不管哪种返回方式，都会导致栈帧被弹出。
也就是说， 栈帧随着方法调用而创建，随着方法结束而销毁。无论方法正常完成还是异常完成都算作方法结束。

除了 StackOverFlowError 错误之外，栈还可能会出现OutOfMemoryError错误，这是因为如果栈的内存大小可以动态扩展， 如果虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常。

### [本地方法栈](/iblog/posts/jvm/jvm-native-stack/)
和虚拟机栈所发挥的作用非常相似，区别是：虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。
Java虚拟机栈于管理Java方法的调用，而本地方法栈用于管理本地方法的调用。在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。

本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。

方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现 StackOverFlowError 和 OutOfMemoryError 两种错误。

### 堆
Java 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。
此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存，因为还有一些对象是在栈上分配的。

在方法执行结束后，堆中的对象不会马上被移除，仅仅在垃圾收集的时候才会被移除。
也就是触发了GC的时候，才会进行回收，如果堆中对象马上被回收，那么用户线程就会收到影响，一个方法频繁的调用频繁的回收程序性能会收到影响。
所以堆是GC（Garbage Collection，垃圾收集器）执行垃圾回收的重点区域。

Java 7及之前，堆内存划分为三部分：新生区+养老区+永久区
- Young Generation Space 新生区，新生区被划分为又被划分为Eden区和Survivor区
- Tenure generation space 养老区
- Permanent Space永久区（逻辑上属于方法区）

Java 8及之后，堆内存逻辑上分为三部分：新生区+养老区+元空间
- Young Generation Space新生区，新生区被划分为又被划分为Eden区和Survivor区
- Tenure generation space 养老区
- Meta Space 元空间

堆空间内部结构，JDK1.8之后永久代替换成了元空间，元空间使用的是本地内存。
![堆内存结构](/iblog/posts/annex/images/essays/堆内存结构.png)

对象分配内存步骤：
1. 新的对象先放伊甸园区，此区有大小限制，如果对象过大可能直接分配在老年代（元空间）。
2. 当伊甸园的空间填满时，程序又需要创建对象，JVM的垃圾回收器将对伊甸园区进行MinorGC，将伊甸园区中的不再被其他对象所引用的对象进行销毁，再将新的对象放到伊甸园区，然后将伊甸园中的剩余对象移动到幸存者0区。
3. 如果再次触发MinorGC，会首先将没有被回收的对象放到幸存者1区，然后判断幸存者0区中的对象是否能被回收，如果没有回收，就会放到幸存者1区。
4. 重复步骤3、4，默认情况下如果一个对象被扫描了15次（阈值），都不能被回收，则将该对象晋升到老年代。
5. 当老年代内存不足时，触发Major GC，进行老年代的内存清理。
6. 若老年代执行了Major GC之后，发现依然无法进行对象的保存，就会产生OOM错误。

可以用 `-XX:MaxTenuringThreshold=N` 进行设置幸存者区到老年代的GC扫描次数，默认15次，不过，设置的值应该在 0-15，否则会爆出以下错误。
> MaxTenuringThreshold of 20 is invalid; must be between 0 and 15

为什么年龄只能是 0-15?
因为记录年龄的区域在对象头中，这个区域的大小通常是 4 位。这 4 位可以表示的最大二进制数字是 1111，即十进制的 15。因此，对象的年龄被限制为 0 到 15。

如果幸存者区满了？
如果Survivor区满了后，将会触发一些特殊的规则，也就是可能直接晋升老年代。
**需要特别注意，在Eden区满了的时候，才会触发MinorGC，而幸存者区满了后，不会触发MinorGC操作。**

#### TLAB
>堆空间都是共享的么？
不是，因为还有 TLAB 这个概念，在堆中划分出一块区域，为每个线程所独占，以此来保证线程安全。

TLAB全称：`Thread Local Allocation Buffer` 译为：线程本地分配缓冲区。

因为堆区是线程共享区域，任何线程都可以访问到堆区中的共享数据，
由于对象实例的创建在JVM中非常频繁，因此在并发环境下从堆区中划分内存空间是线程不安全的。
为避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度。
使用锁又会影响性能，TLAB应运而生。
多线程同时分配内存时，使用TLAB可以避免一系列的非线程安全问题，同时还能够提升内存分配的吞吐量，因此我们可以将这种内存分配方式称之为快速分配策略。

![TLAB](/iblog/posts/annex/images/essays/TLAB.png)

从内存模型而不是垃圾收集的角度，对Eden区域继续进行划分，JVM为每个线程分配了一个私有缓存区域，它包含在Eden空间内。
默认情况下，TLAB空间的内存非常小，仅占有整个Eden空间的1%，当然我们可以通过选项`-XX:TLABWasteTargetPercent`设置TLAB空间所占用Eden空间的百分比大小。

对象首先是通过TLAB开辟空间，如果不能放入，那么需要通过Eden来进行分配。尽管不是所有的对象实例都能够在TLAB中成功分配内存，但JVM确实是将TLAB作为内存分配的首选。
可以通过选项`-XX:UseTLAB`设置是否开启TLAB空间，默认是开启的。一旦对象在TLAB空间分配内存失败时，JVM就会尝试着通过使用加锁机制确保数据操作的原子性，从而直接在Eden空间中分配内存。

![TLAB分配过程.png](/iblog/posts/annex/images/essays/TLAB分配过程.png)

### [方法区](/iblog/posts/jvm/jvm-method-area/)
方法区属于是 JVM 运行时数据区域的一块逻辑区域，是各个线程共享的内存区域。

尽管所有的方法区在逻辑上是属于堆的一部分，但一些简单的实现可能不会选择去进行垃圾收集，所以把方法区看作是一块独立于Java堆的内存空间。

方法区和永久代以及元空间是什么关系呢？
方法区和永久代以及元空间的关系很像 Java 中接口和类的关系，类实现了接口，这里的类就可以看作是永久代和元空间，接口可以看作是方法区，也就是说永久代以及元空间是 HotSpot 虚拟机对虚拟机规范中方法区的两种实现方式。
并且，永久代是 JDK 1.8 之前的方法区实现，JDK 1.8 及以后方法区的实现变成了元空间。

### 运行时常量池
运行时常量池是每一个类或接口的常量池的运行时表示形式。

它包括了若干种不同的常量：从编译期可知的数值字面量到必须运行期解析后才能获得的方法或字段引用。运行时常量池扮演了类似传统语言中符号表的角色，不过它存储数据范围比通常意义上的符号表要更为广泛。

每一个运行时常量池都分配在 Java 虚拟机的方法区之中，在类和接口被加载到虚拟机后，对应的运行时常量池就被创建出来。
- 保存在方法区中的叫运行时常量池；
- 在 class/字节码 文件中的叫class常量池（静态常量池）。

简单说来就是JVM在完成类装载操作后，将class文件中的常量池载入到内存中，并保存在方法区中。我们常说的常量池，就是指方法区中的运行时常量池。

运行时常量池类似于传统编程语言中的符号表，但是它所包含的数据却比符号表要更加丰富一些。
当创建类或接口的运行时常量池时，如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大值，则JVM会抛outOfMemoryError异常。

在不同版本的JDK中，运行时常量池所处的位置也不一样。以`HotSpot`为例：JDK1.7之前方法区位于永久代，由于一些原因在JDK1.8时彻底祛除了永久代，用元空间代替。

根据JVM规范,JVM内存共分为虚拟机栈，堆，方法区，程序计数器，本地方法栈五个部分。运行时常量池存放在JVM内存模型中的方法区中。

**运行时常量池是方法区的一部分**`.class`文件中除了有类的版本、字段、方法、接口等描述信息外,还有一项信息是常量池，用于存放**编译期**生成的**各种字面量和符号引用**，这部分内容将在类加载后进入方法区的运行时常量池中存放。

运行时常量池中包含多种不同的常量，包括编译期就已经明确的数值字面量，也包括到运行期解析后才能够获得的方法或者字段引用。
此时不再是常量池中的符号地址了，这里换为真实地址。

运行时常量池内容包含了class常量池中的常量和字符串常量池中的内容。运行时常量池，相对于class文件常量池的另一重要特征是：具备动态性。

### 字符串常量池
在JVM中，为了减少相同的字符串的重复创建，为了达到节省内存的目的。会单独开辟一块内存，用于保存字符串常量，这个内存区域被叫做字符串常量池。
字符串常量池保存着所有字符串字面量，这些字面量在编译时期就确定。

不同版本JDK内存分配情况：Java6及以前，字符串常量池存放在永久代，Java7将字符串常量池的位置调整到Java堆内。

字符串常量池为什么要调整位置？
JDK7中将字符串常量池放到了堆空间中。因为对永久代的回收效率很低，只有在Full GC的时候才会触发。

Full GC 是老年代的空间不足、永久代不足时才会触发。
这就导致字符串常量池回收效率不高。而我们开发中会有大量的字符串被创建，回收效率低，导致永久代内存不足。
所以JDK7之后将字符串常量池放到堆里，能及时回收内存，避免出现`OOM`错误。

简单说来：
- 永久代垃圾回收频率低；而字符串使用频率比较高，不能及时回收字符串，会导致导致永久代内存不足。
- 永久代的默认比较小；因字符串大量使用，所以会导致`OOM`错误。

### 直接内存
直接内存是一种特殊的内存缓冲区，并不在 Java 堆或方法区中分配的，而是通过 JNI 的方式在本地内存上分配的。

直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致 OutOfMemoryError 错误出现。

JDK1.4 中新加入的 NIO（Non-Blocking I/O，也被称为 New I/O），引入了一种基于通道（Channel）与缓存区（Buffer）的 I/O 方式，它可以直接使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。
这样就能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆之间来回复制数据。

直接内存的分配不会受到 Java 堆的限制，但是，既然是内存就会受到本机总内存大小以及处理器寻址空间的限制。

## [JVM垃圾回收机制](/iblog/posts/jvm/java-garbage-collection/)
垃圾回收（Garbage Collection，GC），顾名思义就是释放垃圾占用的空间，防止内存爆掉。有效的使用可以使用的内存，对内存堆中已经死亡的或者长时间没有使用的对象进行清除和回收。
如果不及时对内存中的垃圾进行清理，那么这些垃圾对象所占的内存空间会一直保留到应用程序的结束，被保留的空间无法被其它对象使用，甚至可能导致**内存溢出**。

### 垃圾判定算法
在运行程序中，当一个对象已经不再被任何存活的对象引用时，就可以就可以判定该对象已经死亡了，这个对象就是需要被回收的垃圾。

一般用会有这么几种算法来确定一个对象是否是垃圾：
- 引用计数算法
- 可达性分析算法

#### 引用计数算法

#### 可达性分析算法

### 垃圾清除算法



