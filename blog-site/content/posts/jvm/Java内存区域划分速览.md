---
title: "Java内存区域划分速览"
date: 2024-05-26
draft: false
tags: ["Java", "JVM"]
slug: "java-memory-divide"
---

Java 虚拟机在执行 Java 程序的过程中会把它管理的内存划分成若干个不同的数据区域。

![运行时数据区](/iblog/posts/annex/images/essays/运行时数据区.png)

Java内存主要就是对运行时数据区域进行划分：
- 程序计数寄存器
- 虚拟机栈
- 本地方法栈
- 堆
- 方法区

其中：方法区、堆、直接内存（非运行时数据区的一部分）为线程共享。程序计数寄存器、虚拟机栈、本地方法栈 为线程私有。

JDK 1.8 和之前的版本略有不同，这里以 JDK 1.7 和 JDK 1.8 这两个版本为例介绍。
<div style="width: 48%;display: inline-block">
    <img src="/iblog/posts/annex/images/essays/jvm1.8之前.png" alt="jvm1.8之前">
</div>
<div style="width: 48%;display: inline-block">
    <img src="/iblog/posts/annex/images/essays/jvm1.8.png" alt="jvm1.8">
</div>

## [程序计数器](/iblog/posts/jvm/jvm-pc-register/)
JVM中的程序计数寄存器（Program Counter Register）中，Register的命名源于CPU的寄存器，寄存器存储指令相关的现场信息。CPU只有把数据装载到寄存器才能够运行。
这里，并非是广义上所指的物理寄存器，或许将其翻译为PC计数器（或指令计数器）会更加贴切（也称为程序钩子），并且也不容易引起一些不必要的误会。
JVM中的PC寄存器是对物理PC寄存器的一种抽象模拟。

特点：
- 它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。
  字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。
- 它是一块很小的内存空间，几乎可以忽略不记。也是运行速度最快的存储区域。
- 它是唯一一个在Java虚拟机规范中没有规定任何`outOfMemoryError`情况的区域。

**程序计数器中既不存在GC又不存在OOM，所以不存在垃圾回收问题。**

作用：
- PC寄存器用来存储指向下一条指令的地址，也即将要执行的指令代码。由执行引擎读取下一条指令。

由于Java的多线程是通过线程轮流切换完成的，一个线程没有执行完时就需要一个东西记录它执行到哪了，下次抢占到了CPU资源时再从这开始，
这个东西就是程序计数器，正是因为这样，所以它也是“线程私有”的内存。

**代码演示**
```
public class MainTest {
    public static void main(String[] args) {
        int i = 10;
        int j = 20;
        int k = i + j;

        String str = "abc";
        System.out.println(str);
        System.out.println(k);
    }
}

```
通过`javap -verbose MainTest.class`命令反编译`.class`文件，得到如下
```
// ...
 public static void main(java.lang.String[]);
    descriptor: ([Ljava/lang/String;)V
    flags: ACC_PUBLIC, ACC_STATIC
    Code:
      stack=2, locals=5, args_size=1
         0: bipush        10
         2: istore_1
         3: bipush        20
         5: istore_2
         6: iload_1
         7: iload_2
         8: iadd
         9: istore_3
        10: ldc           #2                  // String abc
        12: astore        4
        14: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;
        17: aload         4
        19: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
        22: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;
        25: iload_3
        26: invokevirtual #5                  // Method java/io/PrintStream.println:(I)V
        29: return
// ...

```
通过PC寄存器，我们就可以知道当前程序执行到哪一步了。
![PC寄存器保存指令示意](/iblog/posts/annex/images/essays/PC寄存器保存指令示意.png)

## [虚拟机栈](/iblog/posts/jvm/jvm-stack/)
Java虚拟机栈（Java Virtual Machine Stack），早期也叫Java栈，每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧（Stack Frame），对应着一次次的Java方法调用。
与程序计数器一样，Java 虚拟机栈（后文简称栈）也是线程私有的，它的生命周期和线程相同，随着线程的创建而创建，随着线程的死亡而死亡。

栈绝对算的上是 JVM 运行时数据区域的一个核心，除了一些 Native 方法调用是通过本地方法栈实现的，其他所有的 Java 方法调用都是通过栈来实现的，当然也需要和其他运行时数据区域比如程序计数器配合。

方法调用的数据需要通过栈进行传递，每一次方法调用都会有一个对应的栈帧被压入栈中，每一个方法调用结束后，都会有一个栈帧被弹出。
栈由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法返回地址。和数据结构上的栈类似，两者都是先进后出的数据结构，只支持出栈和入栈两种操作。

![栈桢的结构](/iblog/posts/annex/images/essays/栈桢的结构.png)

- 局部变量表：Local Variables，被称之为局部变量数组或本地变量表。定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量这些数据类型包括各类基本数据类型、对象引用（reference），以及returnAddress类型。
- 操作数栈：主要作为方法调用的中转站使用，用于存放方法执行过程中产生的中间计算结果。另外，计算过程中产生的临时变量也会放在操作数栈中。
- 动态链接：主要服务一个方法需要调用其他方法的场景。Class 文件的常量池里保存有大量的符号引用比如方法引用的符号引用。
当一个方法要调用其他方法，需要将常量池中指向方法的符号引用转化为其在内存地址中的直接引用。动态链接的作用就是为了将符号引用转换为调用方法的直接引用，这个过程也被称为动态连接。

栈空间虽然不是无限的，但一般正常调用的情况下是不会出现问题的。
不过，如果函数调用陷入无限循环的话，就会导致栈中被压入太多栈帧而占用太多空间，导致栈空间过深。那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 StackOverFlowError 错误。

Java 方法有两种返回方式，一种是 return 语句正常返回，一种是抛出异常。不管哪种返回方式，都会导致栈帧被弹出。
也就是说， 栈帧随着方法调用而创建，随着方法结束而销毁。无论方法正常完成还是异常完成都算作方法结束。

除了 StackOverFlowError 错误之外，栈还可能会出现OutOfMemoryError错误，这是因为如果栈的内存大小可以动态扩展， 如果虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常。

## [本地方法栈](/iblog/posts/jvm/jvm-native-stack/)
和虚拟机栈所发挥的作用非常相似，区别是：虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。
Java虚拟机栈于管理Java方法的调用，而本地方法栈用于管理本地方法的调用。在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。

本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。

方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现 StackOverFlowError 和 OutOfMemoryError 两种错误。

## 堆
Java 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。
此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存，因为还有一些对象是在栈上分配的。

在方法执行结束后，堆中的对象不会马上被移除，仅仅在垃圾收集的时候才会被移除。
也就是触发了GC的时候，才会进行回收，如果堆中对象马上被回收，那么用户线程就会收到影响，一个方法频繁的调用频繁的回收程序性能会收到影响。
所以堆是GC（Garbage Collection，垃圾收集器）执行垃圾回收的重点区域。

Java 7及之前，堆内存逻辑上分为三部分：新生区+养老区+永久区

- Young Generation Space 新生区，新生区被划分为又被划分为Eden区和Survivor区
- Tenure generation space 养老区
- Permanent Space永久区

Java 8及之后，堆内存逻辑上分为三部分：新生区+养老区+元空间
- Young Generation Space新生区，新生区被划分为又被划分为Eden区和Survivor区
- Tenure generation space 养老区
- Meta Space 元空间

堆空间内部结构，JDK1.8之后永久代替换成了元空间，元空间使用的是本地内存。
![堆内存结构](/iblog/posts/annex/images/essays/堆内存结构.png)

对象分配内存步骤：
1. 新的对象先放伊甸园区，此区有大小限制，如果对象过大可能直接分配在老年代（元空间）。
2. 当伊甸园的空间填满时，程序又需要创建对象，JVM的垃圾回收器将对伊甸园区进行MinorGC，将伊甸园区中的不再被其他对象所引用的对象进行销毁，再将新的对象放到伊甸园区，然后将伊甸园中的剩余对象移动到幸存者0区。
3. 如果再次触发MinorGC，会首先将没有被回收的对象放到幸存者1区，然后判断幸存者0区中的对象是否能被回收，如果没有回收，就会放到幸存者1区。
4. 重复步骤3、4，默认情况下如果一个对象被扫描了15次（阈值），都不能被回收，则将该对象晋升到老年代。
5. 当老年代内存不足时，触发Major GC，进行老年代的内存清理。
6. 若老年代执行了Major GC之后，发现依然无法进行对象的保存，就会产生OOM错误。

可以用 `-XX:MaxTenuringThreshold=N` 进行设置幸存者区到老年代的GC扫描次数，默认15次，不过，设置的值应该在 0-15，否则会爆出以下错误。
> MaxTenuringThreshold of 20 is invalid; must be between 0 and 15

为什么年龄只能是 0-15?
因为记录年龄的区域在对象头中，这个区域的大小通常是 4 位。这 4 位可以表示的最大二进制数字是 1111，即十进制的 15。因此，对象的年龄被限制为 0 到 15。

如果幸存者区满了？
如果Survivor区满了后，将会触发一些特殊的规则，也就是可能直接晋升老年代。
**需要特别注意，在Eden区满了的时候，才会触发MinorGC，而幸存者区满了后，不会触发MinorGC操作。**


## [方法区](/iblog/posts/jvm/jvm-method-area/)
方法区属于是 JVM 运行时数据区域的一块逻辑区域，是各个线程共享的内存区域。
尽管所有的方法区在逻辑上是属于堆的一部分，但一些简单的实现可能不会选择去进行垃圾收集或者进行压缩。
”但对于HotSpotJVM而言，方法区还有一个别名叫做Non-Heap（非堆），目的就是要和堆分开。
把方法区看作是一块独立于Java堆的内存空间。

方法区和永久代以及元空间是什么关系呢？
方法区和永久代以及元空间的关系很像 Java 中接口和类的关系，类实现了接口，这里的类就可以看作是永久代和元空间，接口可以看作是方法区，也就是说永久代以及元空间是 HotSpot 虚拟机对虚拟机规范中方法区的两种实现方式。
并且，永久代是 JDK 1.8 之前的方法区实现，JDK 1.8 及以后方法区的实现变成了元空间。

### 运行时常量池
运行时常量池是每一个类或接口的常量池的运行时表示形式。

它包括了若干种不同的常量：从编译期可知的数值字面量到必须运行期解析后才能获得的方法或字段引用。运行时常量池扮演了类似传统语言中符号表的角色，不过它存储数据范围比通常意义上的符号表要更为广泛。

每一个运行时常量池都分配在 Java 虚拟机的方法区之中，在类和接口被加载到虚拟机后，对应的运行时常量池就被创建出来。
- 保存在方法区中的叫运行时常量池；
- 在 class/字节码 文件中的叫class常量池（静态常量池）。

简单说来就是JVM在完成类装载操作后，将class文件中的常量池载入到内存中，并保存在方法区中。我们常说的常量池，就是指方法区中的运行时常量池。

运行时常量池类似于传统编程语言中的符号表，但是它所包含的数据却比符号表要更加丰富一些。
当创建类或接口的运行时常量池时，如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大值，则JVM会抛outOfMemoryError异常。

在不同版本的JDK中，运行时常量池所处的位置也不一样.以`HotSpot`为例：JDK1.7之前方法区位于永久代，由于一些原因在JDK1.8时彻底祛除了永久代,用元空间代替。

根据JVM规范,JVM内存共分为虚拟机栈，堆，方法区，程序计数器，本地方法栈五个部分。运行时常量池存放在JVM内存模型中的方法区中。

**运行时常量池是方法区的一部分**`.class`文件中除了有类的版本、字段、方法、接口等描述信息外,还有一项信息是常量池，用于存放**编译期**生成的**各种字面量和符号引用**，这部分内容将在类加载后进入方法区的运行时常量池中存放。

运行时常量池中包含多种不同的常量，包括编译期就已经明确的数值字面量，也包括到运行期解析后才能够获得的方法或者字段引用。
此时不再是常量池中的符号地址了，这里换为真实地址。

运行时常量池内容包含了class常量池中的常量和字符串常量池中的内容。运行时常量池，相对于class文件常量池的另一重要特征是：具备动态性。

### 字符串常量池
在JVM中，为了减少相同的字符串的重复创建，为了达到节省内存的目的。会单独开辟一块内存，用于保存字符串常量，这个内存区域被叫做字符串常量池。
字符串常量池保存着所有字符串字面量，这些字面量在编译时期就确定。

不同版本JDK内存分配情况：Java6及以前，字符串常量池存放在永久代，Java7将字符串常量池的位置调整到Java堆内。

字符串常量池为什么要调整位置？
JDK7中将字符串常量池放到了堆空间中。因为对永久代的回收效率很低，只有在Full GC的时候才会触发。

Full GC 是老年代的空间不足、永久代不足时才会触发。
这就导致字符串常量池回收效率不高。而我们开发中会有大量的字符串被创建，回收效率低，导致永久代内存不足。
所以JDK7之后将字符串常量池放到堆里，能及时回收内存，避免出现`OOM`错误。

简单说来：
- 永久代垃圾回收频率低；而字符串使用频率比较高，不能及时回收字符串，会导致导致永久代内存不足。
- 永久代的默认比较小；因字符串大量使用，所以会导致`OOM`错误。

## 直接内存
直接内存是一种特殊的内存缓冲区，并不在 Java 堆或方法区中分配的，而是通过 JNI 的方式在本地内存上分配的。

直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致 OutOfMemoryError 错误出现。

JDK1.4 中新加入的 NIO（Non-Blocking I/O，也被称为 New I/O），引入了一种基于通道（Channel）与缓存区（Buffer）的 I/O 方式，它可以直接使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。
这样就能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆之间来回复制数据。

直接内存的分配不会受到 Java 堆的限制，但是，既然是内存就会受到本机总内存大小以及处理器寻址空间的限制。

