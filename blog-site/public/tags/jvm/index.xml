<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>JVM on 脚踏实地</title>
    <link>http://localhost:1313/iblog/tags/jvm/</link>
    <description>Recent content in JVM on 脚踏实地</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <lastBuildDate>Sun, 26 May 2024 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://localhost:1313/iblog/tags/jvm/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>JVM速览</title>
      <link>http://localhost:1313/iblog/posts/jvm/java-memory-divide/</link>
      <pubDate>Sun, 26 May 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/iblog/posts/jvm/java-memory-divide/</guid>
      <description>JVM整体结构 Java虚拟机有很多，HotSpot VM是目前市面上高性能虚拟机的代表作之一。HotSpot 的技术优势就在于热点代码探测技术（名字就从这来的）和准</description>
    </item>
    <item>
      <title>JVM中的垃圾回收器</title>
      <link>http://localhost:1313/iblog/posts/jvm/java-garbage-collector/</link>
      <pubDate>Thu, 06 May 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/iblog/posts/jvm/java-garbage-collector/</guid>
      <description>垃圾回收器 如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。 虽然我们对各个收集器进行比较，但并非要挑选出一个最好的收集器。 因为直到现在为止</description>
    </item>
    <item>
      <title>JVM中的一些概念</title>
      <link>http://localhost:1313/iblog/posts/jvm/jvm-about/</link>
      <pubDate>Tue, 27 Apr 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/iblog/posts/jvm/jvm-about/</guid>
      <description>内存溢出 内存溢出(Out Of Memory，简称OOM)是指应用系统中存在无法回收的内存或使用的内存过多，最终使得程序运行要用到的内存大于能提供的最大内存。 官方文档</description>
    </item>
    <item>
      <title>JVM中的垃圾回收机制</title>
      <link>http://localhost:1313/iblog/posts/jvm/java-garbage-collection/</link>
      <pubDate>Wed, 21 Apr 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/iblog/posts/jvm/java-garbage-collection/</guid>
      <description>垃圾回收机制 垃圾回收（Garbage Collection，GC），顾名思义就是释放垃圾占用的空间，防止内存爆掉。有效的使用可以使用的内存，对内存堆中已经死亡的或</description>
    </item>
    <item>
      <title>JVM中的执行引擎</title>
      <link>http://localhost:1313/iblog/posts/jvm/jvm-execute-engine/</link>
      <pubDate>Thu, 15 Apr 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/iblog/posts/jvm/jvm-execute-engine/</guid>
      <description>概述 执行引擎是Java虚拟机核心的组成部分之一，属于JVM的下层，里面包括 解释器、及时编译器、垃圾回收器。 “虚拟机”是一个相对于“物理机”的概念，这两种机器都有</description>
    </item>
    <item>
      <title>JVM中的直接内存</title>
      <link>http://localhost:1313/iblog/posts/jvm/jvm-direct-memory/</link>
      <pubDate>Wed, 14 Apr 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/iblog/posts/jvm/jvm-direct-memory/</guid>
      <description>直接内存不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域。 直接内存是在Java堆外的、直接向系统申请的内存区间。 操作直接内存演示代码</description>
    </item>
    <item>
      <title>从JVM角度理解Java对象</title>
      <link>http://localhost:1313/iblog/posts/jvm/java-object/</link>
      <pubDate>Mon, 12 Apr 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/iblog/posts/jvm/java-object/</guid>
      <description>对象实例化 对象的创建方式 使用new关键字创建：最常见的方式、单例类中调用getInstance的静态类方法，XXXFactory的静态方法； 使用反射方式创建： 使</description>
    </item>
    <item>
      <title>JVM中的方法区</title>
      <link>http://localhost:1313/iblog/posts/jvm/jvm-method-area/</link>
      <pubDate>Thu, 08 Apr 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/iblog/posts/jvm/jvm-method-area/</guid>
      <description>Java虚拟机定义了若干种程序运行期间会使用到的运行时数据区，其中有一些会随着虚拟机启动而创建，随着虚拟机退出而销毁。 另外一些则是与线程一一对应的，这些与线程对</description>
    </item>
    <item>
      <title>JVM中的堆</title>
      <link>http://localhost:1313/iblog/posts/jvm/jvm-heap/</link>
      <pubDate>Sat, 03 Apr 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/iblog/posts/jvm/jvm-heap/</guid>
      <description>Java虚拟机定义了若干种程序运行期间会使用到的运行时数据区，其中有一些会随着虚拟机启动而创建，随着虚拟机退出而销毁。 另外一些则是与线程一一对应的，这些与线程对</description>
    </item>
    <item>
      <title>JVM中的本地方法接口</title>
      <link>http://localhost:1313/iblog/posts/jvm/jvm-native-interface/</link>
      <pubDate>Fri, 02 Apr 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/iblog/posts/jvm/jvm-native-interface/</guid>
      <description>概念 简单地讲，一个Native Methodt是一个Java调用非Java代码的接囗。 一个Native Method是这样一个Java方法：该方法的实现由非Java</description>
    </item>
    <item>
      <title>JVM中的本地方法栈</title>
      <link>http://localhost:1313/iblog/posts/jvm/jvm-native-stack/</link>
      <pubDate>Fri, 02 Apr 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/iblog/posts/jvm/jvm-native-stack/</guid>
      <description>Java虚拟机定义了若干种程序运行期间会使用到的运行时数据区，其中有一些会随着虚拟机启动而创建，随着虚拟机退出而销毁。 另外一些则是与线程一一对应的，这些与线程对</description>
    </item>
    <item>
      <title>JVM中的虚拟机栈</title>
      <link>http://localhost:1313/iblog/posts/jvm/jvm-stack/</link>
      <pubDate>Sun, 28 Mar 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/iblog/posts/jvm/jvm-stack/</guid>
      <description>Java虚拟机定义了若干种程序运行期间会使用到的运行时数据区，其中有一些会随着虚拟机启动而创建，随着虚拟机退出而销毁。 另外一些则是与线程一一对应的，这些与线程对</description>
    </item>
    <item>
      <title>JVM中的程序计数寄存器</title>
      <link>http://localhost:1313/iblog/posts/jvm/jvm-pc-register/</link>
      <pubDate>Sat, 27 Mar 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/iblog/posts/jvm/jvm-pc-register/</guid>
      <description>Java虚拟机定义了若干种程序运行期间会使用到的运行时数据区，其中有一些会随着虚拟机启动而创建，随着虚拟机退出而销毁。 另外一些则是与线程一一对应的，这些与线程对</description>
    </item>
    <item>
      <title>JVM介绍</title>
      <link>http://localhost:1313/iblog/posts/jvm/jvm-start/</link>
      <pubDate>Fri, 05 Mar 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/iblog/posts/jvm/jvm-start/</guid>
      <description>为什么要学习JVM 大部分Java开发人员，除了会在项目中使用到与Java平台相关的各种高精尖技术，对于Java技术的核心Java虚拟机了解甚少。 一些有一定工作经</description>
    </item>
    <item>
      <title>Java类加载机制</title>
      <link>http://localhost:1313/iblog/posts/jvm/jvm-classloader/</link>
      <pubDate>Fri, 05 Feb 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/iblog/posts/jvm/jvm-classloader/</guid>
      <description>类加载过程 在Java中，类加载器把一个class装入JVM中，要经过以下步骤： 加载、验证、准备、解析和初始化。其中验证,准备,解析统称为连接。 这5个阶段一般是顺</description>
    </item>
  </channel>
</rss>
