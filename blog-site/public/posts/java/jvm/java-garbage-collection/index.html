<!DOCTYPE html>
<html lang="zh" >
<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="google-site-verification" content="tVxoyWMeaEzEUV0EzY1STfJXZWaZ8WM-i-a8AWBri0o" />
    <meta name="msvalidate.01" content="48159A4EAF3C3F448369E581664B1A21" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="whitepure" />
	
	
	
	<title>JVM中的垃圾回收机制 ｜ 脚踏实地</title>
	
    
    
    <meta name="description" content="什么是垃圾 垃圾回收（Garbage Collection，GC），顾名思义就是释放垃圾占用的空间，防止内存爆掉。有效的使用可以使用的内存，对内存堆中已经死亡的或者" />
    

    
    
    <meta name="keywords" content="whitepure博客, whiteppure, whitepure, Java, 博客, 技术博客" />
    

	

    <link rel="shortcut icon" href="http://localhost:1313/images/favicon.ico" />

    <link rel="stylesheet" type="text/css" media="screen" href="http://localhost:1313/css/normalize.css" />

    <link rel="stylesheet" type="text/css" media="screen" href="http://localhost:1313/css/animate.min.css" />
    <link rel="stylesheet" type="text/css" media="screen" href="http://localhost:1313/css/zozo.css" />
    <link rel="stylesheet" type="text/css" media="screen" href="http://localhost:1313/css/remixicon.css" />

    <link rel="stylesheet" type="text/css" media="screen" href="http://localhost:1313/css/highlight.css" />

    <link rel="stylesheet" type="text/css" media="screen" href="http://localhost:1313/css/toc.css" />
    <link rel="stylesheet" type="text/css" media="screen" href="http://localhost:1313/css/search.css" />
    <link rel="stylesheet" type="text/css" media="screen" href="http://localhost:1313/css/img.css" />

    
    
</head>

<body>
    <div class="post-password">
        
    </div>

    
    
    









<div id="post_content_toc" class="toc">
    <div class="page-header"><strong></strong></div>
    <div id="page-scrollspy" class="toc-nav">

        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e4%bb%80%e4%b9%88%e6%98%af%e5%9e%83%e5%9c%be">
                    什么是垃圾
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e9%9c%80%e8%a6%81%e5%9e%83%e5%9c%be%e5%9b%9e%e6%94%b6">
                    为什么需要垃圾回收
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e6%97%a9%e6%9c%9f%e5%9e%83%e5%9c%be%e5%9b%9e%e6%94%b6">
                    早期垃圾回收
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#java%e7%9a%84%e5%9e%83%e5%9c%be%e5%9b%9e%e6%94%b6%e6%9c%ba%e5%88%b6">
                    Java的垃圾回收机制
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e5%9e%83%e5%9c%be%e5%9b%9e%e6%94%b6%e4%b8%bb%e8%a6%81%e5%85%b3%e6%b3%a8%e7%9a%84%e5%8c%ba%e5%9f%9f">
                    垃圾回收主要关注的区域
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e5%9e%83%e5%9c%be%e5%88%a4%e5%ae%9a%e7%ae%97%e6%b3%95">
                    垃圾判定算法
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e5%bc%95%e7%94%a8%e8%ae%a1%e6%95%b0%e7%ae%97%e6%b3%95">
                    引用计数算法
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e5%8f%af%e8%be%be%e6%80%a7%e5%88%86%e6%9e%90%e7%ae%97%e6%b3%95">
                    可达性分析算法
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e5%9e%83%e5%9c%be%e6%94%b6%e9%9b%86%e7%ae%97%e6%b3%95">
                    垃圾收集算法
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e6%a0%87%e8%ae%b0%e6%b8%85%e9%99%a4%e7%ae%97%e6%b3%95">
                    标记清除算法
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e5%a4%8d%e5%88%b6%e7%ae%97%e6%b3%95">
                    复制算法
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e6%a0%87%e8%ae%b0%e6%95%b4%e7%90%86%e7%ae%97%e6%b3%95">
                    标记整理算法
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e5%88%86%e4%bb%a3%e6%94%b6%e9%9b%86%e6%80%9d%e6%83%b3">
                    分代收集思想
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e5%a2%9e%e9%87%8f%e6%94%b6%e9%9b%86%e7%ae%97%e6%b3%95">
                    增量收集算法
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e5%88%86%e5%8c%ba%e7%ae%97%e6%b3%95">
                    分区算法
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        

    </div>
</div>



    

    
    <div class="main animate__animated animate__fadeInDown" id="main_content">
        <div class="nav_container animated fadeInDown">
    <div class="site_nav" id="site_nav">
        <ul><li class="">
                <a href="http://localhost:1313/">首页</a>
            </li><li class="">
                <a href="http://localhost:1313/posts/">归档</a>
            </li><li class="">
                <a href="http://localhost:1313/tags/">标签</a>
            </li><li class="">
                <a href="http://localhost:1313/about/">关于</a>
            </li>
        </ul>
    </div>
    <div class="menu_icon">
        <a id="menu_icon"><i class="ri-menu-line"></i></a>
    </div>
</div>
        <div id="post_header" class="header animated fadeInDown">
    <div class="site_title_container">
        <div class="site_title">
            <h1>
                <a href="http://localhost:1313/">
                    <span>脚踏实地</span>
                </a>
            </h1>
        </div>
        <div class="description">
            <p class="sub_title">
                
            </p>

            
            <div class="my_socials">
                
                    
                    <a href="https://github.com/whiteppure/" title="github" target="_blank">
                        <i class="ri-github-fill"></i>
                    </a>
                    
                
                <a href="http://localhost:1313/index.xml" type="application/rss+xml" title="rss" target="_blank">
                    <i class="ri-rss-fill"></i>
                </a>
                
                
                <span id="sys_function" class="sys_function display_none">
                    <a id="export_pdf"  title="导出pdf" style="border: none; cursor: pointer; margin-left: 10px">
                        <svg t="1688701481347" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3517" width="16" height="16"><path d="M425.610455 85.814544H149.05897A42.303635 42.303635 0 0 0 106.6274 128.075535V896.492068c0 23.326702 18.976933 42.26099 42.43157 42.26099h682.743143a42.559504 42.559504 0 0 0 42.431569-42.559504v-384.016365a42.644793 42.644793 0 0 1 85.289587 0v384.016365A127.849091 127.849091 0 0 1 831.802113 1024H149.05897A127.635867 127.635867 0 0 1 21.337813 896.449423V128.03289A127.593222 127.593222 0 0 1 149.101614 0.524957h276.466196a42.644793 42.644793 0 0 1 0 85.289587z m564.062683 158.08425l-170.579174 170.579173a42.644793 42.644793 0 1 1-60.299738-60.299738L856.578738 256.393718H618.364922a42.644793 42.644793 0 1 1 0-85.289587h238.213816l-97.784512-97.784511A42.644793 42.644793 0 1 1 819.093964 13.019882l170.579174 170.579174a42.644793 42.644793 0 0 1 0 60.299738zM149.272194 597.552066a42.644793 42.644793 0 0 1 42.644793-42.644794h51.514911c59.190973 0 107.891327 23.284057 107.976617 97.102195 0 71.003581-49.46796 102.347504-106.185536 102.347504h-31.343923v66.781747a32.282109 32.282109 0 0 1-64.606862 0V597.552066z m92.709781 100.215264c31.429213 0 46.568114-16.46089 46.568114-45.757863 0-30.064579-17.313786-40.512554-48.359196-40.512554h-26.311837v86.270417h28.145563z m232.414124-142.860058c81.878003 0 136.036891 43.710913 136.036891 147.67892S556.231457 853.420826 477.935617 853.420826h-38.16709a42.644793 42.644793 0 0 1-42.644794-42.644793v-213.223967a42.644793 42.644793 0 0 1 42.644794-42.644794h34.542282z m-4.008611 240.729859c43.32711 0 73.988717-22.047358 73.988717-93.050939 0-71.046226-30.704251-90.705476-73.988717-90.705476h-8.699538v183.79906h8.699538zM692.481573 853.420826a32.282109 32.282109 0 0 1-32.282109-32.282108V597.552066a42.644793 42.644793 0 0 1 42.644793-42.644794h99.063855a29.680776 29.680776 0 1 1 0 59.404197h-77.144431v65.374469h61.749661a29.894 29.894 0 1 1 0 59.788h-61.749661v81.66478a32.282109 32.282109 0 0 1-32.282108 32.282108z" fill="#5f5f5f" p-id="3518"></path></svg>
                    </a>
                    <a id="export_pic" title="导出图片" style="border: none; cursor: pointer; margin-left: 10px">
                        <svg t="1689071509720" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4564" width="16" height="16"><path d="M909.132886 0.037506h-184.960611a33.909445 33.909445 0 0 0-32.368107 33.909445 33.909445 33.909445 0 0 0 33.909445 33.395666h158.244078l-200.373995 199.346437a33.395666 33.395666 0 0 0 0 47.781491 31.854327 31.854327 0 0 0 23.633856 9.76181 33.909445 33.909445 0 0 0 24.147635-9.76181l198.832657-199.346437V272.340628a33.909445 33.909445 0 0 0 69.874009 0V88.921355A88.37007 88.37007 0 0 0 909.132886 0.037506zM216.558153 347.866211a107.37991 107.37991 0 1 0 107.37991-107.379911 107.89369 107.89369 0 0 0-107.37991 107.379911z m154.133843 0a51.377948 51.377948 0 0 1-97.618101 0 51.377948 51.377948 0 1 1 97.618101 0z" p-id="4565" fill="#424242"></path><path d="M963.079731 437.777619a34.423225 34.423225 0 0 0-33.909446 33.909445v265.110209a1811.07265 1811.07265 0 0 0-137.692899-193.181082 106.352351 106.352351 0 0 0-78.60826-36.478343 123.820854 123.820854 0 0 0-82.204716 35.964563l-3.596456 3.082677-188.557068 176.74014c-11.816928-13.358266-47.781491-51.377948-82.204716-87.856291a83.232275 83.232275 0 0 0-85.801172-21.578738 105.324792 105.324792 0 0 0-38.019681 19.52362l-141.289356 121.765736V89.948914a22.092517 22.092517 0 0 1 22.606297-22.606297h417.702713a33.395666 33.395666 0 0 0 33.395666-33.909445 33.395666 33.395666 0 0 0-33.395666-33.395666H113.802258A89.911408 89.911408 0 0 0 23.89085 89.948914v844.139678a89.911408 89.911408 0 0 0 89.911408 89.911408h793.27551a89.911408 89.911408 0 0 0 89.397629-89.911408v-462.401528a33.909445 33.909445 0 0 0-33.395666-33.909445z m-33.909446 496.310973a22.606297 22.606297 0 0 1-22.092517 22.606297H113.802258a22.606297 22.606297 0 0 1-22.606297-22.606297v-88.37007l183.933052-160.812976a43.157476 43.157476 0 0 1 15.413385-7.192912 15.927164 15.927164 0 0 1 17.982281 5.137794c37.505902 36.478343 78.60826 83.232275 82.718496 87.856291a61.653537 61.653537 0 0 0 42.643696 22.092517 62.681096 62.681096 0 0 0 51.377948-20.037399c8.220472-8.220472 134.610223-125.875971 194.208641-181.877935a57.029522 57.029522 0 0 1 34.423225-16.440943 45.212594 45.212594 0 0 1 29.79921 15.927164 2954.231982 2954.231982 0 0 1 186.501949 256.889738z" p-id="4566" fill="#424242"></path></svg>
                    </a>
                    <a id="export_markdown" title="导出markdown" style="border: none; cursor: pointer; margin-left: 10px">
                        <svg t="1689071035200" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="13570" width="16" height="16"><path d="M178.073367 843.957262V461.158929h107.121045l107.121045 140.734874 107.125433-140.734874h107.116657v382.798333h-107.116657v-219.54307l-107.125433 140.730486-107.116657-140.730486v219.54307zM737.783131 892.148786l-131.221196-209.156132h87.479334V461.158929h87.479335v221.833725h87.483722z" p-id="13571" fill="#424242"></path><path d="M911.9958 217.142709c10.672172 10.663395 19.812851 25.144549 27.430816 43.430297 7.617965 18.285748 11.431335 35.044392 11.431336 50.28471V969.140255c0 15.235929-5.336086 28.18998-15.999481 38.853375-10.667783 10.667783-23.621834 16.003869-38.857763 16.003869H127.994904c-15.240317 0-28.18998-5.336086-38.857763-16.003869-10.663395-10.663395-15.999481-23.617446-15.999481-38.853375V54.852856c0-15.240317 5.331698-28.18998 15.999481-38.857763C99.804925 5.336086 112.758975 0 127.999292 0h512.000944c15.235929 0 31.998962 3.808982 50.28471 11.426947 18.285748 7.622353 32.762514 16.763033 43.430297 27.426428zM658.290372 77.715526v214.856442h214.856442c-3.808982-11.049559-7.99974-18.856218-12.572275-23.43314l-178.855415-178.851027c-4.572534-4.572534-12.383581-8.763292-23.43314-12.572275z m219.428976 873.143369V365.71496h-237.714724c-15.240317 0-28.18998-5.336086-38.857763-15.999481-10.663395-10.667783-15.999481-23.621834-15.999481-38.857763V73.142992H146.28504v877.715903z" p-id="13572" fill="#424242"></path></svg>
                    </a>
                    <a id="export_doc" title="导出文档" style="border: none; cursor: pointer; margin-left: 10px">
                        <svg t="1689246982401" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="6825" width="16" height="16"><path d="M270.76864 608.32h180.8a31.68 31.68 0 0 0 0-62.976H270.76864a31.68 31.68 0 0 0 0 62.976zM271.34464 458.56h457.92a33.472 33.472 0 0 0 31.552-34.752 33.28 33.28 0 0 0-31.552-34.624H271.34464a34.816 34.816 0 0 0 0 69.376zM271.34464 293.504h457.92a33.344 33.344 0 0 0 31.552-34.688 33.216 33.216 0 0 0-31.552-34.624H271.34464a33.28 33.28 0 0 0-31.616 34.624 33.28 33.28 0 0 0 31.616 34.688z" p-id="6826" fill="#424242"></path><path d="M869.87264 0H153.77664A70.4 70.4 0 0 0 84.65664 70.912V953.6A69.952 69.952 0 0 0 153.77664 1024h370.048a32 32 0 0 0 0-63.68H147.12064V64h729.6v468.672a31.296 31.296 0 1 0 62.528 0V70.912A70.4 70.4 0 0 0 869.87264 0z" p-id="6827" fill="#424242"></path><path d="M482.16064 730.624h337.664L715.82464 625.216a28.864 28.864 0 0 1-7.936-28.736 29.184 29.184 0 0 1 20.608-21.184 29.632 29.632 0 0 1 29.12 8.128l174.784 177.216-174.784 176.96a29.184 29.184 0 0 1-49.728-13.312 29.248 29.248 0 0 1 8-28.8l103.936-105.344H482.16064a29.696 29.696 0 0 1-29.504-29.76 29.632 29.632 0 0 1 29.504-29.76z" p-id="6828" fill="#424242"></path></svg>
                    </a>
                </span>
                <a  id="icon_more" title="更多" >
                    <svg t="1688715321313" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5356" width="16" height="16"><path d="M483.555556 199.111111m-85.333334 0a85.333333 85.333333 0 1 0 170.666667 0 85.333333 85.333333 0 1 0-170.666667 0Z" fill="#424242" p-id="5357"></path><path d="M483.555556 540.444444m-85.333334 0a85.333333 85.333333 0 1 0 170.666667 0 85.333333 85.333333 0 1 0-170.666667 0Z" fill="#424242" p-id="5358"></path><path d="M483.555556 881.777778m-85.333334 0a85.333333 85.333333 0 1 0 170.666667 0 85.333333 85.333333 0 1 0-170.666667 0Z" fill="#424242" p-id="5359"></path></svg>
                </a>
                <a  id="icon_less" class="display_none">
                    <svg t="1688723160472" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="15872" width="16" height="16"><path d="M300.105143 592.676571h423.789714a80.676571 80.676571 0 1 0 0-161.353142H300.105143a80.676571 80.676571 0 0 0 0 161.353142z" fill="#8a8a8a" p-id="15873"></path></svg>
                </a>
                
            </div>

            
            <div class="post">
                <div class="post_title post_detail_title">
                    <span class="date" id="busuanzi_container_site_pv">访问量 <span id="busuanzi_value_site_pv">...</span> 次</span>
                </div>
                <div class="post_title post_detail_title">
                    <span class="date" id="busuanzi_container_site_uv">访客数 <span id="busuanzi_value_site_uv">...</span> 人</span>
                </div>
            </div>
            

            <div class="post">
                <div class="post_title post_detail_title">
                    
                    <span class="date">总文章数 192 篇</span>
                </div>
                <div class="post_title post_detail_title">
                    
                    
                    
                    
                    
                    <span class="date">博客已运行 2035 天</span>
                </div>
            </div>

        </div>
    </div>
</div>
        <div class="content">
            <div class="post_page">
                <div class="post animate__animated animate__fadeInDown">
                    <div class="post_title post_detail_title">
                        <h2 id="post_single_title">JVM中的垃圾回收机制</h2>
                        <span id="post_page_title_date" class="date">2021.04.21</span>





                    </div>
                    <div class="post_content markdown"><h2 id="什么是垃圾">什么是垃圾</h2>
<p>垃圾回收（Garbage Collection，GC），顾名思义就是释放垃圾占用的空间，防止内存爆掉。有效的使用可以使用的内存，对内存堆中已经死亡的或者长时间没有使用的对象进行清除和回收。
如果不及时对内存中的垃圾进行清理，那么这些垃圾对象所占的内存空间会一直保留到应用程序的结束，被保留的空间无法被其它对象使用，甚至可能导致<strong>内存溢出</strong>。</p>
<p>垃圾收集，不是Java语言的伴生产物。早在1960年，第一门开始使用内存动态分配和垃圾收集技术的Lisp语言诞生。</p>
<p>垃圾收集机制是Java的招牌能力，极大地提高了开发效率。
如今，垃圾收集几乎成为现代语言的标配，即使经过如此长时间的发展，Java的垃圾收集机制仍然在不断的演进中，不同大小的设备、不同特征的应用场景，对垃圾收集提出了新的挑战，这当然也是面试的热点。</p>
<p>垃圾是指在运行程序中没有任何指针指向的对象，这个对象就是需要被回收的垃圾。 一般用会有这么几种算法来确定一个对象是否是垃圾：</p>
<ul>
<li>引用计数算法</li>
<li>可达性分析算法</li>
</ul>
<h2 id="为什么需要垃圾回收">为什么需要垃圾回收</h2>
<p>对于高级语言来说，一个基本认知是如果不进行垃圾回收，内存迟早都会被消耗完，因为不断地分配内存空间而不进行回收，就好像不停地生产生活垃圾而从来不打扫一样。</p>
<p>除了释放没用的对象，垃圾回收也可以清除内存里的记录碎片。碎片整理将所占用的堆内存移到堆的一端，以便JVM将整理出的内存分配给新的对象。</p>
<p>随着应用程序所应付的业务越来越庞大、复杂，用户越来越多，没有GC就不能保证应用程序的正常进行。而经常造成STW的GC又跟不上实际的需求，所以才会不断地尝试对GC进行优化。</p>
<h2 id="早期垃圾回收">早期垃圾回收</h2>
<p>在早期的C/C++时代，垃圾回收基本上是手工进行的。
开发人员可以使用 <code>new</code> 关键字进行内存申请，并使用 <code>delete</code> 关键字进行内存释放。例如以下代码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">MibBridge *pBridge= new cmBaseGroupBridge();
</span></span><span class="line"><span class="cl">//如果注册失败，使用Delete释放该对象所占内存区域
</span></span><span class="line"><span class="cl">if(pBridge-&gt;Register (kDestroy) != NO ERROR）
</span></span><span class="line"><span class="cl">	delete pBridge;
</span></span></code></pre></div><p>这种方式可以灵活控制内存释放的时间，但是会给开发人员带来频繁申请和释放内存的管理负担。</p>
<p>倘若有一处内存区间由于程序员编码的问题忘记被回收，那么就会产生<strong>内存泄漏</strong>。
垃圾对象永远无法被清除，随着系统运行时间的不断增长，垃圾对象所耗内存可能持续上升，直到出现内存溢出并造成应用程序崩溃。</p>
<p>有了垃圾回收机制后，上述代码极有可能变成这样</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">MibBridge *pBridge=new cmBaseGroupBridge(); 
</span></span><span class="line"><span class="cl">pBridge-&gt;Register(kDestroy);
</span></span></code></pre></div><p>现在，除了Java以外，C#、Python、Ruby等语言都使用了自动垃圾回收的思想，也是未来发展趋势，可以说这种自动化的内存分配和来及回收方式已经成为了现代开发语言必备的标准。</p>
<h2 id="java的垃圾回收机制">Java的垃圾回收机制</h2>
<ul>
<li><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/toc.html">https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/toc.html</a></li>
</ul>
<p>自动内存管理，无需开发人员手动参与内存的分配与回收，这样降低<strong>内存泄漏</strong>和<strong>内存溢出</strong>的风险。
没有垃圾回收器，Java也会和C++一样，各种悬垂指针、野指针、泄露问题让你头疼不已。
自动内存管理机制，将程序员从繁重的内存管理中释放出来，可以更专心地专注于业务开发。</p>
<p>对于Java开发人员而言，自动内存管理就像是一个黑匣子，如果过度依赖于“自动”，那么这将会是一场灾难，最严重的就会弱化Java开发人员在程序出现内存溢出时定位问题和解决问题的能力。
此时，了解JVM的自动内存分配和内存回收原理就显得非常重要，只有在真正了解JVM是如何管理内存后，我们才能够在遇见<code>outOfMemoryError</code>时，快速地根据错误异常日志定位问题和解决问题。</p>
<p>当需要排查各种内存溢出、内存泄漏问题时，当垃圾收集成为系统达到更高并发量的瓶颈时，我们就必须对这些“自动化”的技术实施必要的监控和调节。</p>
<h2 id="垃圾回收主要关注的区域">垃圾回收主要关注的区域</h2>
<p>垃圾收集器主要对方法区 、堆中的垃圾进行收集。
<img alt="GC作用区域" src="/posts/annex/images/essays/GC%E4%BD%9C%E7%94%A8%E5%8C%BA%E5%9F%9F.png"></p>
<p>垃圾收集器可以对年轻代回收，也可以对老年代回收，甚至是全栈和方法区的回收，其中Java堆是垃圾收集器的工作重点。</p>
<p>针对 HotSpot VM 的实现，它里面的 GC 其实准确分类只有两大种：</p>
<ul>
<li>部分收集 (Partial GC)：
<ul>
<li>新生代收集（Minor GC / Young GC）：只对新生代进行垃圾收集；</li>
<li>老年代收集（Major GC / Old GC）：只对老年代进行垃圾收集。需要注意的是 Major GC 在有的语境中也用于指代整堆收集；</li>
<li>混合收集（Mixed GC）：对整个新生代和部分老年代进行垃圾收集。</li>
</ul>
</li>
<li>整堆收集 (Full GC)：收集整个 Java 堆和方法区。</li>
</ul>
<p>从次数上讲：频繁收集新生代 &gt; 较少收集老年代 &raquo; 基本不收集方法区</p>
<h2 id="垃圾判定算法">垃圾判定算法</h2>
<p>在堆里存放着几乎所有的Java对象实例，在GC执行垃圾回收之前，首先需要区分出内存中哪些是存活对象，哪些是已经死亡的对象。
只有被标记为己经死亡的对象，GC才会在执行垃圾回收时，释放掉其所占用的内存空间，因此这个过程我们可以称为<strong>垃圾标记阶段</strong>。</p>
<p>在运行程序中，当一个对象已经不再被任何存活的对象引用时，就可以就可以判定该对象已经死亡了。
判定对象是否存活在有两种算法，引用计数算法、可达性分析算法。</p>
<h3 id="引用计数算法">引用计数算法</h3>
<p>引用计数算法是通过在对象头中分配一个空间来保存该对象被引用的次数。
如果该对象被其它对象引用，则它的引用计数加 1，如果删除对该对象的引用，那么它的引用计数就减 1，当该对象的引用计数为 0 时，那么该对象就会被回收。
在堆中判定新生代中的幸存者区是否可以进老年代，会有一个年龄计数器，这里用的就是引用计数算法。</p>
<p>这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间循环引用的问题。
当p的指针断开的时候，内部的引用形成一个循环，从而造成内存泄漏。</p>
<p><img alt="循环引用" src="/posts/annex/images/essays/%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8.png"></p>
<p>虽然引用计数算法存在循环引用的问题，但是很多语言的资源回收选择，例如：因人工智能而更加火热的Python，它更是同时支持引用计数和垃圾收集机制。
具体哪种最优是要看场景的，业界有大规模实践中仅保留引用计数机制，以提高吞吐量的尝试。</p>
<p><strong>Python如何解决循环引用？</strong></p>
<ul>
<li>手动解除：很好理解，就是在合适的时机，将引用计数器中的计数属性置为零，解除引用关系。</li>
<li>使用弱引用<code>weakref</code>，<code>weakref</code>是Python提供的标准库，旨在解决循环引用。</li>
</ul>
<h3 id="可达性分析算法">可达性分析算法</h3>
<p>可达性分析算法是以根对象集合<code>GCRoots</code>为起始点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到<code>GCRoots</code>没有任何引用链相连的话，则证明此对象是不可用的，需要被回收。</p>
<p><img alt="可达性分析算法" src="/posts/annex/images/essays/%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95.png"></p>
<p>相对于引用计数算法而言，可达性分析算法不仅同样具备实现简单和执行高效等特点，更重要的是，该算法可以有效地解决在引用计数算法中循环引用的问题，防止内存泄漏的发生。
只要你无法与<code>GCRoot</code>建立直接或间接的连接，系统就会判定你为可回收对象。所谓根集合<code>GCRoots</code>就是一组必须活跃的引用，即有在栈中有指针指向堆中的地址，它们是程序运行时的起点，是一切引用链的源头。</p>
<p>在Java中，<code>GCRoots</code>包括以下几种：</p>
<ol>
<li>虚拟机栈中引用的对象；例如：各个线程被调用的方法中使用到的参数、局部变量等；</li>
<li>本地方法栈内,本地方法引用对象方法区中类静态属性引用的对象;例如：Java类的引用类型静态变量；</li>
<li>方法区中常量引用的对象；例如：字符串常量池里的引用；</li>
<li>所有被同步锁<code>synchronized</code>持有的对象；</li>
<li>Java虚拟机内部的引用；例如：一些常驻的异常对象、系统类加载器等；</li>
<li>反映Java虚拟机内部情况的<code>JMXBean、JVMTI</code>中注册的回调、本地代码缓存等；</li>
<li>除了这些固定的<code>GC Roots</code>集合以外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象“临时性”地加入，共同构成完整<code>GCRoots</code>集合，比如：分代收集和局部回收；</li>
</ol>
<p>除了堆空间产生对象的一些结构外，比如：虚拟机栈、本地方法栈、方法区、字符串常量池等地方对堆空间的对象的引用，都可以作为<code>GCRoots</code>进行可达性分析。</p>
<p><img alt="对象集合GCroots" src="/posts/annex/images/essays/%E5%AF%B9%E8%B1%A1%E9%9B%86%E5%90%88GCroots.png"></p>
<p>如何判定是否为<code>GC root</code>?
由于Root采用栈方式存放变量和指针，所以如果一个指针，保存了堆内存里面的对象，但是自己又不存放在堆内存里面，那它就是一个<code>GC root</code>。代码演示：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">StackReference</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">greet</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">Object</span><span class="w"> </span><span class="n">localVar</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Object</span><span class="p">();</span><span class="w"> </span><span class="c1">// 这里的 localVar 是一个局部变量，存在于虚拟机栈中</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">localVar</span><span class="p">.</span><span class="na">toString</span><span class="p">());</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="o">[]</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">new</span><span class="w"> </span><span class="n">StackReference</span><span class="p">().</span><span class="na">greet</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><ul>
<li>在<code>greet</code>方法中<code>localVar</code>是一个局部变量，存在于虚拟机栈中，可以被认为是<code>GCRoots</code>。</li>
<li>在<code>greet</code>方法执行期间，<code>localVar</code>引用的对象是活跃的，因为它是从<code>GCRoots</code>可达的。</li>
<li>当<code>greet</code>方法执行完毕后，<code>localVar</code>的作用域结束，<code>localVar</code>引用的 <code>Object</code> 对象不再由任何<code>GCRoots</code>引用（假设没有其他引用指向这个对象），因此它将有资格作为垃圾被回收掉。</li>
</ul>
<p>如果要使用可达性分析算法来判断内存是否可回收，那么分析工作必须在一个能保障一致性的快照中进行，如果这点不满足，分析结果的准确性就无法保证。
简单来说就是执行这个算法的时候，要停止程序标记对象，不能一边改变对象的引用一边判定对象是不是垃圾。</p>
<p>这点也是导致GC进行时必须<code>Stop The World</code>的一个重要原因。即使是号称几乎不会发生停顿的CMS收集器，标记根节点时也是必须要停顿的。</p>
<h2 id="垃圾收集算法">垃圾收集算法</h2>
<p>当成功区分出内存中存活对象和死亡对象后，GC接下来的任务就是执行垃圾回收，释放掉无用对象所占用的内存空间，以便有足够的可用内存空间为新对象分配内存。
目前在JVM中比较常见的三种垃圾收集算法是:</p>
<ul>
<li>标记清除算法（Mark-Sweep）</li>
<li>复制算法（Copying）</li>
<li>标记整理算法（Mark-Compact）</li>
</ul>
<h3 id="标记清除算法">标记清除算法</h3>
<p>标记清除算法是一种非常基础和常见的垃圾收集算法，该算法被J.McCarthy等人在1960年提出并并应用于<code>Lisp</code>语言。</p>
<p>标记清除算法是最基础的一种垃圾回收算法，它分为两部分，先把内存区域中的这些对象进行标记，哪些属于可回收的标记出来（可达性分析法），然后把这些垃圾拎出来清理掉。
当堆中的有效内存空间被耗尽的时候，就会STW，然后进行两项工作，第一项则是标记，第二项则是清除；</p>
<ul>
<li>标记：垃圾收集器从引用根节点（GCRoots）开始遍历，标记所有被引用的对象，一般是在对象的Header中记录为可达对象。</li>
<li>清除：垃圾收集器对堆内存从头到尾进行线性的遍历，如果发现某个对象在其Header中没有标记为可达对象，则将其回收。</li>
</ul>
<p><img alt="标记清除算法" src="/posts/annex/images/essays/%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95.png"></p>
<p>标记的是可达对象，不是垃圾对象，清除回收的是垃圾对象。</p>
<p>标记的是可达对象，不是垃圾对象，清除回收的是垃圾对象，那么什么是清除？</p>
<p>所谓的清除并不是真的置空，而是把需要清除的对象地址保存在<a href="/posts/jvm/java-object/#%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%BF%87%E7%A8%8B%E5%8F%8A%E6%AD%A5%E9%AA%A4">空闲的地址列表</a>里。
下次有新对象需要加载时，判断垃圾的位置空间是否够，如果够，就存放覆盖原有的地址。</p>
<p>缺点：</p>
<ul>
<li>标记清除算法的效率不算高；</li>
<li>在进行GC的时候，需要停止整个应用程序，用户体验较差；</li>
<li>这种方式清理出来的空闲内存是不连续的，会产生内碎片，需要维护一个空闲列表；存放大对象可能会存不下；</li>
</ul>
<h3 id="复制算法">复制算法</h3>
<p>复制算法是在标记清除算法上演化而来的，为了解决标记清除算法的内存碎片问题，M.L.Minsky于1963年发表了著名的论文：“使用双存储区的Lisp语言垃圾收集器（CA LISP Garbage Collector Algorithm Using Serial Secondary Storage）”。
M.L.Minsky在该论文中描述的算法被人们称为复制算法，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块，它也被M.L.Minsky成功地引入到了Lisp语言的一个实现版本中。</p>
<p><img alt="复制算法" src="/posts/annex/images/essays/%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95.png"></p>
<p>将分配内存空间分为两块，每次只使用其中一块，在垃圾回收时将正在使用的内存中存活对象复制到未被使用的内存块中去，之后清除正在使用的内存块中的所有对象，交换两个内存的角色，最后完成垃圾回收。</p>
<p>复制算法虽然解决了标记清除算法带来的问题，实现简单，运行高效，但是也出现了新的问题：</p>
<ul>
<li>因为用复制的形式，需要两倍的内存空间，或者说只能用分配内存的一半。</li>
<li>对于G1这种分拆成为大量region的GC，复制而不是移动，意味着GC需要维护region之间对象引用关系，不管是内存占用或者时间开销也不小；
简单来说，从From区被复制到To区的可达对象，需要改变之前对象的指针引用，需要内存和时间的开销。</li>
</ul>
<p>复制算法最坏情况，如果系统中的垃圾对象很少，复制算法需要复制的存活对象数量就会很多，那么大部分对象从一个区域移动到另一个区域，GCRoots需要改变了对象的地址，加大了维护成本。
所以复制算法适合，系统中的垃圾对象很多，可复制的存活的对象很少的情况。利用这个特点，在新生代中的幸存者区里面就用到了复制算法的思想。</p>
<h3 id="标记整理算法">标记整理算法</h3>
<p>复制算法的高效性是建立在存活对象少、垃圾对象多的前提下的。这种情况在新生代经常发生，但是在老年代，更常见的情况是大部分对象都是存活对象。
如果依然使用复制算法，由于存活对象较多，复制的成本也将很高。因此，基于老年代垃圾回收的特性，需要使用其他的算法。</p>
<p>标记清除算法的确可以应用在老年代中，但是该算法不仅执行效率低下，而且在执行完内存回收后还会产生内存碎片，所以JVM的设计者需要在此基础之上进行改进。
1970年前后，<code>G.L.Steele、C.J.Chene</code>和<code>D.s.Wise</code>等研究者发布标记整理算法。在许多现代的垃圾收集器中，人们都使用了标记整理算法或其改进版本。</p>
<p><img alt="标记整理算法" src="/posts/annex/images/essays/%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95.png"></p>
<p>标记整理算法，标记过程仍然与标记清除算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，再清理掉端边界以外的内存区域。</p>
<p>执行过程：</p>
<ul>
<li>标记：垃圾收集器从引用根节点（GCRoots）开始遍历，标记所有被引用的对象。一般是在对象的Header中记录为可达对象。</li>
<li>整理：将所有的存活对象压缩到内存的一端，按顺序排放，之后执行清除的步骤。</li>
<li>清除：垃圾收集器对堆内存从头到尾进行线性的遍历，如果发现某个对象在其Header中没有标记为可达对象，则将其回收。</li>
</ul>
<p>与标记清理算法相比，多了一个步骤&quot;压缩（整理）&quot;，也就是移动对象的步骤，是否移动回收后的存活对象是一项优缺点并存的风险决策。
标记的存活对象将会被整理，按照内存地址依次排列，而未被标记的内存会被清理掉。如此一来，当我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可，这比维护一个空闲列表显然少了许多开销。</p>
<p>标记整理算法，消除了标记清除算法当中，内存区域分散的缺点，也规避了复制算法当中，内存减半的高额代价。
看起来很美好，但由于多了整理这一步，内存变动更频繁，需要整理所有存活对象的引用地址，在效率上比复制算法差很多。</p>
<p>标记整理算法相对来说更平滑一些，但是效率上不尽如人意，它比复制算法多了一个标记的阶段，比标记清除多了一个整理内存的阶段。</p>
<table>
<thead>
<tr>
<th></th>
<th>标记清除算法</th>
<th>标记整理算法</th>
<th>复制算法</th>
</tr>
</thead>
<tbody>
<tr>
<td>时间开销</td>
<td>中等</td>
<td>最慢</td>
<td>最快</td>
</tr>
<tr>
<td>空间开销</td>
<td>少（会堆积碎片）</td>
<td>少（不堆积碎片）</td>
<td>通常需要存活对象的两倍空间（不堆积碎片）</td>
</tr>
<tr>
<td>移动对象</td>
<td>否</td>
<td>是</td>
<td>是</td>
</tr>
</tbody>
</table>
<p>这些算法中，并没有一种算法可以完全替代其他算法，它们都具有自己独特的优势和特点。分代收集算法思想应运而生。</p>
<h3 id="分代收集思想">分代收集思想</h3>
<p>分代收集算法严格来说并不是一种思想或理论，而是融合上述三种基础的算法思想，而产生的针对不同情况所采用不同算法的一套组合拳。</p>
<p>分代收集算法，是基于不同的对象的生命周期是不一样的这样一个事实。因此，不同生命周期的对象可以采取不同的收集方式，以便提高回收效率。
一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点使用不同的回收算法，以提高垃圾回收的效率。</p>
<p>在Java程序运行的过程中，会产生大量的对象，其中有些对象是与业务信息相关，比如Http请求中的Session对象、线程、Socket连接，这类对象跟业务直接挂钩，因此生命周期比较长。
但是还有一些对象，主要是程序运行过程中生成的临时变量，这些对象生命周期会比较短，比如：String对象，由于其不变类的特性，系统会产生大量的这些对象，有些对象甚至只用一次即可回收。</p>
<p>分代的思想被现有的虚拟机广泛使用，几乎所有的垃圾回收器都区分新生代和老年代。
在HotSpot中，基于分代的概念，GC所使用的内存回收算法必须结合年轻代和老年代各自的特点。</p>
<ul>
<li>年轻代：区域相对老年代较小，对象生命周期短、存活率低，回收频繁。适合复制算法；复制算法内存利用率不高的问题，通过Hotspot中的两个幸存者区的设计得到缓解。</li>
<li>老年代：区域较大，对象生命周期长、存活率高，回收不及年轻代频繁。不适合复制算法，一般是由标记清除或者是标记清除与标记整理的混合实现。</li>
</ul>
<h3 id="增量收集算法">增量收集算法</h3>
<p>在垃圾回收过程中，应用软件将处于一种Stop The World的状态。
在STW状态下，应用程序所有的线程都会挂起，暂停一切正常的工作，等待垃圾回收的完成。
如果垃圾回收时间过长，应用程序会被挂起很久，将严重影响用户体验或者系统的稳定性。
为了解决这个问题，即对实时垃圾收集算法的研究直接导致了增量收集算法的诞生。</p>
<p>如果一次性将所有的垃圾进行处理，需要造成系统长时间的停顿，那么就可以让垃圾收集线程和应用程序线程交替执行。
每次，垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。依次反复，直到垃圾收集完成。</p>
<p>总的来说，增量收集算法的基础仍是传统的标记清除和复制算法。
增量收集算法通过对线程间冲突的妥善处理，允许垃圾收集线程以分阶段的方式完成标记、清理或复制工作。</p>
<p>使用这种方式，由于在垃圾回收过程中，间断性地还执行了应用程序代码，所以能减少系统的停顿时间。
但是，因为线程切换和上下文转换的消耗，会使得垃圾回收的总体成本上升，造成系统吞吐量的下降。</p>
<h3 id="分区算法">分区算法</h3>
<p>一般来说，在相同条件下，堆空间越大，一次GC时所需要的时间就越长，有关GC产生的停顿也越长。
为了更好地控制GC产生的停顿时间，将一块大的内存区域分割成多个小块，根据目标的停顿时间，每次合理地回收若干个小区间，而不是整个堆空间，从而减少一次GC所产生的停顿。</p>
<p>分代算法将按照对象的生命周期长短划分成两个部分，分区算法将整个堆空间划分成连续的不同小区间。
每一个小区间都独立使用，独立回收。这种算法的好处是可以控制一次回收多少个小区间。</p>
</div>
                    <div id="post_footer" class="post_footer">
                        <div class="meta">

                            <div id="post_footer_info" class="info">
                                <span class="field tags">
                                    <i class="ri-stack-line"></i>
                                    
                                        
                                        <a href="http://localhost:1313/tags/java/">Java</a>
                                        
                                        <a href="http://localhost:1313/tags/jvm/">JVM</a>
                                        
                                    
                                </span>
                            </div>
                        </div>
                    </div>
                </div>
                
                
                <div id="doc_comments" class="doc_comments"></div>
                
            </div>
        </div>
    </div>
    
<a id="search-btn" style="display: inline-block;" href="javascript:void(0);">
    <span class="ri-search-line"></span>
</a>
<div id="fastSearch">
    <input id="searchInput" tabindex="0" autocomplete="off">
    <ul id="searchResults"></ul>
</div>
<div class="side_nav">
    
    <a id="top_to_back" href="#" class="top_to_back">
        <svg t="1688614744062" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2152" width="16" height="16"><path d="M966.4 323.2c-9.6-9.6-25.6-9.6-35.2 0l-416 416-425.6-416c-9.6-9.6-25.6-9.6-35.2 0-9.6 9.6-9.6 25.6 0 35.2l441.6 432c9.6 9.6 25.6 9.6 35.2 0l435.2-432C976 345.6 976 332.8 966.4 323.2z" p-id="2153" fill="#424242"></path></svg>    </a>
    
    <div>
        <a id="content_display" class="content_display">
            <svg t="1688606941910" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="57753" width="18" height="18"><path d="M192 448c10.9 0 21.8-4.2 30.2-12.5L497 160.8c5.4-5.4 11.8-6.2 15.1-6.2 3.3 0 9.6 0.8 15.1 6.2l274.7 274.7c16.7 16.7 43.7 16.7 60.3 0 16.7-16.7 16.7-43.7 0-60.3L587.4 100.4c-41.6-41.6-109.3-41.6-150.9 0L161.8 375.2c-16.7 16.7-16.7 43.7 0 60.3 8.4 8.3 19.3 12.5 30.2 12.5zM801.8 588.5L527.1 863.2c-5.4 5.4-11.8 6.2-15.1 6.2-3.3 0-9.7-0.8-15.1-6.2L222.2 588.5c-16.7-16.7-43.7-16.7-60.3 0-16.7 16.7-16.7 43.7 0 60.3l274.8 274.8c20.8 20.8 48.1 31.2 75.4 31.2 27.3 0 54.6-10.4 75.4-31.2l274.7-274.8c16.7-16.7 16.7-43.7 0-60.3-16.7-16.7-43.7-16.7-60.4 0z" fill="#424242" p-id="57754"></path></svg>
        </a>
        <a id="content_hidden" class="content_hidden">
            <svg t="1688603143752" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="15592" width="18" height="18"><path d="M479.004101 645.938677L165.25229 958.480465a37.510709 37.510709 0 0 0 0 54.059551 36.47863 36.47863 0 0 0 53.063061 0l293.679668-292.576411 293.715256 292.576411a36.443042 36.443042 0 0 0 53.063061 0 37.510709 37.510709 0 0 0 0-54.059551l-313.751811-312.541788c-21.210989-22.349834-36.514219-24.698702-66.017424 0z m66.053013-267.877709l312.577377-312.541789a37.510709 37.510709 0 0 0 0-54.059551 36.443042 36.443042 0 0 0-53.063061 0l-292.505234 292.576411L219.560963 11.459628a36.47863 36.47863 0 0 0-53.063061 0 37.510709 37.510709 0 0 0 0 54.059551l312.577377 312.541789a46.58588 46.58588 0 0 0 65.981835-0.035589z" p-id="15593" fill="#424242"></path></svg>
        </a>
    </div>
    
    <a id="back_to_top" href="#" class="back_to_top">
        <svg t="1688628374733" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3166" width="16" height="16"><path d="M966.4 668.8l-435.2-432c-9.6-9.6-25.6-9.6-35.2 0l-441.6 432c-9.6 9.6-9.6 25.6 0 35.2 9.6 9.6 25.6 9.6 35.2 0l425.6-416 416 416c9.6 9.6 25.6 9.6 35.2 0S976 678.4 966.4 668.8z" p-id="3167" fill="#424242"></path></svg>
    </a>
</div>
    <footer class="footer">
    <div id="footer_powered_by" class="powered_by">
        <a href="https://varkai.com">Designed by VarKai,</a>
        <a href="http://www.gohugo.io/">Proudly published with Hugo</a>
    </div>

    <div id="footer_slogan" class="footer_slogan">
        <span>from 2020</span>
    </div>
</footer>
    <script src="http://localhost:1313/js/jquery-3.5.1.min.js"></script>
<link href="http://localhost:1313/css/fancybox.min.css" rel="stylesheet">
<script src="http://localhost:1313/js/fancybox.min.js"></script>
<script src="http://localhost:1313/js/darkmode.js"></script>
<script src="http://localhost:1313/js/zozo.js"></script>

<script src="http://localhost:1313/js/busuanzi_2.3_busuanzi.pure.mini.js"></script>
<script src="http://localhost:1313/js/html2canvas.js"></script>
<script src="http://localhost:1313/js/utils.js"></script>
<script src="http://localhost:1313/js/html2md.js"></script>
<script src="http://localhost:1313/js/htmlexport.js"></script>

<script src="http://localhost:1313/js/fastsearch.js"></script>
<script src="http://localhost:1313/js/fuse.js"></script>


<script>
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
</script>


<script>
    
    document.addEventListener("DOMContentLoaded", function () {
        const uvE = document.getElementById('busuanzi_value_site_uv');
        const pvE = document.getElementById('busuanzi_value_site_pv');
        const uvObs = new MutationObserver((mutationsList) => {
            for (let mutation of mutationsList) {
                if (mutation.type === 'childList') {
                    uvObs.disconnect();
                    mutation.target.innerHTML = parseInt(mutation.target.innerHTML) + 57030;
                    break;
                }
            }
        });
        const pvObs = new MutationObserver((mutationsList) => {
            for (let mutation of mutationsList) {
                if (mutation.type === 'childList') {
                    pvObs.disconnect();
                    mutation.target.innerHTML = parseInt(mutation.target.innerHTML) + 203040;
                    break;
                }
            }
        });
        const config = {
            childList: true
        };
        uvObs.observe(uvE, config);
        pvObs.observe(pvE, config);
    });
</script>


<script>
    
    document.addEventListener('DOMContentLoaded', function() {
        var links = document.querySelectorAll('.content a');
        links.forEach(function(link) {
            link.setAttribute('target', '_blank');
        });
    });
</script>










</body>

</html>