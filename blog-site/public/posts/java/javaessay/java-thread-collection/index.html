<!DOCTYPE html>




<html lang="zh" >
<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="google-site-verification" content="tVxoyWMeaEzEUV0EzY1STfJXZWaZ8WM-i-a8AWBri0o" />
    <meta name="msvalidate.01" content="48159A4EAF3C3F448369E581664B1A21" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="author" content="whitepure" />
	
	
	
	<title>Java中常用线程安全的集合 ｜ 脚踏实地</title>
	
    
    
    <meta name="description" content="Java中常用线程安全的集合 在多线程环境中，数据的一致性和线程的安全性是至关重要的。传统的集合类，如ArrayList、HashMap和HashSet，在并发访" />
    

    
    
    <meta name="keywords" content="whitepure博客, whiteppure, whitepure, Java, 博客, 技术博客, 生活记录, 技术分享" />
    

	

    <link rel="shortcut icon" href="http://localhost:1313/images/favicon.ico" />

    <link rel="stylesheet" type="text/css" media="screen" href="http://localhost:1313/css/normalize.css" />
    
    <link rel="stylesheet" type="text/css" media="screen" href="http://localhost:1313/css/animate.min.css" />
    <link rel="stylesheet" type="text/css" media="screen" href="http://localhost:1313/css/zozo.css" />
    <link rel="stylesheet" type="text/css" media="screen" href="http://localhost:1313/css/remixicon.css" />
    
    <link rel="stylesheet" type="text/css" media="screen" href="http://localhost:1313/css/highlight.css" />

    <link rel="stylesheet" type="text/css" media="screen" href="http://localhost:1313/css/toc.css" />
    <link rel="stylesheet" type="text/css" media="screen" href="http://localhost:1313/css/search.css" />
    <link rel="stylesheet" type="text/css" media="screen" href="http://localhost:1313/css/img.css" />
</head>

<body>
    <div class="post-password">
        
    </div>

    
    
    









<div id="post_content_toc" class="toc">
    <div class="page-header"><strong></strong></div>
    <div id="page-scrollspy" class="toc-nav">

        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#java%e4%b8%ad%e5%b8%b8%e7%94%a8%e7%ba%bf%e7%a8%8b%e5%ae%89%e5%85%a8%e7%9a%84%e9%9b%86%e5%90%88">
                    Java中常用线程安全的集合
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#copywritearraylist">
                    CopyWriteArrayList
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#copyonwritearrayset">
                    CopyOnWriteArraySet
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#hashtable">
                    HashTable
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#concurrenthashmap">
                    ConcurrentHashMap
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#jdk17">
                    JDK1.7
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#jdk18">
                    JDK1.8
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        

    </div>
</div>



    

    
    <div class="main animate__animated animate__fadeInDown" id="main_content">
        <div class="nav_container animated fadeInDown">
    <div class="site_nav" id="site_nav">
        <ul><li class="">
                <a href="http://localhost:1313/">首页</a>
            </li><li class="">
                <a href="http://localhost:1313/posts/">归档</a>
            </li><li class="">
                <a href="http://localhost:1313/tags/">标签</a>
            </li><li class="">
                <a href="http://localhost:1313/about/">关于</a>
            </li>
        </ul>
    </div>
    <div class="menu_icon">
        <a id="menu_icon"><i class="ri-menu-line"></i></a>
    </div>
</div>
        <div id="post_header" class="header animated fadeInDown">
    <div class="site_title_container">
        <div class="site_title">
            <h1>
                <a href="http://localhost:1313/">
                    <span>脚踏实地</span>
                </a>
            </h1>
        </div>
        <div class="description">
            <p class="sub_title">
                
            </p>

            
            <div class="my_socials">
                
                    
                    <a href="https://github.com/whiteppure/" title="github" target="_blank">
                        <i class="ri-github-fill"></i>
                    </a>
                    
                
                <a href="" type="application/rss+xml" title="rss" target="_blank">
                    <i class="ri-rss-fill"></i>
                </a>
                
                
                <span id="sys_function" class="sys_function display_none">
                    <a id="export_pdf"  title="导出pdf" style="border: none; cursor: pointer; margin-left: 10px">
                        <svg t="1688701481347" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3517" width="16" height="16"><path d="M425.610455 85.814544H149.05897A42.303635 42.303635 0 0 0 106.6274 128.075535V896.492068c0 23.326702 18.976933 42.26099 42.43157 42.26099h682.743143a42.559504 42.559504 0 0 0 42.431569-42.559504v-384.016365a42.644793 42.644793 0 0 1 85.289587 0v384.016365A127.849091 127.849091 0 0 1 831.802113 1024H149.05897A127.635867 127.635867 0 0 1 21.337813 896.449423V128.03289A127.593222 127.593222 0 0 1 149.101614 0.524957h276.466196a42.644793 42.644793 0 0 1 0 85.289587z m564.062683 158.08425l-170.579174 170.579173a42.644793 42.644793 0 1 1-60.299738-60.299738L856.578738 256.393718H618.364922a42.644793 42.644793 0 1 1 0-85.289587h238.213816l-97.784512-97.784511A42.644793 42.644793 0 1 1 819.093964 13.019882l170.579174 170.579174a42.644793 42.644793 0 0 1 0 60.299738zM149.272194 597.552066a42.644793 42.644793 0 0 1 42.644793-42.644794h51.514911c59.190973 0 107.891327 23.284057 107.976617 97.102195 0 71.003581-49.46796 102.347504-106.185536 102.347504h-31.343923v66.781747a32.282109 32.282109 0 0 1-64.606862 0V597.552066z m92.709781 100.215264c31.429213 0 46.568114-16.46089 46.568114-45.757863 0-30.064579-17.313786-40.512554-48.359196-40.512554h-26.311837v86.270417h28.145563z m232.414124-142.860058c81.878003 0 136.036891 43.710913 136.036891 147.67892S556.231457 853.420826 477.935617 853.420826h-38.16709a42.644793 42.644793 0 0 1-42.644794-42.644793v-213.223967a42.644793 42.644793 0 0 1 42.644794-42.644794h34.542282z m-4.008611 240.729859c43.32711 0 73.988717-22.047358 73.988717-93.050939 0-71.046226-30.704251-90.705476-73.988717-90.705476h-8.699538v183.79906h8.699538zM692.481573 853.420826a32.282109 32.282109 0 0 1-32.282109-32.282108V597.552066a42.644793 42.644793 0 0 1 42.644793-42.644794h99.063855a29.680776 29.680776 0 1 1 0 59.404197h-77.144431v65.374469h61.749661a29.894 29.894 0 1 1 0 59.788h-61.749661v81.66478a32.282109 32.282109 0 0 1-32.282108 32.282108z" fill="#5f5f5f" p-id="3518"></path></svg>
                    </a>
                    <a id="export_pic" title="导出图片" style="border: none; cursor: pointer; margin-left: 10px">
                        <svg t="1689071509720" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4564" width="16" height="16"><path d="M909.132886 0.037506h-184.960611a33.909445 33.909445 0 0 0-32.368107 33.909445 33.909445 33.909445 0 0 0 33.909445 33.395666h158.244078l-200.373995 199.346437a33.395666 33.395666 0 0 0 0 47.781491 31.854327 31.854327 0 0 0 23.633856 9.76181 33.909445 33.909445 0 0 0 24.147635-9.76181l198.832657-199.346437V272.340628a33.909445 33.909445 0 0 0 69.874009 0V88.921355A88.37007 88.37007 0 0 0 909.132886 0.037506zM216.558153 347.866211a107.37991 107.37991 0 1 0 107.37991-107.379911 107.89369 107.89369 0 0 0-107.37991 107.379911z m154.133843 0a51.377948 51.377948 0 0 1-97.618101 0 51.377948 51.377948 0 1 1 97.618101 0z" p-id="4565" fill="#424242"></path><path d="M963.079731 437.777619a34.423225 34.423225 0 0 0-33.909446 33.909445v265.110209a1811.07265 1811.07265 0 0 0-137.692899-193.181082 106.352351 106.352351 0 0 0-78.60826-36.478343 123.820854 123.820854 0 0 0-82.204716 35.964563l-3.596456 3.082677-188.557068 176.74014c-11.816928-13.358266-47.781491-51.377948-82.204716-87.856291a83.232275 83.232275 0 0 0-85.801172-21.578738 105.324792 105.324792 0 0 0-38.019681 19.52362l-141.289356 121.765736V89.948914a22.092517 22.092517 0 0 1 22.606297-22.606297h417.702713a33.395666 33.395666 0 0 0 33.395666-33.909445 33.395666 33.395666 0 0 0-33.395666-33.395666H113.802258A89.911408 89.911408 0 0 0 23.89085 89.948914v844.139678a89.911408 89.911408 0 0 0 89.911408 89.911408h793.27551a89.911408 89.911408 0 0 0 89.397629-89.911408v-462.401528a33.909445 33.909445 0 0 0-33.395666-33.909445z m-33.909446 496.310973a22.606297 22.606297 0 0 1-22.092517 22.606297H113.802258a22.606297 22.606297 0 0 1-22.606297-22.606297v-88.37007l183.933052-160.812976a43.157476 43.157476 0 0 1 15.413385-7.192912 15.927164 15.927164 0 0 1 17.982281 5.137794c37.505902 36.478343 78.60826 83.232275 82.718496 87.856291a61.653537 61.653537 0 0 0 42.643696 22.092517 62.681096 62.681096 0 0 0 51.377948-20.037399c8.220472-8.220472 134.610223-125.875971 194.208641-181.877935a57.029522 57.029522 0 0 1 34.423225-16.440943 45.212594 45.212594 0 0 1 29.79921 15.927164 2954.231982 2954.231982 0 0 1 186.501949 256.889738z" p-id="4566" fill="#424242"></path></svg>
                    </a>
                    <a id="export_markdown" title="导出markdown" style="border: none; cursor: pointer; margin-left: 10px">
                        <svg t="1689071035200" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="13570" width="16" height="16"><path d="M178.073367 843.957262V461.158929h107.121045l107.121045 140.734874 107.125433-140.734874h107.116657v382.798333h-107.116657v-219.54307l-107.125433 140.730486-107.116657-140.730486v219.54307zM737.783131 892.148786l-131.221196-209.156132h87.479334V461.158929h87.479335v221.833725h87.483722z" p-id="13571" fill="#424242"></path><path d="M911.9958 217.142709c10.672172 10.663395 19.812851 25.144549 27.430816 43.430297 7.617965 18.285748 11.431335 35.044392 11.431336 50.28471V969.140255c0 15.235929-5.336086 28.18998-15.999481 38.853375-10.667783 10.667783-23.621834 16.003869-38.857763 16.003869H127.994904c-15.240317 0-28.18998-5.336086-38.857763-16.003869-10.663395-10.663395-15.999481-23.617446-15.999481-38.853375V54.852856c0-15.240317 5.331698-28.18998 15.999481-38.857763C99.804925 5.336086 112.758975 0 127.999292 0h512.000944c15.235929 0 31.998962 3.808982 50.28471 11.426947 18.285748 7.622353 32.762514 16.763033 43.430297 27.426428zM658.290372 77.715526v214.856442h214.856442c-3.808982-11.049559-7.99974-18.856218-12.572275-23.43314l-178.855415-178.851027c-4.572534-4.572534-12.383581-8.763292-23.43314-12.572275z m219.428976 873.143369V365.71496h-237.714724c-15.240317 0-28.18998-5.336086-38.857763-15.999481-10.663395-10.667783-15.999481-23.621834-15.999481-38.857763V73.142992H146.28504v877.715903z" p-id="13572" fill="#424242"></path></svg>
                    </a>
                    <a id="export_doc" title="导出文档" style="border: none; cursor: pointer; margin-left: 10px">
                        <svg t="1689246982401" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="6825" width="16" height="16"><path d="M270.76864 608.32h180.8a31.68 31.68 0 0 0 0-62.976H270.76864a31.68 31.68 0 0 0 0 62.976zM271.34464 458.56h457.92a33.472 33.472 0 0 0 31.552-34.752 33.28 33.28 0 0 0-31.552-34.624H271.34464a34.816 34.816 0 0 0 0 69.376zM271.34464 293.504h457.92a33.344 33.344 0 0 0 31.552-34.688 33.216 33.216 0 0 0-31.552-34.624H271.34464a33.28 33.28 0 0 0-31.616 34.624 33.28 33.28 0 0 0 31.616 34.688z" p-id="6826" fill="#424242"></path><path d="M869.87264 0H153.77664A70.4 70.4 0 0 0 84.65664 70.912V953.6A69.952 69.952 0 0 0 153.77664 1024h370.048a32 32 0 0 0 0-63.68H147.12064V64h729.6v468.672a31.296 31.296 0 1 0 62.528 0V70.912A70.4 70.4 0 0 0 869.87264 0z" p-id="6827" fill="#424242"></path><path d="M482.16064 730.624h337.664L715.82464 625.216a28.864 28.864 0 0 1-7.936-28.736 29.184 29.184 0 0 1 20.608-21.184 29.632 29.632 0 0 1 29.12 8.128l174.784 177.216-174.784 176.96a29.184 29.184 0 0 1-49.728-13.312 29.248 29.248 0 0 1 8-28.8l103.936-105.344H482.16064a29.696 29.696 0 0 1-29.504-29.76 29.632 29.632 0 0 1 29.504-29.76z" p-id="6828" fill="#424242"></path></svg>
                    </a>
                </span>
                <a  id="icon_more" title="更多" >
                    <svg t="1688715321313" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5356" width="16" height="16"><path d="M483.555556 199.111111m-85.333334 0a85.333333 85.333333 0 1 0 170.666667 0 85.333333 85.333333 0 1 0-170.666667 0Z" fill="#424242" p-id="5357"></path><path d="M483.555556 540.444444m-85.333334 0a85.333333 85.333333 0 1 0 170.666667 0 85.333333 85.333333 0 1 0-170.666667 0Z" fill="#424242" p-id="5358"></path><path d="M483.555556 881.777778m-85.333334 0a85.333333 85.333333 0 1 0 170.666667 0 85.333333 85.333333 0 1 0-170.666667 0Z" fill="#424242" p-id="5359"></path></svg>
                </a>
                <a  id="icon_less" class="display_none">
                    <svg t="1688723160472" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="15872" width="16" height="16"><path d="M300.105143 592.676571h423.789714a80.676571 80.676571 0 1 0 0-161.353142H300.105143a80.676571 80.676571 0 0 0 0 161.353142z" fill="#8a8a8a" p-id="15873"></path></svg>
                </a>
                
            </div>

            
            <div class="post">
                <div class="post_title post_detail_title">
                    <span class="date" id="busuanzi_container_site_pv">总访问量 <span id="busuanzi_site_pv">...</span> 次</span>
                </div>
                <div class="post_title post_detail_title">
                    <span class="date" id="busuanzi_container_site_uv">总访客数 <span id="busuanzi_site_uv">...</span> 人</span>
                </div>
            </div>
            

            <div class="post">
                <div class="post_title post_detail_title">
                    
                    <span class="date">总文章数 200 篇</span>
                </div>
                <div class="post_title post_detail_title">
                    
                    
                    
                    
                    
                    <span class="date">博客已运行 2109 天</span>
                </div>
            </div>

        </div>
    </div>
</div>
        <div class="content">
            <div class="post_page">
                <div class="post animate__animated animate__fadeInDown">
                    <div class="post_title post_detail_title">
                        <h2 id="post_single_title">Java中常用线程安全的集合</h2>
                        <span id="post_page_title_date" class="date">更新于 2020.04.05</span>





                    </div>
                    <div class="post_content markdown"><h2 id="java中常用线程安全的集合">Java中常用线程安全的集合</h2>
<p>在多线程环境中，数据的一致性和线程的安全性是至关重要的。传统的集合类，如<code>ArrayList</code>、<code>HashMap</code>和<code>HashSet</code>，在并发访问时并不安全，可能会导致数据不一致和其他并发问题。
为了在并发编程中高效且安全地操作数据，Java提供了一系列线程安全的集合类来替代这些传统集合。</p>
<table>
<thead>
<tr>
<th>线程不安全</th>
<th>线程安全替代</th>
</tr>
</thead>
<tbody>
<tr>
<td>ArrayList</td>
<td>CopyOnWriteArrayList</td>
</tr>
<tr>
<td>HashSet</td>
<td>CopyOnWriteArraySet</td>
</tr>
<tr>
<td>HashMap</td>
<td>HashTable、ConcurrentHashMap</td>
</tr>
</tbody>
</table>
<h3 id="copywritearraylist">CopyWriteArrayList</h3>
<p><code>CopyOnWriteArrayList</code>是Java中的一种线程安全的<code>List</code>实现，适用于读操作远多于写操作的场景，该集合在线程不安全的情况下可替代<code>ArrayList</code>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">MainTest</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="o">[]</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">CopyOnWriteArrayList</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span><span class="w"> </span><span class="n">arrayList</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">CopyOnWriteArrayList</span><span class="o">&lt;&gt;</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="n">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="w"> </span><span class="n">10</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">new</span><span class="w"> </span><span class="n">Thread</span><span class="p">(()</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">arrayList</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="n">UUID</span><span class="p">.</span><span class="na">randomUUID</span><span class="p">().</span><span class="na">toString</span><span class="p">());</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">arrayList</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">},</span><span class="n">String</span><span class="p">.</span><span class="na">valueOf</span><span class="p">(</span><span class="n">i</span><span class="p">)).</span><span class="na">start</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p><code>CopyWriteArrayList</code>字面意思就是在写的时候复制，思想就是读写分离的思想。它的基本原理是每次修改操作都会创建该列表的一个新副本，因此读操作不需要加锁，可以并发执行。
以下是<code>CopyOnWriteArrayList</code>的<code>add()</code>方法源码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="w">    </span><span class="cm">/** The array, accessed only via getArray/setArray. */</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kd">transient</span><span class="w"> </span><span class="kd">volatile</span><span class="w"> </span><span class="n">Object</span><span class="o">[]</span><span class="w"> </span><span class="n">array</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="cm">/** The lock protecting all mutators */</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">final</span><span class="w"> </span><span class="kd">transient</span><span class="w"> </span><span class="n">ReentrantLock</span><span class="w"> </span><span class="n">lock</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ReentrantLock</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">     </span><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * Gets the array.  Non-private so as to also be accessible
</span></span></span><span class="line"><span class="cl"><span class="cm">     * from CopyOnWriteArraySet class.
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">final</span><span class="w"> </span><span class="n">Object</span><span class="o">[]</span><span class="w"> </span><span class="nf">getArray</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">array</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * Appends the specified element to the end of this list.
</span></span></span><span class="line"><span class="cl"><span class="cm">     *
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @param e element to be appended to this list
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @return {@code true}
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">boolean</span><span class="w"> </span><span class="nf">add</span><span class="p">(</span><span class="n">E</span><span class="w"> </span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kd">final</span><span class="w"> </span><span class="n">ReentrantLock</span><span class="w"> </span><span class="n">lock</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="na">lock</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">lock</span><span class="p">.</span><span class="na">lock</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">try</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">Object</span><span class="o">[]</span><span class="w"> </span><span class="n">elements</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">getArray</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="kt">int</span><span class="w"> </span><span class="n">len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">elements</span><span class="p">.</span><span class="na">length</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">Object</span><span class="o">[]</span><span class="w"> </span><span class="n">newElements</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Arrays</span><span class="p">.</span><span class="na">copyOf</span><span class="p">(</span><span class="n">elements</span><span class="p">,</span><span class="w"> </span><span class="n">len</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">1</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">newElements</span><span class="o">[</span><span class="n">len</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">e</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">setArray</span><span class="p">(</span><span class="n">newElements</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="kc">true</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">finally</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">lock</span><span class="p">.</span><span class="na">unlock</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p><code>CopyWriteArrayList</code>之所以线程安全的原因是在源码里面使用<code>ReentrantLock</code>保证了某个线程在写的时候不会被打断。
可以看到源码开始先是复制了一份数组，同一时刻只有一个线程写，其余的线程会读。在复制的数组上边进行写操作，写好以后在返回<code>true</code>。
这样就把读写进行了分离，写好以后因为<code>array</code>加了<code>volatile</code>修饰，所以该数组是对于其他的线程是可见的，就会读取到最新的值。</p>
<p>由于每次写操作都会创建一个数组的新副本，所以写操作的开销较大。但是读取操作非常高效且不需要加锁，因此适用于读操作远多于写操作的场景，例如缓存、白名单等。
不适合写操作频繁的场景，在这种情况下，<code>ConcurrentLinkedQueue</code>或<code>ConcurrentHashMap</code>等其他线程安全集合可能更合适。</p>
<h3 id="copyonwritearrayset">CopyOnWriteArraySet</h3>
<p><code>CopyOnWriteArraySet</code>是Java中一种线程安全的<code>Set</code>实现，内部使用了<code>CopyOnWriteArrayList</code>来存储元素。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">private</span><span class="w"> </span><span class="kd">final</span><span class="w"> </span><span class="n">CopyOnWriteArrayList</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span><span class="w"> </span><span class="n">al</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * Creates an empty set.
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">public</span><span class="w"> </span><span class="nf">CopyOnWriteArraySet</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">al</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">CopyOnWriteArrayList</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>这种集合在读操作远多于写操作的场景中非常有用，因为它通过每次修改创建集合的副本来实现线程安全。
因为底层用<code>CopyOnWriteArrayList</code>存储，所以写操作开销大，每次修改都会创建数组副本，适用场景有限。不适用于写操作频繁的场景，否则会导致高昂的内存和时间开销。
与<code>CopyOnWriteArrayList</code>不同的是，<code>CopyOnWriteArraySet</code>不允许包含重复元素。如果尝试添加一个已经存在的元素，集合将保持不变，所以该集合在线程不安全的情况下可替代<code>HashSet</code>。
<code>CopyOnWriteArraySet</code>适用于需要唯一性且不关心元素顺序的场景，例如维护一组独特的订阅者或监听器。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">CopyOnWriteArraySetExample</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="o">[]</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// 创建一个 CopyOnWriteArraySet</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">Set</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span><span class="w"> </span><span class="n">cowSet</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">CopyOnWriteArraySet</span><span class="o">&lt;&gt;</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// 添加元素</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">cowSet</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="s">&#34;Apple&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">cowSet</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="s">&#34;Banana&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">cowSet</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="s">&#34;Apple&#34;</span><span class="p">);</span><span class="w"> </span><span class="c1">// 不允许重复元素</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// 读取元素</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&#34;Set: &#34;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">cowSet</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// 迭代元素</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">String</span><span class="w"> </span><span class="n">fruit</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">cowSet</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">fruit</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// 添加新元素</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">cowSet</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="s">&#34;Grapes&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&#34;After adding Grapes: &#34;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">cowSet</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// 删除元素</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">cowSet</span><span class="p">.</span><span class="na">remove</span><span class="p">(</span><span class="s">&#34;Banana&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&#34;After removing Banana: &#34;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">cowSet</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><h3 id="hashtable">HashTable</h3>
<p><code>HashTable</code>的出现是为了解决<code>HashMap</code>线程不安全的问题，但因为性能的原因，在多线程环境下很少使用，一般都会使用<code>ConcurrentHashMap</code>。<code>HashTable</code>性能低的原因，就是直接加了<code>synchronized</code>修饰。</p>
<p><code>HashMap</code>中的方法大多没有同步，这意味着如果一个线程在遍历<code>HashMap</code>的同时，另一个线程修改了<code>HashMap</code>，例如添加或删除元素，可能会导致<code>ConcurrentModificationException</code>。
当遍历<code>HashTable</code>中的元素时，此时另一个线程来修改数据，这个时候加锁是没问题的。但是在没有另一个线程该数据的时候，<code>HashTable</code>还是加锁，这时性能就不太好了。可理解为<code>HashTable</code>性能不好的原因就是锁的粒度太粗了。</p>
<p><code>Hashtable</code>的线程安全通过在方法级别使用<code>synchronized</code>关键字来实现，这确保了每次只有一个线程能够执行任何给定的方法。这种方法级别的锁定提供了基本的线程安全，但在高并发环境下会导致性能瓶颈。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">HashtableExample</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="o">[]</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// 创建一个 Hashtable</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">Hashtable</span><span class="o">&lt;</span><span class="n">Integer</span><span class="p">,</span><span class="w"> </span><span class="n">String</span><span class="o">&gt;</span><span class="w"> </span><span class="n">hashtable</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Hashtable</span><span class="o">&lt;&gt;</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// 添加元素</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">hashtable</span><span class="p">.</span><span class="na">put</span><span class="p">(</span><span class="n">1</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;One&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">hashtable</span><span class="p">.</span><span class="na">put</span><span class="p">(</span><span class="n">2</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;Two&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">hashtable</span><span class="p">.</span><span class="na">put</span><span class="p">(</span><span class="n">3</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;Three&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// 读取元素</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&#34;Value for key 1: &#34;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">hashtable</span><span class="p">.</span><span class="na">get</span><span class="p">(</span><span class="n">1</span><span class="p">));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&#34;Value for key 2: &#34;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">hashtable</span><span class="p">.</span><span class="na">get</span><span class="p">(</span><span class="n">2</span><span class="p">));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// 删除元素</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">hashtable</span><span class="p">.</span><span class="na">remove</span><span class="p">(</span><span class="n">2</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// 迭代元素</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">Integer</span><span class="w"> </span><span class="n">key</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">hashtable</span><span class="p">.</span><span class="na">keySet</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&#34;Key: &#34;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">key</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">&#34;, Value: &#34;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">hashtable</span><span class="p">.</span><span class="na">get</span><span class="p">(</span><span class="n">key</span><span class="p">));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><h3 id="concurrenthashmap">ConcurrentHashMap</h3>
<p><code>ConcurrentHashMap</code>是Java中的一种线程安全的哈希表实现，用来替代传统的<code>HashMap</code>，来解决在多线程环境中并发修改带来的问题。
与<code>Hashtable</code>不同，<code>ConcurrentHashMap</code>不对整个表进行全局加锁。相反它只对具体操作涉及的部分进行加锁，减少了线程之间的竞争。
因为<code>HashMap</code>在JDK1.7与JDK1.8做了调整，所以<code>ConcurrentHashMap</code>在JDK1.7与JDK1.8实现也有所不同。</p>
<h4 id="jdk17">JDK1.7</h4>
<p>JDK1.7<code>ConcurrentHashMap</code>采用<code>segment</code>的分段锁机制实现线程安全，其中<code>segment</code>类继承自<code>ReentrantLock</code>。用<code>ReentrantLock</code>、CAS来保证线程安全。
每个分段相当于一个独立的哈希表，并且分别加锁。</p>
<p>需要注意的是JDK1.7中的ConcurrentHashMap，分段数量是固定。在创建<code>ConcurrentHashMap</code>实例时，必须指定初始的分段数量。
这个初始的分段数量在实例创建后是不可动态修改的，也就是说一旦创建了<code>ConcurrentHashMap</code>，其分段数量就固定不变了。数组的长度就是<code>concurrencyLevel</code>指定的分段数量。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span><span class="w"> </span><span class="nf">ConcurrentHashMap</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">initialCapacity</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">loadFactor</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">concurrencyLevel</span><span class="p">){}</span><span class="w">
</span></span></span></code></pre></div><p>相比之下，JDK1.8中的<code>ConcurrentHashMap</code>改进了这一点，不再使用固定的分段数量，而是根据当前的容量动态调整分段的数量，从而更好地适应不同的并发场景，提升了并发性能和灵活性。</p>
<p><img alt="jdk1.7ConcurrentHashMap" src="/posts/annex/images/essays/jdk1.7ConcurrentHashMap.png"></p>
<p>整个<code>ConcurrentHashMap</code>被划分为多个分段，每个分段都是一个独立的哈希表。每个分段独立加锁，细化了锁的粒度，同时允许多个线程同时操作不同的分段，从而提高并发性能。
使用<code>ReentrantLock</code>锁定分段，在执行插入、删除或更新操作时，只有操作涉及的分段会被锁定，其他分段不受影响。
在进行插入操作时，先根据键的哈希值确定应该操作哪个分段，然后锁定该分段并进行操作。这种方法可以减少锁争用，提高并发性能。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">public V put(K key， V value) {
</span></span><span class="line"><span class="cl">    Segment&lt;K,V&gt; s;
</span></span><span class="line"><span class="cl">    if (value == null)
</span></span><span class="line"><span class="cl">        throw new NullPointerException();
</span></span><span class="line"><span class="cl">    int hash = hash(key.hashCode());
</span></span><span class="line"><span class="cl">    int j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;
</span></span><span class="line"><span class="cl">    if ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject          // nonvolatile; recheck
</span></span><span class="line"><span class="cl">         (segments, (j &lt;&lt; SSHIFT) + SBASE)) == null) //  in ensureSegment
</span></span><span class="line"><span class="cl">        s = ensureSegment(j);
</span></span><span class="line"><span class="cl">    return s.put(key, hash, value, false);
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><p>首先判空，然后计算哈希值。计算<code>put</code>进来的元素分配到哪个<code>segment</code>数组上，判断当前<code>segments</code>数组上的元素是否为空，如果分段为空就会使用<code>ensureSegment</code>方法创建<code>segment</code>对象；
最后调用<code>Segment.put</code>方法存放到对应的节点中。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * Returns the segment for the given index, creating it and
</span></span></span><span class="line"><span class="cl"><span class="cm"> * recording in segment table (via CAS) if not already present.
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param k the index
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @return the segment
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">private</span><span class="w"> </span><span class="n">Segment</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="n">V</span><span class="o">&gt;</span><span class="w"> </span><span class="nf">ensureSegment</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">k</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kd">final</span><span class="w"> </span><span class="n">Segment</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="n">V</span><span class="o">&gt;[]</span><span class="w"> </span><span class="n">ss</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="na">segments</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kt">long</span><span class="w"> </span><span class="n">u</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">k</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">SSHIFT</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">SBASE</span><span class="p">;</span><span class="w"> </span><span class="c1">// raw offset</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">Segment</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="n">V</span><span class="o">&gt;</span><span class="w"> </span><span class="n">seg</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="n">seg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">Segment</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="n">V</span><span class="o">&gt;</span><span class="p">)</span><span class="n">UNSAFE</span><span class="p">.</span><span class="na">getObjectVolatile</span><span class="p">(</span><span class="n">ss</span><span class="p">,</span><span class="w"> </span><span class="n">u</span><span class="p">))</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kc">null</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">Segment</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="n">V</span><span class="o">&gt;</span><span class="w"> </span><span class="n">proto</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ss</span><span class="o">[</span><span class="n">0</span><span class="o">]</span><span class="p">;</span><span class="w"> </span><span class="c1">// use segment 0 as prototype</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="kt">int</span><span class="w"> </span><span class="n">cap</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">proto</span><span class="p">.</span><span class="na">table</span><span class="p">.</span><span class="na">length</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="kt">float</span><span class="w"> </span><span class="n">lf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">proto</span><span class="p">.</span><span class="na">loadFactor</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="kt">int</span><span class="w"> </span><span class="n">threshold</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="n">cap</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">lf</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">HashEntry</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="n">V</span><span class="o">&gt;[]</span><span class="w"> </span><span class="n">tab</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">HashEntry</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="n">V</span><span class="o">&gt;[]</span><span class="p">)</span><span class="k">new</span><span class="w"> </span><span class="n">HashEntry</span><span class="o">[</span><span class="n">cap</span><span class="o">]</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="n">seg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">Segment</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="n">V</span><span class="o">&gt;</span><span class="p">)</span><span class="n">UNSAFE</span><span class="p">.</span><span class="na">getObjectVolatile</span><span class="p">(</span><span class="n">ss</span><span class="p">,</span><span class="w"> </span><span class="n">u</span><span class="p">))</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="o">==</span><span class="w"> </span><span class="kc">null</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// recheck</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">Segment</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="n">V</span><span class="o">&gt;</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Segment</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="n">V</span><span class="o">&gt;</span><span class="p">(</span><span class="n">lf</span><span class="p">,</span><span class="w"> </span><span class="n">threshold</span><span class="p">,</span><span class="w"> </span><span class="n">tab</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="k">while</span><span class="w"> </span><span class="p">((</span><span class="n">seg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">Segment</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="n">V</span><span class="o">&gt;</span><span class="p">)</span><span class="n">UNSAFE</span><span class="p">.</span><span class="na">getObjectVolatile</span><span class="p">(</span><span class="n">ss</span><span class="p">,</span><span class="w"> </span><span class="n">u</span><span class="p">))</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                       </span><span class="o">==</span><span class="w"> </span><span class="kc">null</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">UNSAFE</span><span class="p">.</span><span class="na">compareAndSwapObject</span><span class="p">(</span><span class="n">ss</span><span class="p">,</span><span class="w"> </span><span class="n">u</span><span class="p">,</span><span class="w"> </span><span class="kc">null</span><span class="p">,</span><span class="w"> </span><span class="n">seg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s</span><span class="p">))</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                        </span><span class="k">break</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">seg</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p><code>ensureSegment</code>方法作用是返回指定索引的分段对象，通过CAS判断，如果还没有分段则创建它并记录在分段表中。</p>
<p>当多个线程同时执行该方法，同时通过<code>ensureSegment</code>方法创建<code>segment</code>对象时，只有一个线程能够创建成功。
其中创建的新<code>segment</code>对象中的加载因子、存放位置、扩容阈值与<code>segment[0]</code>元素保持一致，这样性能更高，因为不用在计算了。</p>
<p>为了保证线程安全，在<code>ensureSegment</code>方法中用<code>Unsafe</code>类中的一些方法做了三次判断，其中最后一次也就是该方法保证线程安全的关键，用到了CAS操作。确保只有一个线程能够成功创建分段。
当多个线程并发执行下面的代码，先执行CAS的线程，判断<code>segment</code>数组中某个位置是空的，然后就把这个线程自己创建的<code>segment</code>数组赋值给<code>seg</code>，即<code>seg = s</code>然后<code>break</code>跳出循环。
后执行的线程会再次判断seg是否为空，因先执行的线程已经<code>seg = s</code>不为空了，所以循环条件不成立，也就不再执行了。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">while ((seg = (Segment&lt;K，V&gt;)UNSAFE.getObjectVolatile(ss, u)) == null) {
</span></span><span class="line"><span class="cl">    if (UNSAFE.compareAndSwapObject(ss, u, null, seg = s))
</span></span><span class="line"><span class="cl">        break;
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><p><code>Segment.put</code>为了保证线程安全，执行<code>put</code>方法时需要加锁，如果未能获取锁，会执行<code>scanAndLockForPut</code>方法，确保最终能获取到锁。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">final V put(K key, int hash, V value, boolean onlyIfAbsent) {
</span></span><span class="line"><span class="cl">    HashEntry&lt;K,V&gt; node = tryLock() ? null :
</span></span><span class="line"><span class="cl">        scanAndLockForPut(key, hash, value);
</span></span><span class="line"><span class="cl">    // ... 插入节点操作 最后释放锁
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><p><code>scanAndLockForPut</code>方法的主要作用就是加锁，如果没有获取锁，就会一致遍历<code>segment</code>数组，直到遍历到最后一个元素。
每次遍历完都会尝试获取锁，如果还是获取不到锁，就会重试，最大次数为<code>MAX_SCAN_RETRIES</code>在CPU多核下为64次，如果大于64次就会强制加锁。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">private</span><span class="w"> </span><span class="n">HashEntry</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="n">V</span><span class="o">&gt;</span><span class="w"> </span><span class="nf">scanAndLockForPut</span><span class="p">(</span><span class="n">K</span><span class="w"> </span><span class="n">key</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">hash</span><span class="p">,</span><span class="w"> </span><span class="n">V</span><span class="w"> </span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">HashEntry</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="n">V</span><span class="o">&gt;</span><span class="w"> </span><span class="n">first</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">entryForHash</span><span class="p">(</span><span class="k">this</span><span class="p">,</span><span class="w"> </span><span class="n">hash</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">HashEntry</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="n">V</span><span class="o">&gt;</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">first</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">HashEntry</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="n">V</span><span class="o">&gt;</span><span class="w"> </span><span class="n">node</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">null</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">retries</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="n">1</span><span class="p">;</span><span class="w"> </span><span class="c1">// negative while locating node</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">tryLock</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">HashEntry</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="n">V</span><span class="o">&gt;</span><span class="w"> </span><span class="n">f</span><span class="p">;</span><span class="w"> </span><span class="c1">// to recheck first below</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">retries</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">e</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kc">null</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">node</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kc">null</span><span class="p">)</span><span class="w"> </span><span class="c1">// speculatively create node</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="n">node</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">HashEntry</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="n">V</span><span class="o">&gt;</span><span class="p">(</span><span class="n">hash</span><span class="p">,</span><span class="w"> </span><span class="n">key</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="kc">null</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">retries</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">0</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">key</span><span class="p">.</span><span class="na">equals</span><span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="na">key</span><span class="p">))</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">retries</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">0</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">else</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">e</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">e</span><span class="p">.</span><span class="na">next</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">++</span><span class="n">retries</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">MAX_SCAN_RETRIES</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">lock</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">break</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="n">retries</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">1</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                 </span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">entryForHash</span><span class="p">(</span><span class="k">this</span><span class="p">,</span><span class="w"> </span><span class="n">hash</span><span class="p">))</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">first</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">e</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">first</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">f</span><span class="p">;</span><span class="w"> </span><span class="c1">// re-traverse if entry changed</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">retries</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="n">1</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">node</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">static</span><span class="w"> </span><span class="kd">final</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">MAX_SCAN_RETRIES</span><span class="w"> </span><span class="o">=</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">Runtime</span><span class="p">.</span><span class="na">getRuntime</span><span class="p">().</span><span class="na">availableProcessors</span><span class="p">()</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">1</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">64</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">1</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div><h4 id="jdk18">JDK1.8</h4>
<p>在JDK1.8中，<code>ConcurrentHashMap</code>进行了重大改进，弃用了分段锁机制，转而采用更细粒度的并发控制机制。
直接用Node数组+链表/红黑树的数据结构来实现，并发控制使用 <code>synchronized</code> 和CAS来操作，整体看起来就像是优化过且线程安全的<code>HashMap</code>。
虽然在JDK1.8中还能看到<code>Segment</code>的数据结构，但是已经简化了其属性，这样做只是为了兼容旧版本。</p>
<p>JDK1.8中彻底放弃了<code>Segment</code>转而采用的是<code>Node</code>，其设计思想也不再是JDK1.7中的分段锁思想。
<code>ConcurrentHashMap</code>在JDK1.8中不再使用分段锁，而是使用与<code>HashMap</code>类似的数组+链表/红黑树的数据结构。
数组中的每个桶是一个链表或红黑树的头节点。<code>HashMap</code>不同的是<code>ConcurrentHashMap</code>只是增加了同步操作来控制并发。</p>
<p><img alt="jdk1.8ConcurrentHashMap" src="/posts/annex/images/essays/jdk1.8ConcurrentHashMap.png"></p>
<p>插入操作首先根据键的哈希值定位到具体的桶。如果该桶为空，则使用CAS操作插入新的节点。如果该桶非空，则使用<code>synchronized</code>锁定该桶，并进行链表或红黑树的插入操作。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">final V putVal(K key, V value, boolean onlyIfAbsent) {
</span></span><span class="line"><span class="cl">    if (key == null || value == null)
</span></span><span class="line"><span class="cl">        throw new NullPointerException();
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    // 计算键的哈希值，并将其扩散
</span></span><span class="line"><span class="cl">    int hash = spread(key.hashCode());
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    // 记录桶中元素个数
</span></span><span class="line"><span class="cl">    int binCount = 0;
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    // 循环查找或插入元素
</span></span><span class="line"><span class="cl">    for (Node&lt;K,V&gt;[] tab = table;;) {
</span></span><span class="line"><span class="cl">        Node&lt;K,V&gt; f;
</span></span><span class="line"><span class="cl">        int n, i, fh;
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        // 如果表为空或长度为0，则进行初始化
</span></span><span class="line"><span class="cl">        if (tab == null || (n = tab.length) == 0)
</span></span><span class="line"><span class="cl">            tab = initTable();
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        // 计算存储位置
</span></span><span class="line"><span class="cl">        else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) {
</span></span><span class="line"><span class="cl">            // 如果位置为空，则尝试使用 CAS 插入新节点
</span></span><span class="line"><span class="cl">            if (casTabAt(tab, i, null, new Node&lt;K,V&gt;(hash, key, value, null)))
</span></span><span class="line"><span class="cl">                break;  // 插入成功，退出循环
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        // 如果位置非空，处理链表或红黑树结构
</span></span><span class="line"><span class="cl">        else if ((fh = f.hash) == MOVED)
</span></span><span class="line"><span class="cl">            tab = helpTransfer(tab, f); // 如果处于扩容状态，则帮助进行扩容
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        else {
</span></span><span class="line"><span class="cl">            V oldVal = null;
</span></span><span class="line"><span class="cl">            
</span></span><span class="line"><span class="cl">            // 使用 synchronized 锁定桶
</span></span><span class="line"><span class="cl">            synchronized (f) {
</span></span><span class="line"><span class="cl">                if (tabAt(tab, i) == f) {
</span></span><span class="line"><span class="cl">                    if (fh &gt;= 0) {
</span></span><span class="line"><span class="cl">                        // 处理链表结构
</span></span><span class="line"><span class="cl">                        binCount = 1;
</span></span><span class="line"><span class="cl">                        for (Node&lt;K,V&gt; e = f;; ++binCount) {
</span></span><span class="line"><span class="cl">                            K ek;
</span></span><span class="line"><span class="cl">                            if (e.hash == hash &amp;&amp;
</span></span><span class="line"><span class="cl">                                ((ek = e.key) == key ||
</span></span><span class="line"><span class="cl">                                 (ek != null &amp;&amp; key.equals(ek)))) {
</span></span><span class="line"><span class="cl">                                oldVal = e.val;
</span></span><span class="line"><span class="cl">                                if (!onlyIfAbsent)
</span></span><span class="line"><span class="cl">                                    e.val = value;
</span></span><span class="line"><span class="cl">                                break;
</span></span><span class="line"><span class="cl">                            }
</span></span><span class="line"><span class="cl">                            Node&lt;K,V&gt; pred = e;
</span></span><span class="line"><span class="cl">                            if ((e = e.next) == null) {
</span></span><span class="line"><span class="cl">                                pred.next = new Node&lt;K,V&gt;(hash, key, value, null);
</span></span><span class="line"><span class="cl">                                break;
</span></span><span class="line"><span class="cl">                            }
</span></span><span class="line"><span class="cl">                        }
</span></span><span class="line"><span class="cl">                    } else if (f instanceof TreeBin) {
</span></span><span class="line"><span class="cl">                        // 处理红黑树结构
</span></span><span class="line"><span class="cl">                        Node&lt;K,V&gt; p;
</span></span><span class="line"><span class="cl">                        binCount = 2;
</span></span><span class="line"><span class="cl">                        if ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key, value)) != null) {
</span></span><span class="line"><span class="cl">                            oldVal = p.val;
</span></span><span class="line"><span class="cl">                            if (!onlyIfAbsent)
</span></span><span class="line"><span class="cl">                                p.val = value;
</span></span><span class="line"><span class="cl">                        }
</span></span><span class="line"><span class="cl">                    }
</span></span><span class="line"><span class="cl">                }
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">            
</span></span><span class="line"><span class="cl">            // 根据操作结果进行进一步处理
</span></span><span class="line"><span class="cl">            if (binCount != 0) {
</span></span><span class="line"><span class="cl">                if (binCount &gt;= TREEIFY_THRESHOLD)  // 如果链表长度达到阈值，则转为红黑树
</span></span><span class="line"><span class="cl">                    treeifyBin(tab, i);
</span></span><span class="line"><span class="cl">                if (oldVal != null)
</span></span><span class="line"><span class="cl">                    return oldVal;  // 返回旧值
</span></span><span class="line"><span class="cl">                break;  // 插入完成，退出循环
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    // 更新计数器
</span></span><span class="line"><span class="cl">    addCount(1L, binCount);
</span></span><span class="line"><span class="cl">    return null;
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><p>如果<code>table</code>为空或长度为0，则调用<code>initTable()</code>方法进行初始化。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">private final Node&lt;K,V&gt;[] initTable() {
</span></span><span class="line"><span class="cl">    Node&lt;K,V&gt;[] tab; int sc;
</span></span><span class="line"><span class="cl">    while ((tab = table) == null || tab.length == 0) {
</span></span><span class="line"><span class="cl">        if ((sc = sizeCtl) &lt; 0)
</span></span><span class="line"><span class="cl">            Thread.yield(); // lost initialization race; just spin
</span></span><span class="line"><span class="cl">        else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) {
</span></span><span class="line"><span class="cl">            try {
</span></span><span class="line"><span class="cl">                if ((tab = table) == null || tab.length == 0) {
</span></span><span class="line"><span class="cl">                    int n = (sc &gt; 0) ? sc : DEFAULT_CAPACITY;
</span></span><span class="line"><span class="cl">                    @SuppressWarnings(&#34;unchecked&#34;)
</span></span><span class="line"><span class="cl">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n];
</span></span><span class="line"><span class="cl">                    table = tab = nt;
</span></span><span class="line"><span class="cl">                    sc = n - (n &gt;&gt;&gt; 2);
</span></span><span class="line"><span class="cl">                }
</span></span><span class="line"><span class="cl">            } finally {
</span></span><span class="line"><span class="cl">                sizeCtl = sc;
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">            break;
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    return tab;
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><p>根据键的哈希值<code>hash</code>计算存储在<code>table</code>中的位置。如果该位置为空，则使用<code>casTabAt()</code>方法尝试通过CAS操作插入新的<code>Node</code>节点。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">int hash = spread(key.hashCode());
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">// hash算法，计算存放在map中的位置；要保证尽可能的均匀分散，避免hash冲突
</span></span><span class="line"><span class="cl">static final int HASH_BITS = 0x7fffffff;
</span></span><span class="line"><span class="cl">static final int spread(int h) {
</span></span><span class="line"><span class="cl">    // 等同于： key.hashCode() ^ (key.hashCode() &gt;&gt;&gt; 16) &amp; 0x7fffffff
</span></span><span class="line"><span class="cl">    return (h ^ (h &gt;&gt;&gt; 16)) &amp; HASH_BITS;
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><p>如果位置非空，首先判断是否处于扩容状态<code>MOVED</code>，如果是，则调用<code>helpTransfer()</code>方法协助进行扩容操作。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">// MOVED = -1
</span></span><span class="line"><span class="cl">if ((fh = f.hash) == MOVED)
</span></span><span class="line"><span class="cl">tab = helpTransfer(tab, f);
</span></span></code></pre></div><p>如果位置上是链表结构<code>(fh &gt;= 0)</code>，则遍历链表，根据键查找或插入节点。如果位置上是红黑树结构<code>(f instanceof TreeBin)</code>，则调用<code>putTreeVal()</code>方法在红黑树中插入节点。
然后使用<code>synchronized (f)</code>锁定桶，确保在链表或红黑树操作期间其他线程不能修改桶的结构。根据链表长度<code>binCount &gt;= TREEIFY_THRESHOLD(默认是8)</code>，则把链表转化为红黑树结构的情况，如果插入操作修改了已有节点的值，则返回旧值。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">V oldVal = null;
</span></span><span class="line"><span class="cl">synchronized (f) {
</span></span><span class="line"><span class="cl">    if (tabAt(tab, i) == f) {
</span></span><span class="line"><span class="cl">        if (fh &gt;= 0) {
</span></span><span class="line"><span class="cl">            binCount = 1;
</span></span><span class="line"><span class="cl">            for (Node&lt;K,V&gt; e = f;; ++binCount) {
</span></span><span class="line"><span class="cl">                K ek;
</span></span><span class="line"><span class="cl">                if (e.hash == hash &amp;&amp;
</span></span><span class="line"><span class="cl">                    ((ek = e.key) == key ||
</span></span><span class="line"><span class="cl">                     (ek != null &amp;&amp; key.equals(ek)))) {
</span></span><span class="line"><span class="cl">                    oldVal = e.val;
</span></span><span class="line"><span class="cl">                    if (!onlyIfAbsent)
</span></span><span class="line"><span class="cl">                        e.val = value;
</span></span><span class="line"><span class="cl">                    break;
</span></span><span class="line"><span class="cl">                }
</span></span><span class="line"><span class="cl">                Node&lt;K,V&gt; pred = e;
</span></span><span class="line"><span class="cl">                if ((e = e.next) == null) {
</span></span><span class="line"><span class="cl">                    pred.next = new Node&lt;K,V&gt;(hash, key,
</span></span><span class="line"><span class="cl">                                              value, null);
</span></span><span class="line"><span class="cl">                    break;
</span></span><span class="line"><span class="cl">                }
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        else if (f instanceof TreeBin) {
</span></span><span class="line"><span class="cl">            Node&lt;K,V&gt; p;
</span></span><span class="line"><span class="cl">            binCount = 2;
</span></span><span class="line"><span class="cl">            if ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,
</span></span><span class="line"><span class="cl">                                           value)) != null) {
</span></span><span class="line"><span class="cl">                oldVal = p.val;
</span></span><span class="line"><span class="cl">                if (!onlyIfAbsent)
</span></span><span class="line"><span class="cl">                    p.val = value;
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">if (binCount != 0) {
</span></span><span class="line"><span class="cl">    if (binCount &gt;= TREEIFY_THRESHOLD)
</span></span><span class="line"><span class="cl">        treeifyBin(tab, i);
</span></span><span class="line"><span class="cl">    if (oldVal != null)
</span></span><span class="line"><span class="cl">        return oldVal;
</span></span><span class="line"><span class="cl">    break;
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><p>最后调用<code>addCount()</code>方法更新元素计数器，表示成功插入了一个节点。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">// 相当于size++
</span></span><span class="line"><span class="cl">addCount(1L, binCount);
</span></span></code></pre></div><p>其中<code>addCount()</code>方法中也包含了扩容操作。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">private</span><span class="w"> </span><span class="kd">final</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">addCount</span><span class="p">(</span><span class="kt">long</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">check</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">CounterCell</span><span class="o">[]</span><span class="w"> </span><span class="n">as</span><span class="p">;</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">s</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="n">as</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">counterCells</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">null</span><span class="w"> </span><span class="o">||</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="o">!</span><span class="n">U</span><span class="p">.</span><span class="na">compareAndSwapLong</span><span class="p">(</span><span class="k">this</span><span class="p">,</span><span class="w"> </span><span class="n">BASECOUNT</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">baseCount</span><span class="p">,</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">x</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">CounterCell</span><span class="w"> </span><span class="n">a</span><span class="p">;</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">v</span><span class="p">;</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">m</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kt">boolean</span><span class="w"> </span><span class="n">uncontended</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">true</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">as</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kc">null</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="p">(</span><span class="n">m</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">as</span><span class="p">.</span><span class="na">length</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">1</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">0</span><span class="w"> </span><span class="o">||</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">as</span><span class="o">[</span><span class="n">ThreadLocalRandom</span><span class="p">.</span><span class="na">getProbe</span><span class="p">()</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">m</span><span class="o">]</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kc">null</span><span class="w"> </span><span class="o">||</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="o">!</span><span class="p">(</span><span class="n">uncontended</span><span class="w"> </span><span class="o">=</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">              </span><span class="n">U</span><span class="p">.</span><span class="na">compareAndSwapLong</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">CELLVALUE</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="na">value</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">x</span><span class="p">)))</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">fullAddCount</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">uncontended</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">return</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">check</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">1</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">return</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sumCount</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">check</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="n">V</span><span class="o">&gt;[]</span><span class="w"> </span><span class="n">tab</span><span class="p">,</span><span class="w"> </span><span class="n">nt</span><span class="p">;</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">sc</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">s</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="p">(</span><span class="kt">long</span><span class="p">)(</span><span class="n">sc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sizeCtl</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">(</span><span class="n">tab</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">table</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">null</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">               </span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tab</span><span class="p">.</span><span class="na">length</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">MAXIMUM_CAPACITY</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="kt">int</span><span class="w"> </span><span class="n">rs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">resizeStamp</span><span class="p">(</span><span class="n">n</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">sc</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="n">sc</span><span class="w"> </span><span class="o">&gt;&gt;&gt;</span><span class="w"> </span><span class="n">RESIZE_STAMP_SHIFT</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">rs</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">sc</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">rs</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">1</span><span class="w"> </span><span class="o">||</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="n">sc</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">rs</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">MAX_RESIZERS</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="p">(</span><span class="n">nt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nextTable</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kc">null</span><span class="w"> </span><span class="o">||</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="n">transferIndex</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">0</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="k">break</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">U</span><span class="p">.</span><span class="na">compareAndSwapInt</span><span class="p">(</span><span class="k">this</span><span class="p">,</span><span class="w"> </span><span class="n">SIZECTL</span><span class="p">,</span><span class="w"> </span><span class="n">sc</span><span class="p">,</span><span class="w"> </span><span class="n">sc</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">1</span><span class="p">))</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="n">transfer</span><span class="p">(</span><span class="n">tab</span><span class="p">,</span><span class="w"> </span><span class="n">nt</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">U</span><span class="p">.</span><span class="na">compareAndSwapInt</span><span class="p">(</span><span class="k">this</span><span class="p">,</span><span class="w"> </span><span class="n">SIZECTL</span><span class="p">,</span><span class="w"> </span><span class="n">sc</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                                         </span><span class="p">(</span><span class="n">rs</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">RESIZE_STAMP_SHIFT</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">2</span><span class="p">))</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">transfer</span><span class="p">(</span><span class="n">tab</span><span class="p">,</span><span class="w"> </span><span class="kc">null</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sumCount</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>节点从<code>table</code>移动到<code>nextTable</code>，大体思想是遍历、复制的过程。
通过<code>Unsafe.compareAndSwapInt</code>修改<code>sizeCtl</code>值，保证只有一个线程能够初始化<code>nextTable</code>，扩容后的数组长度为原来的两倍，但是容量是原来的1.5。</p>
</div>
                    <div id="post_footer" class="post_footer">
                        <div class="meta">

                            <div id="post_footer_info" class="info">
                                <span class="field tags">
                                    <i class="ri-stack-line"></i>
                                    
                                        
                                        <a href="http://localhost:1313/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a>
                                        
                                        <a href="http://localhost:1313/tags/java/">Java</a>
                                        
                                        <a href="http://localhost:1313/tags/%E9%9B%86%E5%90%88/">集合</a>
                                        
                                        <a href="http://localhost:1313/tags/%E9%9A%8F%E7%AC%94/">随笔</a>
                                        
                                    
                                </span>
                            </div>
                        </div>
                    </div>
                </div>
                
                
                <div id="doc_comments" class="doc_comments"></div>
                
            </div>
        </div>
    </div>
    
<a id="search-btn" style="display: inline-block;" href="javascript:void(0);">
    <span class="ri-search-line"></span>
</a>
<div id="fastSearch">
    <input id="searchInput" tabindex="0" autocomplete="off">
    <ul id="searchResults"></ul>
</div>
<div class="side_nav">
    
    <a id="top_to_back" href="#" class="top_to_back">
        <svg t="1688614744062" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2152" width="16" height="16"><path d="M966.4 323.2c-9.6-9.6-25.6-9.6-35.2 0l-416 416-425.6-416c-9.6-9.6-25.6-9.6-35.2 0-9.6 9.6-9.6 25.6 0 35.2l441.6 432c9.6 9.6 25.6 9.6 35.2 0l435.2-432C976 345.6 976 332.8 966.4 323.2z" p-id="2153" fill="#424242"></path></svg>    </a>
    
    <div>
        <a id="content_display" class="content_display">
            <svg t="1688606941910" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="57753" width="18" height="18"><path d="M192 448c10.9 0 21.8-4.2 30.2-12.5L497 160.8c5.4-5.4 11.8-6.2 15.1-6.2 3.3 0 9.6 0.8 15.1 6.2l274.7 274.7c16.7 16.7 43.7 16.7 60.3 0 16.7-16.7 16.7-43.7 0-60.3L587.4 100.4c-41.6-41.6-109.3-41.6-150.9 0L161.8 375.2c-16.7 16.7-16.7 43.7 0 60.3 8.4 8.3 19.3 12.5 30.2 12.5zM801.8 588.5L527.1 863.2c-5.4 5.4-11.8 6.2-15.1 6.2-3.3 0-9.7-0.8-15.1-6.2L222.2 588.5c-16.7-16.7-43.7-16.7-60.3 0-16.7 16.7-16.7 43.7 0 60.3l274.8 274.8c20.8 20.8 48.1 31.2 75.4 31.2 27.3 0 54.6-10.4 75.4-31.2l274.7-274.8c16.7-16.7 16.7-43.7 0-60.3-16.7-16.7-43.7-16.7-60.4 0z" fill="#424242" p-id="57754"></path></svg>
        </a>
        <a id="content_hidden" class="content_hidden">
            <svg t="1688603143752" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="15592" width="18" height="18"><path d="M479.004101 645.938677L165.25229 958.480465a37.510709 37.510709 0 0 0 0 54.059551 36.47863 36.47863 0 0 0 53.063061 0l293.679668-292.576411 293.715256 292.576411a36.443042 36.443042 0 0 0 53.063061 0 37.510709 37.510709 0 0 0 0-54.059551l-313.751811-312.541788c-21.210989-22.349834-36.514219-24.698702-66.017424 0z m66.053013-267.877709l312.577377-312.541789a37.510709 37.510709 0 0 0 0-54.059551 36.443042 36.443042 0 0 0-53.063061 0l-292.505234 292.576411L219.560963 11.459628a36.47863 36.47863 0 0 0-53.063061 0 37.510709 37.510709 0 0 0 0 54.059551l312.577377 312.541789a46.58588 46.58588 0 0 0 65.981835-0.035589z" p-id="15593" fill="#424242"></path></svg>
        </a>
    </div>
    
    <a id="back_to_top" href="#" class="back_to_top">
        <svg t="1688628374733" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3166" width="16" height="16"><path d="M966.4 668.8l-435.2-432c-9.6-9.6-25.6-9.6-35.2 0l-441.6 432c-9.6 9.6-9.6 25.6 0 35.2 9.6 9.6 25.6 9.6 35.2 0l425.6-416 416 416c9.6 9.6 25.6 9.6 35.2 0S976 678.4 966.4 668.8z" p-id="3167" fill="#424242"></path></svg>
    </a>
</div>
    <footer class="footer">
    <div id="footer_powered_by" class="powered_by">
        <a href="https://varkai.com">Designed by VarKai,</a>
        <a href="http://www.gohugo.io/">Proudly published with Hugo</a>
    </div>

    <div id="footer_slogan" class="footer_slogan">
        <span>脚踏实地，仰望星空</span>
    </div>
</footer>
    




<script src="http://localhost:1313/js/jquery-3.5.1.min.js"></script>
<script src="http://localhost:1313/js/fancybox.min.js"></script>
<script src="http://localhost:1313/js/darkmode.js"></script>
<script src="http://localhost:1313/js/zozo.js"></script>


<script src="//cdn.busuanzi.cc/busuanzi/3.6.9/busuanzi.min.js" defer></script>
<script src="http://localhost:1313/js/html2canvas.js"></script>
<script src="http://localhost:1313/js/utils.js"></script>
<script src="http://localhost:1313/js/html2md.js"></script>
<script src="http://localhost:1313/js/htmlexport.js"></script>
<script src="http://localhost:1313/js/fastsearch.js"></script>
<script src="http://localhost:1313/js/fuse.js"></script>


<script>
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
</script>


<script>
    
    document.addEventListener("DOMContentLoaded", function () {
        const uvE = document.getElementById('busuanzi_site_pv');
        const pvE = document.getElementById('busuanzi_site_uv');
        const uvObs = new MutationObserver((mutationsList) => {
            for (let mutation of mutationsList) {
                if (mutation.type === 'childList') {
                    uvObs.disconnect();
                    mutation.target.innerHTML = parseInt(mutation.target.innerHTML) + 57030;
                    break;
                }
            }
        });
        const pvObs = new MutationObserver((mutationsList) => {
            for (let mutation of mutationsList) {
                if (mutation.type === 'childList') {
                    pvObs.disconnect();
                    mutation.target.innerHTML = parseInt(mutation.target.innerHTML) + 203040;
                    break;
                }
            }
        });
        const config = {
            childList: true
        };
        uvObs.observe(uvE, config);
        pvObs.observe(pvE, config);
    });
</script>


<script>
    
    document.addEventListener('DOMContentLoaded', function() {
        var links = document.querySelectorAll('.content a');
        links.forEach(function(link) {
            link.setAttribute('target', '_blank');
        });
    });
</script>







  






</body>

</html>