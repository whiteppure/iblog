<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>JVM on 唯手熟尔</title>
    <link>https://whiteppure.github.io/iblog/tags/jvm/</link>
    <description>Recent content in JVM on 唯手熟尔</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <lastBuildDate>Thu, 06 May 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://whiteppure.github.io/iblog/tags/jvm/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>JVM-垃圾回收器</title>
      <link>https://whiteppure.github.io/iblog/posts/jvm/java-garbage-collector/</link>
      <pubDate>Thu, 06 May 2021 00:00:00 +0000</pubDate>
      
      <guid>https://whiteppure.github.io/iblog/posts/jvm/java-garbage-collector/</guid>
      <description>垃圾回收器分类 垃圾收集器没有在规范中进行过多的规定，可以由不同的厂商、不同版本的JVM来实现。 由于JDK的版本处于高速迭代过程中，因此Java发展至今已经衍生了众多的GC版本。 Java不同版本新特性学习思路： 语法层面：Lambda表达式、s</description>
    </item>
    
    <item>
      <title>JVM-相关概念</title>
      <link>https://whiteppure.github.io/iblog/posts/jvm/jvm-about/</link>
      <pubDate>Tue, 27 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://whiteppure.github.io/iblog/posts/jvm/jvm-about/</guid>
      <description>内存溢出 内存溢出(Out Of Memory，简称OOM)是指应用系统中存在无法回收的内存或使用的内存过多，最终使得程序运行要用到的内存大于能提供的最大内存。 官方文档中对内存溢出的解释是，没有空闲内存，并且垃圾收集器也无法提供更多内存。 由于GC一</description>
    </item>
    
    <item>
      <title>JVM-垃圾回收</title>
      <link>https://whiteppure.github.io/iblog/posts/jvm/java-garbage-collection/</link>
      <pubDate>Wed, 21 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://whiteppure.github.io/iblog/posts/jvm/java-garbage-collection/</guid>
      <description>垃圾回收 垃圾收集，不是Java语言的伴生产物。早在1960年，第一门开始使用内存动态分配和垃圾收集技术的Lisp语言诞生。 垃圾收集机制是Java的招牌能力，极大地提高了开发效率。 如今，垃圾收集几乎成为现代语言的标配，即使经过如此长时间的发展</description>
    </item>
    
    <item>
      <title>JVM-执行引擎</title>
      <link>https://whiteppure.github.io/iblog/posts/jvm/jvm-execute-engine/</link>
      <pubDate>Thu, 15 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://whiteppure.github.io/iblog/posts/jvm/jvm-execute-engine/</guid>
      <description>概述 执行引擎是Java虚拟机核心的组成部分之一，属于JVM的下层，里面包括 解释器、及时编译器、垃圾回收器。 “虚拟机”是一个相对于“物理机”的概念，这两种机器都有代码执行能力， 其区别是物理机的执行引擎是直接建立在处理器、缓存、指令集和操作系统</description>
    </item>
    
    <item>
      <title>JVM-直接内存</title>
      <link>https://whiteppure.github.io/iblog/posts/jvm/jvm-direct-memory/</link>
      <pubDate>Wed, 14 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://whiteppure.github.io/iblog/posts/jvm/jvm-direct-memory/</guid>
      <description>直接内存不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域。 直接内存是在Java堆外的、直接向系统申请的内存区间。 操作直接内存演示代码： public class MainTest { public static void main(String[] args) { ByteBuffer allocate = ByteBuffer.allocate(1024 * 1024 * 1024); System.out.println(&amp;#</description>
    </item>
    
    <item>
      <title>JVM-Java对象</title>
      <link>https://whiteppure.github.io/iblog/posts/jvm/java-object/</link>
      <pubDate>Mon, 12 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://whiteppure.github.io/iblog/posts/jvm/java-object/</guid>
      <description>对象实例化 对象的创建方式 使用new关键字创建：最常见的方式、单例类中调用getInstance的静态类方法，XXXFactory的静态方法； 使用反射方式创建： 使用Class的newInstance方法：在JDK9里面被标记为过时的方法，因为</description>
    </item>
    
    <item>
      <title>JVM-方法区</title>
      <link>https://whiteppure.github.io/iblog/posts/jvm/jvm-method-area/</link>
      <pubDate>Thu, 08 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://whiteppure.github.io/iblog/posts/jvm/jvm-method-area/</guid>
      <description>Java虚拟机定义了若干种程序运行期间会使用到的运行时数据区，其中有一些会随着虚拟机启动而创建，随着虚拟机退出而销毁。 另外一些则是与线程一一对应的，这些与线程对应的数据区域会随着线程开始和结束而创建和销毁。 运行时数据区域包括 程序计数寄存器 虚</description>
    </item>
    
    <item>
      <title>JVM-堆</title>
      <link>https://whiteppure.github.io/iblog/posts/jvm/jvm-heap/</link>
      <pubDate>Sat, 03 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://whiteppure.github.io/iblog/posts/jvm/jvm-heap/</guid>
      <description>Java虚拟机定义了若干种程序运行期间会使用到的运行时数据区，其中有一些会随着虚拟机启动而创建，随着虚拟机退出而销毁。 另外一些则是与线程一一对应的，这些与线程对应的数据区域会随着线程开始和结束而创建和销毁。 运行时数据区域包括 程序计数寄存器 虚</description>
    </item>
    
    <item>
      <title>JVM-本地方法接口</title>
      <link>https://whiteppure.github.io/iblog/posts/jvm/jvm-native-interface/</link>
      <pubDate>Fri, 02 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://whiteppure.github.io/iblog/posts/jvm/jvm-native-interface/</guid>
      <description>概念 简单地讲，一个Native Methodt是一个Java调用非Java代码的接囗。 一个Native Method是这样一个Java方法：该方法的实现由非Java语言实现，比如C。 这个特征并非Java所特有，很多其它的编程语言都有这一机制，比</description>
    </item>
    
    <item>
      <title>JVM-本地方法栈</title>
      <link>https://whiteppure.github.io/iblog/posts/jvm/jvm-native-stack/</link>
      <pubDate>Fri, 02 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://whiteppure.github.io/iblog/posts/jvm/jvm-native-stack/</guid>
      <description>Java虚拟机定义了若干种程序运行期间会使用到的运行时数据区，其中有一些会随着虚拟机启动而创建，随着虚拟机退出而销毁。 另外一些则是与线程一一对应的，这些与线程对应的数据区域会随着线程开始和结束而创建和销毁。 运行时数据区域包括 程序计数寄存器 虚</description>
    </item>
    
    <item>
      <title>JVM-虚拟机栈</title>
      <link>https://whiteppure.github.io/iblog/posts/jvm/jvm-stack/</link>
      <pubDate>Sun, 28 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://whiteppure.github.io/iblog/posts/jvm/jvm-stack/</guid>
      <description>Java虚拟机定义了若干种程序运行期间会使用到的运行时数据区，其中有一些会随着虚拟机启动而创建，随着虚拟机退出而销毁。 另外一些则是与线程一一对应的，这些与线程对应的数据区域会随着线程开始和结束而创建和销毁。 运行时数据区域包括 程序计数寄存器 虚</description>
    </item>
    
    <item>
      <title>JVM-程序计数寄存器</title>
      <link>https://whiteppure.github.io/iblog/posts/jvm/jvm-pc-register/</link>
      <pubDate>Sat, 27 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://whiteppure.github.io/iblog/posts/jvm/jvm-pc-register/</guid>
      <description>Java虚拟机定义了若干种程序运行期间会使用到的运行时数据区，其中有一些会随着虚拟机启动而创建，随着虚拟机退出而销毁。 另外一些则是与线程一一对应的，这些与线程对应的数据区域会随着线程开始和结束而创建和销毁。 运行时数据区域包括 程序计数寄存器 虚</description>
    </item>
    
    <item>
      <title>JVM-JVM介绍</title>
      <link>https://whiteppure.github.io/iblog/posts/jvm/jvm-start/</link>
      <pubDate>Fri, 05 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://whiteppure.github.io/iblog/posts/jvm/jvm-start/</guid>
      <description>为什么要学习JVM 大部分Java开发人员，除了会在项目中使用到与Java平台相关的各种高精尖技术，对于Java技术的核心Java虚拟机了解甚少。 一些有一定工作经验的开发人员，打心眼儿里觉得SSM、微服务等上层技术才是重点，基础技术并不重要，</description>
    </item>
    
    <item>
      <title>JVM-Java类加载机制</title>
      <link>https://whiteppure.github.io/iblog/posts/jvm/jvm-classloader/</link>
      <pubDate>Fri, 05 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>https://whiteppure.github.io/iblog/posts/jvm/jvm-classloader/</guid>
      <description>类加载过程 在Java中，类加载器把一个类装入JVM中，要经过以下步骤： 加载、验证、准备、解析和初始化。其中验证,准备,解析统称为连接。 这5个阶段一般是顺序发生的，但在动态绑定的情况下，解析阶段发生在初始化阶段之后。 类加载器只负责class文</description>
    </item>
    
  </channel>
</rss>
