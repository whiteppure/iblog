<!DOCTYPE html>
<html lang="zh" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="whitepure" />
	
	
	
	<title>Java集合 ｜ 唯手熟尔</title>
	
    
    
    <meta name="description" content="概述 Java中的集合主要包括 Collection 和 Map 两种，Collection 存储着对象的集合，而 Map 存储着键值对（两个对象）的映射表。 如果你看过ArrayList类源码，就知道ArrayList底层是通过数组来存储元素的，所以如果严格来说，数组也算集合的一种" />
    

    
    
    <meta name="keywords" content="whitepure博客, whiteppure, whitepure" />
    

	

    <link rel="shortcut icon" href="https://whiteppure.github.io/iblog/images/favicon.ico" />

    <link rel="stylesheet" type="text/css" media="screen" href="https://whiteppure.github.io/iblog/css/normalize.css" />

    <link rel="stylesheet" type="text/css" media="screen" href="https://whiteppure.github.io/iblog/css/animate.min.css" />
    <link rel="stylesheet" type="text/css" media="screen" href="https://whiteppure.github.io/iblog/css/zozo.css" />
	<link rel="stylesheet" type="text/css" media="screen" href="https://cdn.jsdelivr.net/npm/remixicon@2.5.0/fonts/remixicon.css" />
    <link rel="stylesheet" type="text/css" media="screen" href="https://whiteppure.github.io/iblog/css/highlight.css" />

    <link rel="stylesheet" type="text/css" media="screen" href="https://whiteppure.github.io/iblog/css/toc.css" />

    
    
</head>

<body>
    
    
    









<div id="post_content_toc" class="toc">
    <div class="page-header"><strong></strong></div>
    <div id="page-scrollspy" class="toc-nav">

        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e6%a6%82%e8%bf%b0">
                    概述
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e6%95%b0%e7%bb%84">
                    数组
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e4%bc%98%e7%bc%ba%e7%82%b9">
                    优缺点
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e6%93%8d%e4%bd%9c%e6%95%b0%e7%bb%84">
                    操作数组
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e5%ae%9a%e4%b9%89%e6%95%b0%e7%bb%84">
                    定义数组
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e9%81%8d%e5%8e%86%e6%95%b0%e7%bb%84">
                    遍历数组
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e6%95%b0%e7%bb%84%e5%8e%bb%e9%87%8d">
                    数组去重
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e6%95%b0%e7%bb%84%e4%b8%8e%e9%9b%86%e5%90%88%e8%bd%ac%e6%8d%a2">
                    数组与集合转换
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e6%95%b0%e7%bb%84%e6%8e%92%e5%ba%8f">
                    数组排序
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e5%a4%8d%e5%88%b6%e6%95%b0%e7%bb%84">
                    复制数组
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#arraylist">
                    ArrayList
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#randomaccess">
                    RandomAccess
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#cloneable">
                    Cloneable
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e6%b5%85%e6%8b%b7%e8%b4%9d%e4%b8%8e%e6%b7%b1%e6%8b%b7%e8%b4%9d">
                    浅拷贝与深拷贝
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#arraylist%e4%b8%adclone%e6%96%b9%e6%b3%95">
                    ArrayList中clone方法
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#arraylist%e6%89%a9%e5%ae%b9">
                    ArrayList扩容
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#arraylist%e4%b8%8elinkedlist">
                    ArrayList与LinkedList
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e7%ba%bf%e7%a8%8b%e5%ae%89%e5%85%a8%e9%97%ae%e9%a2%98">
                    线程安全问题
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#set">
                    Set
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#queue">
                    Queue
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#hashmap">
                    HashMap
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e7%9b%b8%e5%85%b3%e6%a6%82%e5%bf%b5">
                    相关概念
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e7%bb%93%e6%9e%84">
                    结构
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e4%bd%bf%e7%94%a8%e7%ba%a2%e9%bb%91%e6%a0%91">
                    为什么要使用红黑树
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e4%b8%8d%e4%b8%80%e5%bc%80%e5%a7%8b%e5%b0%b1%e7%94%a8%e7%ba%a2%e9%bb%91%e6%a0%91%e4%bb%a3%e6%9b%bf%e9%93%be%e8%a1%a8%e7%bb%93%e6%9e%84">
                    为什么不一开始就用红黑树代替链表结构
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e6%a0%91%e5%8c%96%e9%98%88%e5%80%bc%e4%b8%ba8">
                    为什么树化阈值为8
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e6%a0%91%e5%8c%96%e9%98%88%e5%80%bc%e5%92%8c%e9%93%be%e8%a1%a8%e9%98%88%e5%80%bc%e4%b8%8d%e8%ae%be%e7%bd%ae%e6%88%90%e4%b8%80%e6%a0%b7">
                    为什么树化阈值和链表阈值不设置成一样
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e5%bc%95%e5%85%a5%e7%ba%a2%e9%bb%91%e6%a0%91%e5%90%8e%e5%a6%82%e6%9e%9c%e5%8d%95%e9%93%be%e8%a1%a8%e8%8a%82%e7%82%b9%e4%b8%aa%e6%95%b0%e8%b6%85%e8%bf%878%e4%b8%aa%e6%98%af%e5%90%a6%e4%b8%80%e5%ae%9a%e4%bc%9a%e6%a0%91%e5%8c%96">
                    引入红黑树后，如果单链表节点个数超过8个是否一定会树化
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e5%ae%b9%e9%87%8f">
                    容量
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e8%b4%9f%e8%bd%bd%e5%9b%a0%e5%ad%90%e9%bb%98%e8%ae%a4%e6%98%af075">
                    为什么负载因子默认是0.75
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e5%a6%82%e6%9e%9c%e6%8c%87%e5%ae%9a%e5%ae%b9%e9%87%8f%e5%a4%a7%e5%b0%8f%e4%b8%ba10%e9%82%a3%e4%b9%88%e5%ae%9e%e9%99%85%e5%a4%a7%e5%b0%8f%e6%98%af%e5%a4%9a%e5%b0%91">
                    如果指定容量大小为10，那么实际大小是多少
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e9%bb%98%e8%ae%a4%e5%88%9d%e5%a7%8b%e5%8c%96%e5%ae%b9%e9%87%8f%e4%b8%ba%e4%bb%80%e4%b9%88%e6%98%af16">
                    默认初始化容量为什么是16
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e5%88%9d%e5%a7%8b%e5%8c%96%e5%ae%b9%e9%87%8f%e8%ae%be%e7%bd%ae%e5%a4%9a%e5%b0%91%e5%90%88%e9%80%82">
                    初始化容量设置多少合适
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e6%89%a9%e5%ae%b9">
                    扩容
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e8%bf%9b%e8%a1%8c%e6%89%a9%e5%ae%b9">
                    为什么要进行扩容
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e4%bb%80%e4%b9%88%e6%97%b6%e6%9c%ba%e8%bf%9b%e8%a1%8c%e6%89%a9%e5%ae%b9">
                    什么时机进行扩容
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#17%e6%89%a9%e5%ae%b9">
                    1.7扩容
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#18%e6%89%a9%e5%ae%b9">
                    1.8扩容
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        

    </div>

</div>



    

    
    <div class="main animate__animated animate__fadeInDown" id="main_content">
        <div class="nav_container animated fadeInDown">
    <div class="site_nav" id="site_nav">
        <ul><li class="">
                <a href="https://whiteppure.github.io/iblog/">首页</a>
            </li><li class="">
                <a href="https://whiteppure.github.io/iblog/posts/">归档</a>
            </li><li class="">
                <a href="https://whiteppure.github.io/iblog/tags/">标签</a>
            </li><li class="">
                <a href="https://whiteppure.github.io/iblog/about/">关于</a>
            </li>
        </ul>
    </div>
    <div class="menu_icon">
        <a id="menu_icon"><i class="ri-menu-line"></i></a>
    </div>
</div>
        <div id="post_header" class="header animated fadeInDown">
    <div class="site_title_container">
        <div class="site_title">
            <h1>
                <a href="https://whiteppure.github.io/iblog/">
                    <span>唯手熟尔</span>
                </a>
            </h1>
        </div>
        <div class="description">
            <p class="sub_title">
                无他,唯手熟尔
            </p>

            
            <div class="my_socials">
                
                    
                    <a href="https://github.com/whiteppure/" title="github" target="_blank">
                        <i class="ri-github-fill"></i>
                    </a>
                    
                
                <a href="https://whiteppure.github.io/iblog/index.xml" type="application/rss+xml" title="rss" target="_blank">
                    <i class="ri-rss-fill"></i>
                </a>
                
                
                <span id="sys_function" class="sys_function display_none">
                    <a id="export_pdf"  title="导出pdf" style="border: none; background-color: #ffffff; cursor: pointer; margin-left: 10px">
                        <svg t="1688701481347" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3517" width="16" height="16"><path d="M425.610455 85.814544H149.05897A42.303635 42.303635 0 0 0 106.6274 128.075535V896.492068c0 23.326702 18.976933 42.26099 42.43157 42.26099h682.743143a42.559504 42.559504 0 0 0 42.431569-42.559504v-384.016365a42.644793 42.644793 0 0 1 85.289587 0v384.016365A127.849091 127.849091 0 0 1 831.802113 1024H149.05897A127.635867 127.635867 0 0 1 21.337813 896.449423V128.03289A127.593222 127.593222 0 0 1 149.101614 0.524957h276.466196a42.644793 42.644793 0 0 1 0 85.289587z m564.062683 158.08425l-170.579174 170.579173a42.644793 42.644793 0 1 1-60.299738-60.299738L856.578738 256.393718H618.364922a42.644793 42.644793 0 1 1 0-85.289587h238.213816l-97.784512-97.784511A42.644793 42.644793 0 1 1 819.093964 13.019882l170.579174 170.579174a42.644793 42.644793 0 0 1 0 60.299738zM149.272194 597.552066a42.644793 42.644793 0 0 1 42.644793-42.644794h51.514911c59.190973 0 107.891327 23.284057 107.976617 97.102195 0 71.003581-49.46796 102.347504-106.185536 102.347504h-31.343923v66.781747a32.282109 32.282109 0 0 1-64.606862 0V597.552066z m92.709781 100.215264c31.429213 0 46.568114-16.46089 46.568114-45.757863 0-30.064579-17.313786-40.512554-48.359196-40.512554h-26.311837v86.270417h28.145563z m232.414124-142.860058c81.878003 0 136.036891 43.710913 136.036891 147.67892S556.231457 853.420826 477.935617 853.420826h-38.16709a42.644793 42.644793 0 0 1-42.644794-42.644793v-213.223967a42.644793 42.644793 0 0 1 42.644794-42.644794h34.542282z m-4.008611 240.729859c43.32711 0 73.988717-22.047358 73.988717-93.050939 0-71.046226-30.704251-90.705476-73.988717-90.705476h-8.699538v183.79906h8.699538zM692.481573 853.420826a32.282109 32.282109 0 0 1-32.282109-32.282108V597.552066a42.644793 42.644793 0 0 1 42.644793-42.644794h99.063855a29.680776 29.680776 0 1 1 0 59.404197h-77.144431v65.374469h61.749661a29.894 29.894 0 1 1 0 59.788h-61.749661v81.66478a32.282109 32.282109 0 0 1-32.282108 32.282108z" fill="#5f5f5f" p-id="3518"></path></svg>
                    </a>
                    <a id="export_pic" title="导出图片" style="border: none; background-color: #ffffff; cursor: pointer; margin-left: 10px">
                        <svg t="1689071509720" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4564" width="16" height="16"><path d="M909.132886 0.037506h-184.960611a33.909445 33.909445 0 0 0-32.368107 33.909445 33.909445 33.909445 0 0 0 33.909445 33.395666h158.244078l-200.373995 199.346437a33.395666 33.395666 0 0 0 0 47.781491 31.854327 31.854327 0 0 0 23.633856 9.76181 33.909445 33.909445 0 0 0 24.147635-9.76181l198.832657-199.346437V272.340628a33.909445 33.909445 0 0 0 69.874009 0V88.921355A88.37007 88.37007 0 0 0 909.132886 0.037506zM216.558153 347.866211a107.37991 107.37991 0 1 0 107.37991-107.379911 107.89369 107.89369 0 0 0-107.37991 107.379911z m154.133843 0a51.377948 51.377948 0 0 1-97.618101 0 51.377948 51.377948 0 1 1 97.618101 0z" p-id="4565" fill="#424242"></path><path d="M963.079731 437.777619a34.423225 34.423225 0 0 0-33.909446 33.909445v265.110209a1811.07265 1811.07265 0 0 0-137.692899-193.181082 106.352351 106.352351 0 0 0-78.60826-36.478343 123.820854 123.820854 0 0 0-82.204716 35.964563l-3.596456 3.082677-188.557068 176.74014c-11.816928-13.358266-47.781491-51.377948-82.204716-87.856291a83.232275 83.232275 0 0 0-85.801172-21.578738 105.324792 105.324792 0 0 0-38.019681 19.52362l-141.289356 121.765736V89.948914a22.092517 22.092517 0 0 1 22.606297-22.606297h417.702713a33.395666 33.395666 0 0 0 33.395666-33.909445 33.395666 33.395666 0 0 0-33.395666-33.395666H113.802258A89.911408 89.911408 0 0 0 23.89085 89.948914v844.139678a89.911408 89.911408 0 0 0 89.911408 89.911408h793.27551a89.911408 89.911408 0 0 0 89.397629-89.911408v-462.401528a33.909445 33.909445 0 0 0-33.395666-33.909445z m-33.909446 496.310973a22.606297 22.606297 0 0 1-22.092517 22.606297H113.802258a22.606297 22.606297 0 0 1-22.606297-22.606297v-88.37007l183.933052-160.812976a43.157476 43.157476 0 0 1 15.413385-7.192912 15.927164 15.927164 0 0 1 17.982281 5.137794c37.505902 36.478343 78.60826 83.232275 82.718496 87.856291a61.653537 61.653537 0 0 0 42.643696 22.092517 62.681096 62.681096 0 0 0 51.377948-20.037399c8.220472-8.220472 134.610223-125.875971 194.208641-181.877935a57.029522 57.029522 0 0 1 34.423225-16.440943 45.212594 45.212594 0 0 1 29.79921 15.927164 2954.231982 2954.231982 0 0 1 186.501949 256.889738z" p-id="4566" fill="#424242"></path></svg>
                    </a>
                    <a id="export_markdown" title="导出markdown" style="border: none; background-color: #ffffff; cursor: pointer; margin-left: 10px">
                        <svg t="1689071035200" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="13570" width="16" height="16"><path d="M178.073367 843.957262V461.158929h107.121045l107.121045 140.734874 107.125433-140.734874h107.116657v382.798333h-107.116657v-219.54307l-107.125433 140.730486-107.116657-140.730486v219.54307zM737.783131 892.148786l-131.221196-209.156132h87.479334V461.158929h87.479335v221.833725h87.483722z" p-id="13571" fill="#424242"></path><path d="M911.9958 217.142709c10.672172 10.663395 19.812851 25.144549 27.430816 43.430297 7.617965 18.285748 11.431335 35.044392 11.431336 50.28471V969.140255c0 15.235929-5.336086 28.18998-15.999481 38.853375-10.667783 10.667783-23.621834 16.003869-38.857763 16.003869H127.994904c-15.240317 0-28.18998-5.336086-38.857763-16.003869-10.663395-10.663395-15.999481-23.617446-15.999481-38.853375V54.852856c0-15.240317 5.331698-28.18998 15.999481-38.857763C99.804925 5.336086 112.758975 0 127.999292 0h512.000944c15.235929 0 31.998962 3.808982 50.28471 11.426947 18.285748 7.622353 32.762514 16.763033 43.430297 27.426428zM658.290372 77.715526v214.856442h214.856442c-3.808982-11.049559-7.99974-18.856218-12.572275-23.43314l-178.855415-178.851027c-4.572534-4.572534-12.383581-8.763292-23.43314-12.572275z m219.428976 873.143369V365.71496h-237.714724c-15.240317 0-28.18998-5.336086-38.857763-15.999481-10.663395-10.667783-15.999481-23.621834-15.999481-38.857763V73.142992H146.28504v877.715903z" p-id="13572" fill="#424242"></path></svg>
                    </a>
                </span>
                <a  id="icon_more" title="更多" >
                    <svg t="1688715321313" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5356" width="16" height="16"><path d="M483.555556 199.111111m-85.333334 0a85.333333 85.333333 0 1 0 170.666667 0 85.333333 85.333333 0 1 0-170.666667 0Z" fill="#424242" p-id="5357"></path><path d="M483.555556 540.444444m-85.333334 0a85.333333 85.333333 0 1 0 170.666667 0 85.333333 85.333333 0 1 0-170.666667 0Z" fill="#424242" p-id="5358"></path><path d="M483.555556 881.777778m-85.333334 0a85.333333 85.333333 0 1 0 170.666667 0 85.333333 85.333333 0 1 0-170.666667 0Z" fill="#424242" p-id="5359"></path></svg>
                </a>
                <a  id="icon_less" class="display_none">
                    <svg t="1688723160472" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="15872" width="16" height="16"><path d="M300.105143 592.676571h423.789714a80.676571 80.676571 0 1 0 0-161.353142H300.105143a80.676571 80.676571 0 0 0 0 161.353142z" fill="#8a8a8a" p-id="15873"></path></svg>
                </a>
                
            </div>

            
            <div class="post">
                <div class="post_title post_detail_title">
                    <span class="date" id="busuanzi_container_site_pv">访问量 <span id="busuanzi_value_site_pv"></span>次</span>
                </div>
                <div class="post_title post_detail_title">
                    <span class="date" id="busuanzi_container_site_uv">访客数 <span id="busuanzi_value_site_uv"></span>人</span>
                </div>
            </div>
            
        </div>
    </div>
</div>
        <div class="content">
            <div class="post_page">
                <div class="post animate__animated animate__fadeInDown">
                    <div class="post_title post_detail_title">
                        <h2 id="post_single_title">Java集合</h2>
                        <span id="post_page_title_date" class="date">2021.10.04</span>
                    </div>
                    <div class="post_content markdown"><h2 id="概述">概述</h2>
<p>Java中的集合主要包括 <code>Collection</code> 和 <code>Map</code> 两种，<code>Collection</code> 存储着对象的集合，而 <code>Map</code> 存储着键值对（两个对象）的映射表。</p>
<p><img src="/iblog/posts/annex/images/essays/Java%E4%B8%AD%E7%9A%84%E9%9B%86%E5%90%88-01.jpg" alt="Java中的集合-01"></p>
<p>如果你看过ArrayList类源码，就知道ArrayList底层是通过数组来存储元素的，所以如果严格来说，数组也算集合的一种。</p>
<h2 id="数组">数组</h2>
<p>Java中提供的数组是用来存储固定大小的同类型元素，所以Java数组就是同类数据元素的集合。</p>
<p>数组是引用数据类型，如果使用了没有开辟空间的数组，则一定会出现<code>NullPointerException</code>异常信息。所以数组本质上也是Java对象，能够向下或者向上转型,能使用<code>instanceof</code>关键字。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">// 数组的父类也是Object,可以将a向上转型到Object  
</span></span><span class="line"><span class="cl">int[] a = new int[8];  
</span></span><span class="line"><span class="cl">Object obj = a ; 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">// 可以进行向下转型 
</span></span><span class="line"><span class="cl">int[] b = (int[])obj;  
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">// 可以用instanceof关键字进行类型判定 
</span></span><span class="line"><span class="cl">if(obj instanceof int[]){ 
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><blockquote>
<p><code>void  method_name(int ... value)</code>方法中变参就是当数组处理的，参数为定参的编译后就是数组。一个方法只能有一个变参，即使是不同的类型也不行，变参参数只能在形参列表的末尾，如果传入的是数组，则只能传一个。</p>
</blockquote>
<h3 id="优缺点">优缺点</h3>
<p>数组优点:</p>
<ul>
<li>数组元素的内存地址是连续分配的，所以通过下标访问元素的效率很高，可以快速找到指定下标为n的元素的地址；</li>
</ul>
<p>数组缺点:</p>
<ul>
<li>数组一旦初始化之后长度是固定的不能变的；</li>
<li>数组进行元素的删除和插入操作的时候，效率比较低,需要移动大量的元素；</li>
<li>数组元素的类型只能是一种；</li>
<li>数组元素的内存地址是连续分配的,对内存要求高一些;相对于链表结构比较,链表的内存是连续不连续都可以；</li>
</ul>
<p>数组的优点是效率高，但为此，所付出的代价就是数组对象的大小被固定。这也使得在工作中，数组并不实用。所以我们应该优选容器，而不是数组。只有在已证明性能成为问题的时候，并且确定切换到数组对性能提高有帮助时，才应该将项目重构为使用数组。</p>
<h3 id="操作数组">操作数组</h3>
<p>由于数组没有提供任何的封装，所有对元素的操作，都是通过自定义的方法实现的，对数组元素的操作比较麻烦，好在Java自带了一些API供开发者调用。</p>
<h4 id="定义数组">定义数组</h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl"> int[] array1 = { 1,2,3,4,5 }; 
</span></span><span class="line"><span class="cl"> int[] array2 = new int[10];
</span></span><span class="line"><span class="cl"> int[] array3 = new int[]{ 1,2,3,4,5 };
</span></span></code></pre></div><p>需要注意的是[],写在数组名称的前后都可以,但是推荐第一种写法：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">  int[] array1 = { 1,2,3,4,5 };
</span></span><span class="line"><span class="cl">  int array2[] = { 1,2,3,4,5 };
</span></span></code></pre></div><h4 id="遍历数组">遍历数组</h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl"> for (int i = 0; i &lt; array1.length; i++) {
</span></span><span class="line"><span class="cl">       System.out.println(array1[i]);
</span></span><span class="line"><span class="cl"> }
</span></span></code></pre></div><h4 id="数组去重">数组去重</h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">// 最简单方法，利用 hashSet 集合去重
</span></span><span class="line"><span class="cl">Set&lt;Integer&gt; set2 = new HashSet&lt;Integer&gt;();
</span></span><span class="line"><span class="cl">for (int i = 0; i &lt; arr11.length; i++) {
</span></span><span class="line"><span class="cl">    set2.add(arr11[i]);
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><h4 id="数组与集合转换">数组与集合转换</h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">// 数组转成set集合
</span></span><span class="line"><span class="cl">Set&lt;String&gt; set = new HashSet&lt;String&gt;(Arrays.asList(array2));
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">// 数组转list 
</span></span><span class="line"><span class="cl">List&lt;String &gt; list2 = Arrays.asList(array);
</span></span></code></pre></div><h4 id="数组排序">数组排序</h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl"> // 原生方法 或 8种排序算法
</span></span><span class="line"><span class="cl"> Arrays.sort(arr);
</span></span></code></pre></div><h4 id="复制数组">复制数组</h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">// 待复制的数组
</span></span><span class="line"><span class="cl">int[] arr = {1, 2, 3, 4};
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">// 指定新数组的长度
</span></span><span class="line"><span class="cl">int[] arr2 = Arrays.copyOf(arr, 10);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">// 只复制从索引[1]到索引[3]之间的元素（不包括索引[3]的元素）
</span></span><span class="line"><span class="cl">int[] arr3 = Arrays.copyOfRange(arr, 1, 3);
</span></span></code></pre></div><h2 id="arraylist">ArrayList</h2>
<p>在List接口实现类中，最常用的就是ArrayList,ArrayList 类是一个可以动态修改的数组，与普通数组的区别就是它是没有固定大小的限制，可以添加或删除元素。</p>
<p>ArrayList 继承了 AbstractList ，并实现了 List、RandomAccess, Cloneable 接口：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess,Cloneable,Serializable
</span></span></code></pre></div><h3 id="randomaccess">RandomAccess</h3>
<p>Random是随机的意思，Access是访问的意思，合起来就是随机访问的意思。</p>
<p>RandomAccess接口是一个标记接口，用来标记实现的List集合具备快速随机访问的能力。所有的List实现都支持随机访问的，只是基于基本结构的不同，实现的速度不同罢了。</p>
<p>当一个List拥有快速访问功能时，其遍历方法采用随机访问速度最快，而没有快速随机访问的List采用顺序访问的速度最快。如果集合中的数据量过大需要遍历时，此时需要格外注意，因为不同的遍历方式会影响很大，可以使用<code>instanceof</code>关键字来判断该类有没有RandomAccess标记:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">// 假设 list 数据量非常大,推荐写法
</span></span><span class="line"><span class="cl">List&lt;Object&gt; list = ...;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">if(list instanceof RandomAccess){
</span></span><span class="line"><span class="cl">    // 随机访问
</span></span><span class="line"><span class="cl">    for (int i = 0;i&lt; list.size();i++) {
</span></span><span class="line"><span class="cl">        System.out.println(list.get(i));
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}else {
</span></span><span class="line"><span class="cl">    // 顺序访问
</span></span><span class="line"><span class="cl">    for(Object obj: list) {
</span></span><span class="line"><span class="cl">        System.out.println(obj);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><p>在List中ArrayList被RandomAccess接口标记，而LinkedList没有被RandomAccess接口标记，所以ArrayList适合随机访问，LinkedList适合顺序访问。</p>
<h3 id="cloneable">Cloneable</h3>
<p>Cloneable接口是Java开发中常用的一个接口之一,它是一个标记接口。</p>
<p>如果一个想要拷贝一个对象，就需要重写Object中的clone方法并让其实现Cloneable接口，如果只重写clone方法，不实现Cloneable接口就会报CloneNotSupportedException异常。</p>
<p>JDK中clone方法源码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">protected native Object clone() throws CloneNotSupportedException;
</span></span></code></pre></div><p>应当注意的是，<code>clone()</code> 方法并不是 <code>Cloneable</code> 接口的方法，而是 <code>Object</code> 的一个 <code>protected</code> 方法。<code>Cloneable</code> 接口只是规定，如果一个类没有实现 <code>Cloneable</code> 接口又调用了 <code>clone()</code> 方法，就会抛出 <code>CloneNotSupportedException</code>。</p>
<p>换言之，clone方法规定了想要拷贝对象，就需要实现Cloneable方法，clone方法让Cloneable接口变得有意义。</p>
<h4 id="浅拷贝与深拷贝">浅拷贝与深拷贝</h4>
<ul>
<li>浅拷贝：被复制对象的所有值属性都含有与原来对象的相同，而所有的对象引用属性仍然指向原来的对象。</li>
<li>深拷贝：在浅拷贝的基础上，所有引用其他对象的变量也进行了<code>clone</code>，并指向被复制过的新对象。</li>
</ul>
<p>如果一个被复制的属性都是基本类型，那么只需要实现当前类的<code>cloneable</code>机制就可以了，此为浅拷贝。</p>
<p>如果被复制对象的属性包含其他实体类对象引用，那么这些实体类对象都需要实现<code>cloneable</code>接口并覆盖<code>clone()</code>方法。</p>
<p><strong>浅拷贝：</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public class ShallowCloneExample implements Cloneable {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    private int[] arr;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public ShallowCloneExample() {
</span></span><span class="line"><span class="cl">        arr = new int[10];
</span></span><span class="line"><span class="cl">        for (int i = 0; i &lt; arr.length; i++) {
</span></span><span class="line"><span class="cl">            arr[i] = i;
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public void set(int index, int value) {
</span></span><span class="line"><span class="cl">        arr[index] = value;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public int get(int index) {
</span></span><span class="line"><span class="cl">        return arr[index];
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    protected ShallowCloneExample clone() throws CloneNotSupportedException {
</span></span><span class="line"><span class="cl">        return (ShallowCloneExample) super.clone();
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">ShallowCloneExample e1 = new ShallowCloneExample();
</span></span><span class="line"><span class="cl">ShallowCloneExample e2 = null;
</span></span><span class="line"><span class="cl">try {
</span></span><span class="line"><span class="cl">    e2 = e1.clone();
</span></span><span class="line"><span class="cl">} catch (CloneNotSupportedException e) {
</span></span><span class="line"><span class="cl">    e.printStackTrace();
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">e1.set(2, 222);
</span></span><span class="line"><span class="cl">System.out.println(e2.get(2)); // 222
</span></span></code></pre></div><p><strong>深拷贝：</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public class DeepCloneExample implements Cloneable {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    private int[] arr;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public DeepCloneExample() {
</span></span><span class="line"><span class="cl">        arr = new int[10];
</span></span><span class="line"><span class="cl">        for (int i = 0; i &lt; arr.length; i++) {
</span></span><span class="line"><span class="cl">            arr[i] = i;
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public void set(int index, int value) {
</span></span><span class="line"><span class="cl">        arr[index] = value;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public int get(int index) {
</span></span><span class="line"><span class="cl">        return arr[index];
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    protected DeepCloneExample clone() throws CloneNotSupportedException {
</span></span><span class="line"><span class="cl">        DeepCloneExample result = (DeepCloneExample) super.clone();
</span></span><span class="line"><span class="cl">        result.arr = new int[arr.length];
</span></span><span class="line"><span class="cl">        for (int i = 0; i &lt; arr.length; i++) {
</span></span><span class="line"><span class="cl">            result.arr[i] = arr[i];
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        return result;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">DeepCloneExample e1 = new DeepCloneExample();
</span></span><span class="line"><span class="cl">DeepCloneExample e2 = null;
</span></span><span class="line"><span class="cl">try {
</span></span><span class="line"><span class="cl">    e2 = e1.clone();
</span></span><span class="line"><span class="cl">} catch (CloneNotSupportedException e) {
</span></span><span class="line"><span class="cl">    e.printStackTrace();
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">e1.set(2, 222);
</span></span><span class="line"><span class="cl">System.out.println(e2.get(2)); // 2
</span></span></code></pre></div><h4 id="arraylist中clone方法">ArrayList中clone方法</h4>
<p>clone方法调用栈：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">clone 
</span></span><span class="line"><span class="cl">    -&gt; Object.clone
</span></span><span class="line"><span class="cl">    -&gt; Arrays.copyOf(T[] original, int newLength)
</span></span><span class="line"><span class="cl">    -&gt; Arrays.copyOf(U[] original, int newLength, Class&lt;? extends T[]&gt; newType)
</span></span></code></pre></div><p>文档注释大意：返回这个ArrayList实例的浅拷贝(元素本身不会被复制)。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public class ArrayList implements Cloneable {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    transient Object[] elementData;     
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    /**
</span></span><span class="line"><span class="cl">     * Returns a shallow copy of this &lt;tt&gt;ArrayList&lt;/tt&gt; instance.  (The
</span></span><span class="line"><span class="cl">     * elements themselves are not copied.)
</span></span><span class="line"><span class="cl">     *
</span></span><span class="line"><span class="cl">     * @return a clone of this &lt;tt&gt;ArrayList&lt;/tt&gt; instance
</span></span><span class="line"><span class="cl">     */
</span></span><span class="line"><span class="cl">    public Object clone() {
</span></span><span class="line"><span class="cl">        try {
</span></span><span class="line"><span class="cl">            // 调用Object类的clone方法
</span></span><span class="line"><span class="cl">            ArrayList&lt;?&gt; v = (ArrayList&lt;?&gt;) super.clone();
</span></span><span class="line"><span class="cl">            
</span></span><span class="line"><span class="cl">            // 将集合中的元素进行拷贝
</span></span><span class="line"><span class="cl">            v.elementData = Arrays.copyOf(elementData, size);
</span></span><span class="line"><span class="cl">            v.modCount = 0;
</span></span><span class="line"><span class="cl">            return v;
</span></span><span class="line"><span class="cl">        } catch (CloneNotSupportedException e) {
</span></span><span class="line"><span class="cl">            // this shouldn&#39;t happen, since we are Cloneable
</span></span><span class="line"><span class="cl">            throw new InternalError(e);
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public class Arrays{
</span></span><span class="line"><span class="cl">   public static &lt;T&gt; T[] copyOf(T[] original, int newLength) {
</span></span><span class="line"><span class="cl">        return (T[]) copyOf(original, newLength, original.getClass());
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    public static &lt;T,U&gt; T[] copyOf(U[] original, int newLength, Class&lt;? extends T[]&gt; newType) {
</span></span><span class="line"><span class="cl">        @SuppressWarnings(&#34;unchecked&#34;)
</span></span><span class="line"><span class="cl">        T[] copy = ((Object)newType == (Object)Object[].class)
</span></span><span class="line"><span class="cl">            ? (T[]) new Object[newLength]
</span></span><span class="line"><span class="cl">            : (T[]) Array.newInstance(newType.getComponentType(), newLength);
</span></span><span class="line"><span class="cl">        System.arraycopy(original, 0, copy, 0, Math.min(original.length, newLength));
</span></span><span class="line"><span class="cl">        return copy;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><p>ArrayList中clone方法底层是调用父类的clone方法，父类没有重写clone方法所以调用的是Object类的clone方法。</p>
<p>在ArrayList中核心方法最终调用<code>Arrays.copyOf</code>方法,不论怎样都会创建一个Object数组。</p>
<blockquote>
<p><code>Arrays.newInstance(Class&lt;?&gt; componentType,int length)</code>方法作用，创建具有指定组件类型和长度的新数组。</p>
</blockquote>
<p>最终使用<code>System.arraycopy</code>方法将之前的旧数组中的元素拷贝到新创建的数组中，然后赋值给<code>ArrayList.elementData</code>对象并返回。</p>
<h3 id="arraylist扩容">ArrayList扩容</h3>
<p>因为ArrayList底层使用数组保存数据的，而数组一旦被创建就不能改变大小，但是ArrayList的长度是可以改变的，所以可以通过ArrayList类中的add方法找到数组扩容方法。</p>
<p>add方法调用栈：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">add 
</span></span><span class="line"><span class="cl">    -&gt; ensureCapacityInternal()
</span></span><span class="line"><span class="cl">    -&gt; calculateCapacity()
</span></span><span class="line"><span class="cl">    -&gt; ensureExplicitCapacity()
</span></span><span class="line"><span class="cl">    -&gt; grow()
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">    private void grow(int minCapacity) {
</span></span><span class="line"><span class="cl">        // overflow-conscious code
</span></span><span class="line"><span class="cl">        int oldCapacity = elementData.length;
</span></span><span class="line"><span class="cl">        int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);
</span></span><span class="line"><span class="cl">        if (newCapacity - minCapacity &lt; 0)
</span></span><span class="line"><span class="cl">            newCapacity = minCapacity;
</span></span><span class="line"><span class="cl">        if (newCapacity - MAX_ARRAY_SIZE &gt; 0)
</span></span><span class="line"><span class="cl">            newCapacity = hugeCapacity(minCapacity);
</span></span><span class="line"><span class="cl">        // minCapacity is usually close to size, so this is a win:
</span></span><span class="line"><span class="cl">        elementData = Arrays.copyOf(elementData, newCapacity);
</span></span><span class="line"><span class="cl">    }
</span></span></code></pre></div><p>ArrayList容量：如果没有指定容量创建数组，默认会创建一个长度为10的数组用来保存元素，之后通过：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl"> int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);
</span></span></code></pre></div><p>每次扩容都是原容量的1.5倍。</p>
<blockquote>
<p><code>&gt;&gt;</code>,右移几位就是相当于除以2的几次幂
<code>&lt;&lt;</code>,左移几位就是相当于乘以2的几次幂</p>
</blockquote>
<p>最后通过Arrays.copyOf方法将之前的数组中元素，全部移到新创建的数组上。</p>
<p>由于频繁的扩容数组会对性能产生影响，如果在ArrayList中要存储很大的数据，就需要在ArrayList的有参构造中指定数组的长度：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">List&lt;String&gt; list = new ArrayList(1000000);
</span></span></code></pre></div><p>需要注意的是创建指定长度的ArrayList，在没有add之前ArrayList中的数组已经初始化了，但是List的大小没变，因为List的大小是由size决定的。</p>
<h3 id="arraylist与linkedlist">ArrayList与LinkedList</h3>
<p>ArrayList与LinkedList性能比较是一道经典的面试题，ArrayList查找快，增删慢；而LinkedList增删快，查找慢。</p>
<p>造成这种原因是因为底层的数据结构不一样，ArrayList底层是数组，而数组的中的元素内存分配都是连续的，并且数组中的元素只能存放一种，这就造成了数组中的元素地址是有规律的，数组中查找元素快速的原因正是利用了这一特点。</p>
<blockquote>
<p>查询方式为: 首地址＋（元素长度＊下标）
例如：new int arr[5]; arr数组的地址假设为0x1000，arr[0] ~ arr[5] 地址可看作为 0x1000 + i * 4。</p>
</blockquote>
<p>而LinkedList在Java中的底层结构是对象，每一个对象结点中都保存了下一个结点的位置形成的链表结构，由于LinkedList元素的地址是不连续的，所以没办法按照数组那样去查找，所以就比较慢。</p>
<p>由于数组一旦分配了大小就不能改变，所以ArrayList在进行添加操作时会创建新的数组，如果要添加到ArrayList中的指定的位置，是通过System.arraycopy方法将数组进行复制，新的数组会将待插入的指定位置空余出来，最后在将元素添加到集合中。</p>
<p>在进行删除操作时是通过System.arraycopy方法，将待删除元素后面剩余元素复制到待删除元素的位置。当ArrayList里有大量数据时，这时候去频繁插入或删除元素会触发底层数组频繁拷贝，效率不高，还会造成内存空间的浪费。</p>
<p>LinkedList在进行添加，删除操作时，会用二分查找法找到将要添加或删除的元素，之后再设置对象的下一个结点来进行添加或删除操作。</p>
<blockquote>
<p>二分查找法：也称为折半查找法，是一种适用于大量数据查找的方法，但是要求数据必须的排好序的，每次以中间的值进行比较，根据比较的结果可以直接舍去一半的值，直至全部找完（可能会找不到）或者找到数据为止。</p>
<p>此处LinkedList会比较查找的元素是距离头结点比较近，还是尾结点比较近，距离哪边较近则从哪边开始查找。</p>
</blockquote>
<p>ArrayList，获取元素效率非常的高，时间复杂度是O(1)，而查找，插入和删除元素效率似乎不太高，时间复杂度为O(n)。</p>
<p>LinkedList，正与ArrayList相反，获取第几个元素依次遍历复杂度O(n)，添加到末尾复杂度O(1)，<strong>添加到指定位置复杂度O(n)</strong>，删除元素，直接指针指向操作复杂度O(1)。</p>
<p><strong>注意，ArrayList的增删不一定比LinkedList效率低，但是ArrayList查找效率一定比LinkedList高，如果在List靠近末尾的地方插入，那么ArrayList只需要移动较少的数据，而LinkedList则需要一直查找到列表尾部，反而耗费较多时间，这时ArrayList就比LinkedList要快。</strong></p>
<p>使用场景：</p>
<ul>
<li>如果应用程序对数据有较多的随机访问，ArrayList要优于LinkedList；</li>
<li>如果应用程序有更多的插入或者删除操作，较少的随机访问，LinkedList要优于ArrayList；</li>
</ul>
<h3 id="线程安全问题">线程安全问题</h3>
<p>众所周知，ArrayList是线程不安全的：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public class MainTest {
</span></span><span class="line"><span class="cl">    // 如果没有报错，需要多试几次
</span></span><span class="line"><span class="cl">    public static void main(String[] args) {
</span></span><span class="line"><span class="cl">        ArrayList&lt;String&gt; arrayList = new ArrayList&lt;&gt;();
</span></span><span class="line"><span class="cl">        for(int i=0; i&lt; 10; i++) {
</span></span><span class="line"><span class="cl">            new Thread(() -&gt; {
</span></span><span class="line"><span class="cl">                arrayList.add(UUID.randomUUID().toString());
</span></span><span class="line"><span class="cl">                System.out.println(arrayList);
</span></span><span class="line"><span class="cl">            },String.valueOf(i)).start();
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><p>为避免偶然事件，请重复多试几次上面的代码,很大情况会出现<code>ConcurrentModificationException</code>&ldquo;同步修改异常&rdquo;：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">java.util.ConcurrentModificationException
</span></span></code></pre></div><p>出现该异常的原因是，当某个线程正在执行 <code>add()</code>方法时,被某个线程打断,添加到一半被打断,没有被添加完。</p>
<p>保证ArrayList线程安全有以下几种方法：</p>
<ul>
<li>可以使用 <code>Vector</code> 来代替 <code>ArrayList</code>,<code>Vector</code> 是线程安全的 <code>ArrayList</code>,但是由于底层是加了<code>synchronized</code>,性能略差不推荐使用;
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">List list = new Vector();
</span></span><span class="line"><span class="cl">list.add(UUID.randomUUID().toString());
</span></span></code></pre></div></li>
<li>使用<code>Collections.synchronizedArrayList()</code> 来创建 <code>ArrayList</code>；使用 <code>Collections</code> 工具类来创建 <code>ArrayList</code> 的思路是,在 <code>ArrayList</code> 的外边套了一个<code>synchronized</code>外壳,来使 <code>ArrayList</code> 线程安全;
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">List list = Collections.synchronizedArrayList();
</span></span><span class="line"><span class="cl">list.add(UUID.randomUUID().toString());
</span></span></code></pre></div></li>
<li>使用<code>CopyOnWriteArrayList()</code>来保证 <code>ArrayList</code> 线程安全；<code>CopyWriteArrayList</code>字面意思就是在写的时候复制,主要思想就是读写分离的思想。<code>CopyWriteArrayList</code>之所以线程安全的原因是在源码里面使用<code>ReentrantLock</code>，所以保证了某个线程在写的时候不会被打断；
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">CopyOnWriteArrayList&lt;String&gt; list = new CopyOnWriteArrayList&lt;&gt;();
</span></span><span class="line"><span class="cl">list.add(UUID.randomUUID().toString());
</span></span></code></pre></div></li>
</ul>
<h2 id="set">Set</h2>
<ul>
<li>TreeSet：基于红黑树实现，支持有序性操作，例如根据一个范围查找元素的操作。但是查找效率不如 HashSet，HashSet 查找的时间复杂度为 O(1)，TreeSet 则为 O(logN)；</li>
<li>HashSet：基于哈希表实现，支持快速查找，但不支持有序性操作。并且失去了元素的插入顺序信息，也就是说使用 Iterator 遍历 HashSet 得到的结果是不确定的。HashSet的value作为hashmap的key，来保证不重复；</li>
<li>LinkedHashSet：具有 HashSet 的查找效率，且内部使用双向链表维护元素的插入顺序；</li>
</ul>
<h2 id="queue">Queue</h2>
<p>队列是一种经常使用的集合。Queue实际上是实现了一个先进先出（FIFO：First In First Out）的有序列表。它和List的区别在于，List可以在任意位置添加和删除元素，而Queue只有两个操作：</p>
<ul>
<li>把元素添加到队列末尾；</li>
<li>从队列头部取出元素；</li>
</ul>
<p>常见实现：</p>
<ul>
<li>LinkedList：可以用它来实现双向队列；</li>
<li>PriorityQueue：基于堆结构实现，可以用它来实现优先队列；</li>
</ul>
<p>Queue实现通常不允许插入null元素，尽管一些实现，如LinkedList，不禁止插入null元素。即使在允许它的实现中，null也不应插入Queue中，因为poll方法也使用null作为特殊返回值，用来表示队列不包含任何元素。</p>
<blockquote>
<p>poll(): 检索并删除此队列的头部，如果此队列为空，则返回null
peek(): 检索但不删除此队列的头部，如果此队列为空，则返回null</p>
</blockquote>
<h2 id="hashmap">HashMap</h2>
<ul>
<li>HashMap 是一个散列表，它存储的内容是键值对(key-value)映射；</li>
<li>HashMap 实现了 Map 接口，根据键的 HashCode 值存储数据，具有很快的访问速度，最多允许一条记录的键为 null，不支持线程同步；</li>
<li>HashMap 是无序的，即不会记录插入的顺序；</li>
</ul>
<p>相关操作：</p>
<ul>
<li>存贮: 通过key的hashcode方法找到在hashMap 存贮的位置,如果该位置有元素,则通过equals方法进行比较,equals返回值为true,则覆盖value,equals返回值为false则,在该数组元素的头部追加该元素,形成一个链表结构；</li>
<li>读取:通过key的hashcode方法获取元素存在该数组的位置,然后通过equals拿到该值；</li>
<li>结构: hashMap是一个散列数据结构,HashMap底层就是一个数组结构，数组中的每一项又是一个链表；</li>
</ul>
<p>总的来说hashMap底层将key-value(键值对)当成一个整体来处理,hashMap底层采用一个 Entry 数组保存所有的键值对,当存储一个entry对象时,会根据key的hash算法来决定存放在数组中的位置,在根据equals方法来确定在链表中的位置,读取一个entry对象,先根据hash算法确定在数组中的位置,再根据equals来获取该值,equals和equals在hashMap中就像一个坐标一样,来确定hashMap中的值。</p>
<h3 id="相关概念">相关概念</h3>
<ul>
<li><code>capacity</code>： 容量，默认16；</li>
<li><code>loadFactor</code>： 负载因子，表示HashMap满的程度，默认值为0.75f，也就是说默认情况下，当HashMap中元素个数达到了容量的3/4的时候就会进行自动扩容；</li>
<li><code>threshold</code>： 阈值；<code>阈值 = 容量 * 负载因子</code>。默认12；</li>
<li>hash碰撞：即hash冲突，两个不同的输入值，根据同一散列函数计算出的散列值相同的现象叫做碰撞。hash碰撞就是用同一hash散列函数计算出相同的散列值；当插入hashmap中元素的key出现重复时，这个时候就发生了hash碰撞；</li>
</ul>
<h3 id="结构">结构</h3>
<p><img src="/iblog/posts/annex/images/essays/HashMap%E7%BB%93%E6%9E%84.png" alt="HashMap结构"></p>
<ul>
<li>JDK1.7：数组 + 单向链表；</li>
<li>JDK1.8: 数组 + 单向链表/红黑树；</li>
</ul>
<p>在JDK1.8时，如果存储Map中数组元素对应的索引的每个链表超过8，就将单向链表转化为红黑树；当红黑树的节点少于6个的时候又开始使用链表。</p>
<h4 id="为什么要使用红黑树">为什么要使用红黑树</h4>
<p>当有发生大量的hash冲突时，因为链表遍历效率很慢，为了提升查询的效率，所以使用了红黑树的数据结构。</p>
<h4 id="为什么不一开始就用红黑树代替链表结构">为什么不一开始就用红黑树代替链表结构</h4>
<p>JDK文档注释：</p>
<blockquote>
<p>Because TreeNodes are about twice the size of regular nodes, we use them only when bins contain enough nodes to warrant use  (see TREEIFY_THRESHOLD). 
And when they become too small (due to removal or resizing) they are converted back to plain bins.</p>
</blockquote>
<p>单个 TreeNode 需要占用的空间大约是普通 Node 的两倍，所以只有当包含足够多的 Nodes 时才会转成 TreeNodes，而是否足够多就是由 TREEIFY_THRESHOLD 的值（默认值8）决定的。而当桶中节点数由于移除或者 resize 变少后，又会变回普通的链表的形式，以便节省空间，这个阈值是 UNTREEIFY_THRESHOLD（默认值6）。</p>
<h4 id="为什么树化阈值为8">为什么树化阈值为8</h4>
<p>JDK1.8HashMap文档注释：</p>
<blockquote>
<p>如果 hashCode 分布良好，也就是 hash 计算的结果离散好的话，那么红黑树这种形式是很少会被用到的，因为各个值都均匀分布，很少出现链表很长的情况。
在理想情况下，链表长度符合泊松分布，各个长度的命中概率依次递减，当长度为 8 的时候，概率仅为 0.00000006。这是一个小于千万分之一的概率，通常我们的 Map 里面是不会存储这么多的数据的，所以通常情况下，并不会发生从链表向红黑树的转换。</p>
</blockquote>
<p>HashMap是通过hash算法，来判断对象应该放在哪个桶里面的；JDK 并不能阻止我们用户实现自己的哈希算法，如果我们故意把哈希算法变得不均匀，那么每次存放对象很容易造成hash冲突。</p>
<p>链表长度超过 8 就转为红黑树的设计，更多的是为了防止用户自己实现了不好的哈希算法时导致链表过长，从而导致查询效率低，而此时转为红黑树更多的是一种保底策略，用来保证极端情况下查询的效率。红黑树的引入保证了在大量hash冲突的情况下，HashMap还具有良好的查询性能。</p>
<h4 id="为什么树化阈值和链表阈值不设置成一样">为什么树化阈值和链表阈值不设置成一样</h4>
<p>为了防止出现节点个数频繁在一个相同的数值来回切换。</p>
<p>举个极端例子，现在单链表的节点个数是9，开始变成红黑树，然后红黑树节点个数又变成8，就又得变成单链表，然后节点个数又变成9，就又得变成红黑树，这样的情况消耗严重浪费。因此干脆错开两个阈值的大小，使得变成红黑树后“不那么容易”就需要变回单链表，同样，使得变成单链表后，“不那么容易”就需要变回红黑树。</p>
<h4 id="引入红黑树后如果单链表节点个数超过8个是否一定会树化">引入红黑树后，如果单链表节点个数超过8个是否一定会树化</h4>
<p>不一定，在进行树化之前会进行判断<code>(n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</code>是否需要扩容，如果表中数组元素小于这个阈值（默认是64），就会进行扩容。 因为扩容不仅能增加表中的容量，还能缩短单链表的节点数，从而更长远的解决链表遍历慢问题。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">    /**
</span></span><span class="line"><span class="cl">     * Replaces all linked nodes in bin at index for given hash unless
</span></span><span class="line"><span class="cl">     * table is too small, in which case resizes instead.
</span></span><span class="line"><span class="cl">     */
</span></span><span class="line"><span class="cl">    final void treeifyBin(Node&lt;K,V&gt;[] tab, int hash) {
</span></span><span class="line"><span class="cl">        int n, index; Node&lt;K,V&gt; e;
</span></span><span class="line"><span class="cl">        if (tab == null || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)
</span></span><span class="line"><span class="cl">            resize();
</span></span><span class="line"><span class="cl">        else if ((e = tab[index = (n - 1) &amp; hash]) != null) {
</span></span><span class="line"><span class="cl">            TreeNode&lt;K,V&gt; hd = null, tl = null;
</span></span><span class="line"><span class="cl">            do {
</span></span><span class="line"><span class="cl">                TreeNode&lt;K,V&gt; p = replacementTreeNode(e, null);
</span></span><span class="line"><span class="cl">                if (tl == null)
</span></span><span class="line"><span class="cl">                    hd = p;
</span></span><span class="line"><span class="cl">                else {
</span></span><span class="line"><span class="cl">                    p.prev = tl;
</span></span><span class="line"><span class="cl">                    tl.next = p;
</span></span><span class="line"><span class="cl">                }
</span></span><span class="line"><span class="cl">                tl = p;
</span></span><span class="line"><span class="cl">            } while ((e = e.next) != null);
</span></span><span class="line"><span class="cl">            if ((tab[index] = hd) != null)
</span></span><span class="line"><span class="cl">                hd.treeify(tab);
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    }
</span></span></code></pre></div><h3 id="容量">容量</h3>
<h4 id="为什么负载因子默认是075">为什么负载因子默认是0.75</h4>
<p>HashMap中的负载因子这个值现在在JDK的源码中默认是0.75：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">/**
</span></span><span class="line"><span class="cl"> * The load factor used when none specified in constructor.
</span></span><span class="line"><span class="cl"> */
</span></span><span class="line"><span class="cl">static final float DEFAULT_LOAD_FACTOR = 0.75f;
</span></span></code></pre></div><p>在<a href="https://docs.oracle.com/javase/6/docs/api/java/util/HashMap.html">JDK的官方文档</a>中解释如下：</p>
<blockquote>
<p>As a general rule, the default load factor (.75) offers a good tradeoff between time and space costs.
Higher values decrease the space overhead but increase the lookup cost (reflected in most of the operations of the HashMap class, including get and put). 
The expected number of entries in the map and its load factor should be taken into account when setting its initial capacity, so as to minimize the number of rehash operations. 
If the initial capacity is greater than the maximum number of entries divided by the load factor, no rehash operations will ever occur.</p>
</blockquote>
<p>大意：一般来说，默认的负载因子(0.75)在时间和空间成本之间提供了很好的权衡。更高的值减少了空间开销，但增加了查找成本(反映在HashMap类的大多数操作中，包括get和put)。在设置映射的初始容量时，应该考虑映射中预期的条目数及其负载因子，以便最小化重哈希操作的数量。如果初始容量大于最大条目数除以负载因子，则不会发生重新散列操作。</p>
<p>负载因子和hashmap中的扩容有关，当hashmap中的元素大于临界值（<code>threshold = loadFactor * capacity</code>）就会扩容。所以负载因子的大小决定了什么时机扩容，扩容又影响到了hash碰撞的频率。所以设置一个合理的负载因子可以有效的避免hash碰撞。</p>
<p>设置为0.75的其他解释：</p>
<ul>
<li>根据数学公式推算。这个值在<code>log(2)</code>的时候比较合理;</li>
<li>为了提升扩容效率，HashMap的容量有一个固定的要求，那就是一定是2的幂。如果负载因子是3/4的话，那么和容量的乘积结果就可以是一个整数；</li>
</ul>
<h4 id="如果指定容量大小为10那么实际大小是多少">如果指定容量大小为10，那么实际大小是多少</h4>
<p>实际大小是16。其容量为不小于指定容量的2的幂数。</p>
<p><strong>为什么容量始终是2的N次方？</strong></p>
<p>为了减少Hash碰撞，尽量使Hash算法的结果均匀分布。</p>
<p>当使用put方法时，到底存入HashMap中的那个数组中？这时是通过hash算法决定的，如果某一个数组中的链表过长旧会影响查询的效率；那么为了避免出现hash碰撞，让hash尽可能的散列分布，就需要在hash算法上做文章。</p>
<p>JDK1.7通过逻辑与运算，来判断这个元素该进入哪个数组；在下面的代码中length的长度始终为不小于指定容量的2的幂数。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">static int indexFor(int h, int length) {
</span></span><span class="line"><span class="cl">    return h &amp; (length - 1);
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><p>为了更好的理解举个例子：假设h=2或h=3，length=15，进行与运算，最终逻辑与运算后的结果是一致的，因为最终结果是一致的所以就发生了hash碰撞，这种问题多了以后会造成容器中的元素分布不均匀，都分配在同一个数组上，在查询的时候就减慢了查询的效率，另一方面也造成空间的浪费。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">-- 2转换为2进制与15-1进行&amp;运算
</span></span><span class="line"><span class="cl">  0000 0010
</span></span><span class="line"><span class="cl">&amp; 0000 1110 
</span></span><span class="line"><span class="cl">———————————— 
</span></span><span class="line"><span class="cl">  0000 1110
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">-- 3转换为2进制与15-1进行&amp;运算
</span></span><span class="line"><span class="cl">  0000 0011
</span></span><span class="line"><span class="cl">&amp; 0000 1110 
</span></span><span class="line"><span class="cl">————————————
</span></span><span class="line"><span class="cl">  0000 1110
</span></span></code></pre></div><p>为了避免上面<code>length=15</code>这类问题出现，所以集合的容量采用必须是2的N次幂这种方式，因为2的N次幂的结果减一转换为二进制后都是以<code>...1111</code>结尾的，所以在进行逻辑与运算时碰撞几率小。</p>
<p>在JDK1.8中，在<code>putVal()</code>方法中通过<code>i = (n - 1) &amp; hash</code>来计算key的散列地址：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
</span></span><span class="line"><span class="cl">                   boolean evict) {
</span></span><span class="line"><span class="cl">        // 此处省略了代码
</span></span><span class="line"><span class="cl">        // i = (n - 1) &amp; hash]
</span></span><span class="line"><span class="cl">        if ((p = tab[i = (n - 1) &amp; hash]) == null)
</span></span><span class="line"><span class="cl">            
</span></span><span class="line"><span class="cl">            tab[i] = newNode(hash, key, value, null);
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">        else {
</span></span><span class="line"><span class="cl">            // 省略了代码
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><blockquote>
<p>这里的 &ldquo;&amp;&rdquo; 等同于 %&quot;，但是&quot;%&ldquo;运算的速度并没有&rdquo;&amp;&ldquo;的操作速度快；&rdquo;&amp;&ldquo;操作能代替&rdquo;%&ldquo;运算，必须满足一定的条件，也就是<code>a%b=a&amp;(b-1)</code>仅当b是2的n次方的时候方能成立。</p>
</blockquote>
<p><strong>容器容量怎么保持始终为2的N次方？</strong></p>
<p><code>HashMap</code>的<code>tableSizeFor()</code>方法做了处理，能保证n永远都是2次幂。</p>
<p>如果用户制定了初始容量，那么HashMap会计算出比该数大的第一个2的幂作为初始容量；另外就是在扩容的时候，也是进行成倍的扩容，即4变成8，8变成16。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">/**
</span></span><span class="line"><span class="cl"> * Returns a power of two size for the given target capacity.
</span></span><span class="line"><span class="cl"> */
</span></span><span class="line"><span class="cl">static final int tableSizeFor(int cap) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // 假设n=17
</span></span><span class="line"><span class="cl">    // n = 00010001 - 00010000 = 00010000 = 16
</span></span><span class="line"><span class="cl">    int n = cap - 1;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // n = (00010000 | 00001000) = 00011000 = 24
</span></span><span class="line"><span class="cl">    n |= n &gt;&gt;&gt; 1;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // n = (00011000 | 00000110) = 00011110 = 30
</span></span><span class="line"><span class="cl">    n |= n &gt;&gt;&gt; 2;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // n = (00011110 | 00000001) = 00011111 = 31
</span></span><span class="line"><span class="cl">    n |= n &gt;&gt;&gt; 4;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // n = (00011111 | 00000000) = 00011111 = 31
</span></span><span class="line"><span class="cl">    n |= n &gt;&gt;&gt; 8;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // n = (00011111 | 00000000) = 00011111 = 31
</span></span><span class="line"><span class="cl">    n |= n &gt;&gt;&gt; 16;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // n = 00011111 = 31，MAXIMUM_CAPACITY：Integer的最大长度
</span></span><span class="line"><span class="cl">    // (31 &lt; 0) ? 1 : (31 &gt;= Integer的最大长度) ? Integer的最大长度 : 31 + 1 ;
</span></span><span class="line"><span class="cl">    // 即最终返回 32 = 2 的 (n=5)次方
</span></span><span class="line"><span class="cl">    return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><p>发现上面在进行<code>&gt;&gt;&gt;</code>操作时会将cap的二进制值变为最高位后边全是1，<code>00010001 -&gt; 00011111</code>这个算法就导致了任意传入一个数值，会将该数字变为它的2倍减1，因为任何尾数全为1的在加1都为2的倍数。</p>
<p>至于开头减1，是因为如果给定的n已经是2的次幂，但是不进行减1操作的话，那么得到的值就是大于给定值的最小2的次幂值，例如传入4就会返回8。</p>
<p>为什么最大右移到16位，因为可以得到的最大值是32个1，这个是int类型存储变量的最大值，在往后就没意义了。</p>
<h4 id="默认初始化容量为什么是16">默认初始化容量为什么是16</h4>
<p>没有找到相关解释，推断这应该就是个经验值，既然一定要设置一个默认的2^n 作为初始值，那么就需要在效率和内存使用上做一个权衡。这个值既不能太小，也不能太大。太小了就有可能频繁发生扩容，影响效率。太大了又浪费空间，不划算。所以，16就作为一个经验值被采用了。</p>
<p>关于默认容量的定义：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">/**
</span></span><span class="line"><span class="cl"> * The default initial capacity - MUST be a power of two.
</span></span><span class="line"><span class="cl"> */
</span></span><span class="line"><span class="cl">static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16
</span></span></code></pre></div><p>故意把16写成<code>1 &lt;&lt; 4</code>这种形式，就是提醒开发者，这个地方要是2的次幂。</p>
<h4 id="初始化容量设置多少合适">初始化容量设置多少合适</h4>
<p>当我们使用<code>HashMap(int initialCapacity)</code>来初始化容量的时候，<code>HashMap</code>并不会使用我们传进来的<code>initialCapacity</code>直接作为初始容量。JDK会默认帮我们计算一个相对合理的值当做初始容量。所谓合理值，其实是找到第一个比用户传入的值大的2的幂。</p>
<p>如果创建hashMap初始化容量设置为7，那么JDK通过计算会创建一个初始化为8的hashMap。当hashMap中的元素到<code>0.75 * 8 = 6</code>就会进行扩容，这明显是我们不希望看到的。</p>
<p>参考JDK8中<code>putAll</code>方法中的实现：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">(int) ((float) expectedSize / 0.75F + 1.0F);
</span></span></code></pre></div><p>通过<code>expectedSize / 0.75F + 1.0F</code>计算，<code>7/0.75 + 1 = 10</code> ,10经过JDK处理之后，会被设置成16，这就大大的减少了扩容的几率。</p>
<p>当我们明确知道HashMap中元素的个数的时候，把默认容量设置成<code>expectedSize / 0.75F + 1.0F</code> 是一个在性能上相对好的选择，但是，同时也会牺牲些内存。</p>
<p>这个算法在guava中有实现，开发的时候，可以直接通过Maps类创建一个HashMap：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">Map&lt;String, String&gt; map = Maps.newHashMapWithExpectedSize(7);
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public static &lt;K, V&gt; HashMap&lt;K, V&gt; newHashMapWithExpectedSize(int expectedSize) {
</span></span><span class="line"><span class="cl">    return new HashMap(capacity(expectedSize));
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">static int capacity(int expectedSize) {
</span></span><span class="line"><span class="cl">    if (expectedSize &lt; 3) {
</span></span><span class="line"><span class="cl">        CollectPreconditions.checkNonnegative(expectedSize, &#34;expectedSize&#34;);
</span></span><span class="line"><span class="cl">        return expectedSize + 1;
</span></span><span class="line"><span class="cl">    } else {
</span></span><span class="line"><span class="cl">        return expectedSize &lt; 1073741824 ? (int)((float)expectedSize / 0.75F + 1.0F) : 2147483647;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><h3 id="扩容">扩容</h3>
<ul>
<li>JDK1.7: 先扩容在添加元素；</li>
<li>JDK1.8: 先添加元素在扩容；</li>
</ul>
<h4 id="为什么要进行扩容">为什么要进行扩容</h4>
<p>随着HashMap中的元素增加，Hash碰撞导致获取元素方法的效率就会越来越低，为了保证获取元素方法的效率，所以针对HashMap中的数组进行扩容。扩容数组的方式只能再去开辟一个新的数组，并把之前的元素转移到新数组上。</p>
<blockquote>
<p>PS 如何能避免哈希碰撞?</p>
<ul>
<li>容量太小。容量小，碰撞的概率就高了。狼多肉少，就会发生争抢。</li>
<li>hash算法不够好。算法不合理，就可能都分到同一个或几个桶中。分配不均，也会发生争抢。</li>
</ul>
</blockquote>
<h4 id="什么时机进行扩容">什么时机进行扩容</h4>
<p>HashMap的扩容条件就是当HashMap中的元素个数（size）超过临界值（threshold）时就会自动扩容。在HashMap中，<code>threshold = loadFactor * capacity</code>。默认情况下负载因子为0.75,理解为当容器中元素到容器的3/4时就会扩容。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl"> if (++size &gt; threshold)
</span></span><span class="line"><span class="cl">    resize();
</span></span></code></pre></div><p>HashMap的容量是有上限的，必须小于<code>1&lt;&lt;30</code>，即<code>1073741824</code>。如果容量超出了这个数，则不再增长，且阈值会被设置为<code>Integer.MAX_VALUE</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">// Java8
</span></span><span class="line"><span class="cl">if (oldCap &gt;= MAXIMUM_CAPACITY) {
</span></span><span class="line"><span class="cl">    threshold = Integer.MAX_VALUE;
</span></span><span class="line"><span class="cl">    return oldTab;
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">// Java7
</span></span><span class="line"><span class="cl">if (oldCapacity == MAXIMUM_CAPACITY) { 
</span></span><span class="line"><span class="cl">    threshold = Integer.MAX_VALUE;
</span></span><span class="line"><span class="cl">    return;
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><h4 id="17扩容">1.7扩容</h4>
<ul>
<li><code>新容量 = 旧容量 * 2</code></li>
<li><code>新阈值 = 新容量 * 负载因子</code></li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">void addEntry(int hash, K key, V value, int bucketIndex) {  
</span></span><span class="line"><span class="cl">    //size：The number of key-value mappings contained in this map.  
</span></span><span class="line"><span class="cl">    //threshold：The next size value at which to resize (capacity * load factor)  
</span></span><span class="line"><span class="cl">    //数组扩容条件：1.已经存在的key-value mappings的个数大于等于阈值  
</span></span><span class="line"><span class="cl">    //             2.底层数组的bucketIndex坐标处不等于null  
</span></span><span class="line"><span class="cl">    if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) {  
</span></span><span class="line"><span class="cl">        resize(2 * table.length);//扩容之后，数组长度变了  
</span></span><span class="line"><span class="cl">        hash = (null != key) ? hash(key) : 0;//为什么要再次计算一下hash值呢？  
</span></span><span class="line"><span class="cl">        bucketIndex = indexFor(hash, table.length);//扩容之后，数组长度变了，在数组的下标跟数组长度有关，得重算。  
</span></span><span class="line"><span class="cl">    }  
</span></span><span class="line"><span class="cl">    createEntry(hash, key, value, bucketIndex);  
</span></span><span class="line"><span class="cl">} 
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">void resize(int newCapacity) {   //传入新的容量
</span></span><span class="line"><span class="cl">    Entry[] oldTable = table;    //引用扩容前的Entry数组
</span></span><span class="line"><span class="cl">    int oldCapacity = oldTable.length;
</span></span><span class="line"><span class="cl">    if (oldCapacity == MAXIMUM_CAPACITY) {  //扩容前的数组大小如果已经达到最大(2^30)了
</span></span><span class="line"><span class="cl">        threshold = Integer.MAX_VALUE; //修改阈值为int的最大值(2^31-1)，这样以后就不会扩容了
</span></span><span class="line"><span class="cl">        return;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    Entry[] newTable = new Entry[newCapacity];  //初始化一个新的Entry数组
</span></span><span class="line"><span class="cl">    transfer(newTable);                         //！！将数据转移到新的Entry数组里
</span></span><span class="line"><span class="cl">    table = newTable;                           //HashMap的table属性引用新的Entry数组
</span></span><span class="line"><span class="cl">    threshold = (int) (newCapacity * loadFactor);//修改阈值
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><p>通过transfer方法将旧数组上的元素转移到扩容后的新数组上</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">void transfer(Entry[] newTable) {
</span></span><span class="line"><span class="cl">    Entry[] src = table;                   //src引用了旧的Entry数组
</span></span><span class="line"><span class="cl">    int newCapacity = newTable.length;
</span></span><span class="line"><span class="cl">    for (int j = 0; j &lt; src.length; j++) { //遍历旧的Entry数组
</span></span><span class="line"><span class="cl">        Entry&lt;K, V&gt; e = src[j];             //取得旧Entry数组的每个元素
</span></span><span class="line"><span class="cl">        if (e != null) {
</span></span><span class="line"><span class="cl">            src[j] = null;//释放旧Entry数组的对象引用（for循环后，旧的Entry数组不再引用任何对象）
</span></span><span class="line"><span class="cl">            do {
</span></span><span class="line"><span class="cl">                Entry&lt;K, V&gt; next = e.next;
</span></span><span class="line"><span class="cl">                int i = indexFor(e.hash, newCapacity); //！！重新计算每个元素在数组中的位置
</span></span><span class="line"><span class="cl">                e.next = newTable[i]; //标记[1]
</span></span><span class="line"><span class="cl">                newTable[i] = e;      //将元素放在数组上
</span></span><span class="line"><span class="cl">                e = next;             //访问下一个Entry链上的元素
</span></span><span class="line"><span class="cl">            } while (e != null);
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><h4 id="18扩容">1.8扩容</h4>
<p>容量变为原来的2倍，阈值也变为原来的2倍。容量和阈值都变为原来的2倍时，负载因子还是不变。</p>
<p>在1.8时做了一些优化，文档注释写的很清楚：&ldquo;元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置&rdquo;。也就是对比1.7的迁移到新的数组上省去了重新计算hash值的时间。</p>
<p>这里的&quot;2次幂的位置&quot;是指长度为原来数组元素的两倍的位置;举个例子,现在容量为16，要扩容到32，要将之前的元素迁移过去，要根据hash值来判断迁移过去的位置；假设元素A：hash值：0101 0101；根据代码<code>h &amp; (length - 1)</code>可得<code>元素A &amp; 15</code>、<code>元素A &amp; 31</code></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">扩容之前的位置：
</span></span><span class="line"><span class="cl">  0101 0101
</span></span><span class="line"><span class="cl">&amp; 0000 1111
</span></span><span class="line"><span class="cl">————————————
</span></span><span class="line"><span class="cl">  0000 0101
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">扩容之后的位置：
</span></span><span class="line"><span class="cl">  0101 0101
</span></span><span class="line"><span class="cl">&amp; 0001 1111
</span></span><span class="line"><span class="cl">————————————
</span></span><span class="line"><span class="cl">  0001 0101
</span></span></code></pre></div><p>发现规律：扩容前的hash值和扩容后的hash值，如果元素A二进制形式第三位如果是0，扩容之后就还是原来的位置，如果是1扩容后就是原来的位置加16，而16就是扩容的大小。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl"> /**
</span></span><span class="line"><span class="cl">     * Initializes or doubles table size.  If null, allocates in
</span></span><span class="line"><span class="cl">     * accord with initial capacity target held in field threshold.
</span></span><span class="line"><span class="cl">     * Otherwise, because we are using power-of-two expansion, the
</span></span><span class="line"><span class="cl">     * elements from each bin must either stay at same index, or move
</span></span><span class="line"><span class="cl">     * with a power of two offset in the new table.
</span></span><span class="line"><span class="cl">     *
</span></span><span class="line"><span class="cl">     * @return the table
</span></span><span class="line"><span class="cl">     */
</span></span><span class="line"><span class="cl">    final Node&lt;K,V&gt;[] resize() {
</span></span><span class="line"><span class="cl">        Node&lt;K,V&gt;[] oldTab = table;
</span></span><span class="line"><span class="cl">        int oldCap = (oldTab == null) ? 0 : oldTab.length;
</span></span><span class="line"><span class="cl">        int oldThr = threshold;
</span></span><span class="line"><span class="cl">        int newCap, newThr = 0;
</span></span><span class="line"><span class="cl">        if (oldCap &gt; 0) {
</span></span><span class="line"><span class="cl">            if (oldCap &gt;= MAXIMUM_CAPACITY) {
</span></span><span class="line"><span class="cl">                threshold = Integer.MAX_VALUE;
</span></span><span class="line"><span class="cl">                return oldTab;
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">            else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;
</span></span><span class="line"><span class="cl">                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)
</span></span><span class="line"><span class="cl">                newThr = oldThr &lt;&lt; 1; // double threshold
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        else if (oldThr &gt; 0) // initial capacity was placed in threshold
</span></span><span class="line"><span class="cl">            newCap = oldThr;
</span></span><span class="line"><span class="cl">        else {               // zero initial threshold signifies using defaults
</span></span><span class="line"><span class="cl">            newCap = DEFAULT_INITIAL_CAPACITY;
</span></span><span class="line"><span class="cl">            newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        if (newThr == 0) {
</span></span><span class="line"><span class="cl">            float ft = (float)newCap * loadFactor;
</span></span><span class="line"><span class="cl">            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?
</span></span><span class="line"><span class="cl">                      (int)ft : Integer.MAX_VALUE);
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        threshold = newThr;
</span></span><span class="line"><span class="cl">        @SuppressWarnings({&#34;rawtypes&#34;,&#34;unchecked&#34;})
</span></span><span class="line"><span class="cl">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];
</span></span><span class="line"><span class="cl">        table = newTab;
</span></span><span class="line"><span class="cl">        if (oldTab != null) {
</span></span><span class="line"><span class="cl">            for (int j = 0; j &lt; oldCap; ++j) {
</span></span><span class="line"><span class="cl">                Node&lt;K,V&gt; e;
</span></span><span class="line"><span class="cl">                if ((e = oldTab[j]) != null) {
</span></span><span class="line"><span class="cl">                    oldTab[j] = null;
</span></span><span class="line"><span class="cl">                    if (e.next == null)
</span></span><span class="line"><span class="cl">                        newTab[e.hash &amp; (newCap - 1)] = e;
</span></span><span class="line"><span class="cl">                    else if (e instanceof TreeNode)
</span></span><span class="line"><span class="cl">                        ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);
</span></span><span class="line"><span class="cl">                    else { // preserve order
</span></span><span class="line"><span class="cl">                        Node&lt;K,V&gt; loHead = null, loTail = null;
</span></span><span class="line"><span class="cl">                        Node&lt;K,V&gt; hiHead = null, hiTail = null;
</span></span><span class="line"><span class="cl">                        Node&lt;K,V&gt; next;
</span></span><span class="line"><span class="cl">                        do {
</span></span><span class="line"><span class="cl">                            next = e.next;
</span></span><span class="line"><span class="cl">                            if ((e.hash &amp; oldCap) == 0) {
</span></span><span class="line"><span class="cl">                                if (loTail == null)
</span></span><span class="line"><span class="cl">                                    loHead = e;
</span></span><span class="line"><span class="cl">                                else
</span></span><span class="line"><span class="cl">                                    loTail.next = e;
</span></span><span class="line"><span class="cl">                                loTail = e;
</span></span><span class="line"><span class="cl">                            }
</span></span><span class="line"><span class="cl">                            else {
</span></span><span class="line"><span class="cl">                                if (hiTail == null)
</span></span><span class="line"><span class="cl">                                    hiHead = e;
</span></span><span class="line"><span class="cl">                                else
</span></span><span class="line"><span class="cl">                                    hiTail.next = e;
</span></span><span class="line"><span class="cl">                                hiTail = e;
</span></span><span class="line"><span class="cl">                            }
</span></span><span class="line"><span class="cl">                        } while ((e = next) != null);
</span></span><span class="line"><span class="cl">                        if (loTail != null) {
</span></span><span class="line"><span class="cl">                            loTail.next = null;
</span></span><span class="line"><span class="cl">                            newTab[j] = loHead;
</span></span><span class="line"><span class="cl">                        }
</span></span><span class="line"><span class="cl">                        if (hiTail != null) {
</span></span><span class="line"><span class="cl">                            hiTail.next = null;
</span></span><span class="line"><span class="cl">                            newTab[j + oldCap] = hiHead;
</span></span><span class="line"><span class="cl">                        }
</span></span><span class="line"><span class="cl">                    }
</span></span><span class="line"><span class="cl">                }
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        return newTab;
</span></span><span class="line"><span class="cl">    }
</span></span></code></pre></div></div>
                    <div id="post_footer" class="post_footer">
                        <div class="meta">
                            <div id="post_footer_info" class="info">
                                <span class="field tags">
                                    <i class="ri-stack-line"></i>
                                    
                                        
                                        <a href="https://whiteppure.github.io/iblog/tags/java/">Java</a>
                                        
                                        <a href="https://whiteppure.github.io/iblog/tags/java%E5%9F%BA%E7%A1%80/">Java基础</a>
                                        
                                    
                                    
                                      <span id="busuanzi_container_page_pv">
                                          阅读量<span id="busuanzi_value_page_pv"></span>次
                                      </span>
                                    
                                </span>
                            </div>
                        </div>
                    </div>
                </div>
                
                
                
<div id="doc_comments" class="doc_comments">
    <div class="comments_block_title">发表评论</div>
    <div id="vcomments"></div>
</div>

<link rel="stylesheet" href="https://whiteppure.github.io/iblog/css/comments.css" />

<script src='//unpkg.com/valine/dist/Valine.min.js'></script>

<script type="text/javascript">
    new Valine({
        el: '#vcomments',
        appId: 'pRSrjsfbN6L1DUxgfqJWOMYP-gzGzoHsz',
        appKey: 'VPWpnDPGDM8Xhdlh5OvHOpak',
        placeholder: '说点什么吧...',
        visitor: 'true',
        
        emojiCDN: '//i0.hdslb.com/bfs/emote/',
        
        emojiMaps: {
            "tv_doge": "6ea59c827c414b4a2955fe79e0f6fd3dcd515e24.png",
            "tv_亲亲": "a8111ad55953ef5e3be3327ef94eb4a39d535d06.png",
            "tv_偷笑": "bb690d4107620f1c15cff29509db529a73aee261.png",
            "tv_再见": "180129b8ea851044ce71caf55cc8ce44bd4a4fc8.png",
            "tv_冷漠": "b9cbc755c2b3ee43be07ca13de84e5b699a3f101.png",
            "tv_发怒": "34ba3cd204d5b05fec70ce08fa9fa0dd612409ff.png",
            "tv_发财": "34db290afd2963723c6eb3c4560667db7253a21a.png",
            "tv_可爱": "9e55fd9b500ac4b96613539f1ce2f9499e314ed9.png",
            "tv_吐血": "09dd16a7aa59b77baa1155d47484409624470c77.png",
            "tv_呆": "fe1179ebaa191569b0d31cecafe7a2cd1c951c9d.png",
            "tv_呕吐": "9f996894a39e282ccf5e66856af49483f81870f3.png",
            "tv_困": "241ee304e44c0af029adceb294399391e4737ef2.png",
            "tv_坏笑": "1f0b87f731a671079842116e0991c91c2c88645a.png",
            "tv_大佬": "093c1e2c490161aca397afc45573c877cdead616.png",
            "tv_大哭": "23269aeb35f99daee28dda129676f6e9ea87934f.png",
            "tv_委屈": "d04dba7b5465779e9755d2ab6f0a897b9b33bb77.png",
            "tv_害羞": "a37683fb5642fa3ddfc7f4e5525fd13e42a2bdb1.png",
            "tv_尴尬": "7cfa62dafc59798a3d3fb262d421eeeff166cfa4.png",
            "tv_微笑": "70dc5c7b56f93eb61bddba11e28fb1d18fddcd4c.png",
            "tv_思考": "90cf159733e558137ed20aa04d09964436f618a1.png",
            "tv_惊吓": "0d15c7e2ee58e935adc6a7193ee042388adc22af.png",
            "tv_打脸": "56ab10b624063e966bfcb76ea5dc4794d87dfd47.png",
            "tv_抓狂": "fe31c08edad661d63762b04e17b8d5ae3c71a757.png",
            "tv_抠鼻": "c666f55e88d471e51bbd9fab9bb308110824a6eb.png",
            "tv_斜眼笑": "911f987aa8bc1bee12d52aafe62bc41ef4474e6c.png",
            "tv_无奈": "ea8ed89ee9878f2fece2dda0ea8a5dbfe21b5751.png",
            "tv_晕": "5443c22b4d07fb1907ccc610c8e6db254f2461b7.png",
            "tv_流汗": "cead1c351ab8d79e9f369605beb90148db0fbed3.png",
            "tv_流泪": "7e71cde7858f0cd50d74b0264aa26db612a8a167.png",
            "tv_流鼻血": "c32d39db2737f89b904ca32700d140a9241b0767.png",
            "tv_点赞": "f85c354995bd99e28fc76c869bfe42ba6438eff4.png",
            "tv_生气": "26702dcafdab5e8225b43ffd23c94ac1ff932654.png",
            "tv_生病": "8b0ec90e6b86771092a498c54f09fc94621c1900.png",
            "tv_疑问": "0793d949b18d7be716078349c202c15ff166f314.png",
            "tv_白眼": "c1d59f439e379ee50eef488bcb5e5378e5044ea4.png",
            "tv_皱眉": "72ccad6679fea0d14cce648b4d818e09b8ffea2d.png",
            "tv_目瞪口呆": "0b8cb81a68de5d5365212c99375e7ace3e7891b7.png",
            "tv_睡着": "8b196675b53af58264f383c50ad0945048290b33.png",
            "tv_笑哭": "1abc628f6d4f4caf9d0e7800878f4697abbc8273.png",
            "tv_腼腆": "89712c0d4af73e67f89e35cbc518420380a7f6f4.png",
            "tv_色": "61822c7e9aae5da76475e7892534545336b23a6f.png",
            "tv_调侃": "4bc022533ef31544ca0d72c12c808cf4a1cce3e3.png",
            "tv_调皮": "b9c41de8e82dd7a8515ae5e3cb63e898bf245186.png",
            "tv_鄙视": "6e72339f346a692a495b123174b49e4e8e781303.png",
            "tv_闭嘴": "c9e990da7f6e93975e25fd8b70e2e290aa4086ef.png",
            "tv_难过": "87f46748d3f142ebc6586ff58860d0e2fc8263ba.png",
            "tv_馋": "fc7e829b845c43c623c8b490ee3602b7f0e76a31.png",
            "tv_鬼脸": "0ffbbddf8a94d124ca2f54b360bbc04feb6bbfea.png",
            "tv_黑人问号": "45821a01f51bc867da9edbaa2e070410819a95b2.png",
            "tv_鼓掌": "1d21793f96ef4e6f48b23e53e3b9e42da833a0f6.png"
        }
    })
</script>

                
            </div>
        </div>
    </div>
    <div class="side_nav">
    
    <a id="top_to_back" href="#" class="top_to_back">
        <svg t="1688614744062" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2152" width="16" height="16"><path d="M966.4 323.2c-9.6-9.6-25.6-9.6-35.2 0l-416 416-425.6-416c-9.6-9.6-25.6-9.6-35.2 0-9.6 9.6-9.6 25.6 0 35.2l441.6 432c9.6 9.6 25.6 9.6 35.2 0l435.2-432C976 345.6 976 332.8 966.4 323.2z" p-id="2153" fill="#424242"></path></svg>    </a>
    
    <div>
        <a id="content_display" class="content_display">
            <svg t="1688606941910" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="57753" width="18" height="18"><path d="M192 448c10.9 0 21.8-4.2 30.2-12.5L497 160.8c5.4-5.4 11.8-6.2 15.1-6.2 3.3 0 9.6 0.8 15.1 6.2l274.7 274.7c16.7 16.7 43.7 16.7 60.3 0 16.7-16.7 16.7-43.7 0-60.3L587.4 100.4c-41.6-41.6-109.3-41.6-150.9 0L161.8 375.2c-16.7 16.7-16.7 43.7 0 60.3 8.4 8.3 19.3 12.5 30.2 12.5zM801.8 588.5L527.1 863.2c-5.4 5.4-11.8 6.2-15.1 6.2-3.3 0-9.7-0.8-15.1-6.2L222.2 588.5c-16.7-16.7-43.7-16.7-60.3 0-16.7 16.7-16.7 43.7 0 60.3l274.8 274.8c20.8 20.8 48.1 31.2 75.4 31.2 27.3 0 54.6-10.4 75.4-31.2l274.7-274.8c16.7-16.7 16.7-43.7 0-60.3-16.7-16.7-43.7-16.7-60.4 0z" fill="#424242" p-id="57754"></path></svg>
        </a>
        <a id="content_hidden" class="content_hidden">
            <svg t="1688603143752" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="15592" width="18" height="18"><path d="M479.004101 645.938677L165.25229 958.480465a37.510709 37.510709 0 0 0 0 54.059551 36.47863 36.47863 0 0 0 53.063061 0l293.679668-292.576411 293.715256 292.576411a36.443042 36.443042 0 0 0 53.063061 0 37.510709 37.510709 0 0 0 0-54.059551l-313.751811-312.541788c-21.210989-22.349834-36.514219-24.698702-66.017424 0z m66.053013-267.877709l312.577377-312.541789a37.510709 37.510709 0 0 0 0-54.059551 36.443042 36.443042 0 0 0-53.063061 0l-292.505234 292.576411L219.560963 11.459628a36.47863 36.47863 0 0 0-53.063061 0 37.510709 37.510709 0 0 0 0 54.059551l312.577377 312.541789a46.58588 46.58588 0 0 0 65.981835-0.035589z" p-id="15593" fill="#424242"></path></svg>
        </a>
    </div>
    
    <a id="back_to_top" href="#" class="back_to_top">
        <svg t="1688628374733" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3166" width="16" height="16"><path d="M966.4 668.8l-435.2-432c-9.6-9.6-25.6-9.6-35.2 0l-441.6 432c-9.6 9.6-9.6 25.6 0 35.2 9.6 9.6 25.6 9.6 35.2 0l425.6-416 416 416c9.6 9.6 25.6 9.6 35.2 0S976 678.4 966.4 668.8z" p-id="3167" fill="#424242"></path></svg>
    </a>
</div>
    <footer class="footer">
    <div id="footer_powered_by" class="powered_by">
        <a href="https://varkai.com">Designed by VarKai,</a>
        <a href="http://www.gohugo.io/">Proudly published with Hugo</a>
    </div>

    <div id="footer_slogan" class="footer_slogan">
        <span>whitepure@2020</span>
    </div>
</footer>
    <script src="https://whiteppure.github.io/iblog/js/jquery-3.5.1.min.js"></script>
<link href="https://whiteppure.github.io/iblog/css/fancybox.min.css" rel="stylesheet">
<script src="https://whiteppure.github.io/iblog/js/fancybox.min.js"></script>
<script src="https://whiteppure.github.io/iblog/js/darkmode-js.js"></script>
<script src="https://whiteppure.github.io/iblog/js/zozo.js"></script>
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="https://whiteppure.github.io/iblog/js/busuanzi_2.3_busuanzi.pure.mini.js"></script>
<script src="https://whiteppure.github.io/iblog/js/html2canvas.js"></script>
<script src="https://whiteppure.github.io/iblog/js/utils.js"></script>
<script src="https://whiteppure.github.io/iblog/js/html2md_1.0.js"></script>









<script type="text/javascript">
    if (!isMobileReq()) {
        let titleObj = document.getElementById('post_single_title')
        const title = isEmpty(titleObj) ? 'white‘blog' : titleObj.innerHTML

        
        document.getElementById('export_pdf').onclick = () => {
            removeNotContent()
            window.print();
            window.location.reload()
        }

        
        document.getElementById('export_pic').onclick = () => {
            hiddenNotContent()
            const content = document.getElementById('main_content')
            html2canvas(content).then(function (canvas) {
                downloadBase64(title+'.png',canvas.toDataURL("image/png"))
            });
            displayNotContent()
        }

        
        document.getElementById('export_markdown').onclick = () => {
            removeNotContent()
            const content = document.getElementById('main_content')
            const contentMd = html2md(content.innerHTML)
            downloadFile(title+'.md','text/markdown',contentMd)
            window.location.reload()
        }

    }
</script>



<script>
    function darkModelOptions(){
        return  {
            right: '32px', 
            bottom: 'unset', 
            
            time: '0.3s', 
            mixColor: '#f7f7f7', 
            backgroundColor: '#f7f7f7', 
            buttonColorDark: '#212121', 
            buttonColorLight: '#f7f7f7', 
            saveInCookies: false, 
            autoMatchOsTheme: true 
        }
    }

    

    
    const hours = new Date().getHours();
    if (hours >= 19 && hours <= 6 || hours === 19){
        new Darkmode(darkModelOptions()).toggle();
    }

</script>
</body>

</html>