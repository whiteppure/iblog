<!DOCTYPE html>
<html lang="zh" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="whitepure" />
	
	
	
	<title>JavaIO ｜ 脚踏实地</title>
	
    
    
    <meta name="description" content="概念 Java IO通过数据流、序列化和文件系统提供系统输入和输出。 IO，即 in 和 out，也就是输入和输出，指应用程序和外部设备之间的数据传递，常见的外部设备包括文件、管道" />
    

    
    
    <meta name="keywords" content="whitepure博客, whiteppure, whitepure, 李济芝, Java, 博客, 技术博客" />
    

	

    <link rel="shortcut icon" href="https://whiteppure.github.io/iblog/images/favicon.ico" />

    <link rel="stylesheet" type="text/css" media="screen" href="https://whiteppure.github.io/iblog/css/normalize.css" />

    <link rel="stylesheet" type="text/css" media="screen" href="https://whiteppure.github.io/iblog/css/animate.min.css" />
    <link rel="stylesheet" type="text/css" media="screen" href="https://whiteppure.github.io/iblog/css/zozo.css" />
	<link rel="stylesheet" type="text/css" media="screen" href="https://cdn.jsdelivr.net/npm/remixicon@2.5.0/fonts/remixicon.css" />
    <link rel="stylesheet" type="text/css" media="screen" href="https://whiteppure.github.io/iblog/css/highlight.css" />

    <link rel="stylesheet" type="text/css" media="screen" href="https://whiteppure.github.io/iblog/css/toc.css" />
    <link rel="stylesheet" type="text/css" media="screen" href="https://whiteppure.github.io/iblog/css/search.css" />
    <link rel="stylesheet" type="text/css" media="screen" href="https://whiteppure.github.io/iblog/css/img.css" />

    
    
</head>

<body>
    <div class="post-password">
        
    </div>

    
    
    









<div id="post_content_toc" class="toc">
    <div class="page-header"><strong></strong></div>
    <div id="page-scrollspy" class="toc-nav">

        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e6%a6%82%e5%bf%b5">
                    概念
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e6%b5%81%e7%9a%84%e5%88%86%e7%b1%bb">
                    流的分类
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e8%be%93%e5%85%a5%e6%b5%81%e4%b8%8e%e8%be%93%e5%87%ba%e6%b5%81">
                    输入流与输出流
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e5%ad%97%e8%8a%82%e6%b5%81%e4%b8%8e%e5%ad%97%e7%ac%a6%e6%b5%81">
                    字节流与字符流
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e8%8a%82%e7%82%b9%e6%b5%81%e4%b8%8e%e5%a4%84%e7%90%86%e6%b5%81">
                    节点流与处理流
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e4%bd%bf%e7%94%a8%e6%b5%81">
                    使用流
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#file%e7%b1%bb">
                    File类
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e6%93%8d%e4%bd%9c%e5%ad%97%e8%8a%82%e6%b5%81">
                    操作字节流
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e6%93%8d%e4%bd%9c%e5%ad%97%e7%ac%a6%e6%b5%81">
                    操作字符流
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#java%e5%ba%8f%e5%88%97%e5%8c%96%e5%8f%8d%e5%ba%8f%e5%88%97%e5%8c%96httphollischuanggiteeiotobetopjavaer">
                    Java序列化、反序列化
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e5%ba%8f%e5%88%97%e5%8c%96%e4%bd%9c%e7%94%a8">
                    序列化作用
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e4%bd%bf%e7%94%a8%e5%ba%8f%e5%88%97%e5%8c%96">
                    使用序列化
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#serializablehttpsdocsoraclecomjavase7docsapijavaioserializablehtml">
                    Serializable
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#externalizablehttpsdocsoraclecomjavase7docsapijavaioexternalizablehtml">
                    Externalizable
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#transient">
                    transient
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#serialversionuid">
                    serialVersionUID
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e5%ba%8f%e5%88%97%e5%8c%96%e5%ba%95%e5%b1%82%e5%8e%9f%e7%90%86httphollischuanggiteeiotobetopjavaerbasicsjava-basicserialize-principleid%e5%ba%8f%e5%88%97%e5%8c%96%e5%ba%95%e5%b1%82%e5%8e%9f%e7%90%86">
                    序列化底层原理
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e5%a6%82%e4%bd%95%e8%87%aa%e5%ae%9a%e4%b9%89%e7%9a%84%e5%ba%8f%e5%88%97%e5%8c%96%e5%92%8c%e5%8f%8d%e5%ba%8f%e5%88%97%e5%8c%96%e7%ad%96%e7%95%a5">
                    如何自定义的序列化和反序列化策略?
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e5%9c%a8%e4%b8%80%e4%b8%aa%e7%b1%bb%e4%b8%ad%e5%ae%9a%e4%b9%89%e4%ba%86-writeobject-%e5%92%8c-readobject-%e6%96%b9%e6%b3%95%e9%82%a3%e4%b9%88%e8%bf%99%e4%b8%a4%e4%b8%aa%e6%96%b9%e6%b3%95%e6%98%af%e6%80%8e%e4%b9%88%e8%a2%ab%e8%b0%83%e7%94%a8%e7%9a%84%e5%91%a2">
                    在一个类中定义了 writeObject 和 readObject 方法，那么这两个方法是怎么被调用的呢?
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e5%ae%9e%e7%8e%b0%e4%ba%86serializable%e6%8e%a5%e5%8f%a3%e5%b0%b1%e8%83%bd%e4%bf%9d%e8%af%81%e5%af%b9%e8%b1%a1%e5%ba%8f%e5%88%97%e5%8c%96">
                    为什么实现了Serializable接口就能保证对象序列化？
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e5%ba%8f%e5%88%97%e5%8c%96%e4%b8%8e%e5%8d%95%e4%be%8b%e6%a8%a1%e5%bc%8fhttphollischuanggiteeiotobetopjavaerbasicsjava-basicserialize-singletonid%e5%ba%8f%e5%88%97%e5%8c%96%e5%af%b9%e5%8d%95%e4%be%8b%e7%9a%84%e7%a0%b4%e5%9d%8f">
                    序列化与单例模式
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e5%ba%8f%e5%88%97%e5%8c%96%e7%a0%b4%e5%9d%8f%e5%8d%95%e4%be%8b">
                    序列化破坏单例
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e5%88%86%e6%9e%90%e5%8e%9f%e5%9b%a0">
                    分析原因
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e8%a7%a3%e5%86%b3">
                    解决
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#io%e6%a8%a1%e5%9e%8bhttphollischuanggiteeiotobetopjavaerbasicsjava-basiclinux-ioidlinux-5%e7%a7%8dio%e6%a8%a1%e5%9e%8b">
                    IO模型
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e9%98%bb%e5%a1%9e%e5%bc%8fio%e6%a8%a1%e5%9e%8b">
                    阻塞式IO模型
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e9%9d%9e%e9%98%bb%e5%a1%9eio%e6%a8%a1%e5%9e%8b">
                    非阻塞IO模型
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#io%e5%a4%8d%e7%94%a8%e6%a8%a1%e5%9e%8b">
                    IO复用模型
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e4%bf%a1%e5%8f%b7%e9%a9%b1%e5%8a%a8io%e6%a8%a1%e5%9e%8b">
                    信号驱动IO模型
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e5%bc%82%e6%ad%a5io%e6%a8%a1%e5%9e%8b">
                    异步IO模型
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#nio">
                    NIO
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e9%80%9a%e9%81%93%e4%b8%8e%e7%bc%93%e5%86%b2%e5%8c%ba">
                    通道与缓冲区
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e7%bc%93%e5%86%b2%e5%8c%ba">
                    缓冲区
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e9%80%9a%e9%81%93">
                    通道
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e9%98%bb%e5%a1%9e%e4%b8%8e%e9%9d%9e%e9%98%bb%e5%a1%9e%e7%bd%91%e7%bb%9c%e9%80%9a%e4%bf%a1">
                    阻塞与非阻塞网络通信
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e9%98%bb%e5%a1%9e">
                    阻塞
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e9%9d%9e%e9%98%bb%e5%a1%9e">
                    非阻塞
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e9%80%9a%e9%81%93-1">
                    通道
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        

    </div>

</div>



    

    
    <div class="main animate__animated animate__fadeInDown" id="main_content">
        <div class="nav_container animated fadeInDown">
    <div class="site_nav" id="site_nav">
        <ul><li class="">
                <a href="https://whiteppure.github.io/iblog/">首页</a>
            </li><li class="">
                <a href="https://whiteppure.github.io/iblog/posts/">归档</a>
            </li><li class="">
                <a href="https://whiteppure.github.io/iblog/tags/">标签</a>
            </li><li class="">
                <a href="https://whiteppure.github.io/iblog/about/">关于</a>
            </li>
        </ul>
    </div>
    <div class="menu_icon">
        <a id="menu_icon"><i class="ri-menu-line"></i></a>
    </div>
</div>
        <div id="post_header" class="header animated fadeInDown">
    <div class="site_title_container">
        <div class="site_title">
            <h1>
                <a href="https://whiteppure.github.io/iblog/">
                    <span>脚踏实地</span>
                </a>
            </h1>
        </div>
        <div class="description">
            <p class="sub_title">
                
            </p>

            
            <div class="my_socials">
                
                    
                    <a href="https://github.com/whiteppure/" title="github" target="_blank">
                        <i class="ri-github-fill"></i>
                    </a>
                    
                
                <a href="https://whiteppure.github.io/iblog/index.xml" type="application/rss+xml" title="rss" target="_blank">
                    <i class="ri-rss-fill"></i>
                </a>
                
                
                <span id="sys_function" class="sys_function display_none">
                    <a id="export_pdf"  title="导出pdf" style="border: none; background-color: #ffffff; cursor: pointer; margin-left: 10px">
                        <svg t="1688701481347" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3517" width="16" height="16"><path d="M425.610455 85.814544H149.05897A42.303635 42.303635 0 0 0 106.6274 128.075535V896.492068c0 23.326702 18.976933 42.26099 42.43157 42.26099h682.743143a42.559504 42.559504 0 0 0 42.431569-42.559504v-384.016365a42.644793 42.644793 0 0 1 85.289587 0v384.016365A127.849091 127.849091 0 0 1 831.802113 1024H149.05897A127.635867 127.635867 0 0 1 21.337813 896.449423V128.03289A127.593222 127.593222 0 0 1 149.101614 0.524957h276.466196a42.644793 42.644793 0 0 1 0 85.289587z m564.062683 158.08425l-170.579174 170.579173a42.644793 42.644793 0 1 1-60.299738-60.299738L856.578738 256.393718H618.364922a42.644793 42.644793 0 1 1 0-85.289587h238.213816l-97.784512-97.784511A42.644793 42.644793 0 1 1 819.093964 13.019882l170.579174 170.579174a42.644793 42.644793 0 0 1 0 60.299738zM149.272194 597.552066a42.644793 42.644793 0 0 1 42.644793-42.644794h51.514911c59.190973 0 107.891327 23.284057 107.976617 97.102195 0 71.003581-49.46796 102.347504-106.185536 102.347504h-31.343923v66.781747a32.282109 32.282109 0 0 1-64.606862 0V597.552066z m92.709781 100.215264c31.429213 0 46.568114-16.46089 46.568114-45.757863 0-30.064579-17.313786-40.512554-48.359196-40.512554h-26.311837v86.270417h28.145563z m232.414124-142.860058c81.878003 0 136.036891 43.710913 136.036891 147.67892S556.231457 853.420826 477.935617 853.420826h-38.16709a42.644793 42.644793 0 0 1-42.644794-42.644793v-213.223967a42.644793 42.644793 0 0 1 42.644794-42.644794h34.542282z m-4.008611 240.729859c43.32711 0 73.988717-22.047358 73.988717-93.050939 0-71.046226-30.704251-90.705476-73.988717-90.705476h-8.699538v183.79906h8.699538zM692.481573 853.420826a32.282109 32.282109 0 0 1-32.282109-32.282108V597.552066a42.644793 42.644793 0 0 1 42.644793-42.644794h99.063855a29.680776 29.680776 0 1 1 0 59.404197h-77.144431v65.374469h61.749661a29.894 29.894 0 1 1 0 59.788h-61.749661v81.66478a32.282109 32.282109 0 0 1-32.282108 32.282108z" fill="#5f5f5f" p-id="3518"></path></svg>
                    </a>
                    <a id="export_pic" title="导出图片" style="border: none; background-color: #ffffff; cursor: pointer; margin-left: 10px">
                        <svg t="1689071509720" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4564" width="16" height="16"><path d="M909.132886 0.037506h-184.960611a33.909445 33.909445 0 0 0-32.368107 33.909445 33.909445 33.909445 0 0 0 33.909445 33.395666h158.244078l-200.373995 199.346437a33.395666 33.395666 0 0 0 0 47.781491 31.854327 31.854327 0 0 0 23.633856 9.76181 33.909445 33.909445 0 0 0 24.147635-9.76181l198.832657-199.346437V272.340628a33.909445 33.909445 0 0 0 69.874009 0V88.921355A88.37007 88.37007 0 0 0 909.132886 0.037506zM216.558153 347.866211a107.37991 107.37991 0 1 0 107.37991-107.379911 107.89369 107.89369 0 0 0-107.37991 107.379911z m154.133843 0a51.377948 51.377948 0 0 1-97.618101 0 51.377948 51.377948 0 1 1 97.618101 0z" p-id="4565" fill="#424242"></path><path d="M963.079731 437.777619a34.423225 34.423225 0 0 0-33.909446 33.909445v265.110209a1811.07265 1811.07265 0 0 0-137.692899-193.181082 106.352351 106.352351 0 0 0-78.60826-36.478343 123.820854 123.820854 0 0 0-82.204716 35.964563l-3.596456 3.082677-188.557068 176.74014c-11.816928-13.358266-47.781491-51.377948-82.204716-87.856291a83.232275 83.232275 0 0 0-85.801172-21.578738 105.324792 105.324792 0 0 0-38.019681 19.52362l-141.289356 121.765736V89.948914a22.092517 22.092517 0 0 1 22.606297-22.606297h417.702713a33.395666 33.395666 0 0 0 33.395666-33.909445 33.395666 33.395666 0 0 0-33.395666-33.395666H113.802258A89.911408 89.911408 0 0 0 23.89085 89.948914v844.139678a89.911408 89.911408 0 0 0 89.911408 89.911408h793.27551a89.911408 89.911408 0 0 0 89.397629-89.911408v-462.401528a33.909445 33.909445 0 0 0-33.395666-33.909445z m-33.909446 496.310973a22.606297 22.606297 0 0 1-22.092517 22.606297H113.802258a22.606297 22.606297 0 0 1-22.606297-22.606297v-88.37007l183.933052-160.812976a43.157476 43.157476 0 0 1 15.413385-7.192912 15.927164 15.927164 0 0 1 17.982281 5.137794c37.505902 36.478343 78.60826 83.232275 82.718496 87.856291a61.653537 61.653537 0 0 0 42.643696 22.092517 62.681096 62.681096 0 0 0 51.377948-20.037399c8.220472-8.220472 134.610223-125.875971 194.208641-181.877935a57.029522 57.029522 0 0 1 34.423225-16.440943 45.212594 45.212594 0 0 1 29.79921 15.927164 2954.231982 2954.231982 0 0 1 186.501949 256.889738z" p-id="4566" fill="#424242"></path></svg>
                    </a>
                    <a id="export_markdown" title="导出markdown" style="border: none; background-color: #ffffff; cursor: pointer; margin-left: 10px">
                        <svg t="1689071035200" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="13570" width="16" height="16"><path d="M178.073367 843.957262V461.158929h107.121045l107.121045 140.734874 107.125433-140.734874h107.116657v382.798333h-107.116657v-219.54307l-107.125433 140.730486-107.116657-140.730486v219.54307zM737.783131 892.148786l-131.221196-209.156132h87.479334V461.158929h87.479335v221.833725h87.483722z" p-id="13571" fill="#424242"></path><path d="M911.9958 217.142709c10.672172 10.663395 19.812851 25.144549 27.430816 43.430297 7.617965 18.285748 11.431335 35.044392 11.431336 50.28471V969.140255c0 15.235929-5.336086 28.18998-15.999481 38.853375-10.667783 10.667783-23.621834 16.003869-38.857763 16.003869H127.994904c-15.240317 0-28.18998-5.336086-38.857763-16.003869-10.663395-10.663395-15.999481-23.617446-15.999481-38.853375V54.852856c0-15.240317 5.331698-28.18998 15.999481-38.857763C99.804925 5.336086 112.758975 0 127.999292 0h512.000944c15.235929 0 31.998962 3.808982 50.28471 11.426947 18.285748 7.622353 32.762514 16.763033 43.430297 27.426428zM658.290372 77.715526v214.856442h214.856442c-3.808982-11.049559-7.99974-18.856218-12.572275-23.43314l-178.855415-178.851027c-4.572534-4.572534-12.383581-8.763292-23.43314-12.572275z m219.428976 873.143369V365.71496h-237.714724c-15.240317 0-28.18998-5.336086-38.857763-15.999481-10.663395-10.667783-15.999481-23.621834-15.999481-38.857763V73.142992H146.28504v877.715903z" p-id="13572" fill="#424242"></path></svg>
                    </a>
                    <a id="export_doc" title="导出文档" style="border: none; background-color: #ffffff; cursor: pointer; margin-left: 10px">
                        <svg t="1689246982401" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="6825" width="16" height="16"><path d="M270.76864 608.32h180.8a31.68 31.68 0 0 0 0-62.976H270.76864a31.68 31.68 0 0 0 0 62.976zM271.34464 458.56h457.92a33.472 33.472 0 0 0 31.552-34.752 33.28 33.28 0 0 0-31.552-34.624H271.34464a34.816 34.816 0 0 0 0 69.376zM271.34464 293.504h457.92a33.344 33.344 0 0 0 31.552-34.688 33.216 33.216 0 0 0-31.552-34.624H271.34464a33.28 33.28 0 0 0-31.616 34.624 33.28 33.28 0 0 0 31.616 34.688z" p-id="6826" fill="#424242"></path><path d="M869.87264 0H153.77664A70.4 70.4 0 0 0 84.65664 70.912V953.6A69.952 69.952 0 0 0 153.77664 1024h370.048a32 32 0 0 0 0-63.68H147.12064V64h729.6v468.672a31.296 31.296 0 1 0 62.528 0V70.912A70.4 70.4 0 0 0 869.87264 0z" p-id="6827" fill="#424242"></path><path d="M482.16064 730.624h337.664L715.82464 625.216a28.864 28.864 0 0 1-7.936-28.736 29.184 29.184 0 0 1 20.608-21.184 29.632 29.632 0 0 1 29.12 8.128l174.784 177.216-174.784 176.96a29.184 29.184 0 0 1-49.728-13.312 29.248 29.248 0 0 1 8-28.8l103.936-105.344H482.16064a29.696 29.696 0 0 1-29.504-29.76 29.632 29.632 0 0 1 29.504-29.76z" p-id="6828" fill="#424242"></path></svg>
                    </a>
                </span>
                <a  id="icon_more" title="更多" >
                    <svg t="1688715321313" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5356" width="16" height="16"><path d="M483.555556 199.111111m-85.333334 0a85.333333 85.333333 0 1 0 170.666667 0 85.333333 85.333333 0 1 0-170.666667 0Z" fill="#424242" p-id="5357"></path><path d="M483.555556 540.444444m-85.333334 0a85.333333 85.333333 0 1 0 170.666667 0 85.333333 85.333333 0 1 0-170.666667 0Z" fill="#424242" p-id="5358"></path><path d="M483.555556 881.777778m-85.333334 0a85.333333 85.333333 0 1 0 170.666667 0 85.333333 85.333333 0 1 0-170.666667 0Z" fill="#424242" p-id="5359"></path></svg>
                </a>
                <a  id="icon_less" class="display_none">
                    <svg t="1688723160472" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="15872" width="16" height="16"><path d="M300.105143 592.676571h423.789714a80.676571 80.676571 0 1 0 0-161.353142H300.105143a80.676571 80.676571 0 0 0 0 161.353142z" fill="#8a8a8a" p-id="15873"></path></svg>
                </a>
                
            </div>

            
            <div class="post">
                <div class="post_title post_detail_title">
                    <span class="date" id="busuanzi_container_site_pv">访问量 <span id="busuanzi_value_site_pv"></span>次</span>
                </div>
                <div class="post_title post_detail_title">
                    <span class="date" id="busuanzi_container_site_uv">访客数 <span id="busuanzi_value_site_uv"></span>人</span>
                </div>
            </div>
            
        </div>
    </div>
</div>
        <div class="content">
            <div class="post_page">
                <div class="post animate__animated animate__fadeInDown">
                    <div class="post_title post_detail_title">
                        <h2 id="post_single_title">JavaIO</h2>
                        <span id="post_page_title_date" class="date">2021.04.09</span>
                        
                        <span id="busuanzi_container_page_pv" class="m-l-10">
                          阅读量<span id="busuanzi_value_page_pv"></span>次
                        </span>
                        
                    </div>
                    <div class="post_content markdown"><h2 id="概念">概念</h2>
<p>Java IO通过数据流、序列化和文件系统提供系统输入和输出。</p>
<blockquote>
<p>IO，即 in 和 out，也就是输入和输出，指应用程序和外部设备之间的数据传递，常见的外部设备包括文件、管道、网络连接。</p>
</blockquote>
<p>传统的 IO 是通过<em>流技术</em>来处理的。</p>
<blockquote>
<p>流（Stream），是一个抽象的概念，是指一连串的数据（字符或字节），是以先进先出的方式发送信息的通道。
代表任何有能力产出数据的数据源对象或者是有能力接受数据的接收端对象。</p>
</blockquote>
<p>流的作用就是为数据源和目的地建立一个输送通道</p>
<p>一般来说关于流的特性有下面几点：</p>
<ul>
<li>先进先出：最先写入输出流的数据最先被输入流读取到。</li>
<li>顺序存取：可以一个接一个地往流中写入一串字节，读出时也将按写入顺序读取一串字节，不能随机访问中间的数据。（<code>RandomAccessFile</code>除外）</li>
<li>只读或只写：每个流只能是输入流或输出流的一种，不能同时具备两个功能，输入流只能进行读操作，对输出流只能进行写操作。
在一个数据传输通道中，如果既要写入数据，又要读取数据，则要分别提供两个流。</li>
</ul>
<h2 id="流的分类">流的分类</h2>
<p><img alt="JavaIO流分类" src="/iblog/posts/annex/images/essays/JavaIO%E6%B5%81%E5%88%86%E7%B1%BB.png"></p>
<p>根据数据传输特性将流抽象为各种类，方便更直观的进行数据操作。</p>
<p>主要的分类方式有以下3种：</p>
<ul>
<li>按数据流的方向：输入流、输出流</li>
<li>按处理数据单位：字节流、字符流</li>
<li>按功能：节点流、处理流</li>
</ul>
<h3 id="输入流与输出流">输入流与输出流</h3>
<p>此输入、输出是相对于我们写的代码程序而言。</p>
<ul>
<li>输入流：从别的地方获取资源 输入到 我们的程序中</li>
<li>输出流：从我们的程序中输出到别的地方；例如：将一个字符串保存到本地文件中，就需要使用输出流。</li>
</ul>
<h3 id="字节流与字符流">字节流与字符流</h3>
<p>字节流和字符流的用法几乎完成全一样，区别在于字节流和字符流所操作的数据单元不同，字节流操作的单元是数据单元是8位的字节，字符流操作的是数据单元为16位的字符。</p>
<blockquote>
<ul>
<li>字符流的由来</li>
</ul>
<p>Java中字符是采用Unicode标准，一个字符是16位，即一个字符使用两个字节来表示。
为此，JAVA中引入了处理字符的流。因为数据编码的不同，而有了对字符进行高效操作的流对象。本质其实就是基于字节流读取时，去查了指定的码表。</p>
<ul>
<li>为什么要有字符流？</li>
</ul>
<p>Java中字符是采用Unicode标准，Unicode 编码中，一个英文为一个字节，一个中文为两个字节。
如果使用字节流处理中文，如果一次读写一个字符对应的字节数就不会有问题，一旦将一个字符对应的字节分裂开来，就会出现乱码了。</p>
</blockquote>
<ul>
<li>字节流：每次读取(写出)一个字节，当传输的资源文件有中文时，就会出现乱码，</li>
<li>字符流：每次读取(写出)两个字节，有中文时，使用该流就可以正确传输显示中文。</li>
</ul>
<blockquote>
<ul>
<li>字节流一般用来处理图像、视频、音频、<code>PPT、Word</code>等类型的文件。字符流一般用于处理纯文本类型的文件，如TXT文件等，但不能处理图像视频等非文本文件。
用一句话说就是：字节流可以处理一切文件，而字符流只能处理纯文本文件。</li>
<li>字节流本身没有缓冲区，缓冲字节流相对于字节流，效率提升非常高。而字符流本身就带有缓冲区，缓冲字符流相对于字符流效率提升就不是那么大了。</li>
</ul>
</blockquote>
<h3 id="节点流与处理流">节点流与处理流</h3>
<p>按功能不同分为 节点流、处理流：</p>
<ul>
<li>节点流：以从或向一个特定的地方读写数据。如<code>FileInputStream　</code>.</li>
<li>处理流：是对一个已存在的流的连接和封装，通过所封装的流的功能调用实现数据读写。如<code>BufferedReader</code>。
处理流的构造方法总是要带一个其他的流对象做参数。一个流对象经过其他流的多次包装，</li>
</ul>
<p>处理流是对节点流的封装，最终的数据处理还是由节点流完成的。</p>
<h2 id="使用流">使用流</h2>
<p>看上面的几个分类，可能会感觉到有些混乱，那什么时候用字节流，什么时候该用输出流呢？</p>
<blockquote>
<p>1、首先自己要知道是选择输入流还是输出流，这就要根据自己的情况而定，如果你想从程序写东西到别的地方，那么就选择输出流，反之用输入流
2、然后考虑你传输数据时，是选择使用字节流传输还是字符流，也就是每次传1个字节还是2个字节，有中文肯定就选择字符流了。
3、前面两步就可以选出一个合适的节点流了，比如字节输入流inputStream，如果要在此基础上增强功能，那么就在处理流中选择一个合适的即可。</p>
</blockquote>
<h3 id="file类">File类</h3>
<p>如果我们想要操作流首先，那不得不首先说一下<a href="https://docs.oracle.com/javase/8/docs/api/index.html?overview-summary.html">File</a>类。</p>
<p>Java中的File类以抽象的方式代表文件名和目录路径名。该类主要用于文件和目录的创建、文件的查找和文件的删除等。</p>
<p>File对象代表磁盘中实际存在的文件和目录。</p>
<p>使用 File 类,查找文件、删除文件、创建文件的代码演示</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl"> public static void main(String args[]) throws IOException {
</span></span><span class="line"><span class="cl">        String dirname = &#34;/home/dir&#34;;
</span></span><span class="line"><span class="cl">        File file = new File(dirname);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        // 判断目录或文件存在
</span></span><span class="line"><span class="cl">        if (!file.exists()) {
</span></span><span class="line"><span class="cl">            System.out.println(dirname + &#34; 该路径或文件不存在&#34;);
</span></span><span class="line"><span class="cl">            System.out.println(&#34;开始创建该文件或目录....&#34;);
</span></span><span class="line"><span class="cl">            // 不存在则创建
</span></span><span class="line"><span class="cl">            if (file.createNewFile()) {
</span></span><span class="line"><span class="cl">                System.out.println(dirname + &#34; 创建成功&#34;);
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        // 判断是否为目录
</span></span><span class="line"><span class="cl">        if (file.isDirectory()) {
</span></span><span class="line"><span class="cl">            System.out.println(&#34;目录： &#34; + dirname);
</span></span><span class="line"><span class="cl">            String s[] = file.list();
</span></span><span class="line"><span class="cl">            for (int i = 0; i &lt; s.length; i++) {
</span></span><span class="line"><span class="cl">                File f = new File(dirname + &#34;/&#34; + s[i]);
</span></span><span class="line"><span class="cl">                if (f.isDirectory()) {
</span></span><span class="line"><span class="cl">                    System.out.println(s[i] + &#34; 是文件夹&#34;);
</span></span><span class="line"><span class="cl">                } else {
</span></span><span class="line"><span class="cl">                    System.out.println(s[i] + &#34; 是文件&#34;);
</span></span><span class="line"><span class="cl">                }
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">        } else {
</span></span><span class="line"><span class="cl">            System.out.println(dirname + &#34; 不是一个目录&#34;);
</span></span><span class="line"><span class="cl">            System.out.println(&#34;开始删除文件 ...&#34;);
</span></span><span class="line"><span class="cl">            // 删除文件
</span></span><span class="line"><span class="cl">            if (file.delete()) {
</span></span><span class="line"><span class="cl">                System.out.println(dirname + &#34;删除成功&#34;); 
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    }
</span></span></code></pre></div><h3 id="操作字节流">操作字节流</h3>
<p><img alt="字节流" src="/iblog/posts/annex/images/essays/%E5%AD%97%E8%8A%82%E6%B5%81.png"></p>
<p>操作byte类型数据，主要操作类是<code>OutputStream、InputStream</code>的子类；不用缓冲区，直接对文件本身操作。</p>
<p>以下代码就是用<code>FileInputStream、FileOutputStream</code>操作字节流</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public static void main(String[] args) throws IOException {
</span></span><span class="line"><span class="cl">        File file = new File(&#34;./test.txt&#34;);
</span></span><span class="line"><span class="cl">        write(file);
</span></span><span class="line"><span class="cl">        System.out.println(read(file));
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // 用字节流写入
</span></span><span class="line"><span class="cl">    public static void write(File file) throws IOException {
</span></span><span class="line"><span class="cl">        OutputStream os = new FileOutputStream(file, true);
</span></span><span class="line"><span class="cl">        // 要写入的字符串
</span></span><span class="line"><span class="cl">        String string = &#34;awslawslawslawslawslawslawsl&#34;;
</span></span><span class="line"><span class="cl">        // 写入文件
</span></span><span class="line"><span class="cl">        os.write(string.getBytes());
</span></span><span class="line"><span class="cl">        // 关闭流
</span></span><span class="line"><span class="cl">        os.close();
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // 用字节流读取
</span></span><span class="line"><span class="cl">    public static String read(File file) throws IOException {
</span></span><span class="line"><span class="cl">        InputStream in = new FileInputStream(file);
</span></span><span class="line"><span class="cl">        // 一次性取多少个字节
</span></span><span class="line"><span class="cl">        byte[] bytes = new byte[1024];
</span></span><span class="line"><span class="cl">        // 用来接收读取的字节数组
</span></span><span class="line"><span class="cl">        StringBuilder sb = new StringBuilder();
</span></span><span class="line"><span class="cl">        // 读取到的字节数组长度，为-1时表示没有数据
</span></span><span class="line"><span class="cl">        int length = 0;
</span></span><span class="line"><span class="cl">        // 循环取数据
</span></span><span class="line"><span class="cl">        while ((length = in.read(bytes)) != -1) {
</span></span><span class="line"><span class="cl">            // 将读取的内容转换成字符串
</span></span><span class="line"><span class="cl">            sb.append(new String(bytes, 0, length));
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        // 关闭流
</span></span><span class="line"><span class="cl">        in.close();
</span></span><span class="line"><span class="cl">        return sb.toString();
</span></span><span class="line"><span class="cl">    }
</span></span></code></pre></div><p>缓冲字节流是为高效率而设计的，真正的读写操作还是靠<code>FileOutputStream</code>和<code>FileInputStream</code></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public static void main(String[] args) throws IOException {
</span></span><span class="line"><span class="cl">        File file = new File(&#34;test.txt&#34;);
</span></span><span class="line"><span class="cl">        write(file);
</span></span><span class="line"><span class="cl">        System.out.println(read(file));
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public static void write(File file) throws IOException {
</span></span><span class="line"><span class="cl">        // 缓冲字节流，提高了效率
</span></span><span class="line"><span class="cl">        BufferedOutputStream bis = new BufferedOutputStream(new FileOutputStream(file, true));
</span></span><span class="line"><span class="cl">        // 要写入的字符串
</span></span><span class="line"><span class="cl">        String string = &#34;awslawslawslawslawslawslawsl&#34;;
</span></span><span class="line"><span class="cl">        // 写入文件
</span></span><span class="line"><span class="cl">        bis.write(string.getBytes());
</span></span><span class="line"><span class="cl">        // 关闭流
</span></span><span class="line"><span class="cl">        bis.close();
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public static String read(File file) throws IOException {
</span></span><span class="line"><span class="cl">        BufferedInputStream fis = new BufferedInputStream(new FileInputStream(file));
</span></span><span class="line"><span class="cl">        // 一次性取多少个字节
</span></span><span class="line"><span class="cl">        byte[] bytes = new byte[1024];
</span></span><span class="line"><span class="cl">        // 用来接收读取的字节数组
</span></span><span class="line"><span class="cl">        StringBuilder sb = new StringBuilder();
</span></span><span class="line"><span class="cl">        // 读取到的字节数组长度，为-1时表示没有数据
</span></span><span class="line"><span class="cl">        int length = 0;
</span></span><span class="line"><span class="cl">        // 循环取数据
</span></span><span class="line"><span class="cl">        while ((length = fis.read(bytes)) != -1) {
</span></span><span class="line"><span class="cl">            // 将读取的内容转换成字符串
</span></span><span class="line"><span class="cl">            sb.append(new String(bytes, 0, length));
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        // 关闭流
</span></span><span class="line"><span class="cl">        fis.close();
</span></span><span class="line"><span class="cl">        return sb.toString();
</span></span><span class="line"><span class="cl">    }
</span></span></code></pre></div><h3 id="操作字符流">操作字符流</h3>
<p><img alt="字符流" src="/iblog/posts/annex/images/essays/%E5%AD%97%E7%AC%A6%E6%B5%81.png"></p>
<p>操作字符类型数据，主要操作类是<code>Reader、Writer</code>的子类；使用缓冲区缓冲字符，不关闭流就不会输出任何内容。</p>
<p>字符流适用于文本文件的读写，<code>OutputStreamWriter</code> 类其实也是借助 <code>FileOutputStream</code> 类实现的</p>
<p>以下代码就是用<code>InputStreamReader、OutputStreamWriter</code>操作字节流.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public static void main(String[] args) throws IOException {
</span></span><span class="line"><span class="cl">        File file = new File(&#34;test.txt&#34;);
</span></span><span class="line"><span class="cl">        write(file);
</span></span><span class="line"><span class="cl">        System.out.println(read(file));
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public static void write(File file) throws IOException {
</span></span><span class="line"><span class="cl">        // OutputStreamWriter可以显示指定字符集，否则使用默认字符集
</span></span><span class="line"><span class="cl">        OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(file, true), &#34;UTF-8&#34;);
</span></span><span class="line"><span class="cl">        // 要写入的字符串
</span></span><span class="line"><span class="cl">        String string = &#34;awslawslawslawslawslawslawslawsl&#34;;
</span></span><span class="line"><span class="cl">        osw.write(string);
</span></span><span class="line"><span class="cl">        osw.close();
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public static String read(File file) throws IOException {
</span></span><span class="line"><span class="cl">        InputStreamReader isr = new InputStreamReader(new FileInputStream(file), &#34;UTF-8&#34;);
</span></span><span class="line"><span class="cl">        // 字符数组：一次读取多少个字符
</span></span><span class="line"><span class="cl">        char[] chars = new char[1024];
</span></span><span class="line"><span class="cl">        // 每次读取的字符数组先append到StringBuilder中
</span></span><span class="line"><span class="cl">        StringBuilder sb = new StringBuilder();
</span></span><span class="line"><span class="cl">        // 读取到的字符数组长度，为-1时表示没有数据
</span></span><span class="line"><span class="cl">        int length;
</span></span><span class="line"><span class="cl">        // 循环取数据
</span></span><span class="line"><span class="cl">        while ((length = isr.read(chars)) != -1) {
</span></span><span class="line"><span class="cl">            // 将读取的内容转换成字符串
</span></span><span class="line"><span class="cl">            sb.append(chars, 0, length);
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        // 关闭流
</span></span><span class="line"><span class="cl">        isr.close();
</span></span><span class="line"><span class="cl">        return sb.toString();
</span></span><span class="line"><span class="cl">    }
</span></span></code></pre></div><p>字符缓冲流</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public static void main(String[] args) throws IOException {
</span></span><span class="line"><span class="cl">        File file = new File(&#34;test.txt&#34;);
</span></span><span class="line"><span class="cl">        write(file);
</span></span><span class="line"><span class="cl">        System.out.println(read(file));
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public static void write(File file) throws IOException {
</span></span><span class="line"><span class="cl">        // FileWriter可以大幅度简化代码
</span></span><span class="line"><span class="cl">        BufferedWriter bw = new BufferedWriter(new FileWriter(file, true));
</span></span><span class="line"><span class="cl">        // 要写入的字符串
</span></span><span class="line"><span class="cl">        String string = &#34;awslawslawslawslawslawslawslawsl&#34;;
</span></span><span class="line"><span class="cl">        bw.write(string);
</span></span><span class="line"><span class="cl">        bw.close();
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public static String read(File file) throws IOException {
</span></span><span class="line"><span class="cl">        BufferedReader br = new BufferedReader(new FileReader(file));
</span></span><span class="line"><span class="cl">        // 用来接收读取的字节数组
</span></span><span class="line"><span class="cl">        StringBuilder sb = new StringBuilder();
</span></span><span class="line"><span class="cl">        // 按行读数据
</span></span><span class="line"><span class="cl">        String line;
</span></span><span class="line"><span class="cl">        // 循环取数据
</span></span><span class="line"><span class="cl">        while ((line = br.readLine()) != null) {
</span></span><span class="line"><span class="cl">            // 将读取的内容转换成字符串
</span></span><span class="line"><span class="cl">            sb.append(line);
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        // 关闭流
</span></span><span class="line"><span class="cl">        br.close();
</span></span><span class="line"><span class="cl">        return sb.toString();
</span></span><span class="line"><span class="cl">    }
</span></span></code></pre></div><p>字节流和字符流间的转换</p>
<ul>
<li><code>OutputStreamWriter</code> 是字符流通向字节流的桥梁</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">    public static void main(String[] args) throws IOException {
</span></span><span class="line"><span class="cl">        File f = new File(&#34;test.txt&#34;);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        // OutputStreamWriter 是字符流通向字节流的桥梁,创建了一个字符流通向字节流的对象
</span></span><span class="line"><span class="cl">        OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(f),&#34;UTF-8&#34;);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        osw.write(&#34;我是字符流转换成字节流输出的&#34;);
</span></span><span class="line"><span class="cl">        osw.close();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    }
</span></span></code></pre></div><ul>
<li><code>InputStreamReader</code> 是字节流通向字符流的桥梁</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">  public static void main(String[] args) throws IOException {
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        File f = new File(&#34;test.txt&#34;);
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        InputStreamReader inr = new InputStreamReader(new FileInputStream(f),&#34;UTF-8&#34;);
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        char[] buf = new char[1024];
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        int len = inr.read(buf);
</span></span><span class="line"><span class="cl">        System.out.println(new String(buf,0,len));
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        inr.close();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    }
</span></span></code></pre></div><h2 id="java序列化反序列化httphollischuanggiteeiotobetopjavaer"><a href="http://hollischuang.gitee.io/tobetopjavaer">Java序列化、反序列化</a></h2>
<p>序列化是将对象的状态信息转换为可存储或传输的形式的过程（一个对象可以被表示为一个字节序列，该字节序列包括该对象的数据、有关对象的类型的信息和存储在对象中数据的类型）。
是一种数据的持久化手段。一般广泛应用于网络传输，RMI和RPC等场景中。
一般是以字节码或XML格式传输。而字节码或XML编码格式可以还原为完全相等的对象。</p>
<p>将序列化对象写入文件之后，可以从文件中读取出来，这个相反的过程称为反序列化。</p>
<h3 id="序列化作用">序列化作用</h3>
<p>序列化机制允许将实现序列化的Java对象转换位字节序列，这些字节序列可以保存在磁盘上，或通过网络传输，以达到以后恢复成原来的对象。
序列化机制使得对象可以脱离程序的运行而独立存在。</p>
<p>对象序列化机制是Java语言内建的一种对象持久化方式，通过对象序列化，可以把对象的状态保存为字节数组，
并且可以在有需要的时候将这个字节数组通过反序列化的方式再转换成对象。对象序列化可以很容易的在JVM中的活动对象和字节流之间进行转换。</p>
<p>由于序列化整个过程都是 Java 虚拟机独立的，也就是说，在一个平台上序列化的对象可以在另一个完全不同的平台上反序列化该对象。</p>
<p>在Java中，对象的序列化与反序列化被广泛应用到RMI(远程方法调用)及网络传输中。</p>
<h3 id="使用序列化">使用序列化</h3>
<p>使用Java对象序列化，在保存对象时，会把其状态保存为一组字节，在未来，再将这些字节组装成对象。
必须注意地是，对象序列化保存的是对象的&quot;状态&quot;，即它的成员变量。所以，对象序列化不会关注类中的静态变量。</p>
<p>如果需要将某个对象保存到磁盘上或者通过网络传输，那么这个类应该实现<code>Serializable</code>接口或者<code>Externalizable</code>接口。</p>
<h4 id="serializablehttpsdocsoraclecomjavase7docsapijavaioserializablehtml"><a href="https://docs.oracle.com/javase/7/docs/api/java/io/Serializable.html">Serializable</a></h4>
<blockquote>
<p>类的可序列化性是通过实现 <code>java.io.Serializable</code> 接口的类来启用的。没有实现此接口的类的任何状态都不会被序列化或反序列化。
可序列化类的所有子类型本身都是可序列化的。序列化接口没有方法或字段，只用于标识可序列化的语义。</p>
<p>为了允许非序列化类的子类型被序列化，子类型可以承担保存和恢复超类型的公共、受保护和(如果可以访问)包字段的状态的责任。
只有当它所继承的类有一个可访问的无参数构造函数来初始化类的状态时，子类型才可以承担这种责任。如果不是这种情况，则声明一个类可序列化是错误的。
该错误将在运行时检测到。</p>
<p>当试图对一个对象进行序列化的时候，如果遇到不支持 Serializable 接口的对象。在此情况下，将抛出 <code>NotSerializableException</code>。并标识非<code>serializable</code>对象的类。</p>
</blockquote>
<p>实现<code>Serializable</code>序列化反序列对象化代码演示</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public class MainTest {
</span></span><span class="line"><span class="cl">    public static void main(String[] args) {
</span></span><span class="line"><span class="cl">//       serialUser();
</span></span><span class="line"><span class="cl">        System.out.println(&#34;----------反序列化对象----------&#34;);
</span></span><span class="line"><span class="cl">        unSerialUser();
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    private static void serialUser (){
</span></span><span class="line"><span class="cl">        User user = new User();
</span></span><span class="line"><span class="cl">        user.setName(&#34;Jane&#34;);
</span></span><span class="line"><span class="cl">        user.setAge(&#34;100&#34;);
</span></span><span class="line"><span class="cl">        System.out.println(user);
</span></span><span class="line"><span class="cl">        try(ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&#34;./user.txt&#34;));) {
</span></span><span class="line"><span class="cl">            oos.writeObject(user);
</span></span><span class="line"><span class="cl">        } catch (IOException e) {
</span></span><span class="line"><span class="cl">            e.printStackTrace();
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    private static void unSerialUser() {
</span></span><span class="line"><span class="cl">        File file = new File(&#34;./user.txt&#34;);
</span></span><span class="line"><span class="cl">        try(ObjectInputStream ois  = new ObjectInputStream(new FileInputStream(file))) {
</span></span><span class="line"><span class="cl">            User newUser = (User) ois.readObject();
</span></span><span class="line"><span class="cl">            System.out.println(newUser);
</span></span><span class="line"><span class="cl">        } catch (IOException | ClassNotFoundException e) {
</span></span><span class="line"><span class="cl">            e.printStackTrace();
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">class User implements Serializable {
</span></span><span class="line"><span class="cl">    private String name;
</span></span><span class="line"><span class="cl">    private String age;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public String getName() {
</span></span><span class="line"><span class="cl">        return name;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public void setName(String name) {
</span></span><span class="line"><span class="cl">        this.name = name;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public String getAge() {
</span></span><span class="line"><span class="cl">        return age;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public void setAge(String age) {
</span></span><span class="line"><span class="cl">        this.age = age;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    public String toString() {
</span></span><span class="line"><span class="cl">        return &#34;User{&#34; +
</span></span><span class="line"><span class="cl">                &#34;name=&#39;&#34; + name + &#39;\&#39;&#39; +
</span></span><span class="line"><span class="cl">                &#34;, age=&#39;&#34; + age + &#39;\&#39;&#39; +
</span></span><span class="line"><span class="cl">                &#39;}&#39;;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><h4 id="externalizablehttpsdocsoraclecomjavase7docsapijavaioexternalizablehtml"><a href="https://docs.oracle.com/javase/7/docs/api/java/io/Externalizable.html">Externalizable</a></h4>
<blockquote>
<p>Externalizable继承了Serializable，该接口中定义了两个抽象方法：<code>writeExternal</code>()与<code>readExternal()</code>。
当使用Externalizable接口来进行序列化与反序列化的时候需要开发人员重写<code>writeExternal()</code>与<code>readExternal()</code>方法。
由于上面的代码中，并没有在这两个方法中定义序列化实现细节，所以输出的内容为空。</p>
<p>还有一点值得注意：在使用<code>Externalizable</code>进行序列化的时候，在读取对象时，会调用被序列化类的无参构造器去创建一个新的对象，然后再将被保存对象的字段的值分别填充到新对象中。
所以，实现<code>Externalizable</code>接口的类必须要提供一个public的无参的构造器。</p>
</blockquote>
<p>如果User类中没有无参数的构造函数，在反序列化时会抛出异常：
<code>java.io.InvalidClassException: content.posts.rookie.User; no valid constructor</code></p>
<p>实现<code>Externalizable</code>序列化反序列对象化代码演示</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public class MainTest {
</span></span><span class="line"><span class="cl">    public static void main(String[] args) {
</span></span><span class="line"><span class="cl">//       serialUser();
</span></span><span class="line"><span class="cl">        System.out.println(&#34;----------反序列化对象----------&#34;);
</span></span><span class="line"><span class="cl">        unSerialUser();
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    private static void serialUser ()  {
</span></span><span class="line"><span class="cl">        User user = new User();
</span></span><span class="line"><span class="cl">        user.setName(&#34;Jane&#34;);
</span></span><span class="line"><span class="cl">        user.setAge(&#34;100&#34;);
</span></span><span class="line"><span class="cl">        System.out.println(user);
</span></span><span class="line"><span class="cl">        // /将对象序列化到文件
</span></span><span class="line"><span class="cl">        try(ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&#34;./user.txt&#34;));) {
</span></span><span class="line"><span class="cl">            oos.writeObject(user);
</span></span><span class="line"><span class="cl">        } catch (IOException e) {
</span></span><span class="line"><span class="cl">            e.printStackTrace();
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    private static void unSerialUser() {
</span></span><span class="line"><span class="cl">        File file = new File(&#34;./user.txt&#34;);
</span></span><span class="line"><span class="cl">        try(ObjectInputStream ois  = new ObjectInputStream(new FileInputStream(file))) {
</span></span><span class="line"><span class="cl">            User newUser = (User) ois.readObject();
</span></span><span class="line"><span class="cl">            System.out.println(newUser);
</span></span><span class="line"><span class="cl">        } catch (IOException | ClassNotFoundException e) {
</span></span><span class="line"><span class="cl">            e.printStackTrace();
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">class User implements Externalizable {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public User() {
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    private String name;
</span></span><span class="line"><span class="cl">    private String age;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public String getName() {
</span></span><span class="line"><span class="cl">        return name;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public void setName(String name) {
</span></span><span class="line"><span class="cl">        this.name = name;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public String getAge() {
</span></span><span class="line"><span class="cl">        return age;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public void setAge(String age) {
</span></span><span class="line"><span class="cl">        this.age = age;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    public String toString() {
</span></span><span class="line"><span class="cl">        return &#34;User{&#34; +
</span></span><span class="line"><span class="cl">                &#34;name=&#39;&#34; + name + &#39;\&#39;&#39; +
</span></span><span class="line"><span class="cl">                &#34;, age=&#39;&#34; + age + &#39;\&#39;&#39; +
</span></span><span class="line"><span class="cl">                &#39;}&#39;;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    public void writeExternal(ObjectOutput out) throws IOException {
</span></span><span class="line"><span class="cl">        out.writeObject(name);
</span></span><span class="line"><span class="cl">        out.writeObject(age);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
</span></span><span class="line"><span class="cl">        name = (String) in.readObject();
</span></span><span class="line"><span class="cl">        age = (String) in.readObject();
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><h4 id="transient">transient</h4>
<p>对于一个类中的某些字段如果不需要序列化，就需要加上<code>transient</code>关键字。</p>
<blockquote>
<p>被<code>transient</code>修饰的成员变量，在序列化的时候其值会被忽略，在被反序列化后， <code>transient</code> 变量的值被设为初始值，
如 int 型的是 0，对象型的是 null。</p>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">private transient String name;
</span></span></code></pre></div><p>此时name字段将不会被序列化;当然如果一个变量被static修饰，他也不会被序列化。</p>
<h3 id="serialversionuid">serialVersionUID</h3>
<p>虚拟机是否允许反序列化， 不仅取决于类路径和功能代码是否⼀致， ⼀个⾮常重要的⼀点是两个类的序列化 ID 是否⼀致， 即<code>serialVersionUID</code>要求⼀致。</p>
<p>因为⽂件存储中的内容可能被篡改,为了保证数据的安全: 在进⾏反序列化时， JVM会把传来的字节流中的<code>serialVersionUID</code>与本地相应实体类的<code>serialVersionUID</code>进⾏⽐较， 如果相同就认为是⼀致的， 可以进⾏反序列化;
否则就会出现序列化版本不⼀致的异常， 即是<code>InvalidCastException</code>。</p>
<p>以下内容来自<code>Serializable</code>接口注释</p>
<blockquote>
<p>If a serializable class does not explicitly declare a serialVersionUID,
then the serialization runtime will calculate a default
serialVersionUID value for that class based on various aspects of the class,
as described in the Java(TM) Object Serialization Specification.
However, it is strongly recommended that all serializable classes explicitly declare serialVersionUID values,
since the default serialVersionUID computation is highly sensitive to class details that may vary depending on compiler implementations,
and can thus result in unexpectedInvalidClassExceptions during deserialization.</p>
</blockquote>
<p>当实现<code>java.io.Serializable</code>接口的类没有显式地定义⼀个<code>serialVersionUID</code>变量时候，Java序列化机制会根据编译的Class⾃动⽣成⼀个<code>serialVersionUID</code>作序列化版本⽐较⽤,
这种情况下，如果Class⽂件没有发⽣变化，就算再编译多次， <code>serialVersionUID</code>也不会变化的。
但是，如果发⽣了变化，那么这个⽂件对应的<code>serialVersionUID</code>也就会发⽣变化。</p>
<p>Java强烈建议用户自定义一个<code>serialVersionUID</code>,因为默认的<code>serialVersinUID</code>对于class的细节非常敏感，
反序列化时可能会导致<code>InvalidClassException</code>这个异常。</p>
<p>代码演示序列化、反序列化加上<code>serialVersionUID</code></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">private static final long serialVersionUID = 1L;
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public class MainTest {
</span></span><span class="line"><span class="cl">    public static void main(String[] args) {
</span></span><span class="line"><span class="cl">        System.out.println(&#34;----------序列化对象----------&#34;);
</span></span><span class="line"><span class="cl">        serialUser();
</span></span><span class="line"><span class="cl">        System.out.println(&#34;----------反序列化对象----------&#34;);
</span></span><span class="line"><span class="cl">        unSerialUser();
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    private static void serialUser (){
</span></span><span class="line"><span class="cl">        User user = new User();
</span></span><span class="line"><span class="cl">        user.setName(&#34;Jane&#34;);
</span></span><span class="line"><span class="cl">        user.setAge(&#34;100&#34;);
</span></span><span class="line"><span class="cl">        System.out.println(user);
</span></span><span class="line"><span class="cl">        try(ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&#34;./user.txt&#34;));) {
</span></span><span class="line"><span class="cl">            oos.writeObject(user);
</span></span><span class="line"><span class="cl">        } catch (IOException e) {
</span></span><span class="line"><span class="cl">            e.printStackTrace();
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    private static void unSerialUser() {
</span></span><span class="line"><span class="cl">        File file = new File(&#34;./user.txt&#34;);
</span></span><span class="line"><span class="cl">        try(ObjectInputStream ois  = new ObjectInputStream(new FileInputStream(file))) {
</span></span><span class="line"><span class="cl">            User newUser = (User) ois.readObject();
</span></span><span class="line"><span class="cl">            System.out.println(newUser);
</span></span><span class="line"><span class="cl">        } catch (IOException | ClassNotFoundException e) {
</span></span><span class="line"><span class="cl">            e.printStackTrace();
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">class User implements Serializable {
</span></span><span class="line"><span class="cl">    private static final long serialVersionUID = 1L;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    private String name;
</span></span><span class="line"><span class="cl">    private String age;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public String getName() {
</span></span><span class="line"><span class="cl">        return name;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public void setName(String name) {
</span></span><span class="line"><span class="cl">        this.name = name;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public String getAge() {
</span></span><span class="line"><span class="cl">        return age;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public void setAge(String age) {
</span></span><span class="line"><span class="cl">        this.age = age;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    public String toString() {
</span></span><span class="line"><span class="cl">        return &#34;User{&#34; +
</span></span><span class="line"><span class="cl">                &#34;name=&#39;&#34; + name + &#39;\&#39;&#39; +
</span></span><span class="line"><span class="cl">                &#34;, age=&#39;&#34; + age + &#39;\&#39;&#39; +
</span></span><span class="line"><span class="cl">                &#39;}&#39;;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">java.io.InvalidClassException: co.test.User; local class incompatible: stream classdesc serialVersionUID = -1643371274357194431, local class serialVersionUID = 1
</span></span></code></pre></div><p>代码调用链：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">ObjectInputStream.readObject -&gt; readObject0 -&gt; readOrdinaryObject -&gt; readClassDesc -&gt; readNonProxyDesc -&gt; ObjectStreamClass.initNonProxy
</span></span></code></pre></div><p>在<code>initNonProxy</code>中 ，关键代码如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"> <span class="n">void</span> <span class="n">initNonProxy</span><span class="p">(</span><span class="n">ObjectStreamClass</span> <span class="n">model</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                      <span class="n">Class</span><span class="o">&lt;</span><span class="err">?</span><span class="o">&gt;</span> <span class="n">cl</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                      <span class="n">ClassNotFoundException</span> <span class="n">resolveEx</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                      <span class="n">ObjectStreamClass</span> <span class="n">superDesc</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">throws</span> <span class="n">InvalidClassException</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">long</span> <span class="n">suid</span> <span class="o">=</span> <span class="n">Long</span><span class="o">.</span><span class="n">valueOf</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">getSerialVersionUID</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">        <span class="n">ObjectStreamClass</span> <span class="n">osc</span> <span class="o">=</span> <span class="n">null</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">cl</span> <span class="o">!=</span> <span class="n">null</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">osc</span> <span class="o">=</span> <span class="n">lookup</span><span class="p">(</span><span class="n">cl</span><span class="p">,</span> <span class="bp">true</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">osc</span><span class="o">.</span><span class="n">isProxy</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">throw</span> <span class="n">new</span> <span class="n">InvalidClassException</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">                        <span class="s2">&#34;cannot bind non-proxy descriptor to a proxy class&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">isEnum</span> <span class="o">!=</span> <span class="n">osc</span><span class="o">.</span><span class="n">isEnum</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">throw</span> <span class="n">new</span> <span class="n">InvalidClassException</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">isEnum</span> <span class="err">?</span>
</span></span><span class="line"><span class="cl">                        <span class="s2">&#34;cannot bind enum descriptor to a non-enum class&#34;</span> <span class="p">:</span>
</span></span><span class="line"><span class="cl">                        <span class="s2">&#34;cannot bind non-enum descriptor to an enum class&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="o">//</span> <span class="o">==========</span> <span class="err">判断反序列化</span> <span class="n">serializableUID</span> <span class="err">是否一致</span> <span class="o">==========</span> <span class="n">start</span><span class="o">//</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">serializable</span> <span class="o">==</span> <span class="n">osc</span><span class="o">.</span><span class="n">serializable</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">                    <span class="o">!</span><span class="n">cl</span><span class="o">.</span><span class="n">isArray</span><span class="p">()</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">                    <span class="n">suid</span> <span class="o">!=</span> <span class="n">osc</span><span class="o">.</span><span class="n">getSerialVersionUID</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">throw</span> <span class="n">new</span> <span class="n">InvalidClassException</span><span class="p">(</span><span class="n">osc</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                        <span class="s2">&#34;local class incompatible: &#34;</span> <span class="o">+</span>
</span></span><span class="line"><span class="cl">                                <span class="s2">&#34;stream classdesc serialVersionUID = &#34;</span> <span class="o">+</span> <span class="n">suid</span> <span class="o">+</span>
</span></span><span class="line"><span class="cl">                                <span class="s2">&#34;, local class serialVersionUID = &#34;</span> <span class="o">+</span>
</span></span><span class="line"><span class="cl">                                <span class="n">osc</span><span class="o">.</span><span class="n">getSerialVersionUID</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="o">//</span> <span class="o">==========</span> <span class="err">判断反序列化</span> <span class="n">serializableUID</span> <span class="err">是否一致</span> <span class="o">==========</span> <span class="n">end</span><span class="o">//</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">classNamesEqual</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">osc</span><span class="o">.</span><span class="n">name</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">throw</span> <span class="n">new</span> <span class="n">InvalidClassException</span><span class="p">(</span><span class="n">osc</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                        <span class="s2">&#34;local class name incompatible with stream class &#34;</span> <span class="o">+</span>
</span></span><span class="line"><span class="cl">                                <span class="s2">&#34;name </span><span class="se">\&#34;</span><span class="s2">&#34;</span> <span class="o">+</span> <span class="n">model</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&#34;</span><span class="se">\&#34;</span><span class="s2">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            
</span></span><span class="line"><span class="cl">            <span class="o">//</span> <span class="o">...</span>
</span></span><span class="line"><span class="cl">   
</span></span></code></pre></div><p><code>getSerialVersionUID</code>方法：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public long getSerialVersionUID() {
</span></span><span class="line"><span class="cl">    // REMIND: synchronize instead of relying on volatile?
</span></span><span class="line"><span class="cl">    if (suid == null) {
</span></span><span class="line"><span class="cl">        suid = AccessController.doPrivileged(
</span></span><span class="line"><span class="cl">            new PrivilegedAction&lt;Long&gt;() {
</span></span><span class="line"><span class="cl">                public Long run() {
</span></span><span class="line"><span class="cl">                    return computeDefaultSUID(cl);
</span></span><span class="line"><span class="cl">                }
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">        );
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    return suid.longValue();
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><p>在没有定义<code>serialVersionUID</code>的时候，会调用<code>computeDefaultSUID</code>方法，生成一个默认的<code>serialVersionUID</code>。</p>
<p><code>serialVersionUID</code>有两种显示的生成方式：</p>
<ul>
<li>默认的1L，比如：<code>private static final long serialVersionUID = 1L; </code></li>
<li>根据类名、接口名、成员方法及属性等来生成一个64位的哈希字段，比如： <code>private static final  long   serialVersionUID = xxxxL;</code></li>
</ul>
<p>第二种方式可通过编译器进行配置：
<img alt="idea检查serialVersionUID" src="/iblog/posts/annex/images/essays/idea%E6%A3%80%E6%9F%A5serialVersionUID.png"></p>
<p><img alt="idea自动生成serialVersionUID" src="/iblog/posts/annex/images/essays/idea%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90serialVersionUID.png"></p>
<h3 id="序列化底层原理httphollischuanggiteeiotobetopjavaerbasicsjava-basicserialize-principleid序列化底层原理"><a href="http://hollischuang.gitee.io/tobetopjavaer/#/basics/java-basic/serialize-principle?id=%E5%BA%8F%E5%88%97%E5%8C%96%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86">序列化底层原理</a></h3>
<h4 id="如何自定义的序列化和反序列化策略">如何自定义的序列化和反序列化策略?</h4>
<p>通过在被序列化的类中增加 writeObject 和 readObject 方法来实现。</p>
<p>在<code>java.util.ArrayList</code>中我们能找到答案：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="n">public</span> <span class="k">class</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="k">extends</span> <span class="n">AbstractList</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="n">implements</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">RandomAccess</span><span class="p">,</span> <span class="n">Cloneable</span><span class="p">,</span> <span class="n">java</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">Serializable</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">private</span> <span class="k">static</span> <span class="n">final</span> <span class="n">long</span> <span class="n">serialVersionUID</span> <span class="o">=</span> <span class="mi">8683452581122892189</span><span class="n">L</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">transient</span> <span class="ne">Object</span><span class="p">[]</span> <span class="n">elementData</span><span class="p">;</span> <span class="o">//</span> <span class="n">non</span><span class="o">-</span><span class="n">private</span> <span class="n">to</span> <span class="n">simplify</span> <span class="n">nested</span> <span class="k">class</span> <span class="n">access</span>
</span></span><span class="line"><span class="cl">    <span class="n">private</span> <span class="ne">int</span> <span class="n">size</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>ArrayList实现了<code>java.io.Serializable</code>接口，那么我们就可以对它进行序列化及反序列化。
因为<code>elementData</code>是 <code>transient</code> 的，所以这个成员变量不会被序列化而保留下来.</p>
<p>ArrayList底层是通过数组实现的。
那么数组elementData其实就是用来保存列表中的元素的。通过该属性的声明方式我们知道，他是无法通过序列化持久化下来的。
那么为什么却通过序列化和反序列化把List中的元素保留下来了呢？</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public static void main(String[] args) throws IOException, ClassNotFoundException {
</span></span><span class="line"><span class="cl">        List&lt;String&gt; stringList = new ArrayList&lt;String&gt;();
</span></span><span class="line"><span class="cl">        stringList.add(&#34;hello&#34;);
</span></span><span class="line"><span class="cl">        stringList.add(&#34;world&#34;);
</span></span><span class="line"><span class="cl">        stringList.add(&#34;hollis&#34;);
</span></span><span class="line"><span class="cl">        stringList.add(&#34;chuang&#34;);
</span></span><span class="line"><span class="cl">        System.out.println(&#34;init StringList&#34; + stringList);
</span></span><span class="line"><span class="cl">        ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream(&#34;stringlist&#34;));
</span></span><span class="line"><span class="cl">        objectOutputStream.writeObject(stringList);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        IOUtils.close(objectOutputStream);
</span></span><span class="line"><span class="cl">        File file = new File(&#34;stringlist&#34;);
</span></span><span class="line"><span class="cl">        ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream(file));
</span></span><span class="line"><span class="cl">        List&lt;String&gt; newStringList = (List&lt;String&gt;)objectInputStream.readObject();
</span></span><span class="line"><span class="cl">        IOUtils.close(objectInputStream);
</span></span><span class="line"><span class="cl">        if(file.exists()){
</span></span><span class="line"><span class="cl">            file.delete();
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        System.out.println(&#34;new StringList&#34; + newStringList);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">//init StringList[hello, world, hollis, chuang]
</span></span><span class="line"><span class="cl">//new StringList[hello, world, hollis, chuang]
</span></span></code></pre></div><blockquote>
<p>在序列化过程中，如果被序列化的类中定义了<code>writeObject</code> 和 <code>readObject</code> 方法，虚拟机会试图调用对象类里的 <code>writeObject</code> 和 <code>readObject</code> 方法，进行用户自定义的序列化和反序列化。</p>
<p>如果没有这样的方法，则默认调用是 <code>ObjectOutputStream</code> 的 <code>defaultWriteObject</code> 方法以及 <code>ObjectInputStream</code> 的 <code>defaultReadObject</code> 方法。</p>
<p>用户自定义的 <code>writeObject</code> 和 <code>readObject</code> 方法可以允许用户控制序列化的过程，比如可以在序列化的过程中动态改变序列化的数值。
对象的序列化过程通过 <code>ObjectOutputStream</code> 和 <code>ObjectInputputStream</code> 来实现的.</p>
</blockquote>
<p>ArrayList实际上是动态数组，每次在放满以后自动增长设定的长度值，如果数组自动增长长度设为100，
而实际只放了一个元素，那就会序列化99个null元素。为了保证在序列化的时候不会将这么多null同时进行序列化，
ArrayList把元素数组设置为transient。</p>
<p>为了防止一个包含大量空对象的数组被序列化，为了优化存储，所以，ArrayList使用transient来声明elementData。
但是，作为一个集合，在序列化过程中还必须保证其中的元素可以被持久化下来，
所以，通过重写writeObject 和 readObject方法的方式把其中的元素保留下来。</p>
<ul>
<li><code>writeObject</code> 方法把 <code>elementData</code> 数组中的元素遍历的保存到输出流（<code>ObjectOutputStream</code>）中。</li>
<li><code>readObject</code> 方法从输入流（<code>ObjectInputStream</code>）中读出对象并保存赋值到 <code>elementData</code> 数组中。</li>
</ul>
<h4 id="在一个类中定义了-writeobject-和-readobject-方法那么这两个方法是怎么被调用的呢">在一个类中定义了 <code>writeObject</code> 和 <code>readObject</code> 方法，那么这两个方法是怎么被调用的呢?</h4>
<p>在使用 <code>ObjectOutputStream</code> 的 <code>writeObject</code> 方法和 <code>ObjectInputStream</code> 的 <code>readObject</code> 方法时，会通过反射的方式调用。</p>
<p><code>ObjectOutputStream中writeObject</code>的调用栈：</p>
<blockquote>
<p>writeObject &mdash;&gt; writeObject0 &mdash;&gt;writeOrdinaryObject&mdash;&gt;writeSerialData&mdash;&gt;<strong>invokeWriteObject</strong></p>
</blockquote>
<blockquote>
<p>调用表示的 <code>serializable</code> 类的 <code>writeObject</code> 方法。
如果类描述符不与类相关联，或者该类是可外部化、不可序列化的，或者没有定义 <code>writeObject</code>，
则抛出 <code>UnsupportedOperationException</code>。</p>
<p>类定义的writeObject方法，如果没有则为null</p>
</blockquote>
<p><code>invokeWriteObject</code>方法</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">    /**
</span></span><span class="line"><span class="cl">     * Invokes the writeObject method of the represented serializable class.
</span></span><span class="line"><span class="cl">     * Throws UnsupportedOperationException if this class descriptor is not
</span></span><span class="line"><span class="cl">     * associated with a class, or if the class is externalizable,
</span></span><span class="line"><span class="cl">     * non-serializable or does not define writeObject.
</span></span><span class="line"><span class="cl">     */
</span></span><span class="line"><span class="cl">    void invokeWriteObject(Object obj, ObjectOutputStream out)
</span></span><span class="line"><span class="cl">        throws IOException, UnsupportedOperationException
</span></span><span class="line"><span class="cl">    {
</span></span><span class="line"><span class="cl">        requireInitialized();
</span></span><span class="line"><span class="cl">        if (writeObjectMethod != null) {
</span></span><span class="line"><span class="cl">            try {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                // ========== 调用writeObject 方法 start========== //
</span></span><span class="line"><span class="cl">                writeObjectMethod.invoke(obj, new Object[]{ out });
</span></span><span class="line"><span class="cl">                // ========== 调用writeObject 方法 end========== //
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            } catch (InvocationTargetException ex) {
</span></span><span class="line"><span class="cl">                Throwable th = ex.getTargetException();
</span></span><span class="line"><span class="cl">                if (th instanceof IOException) {
</span></span><span class="line"><span class="cl">                    throw (IOException) th;
</span></span><span class="line"><span class="cl">                } else {
</span></span><span class="line"><span class="cl">                    throwMiscException(th);
</span></span><span class="line"><span class="cl">                }
</span></span><span class="line"><span class="cl">            } catch (IllegalAccessException ex) {
</span></span><span class="line"><span class="cl">                // should not occur, as access checks have been suppressed
</span></span><span class="line"><span class="cl">                throw new InternalError(ex);
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">        } else {
</span></span><span class="line"><span class="cl">            throw new UnsupportedOperationException();
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    }
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">    /** class-defined writeObject method, or null if none */
</span></span><span class="line"><span class="cl">    private Method writeObjectMethod;
</span></span></code></pre></div><h4 id="为什么实现了serializable接口就能保证对象序列化">为什么实现了<code>Serializable</code>接口就能保证对象序列化？</h4>
<p><code>ObjectOutputStream中writeObject</code>的调用栈：</p>
<blockquote>
<p>writeObject &mdash;&gt; <strong>writeObject0</strong> &mdash;&gt;writeOrdinaryObject&mdash;&gt;writeSerialData&mdash;&gt;invokeWriteObject</p>
</blockquote>
<p><code>writeObject0</code>方法</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl"> /**
</span></span><span class="line"><span class="cl">     * Underlying writeObject/writeUnshared implementation.
</span></span><span class="line"><span class="cl">     */
</span></span><span class="line"><span class="cl">    private void writeObject0(Object obj, boolean unshared)
</span></span><span class="line"><span class="cl">        throws IOException
</span></span><span class="line"><span class="cl">    {
</span></span><span class="line"><span class="cl">        boolean oldMode = bout.setBlockDataMode(false);
</span></span><span class="line"><span class="cl">        depth++;
</span></span><span class="line"><span class="cl">        try {
</span></span><span class="line"><span class="cl">           // ... 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            // remaining cases
</span></span><span class="line"><span class="cl">            if (obj instanceof String) {
</span></span><span class="line"><span class="cl">                writeString((String) obj, unshared);
</span></span><span class="line"><span class="cl">            } else if (cl.isArray()) {
</span></span><span class="line"><span class="cl">                writeArray(obj, desc, unshared);
</span></span><span class="line"><span class="cl">            } else if (obj instanceof Enum) {
</span></span><span class="line"><span class="cl">                writeEnum((Enum&lt;?&gt;) obj, desc, unshared);
</span></span><span class="line"><span class="cl">            // =============================
</span></span><span class="line"><span class="cl">            } else if (obj instanceof Serializable) {
</span></span><span class="line"><span class="cl">                writeOrdinaryObject(obj, desc, unshared);
</span></span><span class="line"><span class="cl">            } else {
</span></span><span class="line"><span class="cl">                if (extendedDebugInfo) {
</span></span><span class="line"><span class="cl">                    throw new NotSerializableException(
</span></span><span class="line"><span class="cl">                        cl.getName() + &#34;\n&#34; + debugInfoStack.toString());
</span></span><span class="line"><span class="cl">                } else {
</span></span><span class="line"><span class="cl">                    throw new NotSerializableException(cl.getName());
</span></span><span class="line"><span class="cl">                }
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">            // =============================
</span></span><span class="line"><span class="cl">        } finally {
</span></span><span class="line"><span class="cl">            // ... 
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    }
</span></span></code></pre></div><p>在进行序列化操作时，会判断要被序列化的类是否是 <code>String、Enum、Array</code> 和 <code>Serializable</code> 类型，
如果不是则直接抛出 <code>NotSerializableException</code>。</p>
<h3 id="序列化与单例模式httphollischuanggiteeiotobetopjavaerbasicsjava-basicserialize-singletonid序列化对单例的破坏"><a href="http://hollischuang.gitee.io/tobetopjavaer/#/basics/java-basic/serialize-singleton?id=%E5%BA%8F%E5%88%97%E5%8C%96%E5%AF%B9%E5%8D%95%E4%BE%8B%E7%9A%84%E7%A0%B4%E5%9D%8F">序列化与单例模式</a></h3>
<h4 id="序列化破坏单例">序列化破坏单例</h4>
<p>为什么序列化可以破坏单例了？</p>
<p>序列化会通过反射调用无参数的构造方法创建一个新的对象。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public class MainTest {
</span></span><span class="line"><span class="cl">    public static void main(String[] args) throws Exception {
</span></span><span class="line"><span class="cl">        String path = &#34;/Users/whitepure/github/iblog/blog-site/content/posts/rookie/singleton.txt&#34;;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        //Write Obj to file
</span></span><span class="line"><span class="cl">        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(path));
</span></span><span class="line"><span class="cl">        oos.writeObject(Singleton.getSingleton());
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        //Read Obj from file
</span></span><span class="line"><span class="cl">        File file = new File(path);
</span></span><span class="line"><span class="cl">        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(file));
</span></span><span class="line"><span class="cl">        Singleton newInstance = (Singleton) ois.readObject();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        //判断是否是同一个对象
</span></span><span class="line"><span class="cl">        System.out.println(newInstance == Singleton.getSingleton());
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">class Singleton implements Serializable {
</span></span><span class="line"><span class="cl">    private static final long serialVersionUID = 6377402142849822126L;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    private volatile static Singleton singleton;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    private Singleton() {
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public static Singleton getSingleton() {
</span></span><span class="line"><span class="cl">        if (singleton == null) {
</span></span><span class="line"><span class="cl">            synchronized (MainTest.class) {
</span></span><span class="line"><span class="cl">                if (singleton == null) {
</span></span><span class="line"><span class="cl">                    singleton = new Singleton();
</span></span><span class="line"><span class="cl">                }
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        return singleton;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><p>输出结果为false，对<code>Singleton</code> 的序列化与反序列化得到的对象是一个新的对象，这就破坏了 <code>Singleton</code> 的单例性。</p>
<h4 id="分析原因">分析原因</h4>
<p>对象的序列化过程通过 <code>ObjectOutputStream</code> 和 <code>ObjectInputputStream</code> 来实现的</p>
<p><code>ObjectInputStream</code> 中 <code>readObject</code> 的调用栈：</p>
<blockquote>
<p>readObject &mdash;&gt; readObject0 &mdash;&gt; readOrdinary &mdash;&gt; checkResolve</p>
</blockquote>
<p><code>readOrdinaryObject</code> 方法</p>
<blockquote>
<p>读取并返回&quot;ordinary&quot;(即，不是字符串，类，ObjectStreamClass，数组，或枚举常量)对象，如果对象的类是不可解析的，则为null(在这种情况下，ClassNotFoundException将与对象的句柄相关联)。
设置passHandle为对象的赋值句柄。</p>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl">    <span class="o">/**</span>
</span></span><span class="line"><span class="cl">     <span class="o">*</span> <span class="n">Reads</span> <span class="ow">and</span> <span class="n">returns</span> <span class="s2">&#34;ordinary&#34;</span> <span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">e</span><span class="o">.</span><span class="p">,</span> <span class="ow">not</span> <span class="n">a</span> <span class="ne">String</span><span class="p">,</span> <span class="n">Class</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">     <span class="o">*</span> <span class="n">ObjectStreamClass</span><span class="p">,</span> <span class="n">array</span><span class="p">,</span> <span class="ow">or</span> <span class="k">enum</span> <span class="n">constant</span><span class="p">)</span> <span class="n">object</span><span class="p">,</span> <span class="ow">or</span> <span class="n">null</span> <span class="k">if</span> <span class="n">object</span><span class="s1">&#39;s</span>
</span></span><span class="line"><span class="cl">     <span class="o">*</span> <span class="k">class</span> <span class="n">is</span> <span class="n">unresolvable</span> <span class="p">(</span><span class="ow">in</span> <span class="n">which</span> <span class="k">case</span> <span class="n">a</span> <span class="n">ClassNotFoundException</span> <span class="n">will</span> <span class="n">be</span>
</span></span><span class="line"><span class="cl">     <span class="o">*</span> <span class="n">associated</span> <span class="n">with</span> <span class="n">object</span><span class="s1">&#39;s handle).  Sets passHandle to object&#39;</span><span class="n">s</span> <span class="n">assigned</span>
</span></span><span class="line"><span class="cl">     <span class="o">*</span> <span class="n">handle</span><span class="o">.</span>
</span></span><span class="line"><span class="cl">     <span class="o">*/</span>
</span></span><span class="line"><span class="cl">    <span class="n">private</span> <span class="ne">Object</span> <span class="n">readOrdinaryObject</span><span class="p">(</span><span class="n">boolean</span> <span class="n">unshared</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">throws</span> <span class="n">IOException</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="o">//</span> <span class="o">...</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="ne">Object</span> <span class="n">obj</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">try</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="o">//</span> <span class="err">`</span><span class="n">desc</span><span class="o">.</span><span class="n">isInstantiable</span><span class="p">()</span><span class="err">`</span><span class="p">:</span> <span class="err">如果一个</span> <span class="err">`</span><span class="n">serializable</span><span class="o">/</span><span class="n">externalizable</span><span class="err">`</span> <span class="err">的类可以在运行时被实例化，那么该方法就返回</span><span class="bp">true</span>
</span></span><span class="line"><span class="cl">            <span class="o">//</span> <span class="err">`</span><span class="n">desc</span><span class="o">.</span><span class="n">newInstance</span><span class="err">`：该方法通过反射的方式调用无参构造方法新建一个对象</span>
</span></span><span class="line"><span class="cl">            <span class="n">obj</span> <span class="o">=</span> <span class="n">desc</span><span class="o">.</span><span class="n">isInstantiable</span><span class="p">()</span> <span class="err">?</span> <span class="n">desc</span><span class="o">.</span><span class="n">newInstance</span><span class="p">()</span> <span class="p">:</span> <span class="n">null</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span> <span class="n">catch</span> <span class="p">(</span><span class="n">Exception</span> <span class="n">ex</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">throw</span> <span class="p">(</span><span class="n">IOException</span><span class="p">)</span> <span class="n">new</span> <span class="n">InvalidClassException</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">                <span class="n">desc</span><span class="o">.</span><span class="n">forClass</span><span class="p">()</span><span class="o">.</span><span class="n">getName</span><span class="p">(),</span>
</span></span><span class="line"><span class="cl">                <span class="s2">&#34;unable to create instance&#34;</span><span class="p">)</span><span class="o">.</span><span class="n">initCause</span><span class="p">(</span><span class="n">ex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="o">//</span> <span class="o">...</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="o">//</span> <span class="n">hasReadResolveMethod</span><span class="p">:</span><span class="err">如果实现了</span><span class="n">serializable</span> <span class="err">或者</span> <span class="n">externalizable接口的类中包含readResolve则返回true</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">obj</span> <span class="o">!=</span> <span class="n">null</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">            <span class="n">handles</span><span class="o">.</span><span class="n">lookupException</span><span class="p">(</span><span class="n">passHandle</span><span class="p">)</span> <span class="o">==</span> <span class="n">null</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">            <span class="n">desc</span><span class="o">.</span><span class="n">hasReadResolveMethod</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="o">//</span> <span class="n">invokeReadResolve</span><span class="p">:</span><span class="err">通过反射的方式调用要被反序列化的类的</span><span class="n">readResolve方法</span><span class="err">。</span>
</span></span><span class="line"><span class="cl">            <span class="ne">Object</span> <span class="n">rep</span> <span class="o">=</span> <span class="n">desc</span><span class="o">.</span><span class="n">invokeReadResolve</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">unshared</span> <span class="o">&amp;&amp;</span> <span class="n">rep</span><span class="o">.</span><span class="n">getClass</span><span class="p">()</span><span class="o">.</span><span class="n">isArray</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">rep</span> <span class="o">=</span> <span class="n">cloneArray</span><span class="p">(</span><span class="n">rep</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="o">//</span> <span class="o">...</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">obj</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span></code></pre></div><h4 id="解决">解决</h4>
<p>在 <code>Singleton</code> 中定义 <code>readResolve</code> 方法，并在该方法中指定要返回的对象的生成策略，就可以防止单例被破坏。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">class Singleton implements Serializable {
</span></span><span class="line"><span class="cl">    private static final long serialVersionUID = 6377402142849822126L;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    private volatile static Singleton singleton;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    private Singleton() {
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public static Singleton getSingleton() {
</span></span><span class="line"><span class="cl">        if (singleton == null) {
</span></span><span class="line"><span class="cl">            synchronized (MainTest.class) {
</span></span><span class="line"><span class="cl">                if (singleton == null) {
</span></span><span class="line"><span class="cl">                    singleton = new Singleton();
</span></span><span class="line"><span class="cl">                }
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        return singleton;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public Object readResolve() {
</span></span><span class="line"><span class="cl">        return singleton;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><h2 id="io模型httphollischuanggiteeiotobetopjavaerbasicsjava-basiclinux-ioidlinux-5种io模型"><a href="http://hollischuang.gitee.io/tobetopjavaer/#/basics/java-basic/linux-io?id=linux-5%E7%A7%8Dio%E6%A8%A1%E5%9E%8B">IO模型</a></h2>
<p>IO模型共有5种：阻塞IO、非阻塞IO、信号驱动IO、IO多路转接、异步IO。其中，前四个被称为同步IO。</p>
<h3 id="阻塞式io模型">阻塞式IO模型</h3>
<p>BIO（Blocking IO）：最传统的一种IO模型，即在读写数据过程中会发生阻塞现象。</p>
<p>当用户线程发出IO请求之后，内核会去查看数据是否就绪，如果没有就绪就会等待数据就绪，而用户线程就会处于阻塞状态，用户线程交出CPU。
当数据就绪之后，内核会将数据拷贝到用户线程，并返回结果给用户线程，用户线程才解除block状态。</p>
<p>特点：</p>
<ul>
<li>进程阻塞挂起不消耗CPU资源，及时响应每个操作；</li>
<li>适用并发量小的网络应用开发；</li>
</ul>
<p>因为一个请求IO会阻塞进程，不能充分利用cpu资源，所以，得为每请求分配一个处理进程（线程）以及时响应，系统开销大；不适用并发量大的应用。</p>
<h3 id="非阻塞io模型">非阻塞IO模型</h3>
<p>NIO（NoBlocking IO）：当用户线程发起一个read操作后，并不需要等待，而是马上就得到了一个结果。
如果结果是一个error时，它就知道数据还没有准备好，于是它可以再次发送read操作。
一旦内核中的数据准备好了，并且又再次收到了用户线程的请求，那么它马上就将数据拷贝到了用户线程，然后返回。</p>
<p>特点：</p>
<ul>
<li>进程轮询（重复）调用，消耗CPU的资源；</li>
<li>适用并发量较小、且不需要及时响应的网络应用开发；</li>
</ul>
<p>在非阻塞IO模型中，用户线程需要不断地询问内核数据是否就绪，也就说非阻塞IO不会交出CPU，而会一直占用CPU。</p>
<h3 id="io复用模型">IO复用模型</h3>
<p>IO复用模型: 一个线程不断去轮询多个socket的状态，只有当socket真正有读写事件时，才真正调用实际的IO读写操作。
在多路复用IO模型中，只需要使用一个线程就可以管理多个socket，系统不需要建立新的进程或者线程，也不必维护这些线程和进程，并且只有在真正有socket读写事件进行时，才会使用IO资源，所以它大大减少了资源占用。</p>
<p><a href="/iblog/posts/java/rookie-io/#nio">Java NIO</a>实际上就是多路复用IO。
通过<code>selector.select()</code>查询每个通道是否有到达事件，如果没有事件，则一直阻塞在那里，因此这种方式会导致用户线程的阻塞。所以，多路复用IO比较适合连接数比较多的情况。
<img alt="IO多路复用模型" src="/iblog/posts/annex/images/essays/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E6%A8%A1%E5%9E%8B.png"></p>
<p>特点：</p>
<ul>
<li>专一进程解决多个进程IO的阻塞问题，性能好;</li>
<li>适用高并发服务应用开发：一个进程响应多个请求；</li>
</ul>
<blockquote>
<p>多路复用IO为何比非阻塞IO模型的效率高？
因为在非阻塞IO中，不断地询问socket状态是通过用户线程去进行的，而在多路复用IO中，轮询每个socket状态是内核在进行的，这个效率要比用户线程要高的多。</p>
</blockquote>
<p>多路复用IO模型是通过轮询的方式来检测是否有事件到达，并且对到达的事件逐一进行响应。
因此对于多路复用IO模型来说，一旦事件响应体很大，那么就会导致后续的事件迟迟得不到处理，并且会影响新的事件轮询。</p>
<h3 id="信号驱动io模型">信号驱动IO模型</h3>
<p>当用户线程发起一个IO请求操作，会给对应的socket注册一个信号函数，然后用户线程会继续执行不阻塞,
当内核数据就绪时会发送一个信号给用户线程，用户线程接收到信号之后，便在信号函数中调用IO读写操作来进行实际的IO请求操作。</p>
<p>进程预先告知内核，使得当某个socket有事件发生时，系统内核使用信号通知相关进程。</p>
<p>特点：</p>
<ul>
<li>回调机制，实现、开发应用难度较大；</li>
</ul>
<h3 id="异步io模型">异步IO模型</h3>
<p>AIO（Async IO）：当用户线程发起IO操作后，立刻就可以开始去做其它的事。
另一方面，从内核的角度，当它收到一个IO请求之后，它会立刻返回给用户线程，说明IO请求已经成功发起了，因此不会对用户线程产生任何阻塞。
然后，内核会等待数据准备完成，然后将数据拷贝到用户线程，当这一切都完成之后，内核会给用户线程发送一个信号，告诉它IO操作完成了。</p>
<p>用户线程完全不需要知道实际的整个IO操作是如何进行的，只需要先发起一个请求，当接收内核返回的成功信号时表示IO操作已经完成，可以直接去使用数据了。</p>
<p>在异步IO模型中，IO操作的两个阶段都不会阻塞用户线程，这两个阶段都是由内核自动完成，然后发送一个信号告知用户线程操作已完成。</p>
<p>用户线程中不需要再次调用IO函数进行具体的读写。
这点是和信号驱动模型有所不同的，在信号驱动模型中，当用户线程接收到信号表示数据已经就绪，然后需要用户线程调用IO函数进行实际的读写操作；
而在异步IO模型中，收到信号表示IO操作已经完成，不需要再在用户线程中调用IO函数进行实际的读写操作。</p>
<p>特点：</p>
<ul>
<li>不阻塞，数据一步到位；</li>
<li>需要操作系统的底层支持，linux 2.5 版本内核首现，2.6 版本产品的内核标准特性；</li>
<li>实现、开发应用难度大，需要开发者合理控制；</li>
<li>非常适合高性能高并发应用；</li>
</ul>
<h2 id="nio">NIO</h2>
<p><code>Java NIO </code>解释为： <code>New IO</code> 或 <code>Non Blocking IO</code> 是从J ava 1.4 版本开始引入的一个新的IO API，可以替代标准的Java IO API。
NIO支持面向缓冲区的、基于通道的IO操作。NIO将以更加高效的方式进行文件的读写操作。</p>
<p>与传统IO的区别：</p>
<table>
<thead>
<tr>
<th>区别</th>
<th>IO</th>
<th>NIO</th>
</tr>
</thead>
<tbody>
<tr>
<td>传输方式</td>
<td>面向流，通过流传输</td>
<td>面向缓冲区，通过缓冲区传输</td>
</tr>
<tr>
<td>是否阻塞</td>
<td>阻塞IO</td>
<td>非阻塞IO</td>
</tr>
<tr>
<td>其他</td>
<td>无</td>
<td>选择器，可以解决阻塞问题</td>
</tr>
</tbody>
</table>
<p><img alt="IO" src="/iblog/posts/annex/images/essays/IO%E4%B8%8ENIO-1.png"></p>
<p><img alt="NIO" src="/iblog/posts/annex/images/essays/IO%E4%B8%8ENIO-2.png"></p>
<h3 id="通道与缓冲区">通道与缓冲区</h3>
<p>通道负责传输，缓冲区负责存储。</p>
<p>若需要使用 NIO ，需要获取用于连接 IO 设备的通道以及用于容纳数据的缓冲区。然后操作缓冲区，对数据进行处理。</p>
<h4 id="缓冲区">缓冲区</h4>
<p>缓冲区：在java NIO 中负者数据的存储。缓冲区底层实现是数组。用于存储不同类型的数据。
根据数据类型的不同(boolean 除外)，有以下 Buffer 常用子类：</p>
<ul>
<li>ByteBuffer</li>
<li>CharBuffer</li>
<li>ShortBuffer</li>
<li>IntBuffer</li>
<li>LongBuffer</li>
<li>FloatBuffer</li>
<li>DoubleBuffer</li>
</ul>
<h5 id="常用api及属性解析">常用API及属性解析</h5>
<p>在父类抽象类Buffer中存在四个核心属性：</p>
<ul>
<li>capacity：容量，表示缓冲区中最大存储数据的容量。一旦声明不能改变。</li>
<li>limit：界限，表示缓冲区中可以操作数据的大小。(limit后数据不能进行读写)</li>
<li>position：位置，表示缓冲区中正在操作数据的位置。</li>
<li>mark:标记，表示记录当前position位置。可以通过reset()恢复到mark的位置。</li>
</ul>
<p>大小关系：<code>0&lt;=mark&lt;=position&lt;=limit&lt;=capacity</code></p>
<p>存储数据：</p>
<ul>
<li>put():存入数据到缓冲区中</li>
<li>put(byte b)：将给定单个字节写入缓冲区的当前位置</li>
<li>put(byte[] src)：将 src 中的字节写入缓冲区的当前位置</li>
<li>put(int index, byte b)：将指定字节写入缓冲区的索引位置</li>
</ul>
<p>flip(): 切换为读取数据模式</p>
<p>读取数据：</p>
<ul>
<li>get():获取缓存区中的数据</li>
<li>get() ：读取单个字节</li>
<li>get(byte[] dst)：批量读取多个字节到 dst 中</li>
<li>get(int index)：读取指定索引位置的字节</li>
</ul>
<p>clear(): 清空缓冲区；但是缓冲区中的数据依然存在，只是将position、limit 的值回归到初始值</p>
<p>position、limit 数值变化：</p>
<ul>
<li>使用 put() 存储数据时，把 position 向前移动，移动长度为要存储数据的长度；</li>
<li>使用 filp() 切换为只读模式时，把 position 的值赋值给 limit，在将 position 的值归零；</li>
<li>使用 get() 读取数据时，在把 position 移动，移动的长度为想要读取的长度，但是要小于等于 limit 的位置；</li>
<li>使用 rewind() 切换为重读模式时，将 position、limit 恢复到使用 filp() 方法时的值；</li>
<li>使用 clear() 清空缓冲区，将position、limit 的值回归到初始值；</li>
</ul>
<p>代码演示</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public class MainTest {
</span></span><span class="line"><span class="cl">    public static void main(String[] args) {
</span></span><span class="line"><span class="cl">        String str = &#34;abcde&#34;;
</span></span><span class="line"><span class="cl">        ByteBuffer allocate = ByteBuffer.allocate(1024);
</span></span><span class="line"><span class="cl">        allocate.put(str.getBytes());
</span></span><span class="line"><span class="cl">        System.out.println(&#34;========向ByteBuffer添加数据========&#34;);
</span></span><span class="line"><span class="cl">        System.out.println(str);
</span></span><span class="line"><span class="cl">        System.out.println(&#34;capacity: &#34;+ allocate.capacity());
</span></span><span class="line"><span class="cl">        System.out.println(&#34;limit: &#34; + allocate.limit());
</span></span><span class="line"><span class="cl">        System.out.println(&#34;position: &#34; + allocate.position());
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        allocate.flip();
</span></span><span class="line"><span class="cl">        System.out.println(&#34;========切换为读取数据模式========&#34;);
</span></span><span class="line"><span class="cl">        System.out.println(&#34;capacity: &#34;+ allocate.capacity());
</span></span><span class="line"><span class="cl">        System.out.println(&#34;limit: &#34; + allocate.limit());
</span></span><span class="line"><span class="cl">        System.out.println(&#34;position: &#34; + allocate.position());
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        byte[] bytes = str.getBytes();
</span></span><span class="line"><span class="cl">        allocate.get(bytes);
</span></span><span class="line"><span class="cl">        System.out.println(&#34;========从ByteBuffer取出数据========&#34;);
</span></span><span class="line"><span class="cl">        System.out.println(new String(bytes, 0, bytes.length));
</span></span><span class="line"><span class="cl">        System.out.println(&#34;capacity: &#34;+ allocate.capacity());
</span></span><span class="line"><span class="cl">        System.out.println(&#34;limit: &#34; + allocate.limit());
</span></span><span class="line"><span class="cl">        System.out.println(&#34;position: &#34; + allocate.position());
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        allocate.rewind();
</span></span><span class="line"><span class="cl">        System.out.println(&#34;========切换重新读取数据模式========&#34;);
</span></span><span class="line"><span class="cl">        System.out.println(&#34;capacity: &#34;+ allocate.capacity());
</span></span><span class="line"><span class="cl">        System.out.println(&#34;limit: &#34; + allocate.limit());
</span></span><span class="line"><span class="cl">        System.out.println(&#34;position: &#34; + allocate.position());
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        allocate.clear();
</span></span><span class="line"><span class="cl">        System.out.println(&#34;========清空缓冲区========&#34;);
</span></span><span class="line"><span class="cl">        System.out.println(&#34;capacity: &#34;+ allocate.capacity());
</span></span><span class="line"><span class="cl">        System.out.println(&#34;limit: &#34; + allocate.limit());
</span></span><span class="line"><span class="cl">        System.out.println(&#34;position: &#34; + allocate.position());
</span></span><span class="line"><span class="cl">        System.out.println(&#34;再来读取数据：&#34; + (char)allocate.get());
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><p>mark方法: 记录当前position位置。可以通过 reset() 恢复到 mark 的位置。</p>
<p>代码演示</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-mysql" data-lang="mysql"><span class="line"><span class="cl"><span class="n">public</span><span class="w"> </span><span class="n">class</span><span class="w"> </span><span class="n">MainTest</span><span class="w"> </span><span class="err">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">public</span><span class="w"> </span><span class="n">static</span><span class="w"> </span><span class="n">void</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="p">[]</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="err">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">String</span><span class="w"> </span><span class="n">str</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">&#34;abcde&#34;</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">ByteBuffer</span><span class="w"> </span><span class="n">allocate</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ByteBuffer</span><span class="p">.</span><span class="nf">allocate</span><span class="p">(</span><span class="mi">1024</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">allocate</span><span class="p">.</span><span class="nf">put</span><span class="p">(</span><span class="n">str</span><span class="p">.</span><span class="nf">getBytes</span><span class="p">());</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">allocate</span><span class="p">.</span><span class="nf">flip</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">byte</span><span class="p">[]</span><span class="w"> </span><span class="n">bytes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">str</span><span class="p">.</span><span class="nf">getBytes</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">allocate</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="n">bytes</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="k">out</span><span class="p">.</span><span class="nf">println</span><span class="p">(</span><span class="s2">&#34;========从ByteBuffer取出数据========&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="k">out</span><span class="p">.</span><span class="nf">println</span><span class="p">(</span><span class="n">new</span><span class="w"> </span><span class="nf">String</span><span class="p">(</span><span class="n">bytes</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="k">out</span><span class="p">.</span><span class="nf">println</span><span class="p">(</span><span class="s2">&#34;capacity: &#34;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">allocate</span><span class="p">.</span><span class="nf">capacity</span><span class="p">());</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="k">out</span><span class="p">.</span><span class="nf">println</span><span class="p">(</span><span class="s2">&#34;limit: &#34;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">allocate</span><span class="p">.</span><span class="k">limit</span><span class="p">());</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="k">out</span><span class="p">.</span><span class="nf">println</span><span class="p">(</span><span class="s2">&#34;position: &#34;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">allocate</span><span class="p">.</span><span class="nf">position</span><span class="p">());</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">allocate</span><span class="p">.</span><span class="nf">mark</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="k">out</span><span class="p">.</span><span class="nf">println</span><span class="p">(</span><span class="s2">&#34;========记录当前 `position` 的位置========&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="k">out</span><span class="p">.</span><span class="nf">println</span><span class="p">(</span><span class="s2">&#34;capacity: &#34;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">allocate</span><span class="p">.</span><span class="nf">capacity</span><span class="p">());</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="k">out</span><span class="p">.</span><span class="nf">println</span><span class="p">(</span><span class="s2">&#34;limit: &#34;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">allocate</span><span class="p">.</span><span class="k">limit</span><span class="p">());</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="k">out</span><span class="p">.</span><span class="nf">println</span><span class="p">(</span><span class="s2">&#34;position: &#34;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">allocate</span><span class="p">.</span><span class="nf">position</span><span class="p">());</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">allocate</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="n">bytes</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="k">out</span><span class="p">.</span><span class="nf">println</span><span class="p">(</span><span class="s2">&#34;========从ByteBuffer再次取出数据========&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="k">out</span><span class="p">.</span><span class="nf">println</span><span class="p">(</span><span class="n">new</span><span class="w"> </span><span class="nf">String</span><span class="p">(</span><span class="n">bytes</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="k">out</span><span class="p">.</span><span class="nf">println</span><span class="p">(</span><span class="s2">&#34;capacity: &#34;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">allocate</span><span class="p">.</span><span class="nf">capacity</span><span class="p">());</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="k">out</span><span class="p">.</span><span class="nf">println</span><span class="p">(</span><span class="s2">&#34;limit: &#34;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">allocate</span><span class="p">.</span><span class="k">limit</span><span class="p">());</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="k">out</span><span class="p">.</span><span class="nf">println</span><span class="p">(</span><span class="s2">&#34;position: &#34;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">allocate</span><span class="p">.</span><span class="nf">position</span><span class="p">());</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">allocate</span><span class="p">.</span><span class="nf">reset</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="k">out</span><span class="p">.</span><span class="nf">println</span><span class="p">(</span><span class="s2">&#34;========恢复之前被标记的位置========&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="k">out</span><span class="p">.</span><span class="nf">println</span><span class="p">(</span><span class="s2">&#34;capacity: &#34;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">allocate</span><span class="p">.</span><span class="nf">capacity</span><span class="p">());</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="k">out</span><span class="p">.</span><span class="nf">println</span><span class="p">(</span><span class="s2">&#34;limit: &#34;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">allocate</span><span class="p">.</span><span class="k">limit</span><span class="p">());</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="k">out</span><span class="p">.</span><span class="nf">println</span><span class="p">(</span><span class="s2">&#34;position: &#34;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">allocate</span><span class="p">.</span><span class="nf">position</span><span class="p">());</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="err">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="err">}</span><span class="w">
</span></span></span></code></pre></div><h5 id="非直接缓冲区与直接缓冲区">非直接缓冲区与直接缓冲区</h5>
<p>直接缓冲区：通过 <code>allocateDirect()</code> 方法分配直接缓冲区，将缓冲区建立在物理内存中。可以提高读写效率。</p>
<p><img alt="直接缓冲区" src="/iblog/posts/annex/images/essays/%E7%9B%B4%E6%8E%A5%E7%BC%93%E5%86%B2%E5%8C%BA.png"></p>
<p>非直接缓冲区：通过 <code>allocate()</code> 方法分配缓冲区，将缓冲区建立在JVM的内存中。</p>
<p><code>allocate()</code>方法返回的缓冲区进行分配和取消分配所需成本通常高于非直接缓冲区 。
直接缓冲区的内容可以驻留在常规的垃圾回收堆之外.</p>
<p><img alt="非直接缓冲区" src="/iblog/posts/annex/images/essays/%E9%9D%9E%E7%9B%B4%E6%8E%A5%E7%BC%93%E5%86%B2%E5%8C%BA.png"></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public class MainTest {
</span></span><span class="line"><span class="cl">    public static void main(String[] args) {
</span></span><span class="line"><span class="cl">        ByteBuffer allocate = ByteBuffer.allocate(1024);
</span></span><span class="line"><span class="cl">        ByteBuffer direct = ByteBuffer.allocateDirect(1024);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        if (direct.isDirect()){
</span></span><span class="line"><span class="cl">            System.out.println(&#34;allocateDirect 是直接缓冲区&#34;);
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        if (!allocate.isDirect()){
</span></span><span class="line"><span class="cl">            System.out.println(&#34;allocate 是非直接缓冲区&#34;);
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><h4 id="通道">通道</h4>
<p>通道(Channel):用于源节点与目标节点的连接。在 <code>java NIO</code> 中负责缓冲区中数据的传输。Channel本身不存储数据，需要配合缓冲区进行数据传输。</p>
<p>在操作系统中，通道是一种通过执行通道程序管理I/O操作的控制器，它使主机（CPU和内存）与I/O操作之间达到更高的并行程度。
需要进行I/O操作时，CPU只需启动通道，然后可以继续执行自身程序，通道则执行通道程序，管理与实现I/O操作。</p>
<h5 id="操作通道">操作通道</h5>
<p>通道的主要实现类：</p>
<ul>
<li><code>FileChannel</code>：用于读取、写入、映射和操作文件的通道。</li>
<li><code>SocketChannel</code>：通过 TCP 读写网络中的数据。</li>
<li><code>ServerSocketChannel</code>：可以监听新进来的 TCP 连接，对每一个新进来的连接都会创建一个 <code>SocketChannel</code>。</li>
<li><code>DatagramChannel</code>：通过 UDP 读写网络中的数据通道。</li>
</ul>
<p>Java 针对支持通道的类提供了 <code>getChannel()</code> 方法</p>
<p>使用 非直接缓冲区 完成对文件的读写</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public class MainTest {
</span></span><span class="line"><span class="cl">    /**
</span></span><span class="line"><span class="cl">     * 使用非直接缓冲区完成读写操作
</span></span><span class="line"><span class="cl">     * @param args args
</span></span><span class="line"><span class="cl">     */
</span></span><span class="line"><span class="cl">    public static void main(String[] args) {
</span></span><span class="line"><span class="cl">        long start = System.currentTimeMillis();
</span></span><span class="line"><span class="cl">        try (
</span></span><span class="line"><span class="cl">                // 获取通道
</span></span><span class="line"><span class="cl">                FileChannel inChannel = new FileInputStream(&#34;1.jpg&#34;).getChannel();
</span></span><span class="line"><span class="cl">                FileChannel outChannel = new FileOutputStream(&#34;2.jpg&#34;).getChannel();
</span></span><span class="line"><span class="cl">        ) {
</span></span><span class="line"><span class="cl">            // 分配指定大小的缓冲区
</span></span><span class="line"><span class="cl">            ByteBuffer buf = ByteBuffer.allocate(1024);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            // 将通道中的数据存入缓冲区中
</span></span><span class="line"><span class="cl">            while (inChannel.read(buf) != -1) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                // 切换读取数据的模式
</span></span><span class="line"><span class="cl">                buf.flip();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                // 将缓冲区中的数据写入通道中
</span></span><span class="line"><span class="cl">                outChannel.write(buf);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                // 清空缓冲区
</span></span><span class="line"><span class="cl">                buf.clear();
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        } catch (IOException e) {
</span></span><span class="line"><span class="cl">            e.printStackTrace();
</span></span><span class="line"><span class="cl">        } finally {
</span></span><span class="line"><span class="cl">            long end = System.currentTimeMillis();
</span></span><span class="line"><span class="cl">            System.out.println(&#34;耗费的时间为：&#34; + (end - start));
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><p>使用 直接缓冲区 完成对文件的读写</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public class MainTest {
</span></span><span class="line"><span class="cl">    /**
</span></span><span class="line"><span class="cl">     * 使用直接缓冲区完成文件的读写
</span></span><span class="line"><span class="cl">     *
</span></span><span class="line"><span class="cl">     * @param args args
</span></span><span class="line"><span class="cl">     */
</span></span><span class="line"><span class="cl">    public static void main(String[] args) {
</span></span><span class="line"><span class="cl">        long start = System.currentTimeMillis();
</span></span><span class="line"><span class="cl">        try (
</span></span><span class="line"><span class="cl">                FileChannel inChannel = FileChannel.open(Paths.get(&#34;1.jpg&#34;), StandardOpenOption.READ);
</span></span><span class="line"><span class="cl">                FileChannel outChannel = FileChannel.open(Paths.get(&#34;2.jpg&#34;), StandardOpenOption.WRITE, StandardOpenOption.READ, StandardOpenOption.CREATE);
</span></span><span class="line"><span class="cl">        ) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            //内存映射文件
</span></span><span class="line"><span class="cl">            MappedByteBuffer inMappedBuf = inChannel.map(FileChannel.MapMode.READ_ONLY, 0, inChannel.size());
</span></span><span class="line"><span class="cl">            MappedByteBuffer outMappedBuf = outChannel.map(FileChannel.MapMode.READ_WRITE, 0, inChannel.size());
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            //直接对缓冲区进行数据的读写操作
</span></span><span class="line"><span class="cl">            byte[] dst = new byte[inMappedBuf.limit()];
</span></span><span class="line"><span class="cl">            inMappedBuf.get(dst);
</span></span><span class="line"><span class="cl">            outMappedBuf.put(dst);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        } catch (IOException e) {
</span></span><span class="line"><span class="cl">            e.printStackTrace();
</span></span><span class="line"><span class="cl">        } finally {
</span></span><span class="line"><span class="cl">            long end = System.currentTimeMillis();
</span></span><span class="line"><span class="cl">            System.out.println(&#34;耗费的时间为：&#34; + (end - start));
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><p>使用 通道 完成对文件的读写</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public class MainTest {
</span></span><span class="line"><span class="cl">    /**
</span></span><span class="line"><span class="cl">     * 使用通道完成读写操作
</span></span><span class="line"><span class="cl">     *
</span></span><span class="line"><span class="cl">     * @param args args
</span></span><span class="line"><span class="cl">     */
</span></span><span class="line"><span class="cl">    public static void main(String[] args) {
</span></span><span class="line"><span class="cl">        long start = System.currentTimeMillis();
</span></span><span class="line"><span class="cl">        try (
</span></span><span class="line"><span class="cl">                // 获取通道
</span></span><span class="line"><span class="cl">                FileChannel inChannel = FileChannel.open(Paths.get(&#34;1.jpg&#34;), StandardOpenOption.READ);
</span></span><span class="line"><span class="cl">                FileChannel outChannel = FileChannel.open(Paths.get(&#34;2.jpg&#34;), StandardOpenOption.WRITE, StandardOpenOption.READ, StandardOpenOption.CREATE);
</span></span><span class="line"><span class="cl">        ) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            //内存映射文件
</span></span><span class="line"><span class="cl">            MappedByteBuffer inMappedBuf = inChannel.map(FileChannel.MapMode.READ_ONLY, 0, inChannel.size());
</span></span><span class="line"><span class="cl">            MappedByteBuffer outMappedBuf = outChannel.map(FileChannel.MapMode.READ_WRITE, 0, inChannel.size());
</span></span><span class="line"><span class="cl">            
</span></span><span class="line"><span class="cl">            //直接对缓冲区进行数据的读写操作
</span></span><span class="line"><span class="cl">            byte[] dst = new byte[inMappedBuf.limit()];
</span></span><span class="line"><span class="cl">            inMappedBuf.get(dst);
</span></span><span class="line"><span class="cl">            outMappedBuf.put(dst);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        } catch (IOException e) {
</span></span><span class="line"><span class="cl">            e.printStackTrace();
</span></span><span class="line"><span class="cl">        } finally {
</span></span><span class="line"><span class="cl">            long end = System.currentTimeMillis();
</span></span><span class="line"><span class="cl">            System.out.println(&#34;耗费的时间为：&#34; + (end - start));
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><p>分散读取和聚集写入：</p>
<ul>
<li>分散读取（Scattering Reads）：将通道中的数据分散到多个缓冲区中</li>
<li>聚集写入（Gathering Writes）：将多个缓冲区中的数据聚集到通道中</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public class MainTest {
</span></span><span class="line"><span class="cl">    /**
</span></span><span class="line"><span class="cl">     * 分散和聚集
</span></span><span class="line"><span class="cl">     *
</span></span><span class="line"><span class="cl">     * @param args args
</span></span><span class="line"><span class="cl">     */
</span></span><span class="line"><span class="cl">    public static void main(String[] args) {
</span></span><span class="line"><span class="cl">        long start = System.currentTimeMillis();
</span></span><span class="line"><span class="cl">        try (
</span></span><span class="line"><span class="cl">            // 分散读取通道
</span></span><span class="line"><span class="cl">            FileChannel channel1 = new RandomAccessFile(&#34;1.txt&#34;, &#34;rw&#34;).getChannel();
</span></span><span class="line"><span class="cl">            // 聚集写入通道
</span></span><span class="line"><span class="cl">            FileChannel channel2 = new RandomAccessFile(&#34;2.txt&#34;, &#34;rw&#34;).getChannel();
</span></span><span class="line"><span class="cl">        ) {
</span></span><span class="line"><span class="cl">            // 分配指定大小的缓冲区
</span></span><span class="line"><span class="cl">            ByteBuffer buf1 = ByteBuffer.allocate(100);
</span></span><span class="line"><span class="cl">            ByteBuffer buf2 = ByteBuffer.allocate(1024);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            // 分散读取
</span></span><span class="line"><span class="cl">            ByteBuffer[] bufs = {buf1, buf2};
</span></span><span class="line"><span class="cl">            channel1.read(bufs);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            for (ByteBuffer byteBuffer : bufs) {
</span></span><span class="line"><span class="cl">                byteBuffer.flip();
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            System.out.println(new String(bufs[0].array(), 0, bufs[0].limit()));
</span></span><span class="line"><span class="cl">            System.out.println(&#34;--------------------&#34;);
</span></span><span class="line"><span class="cl">            System.out.println(new String(bufs[1].array(), 0, bufs[1].limit()));
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            // 聚集写入
</span></span><span class="line"><span class="cl">            channel2.write(bufs);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        } catch (IOException e) {
</span></span><span class="line"><span class="cl">            e.printStackTrace();
</span></span><span class="line"><span class="cl">        } finally {
</span></span><span class="line"><span class="cl">            long end = System.currentTimeMillis();
</span></span><span class="line"><span class="cl">            System.out.println(&#34;耗费的时间为：&#34; + (end - start));
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><p>解码与编码：</p>
<ul>
<li>编码：字符串转化为字符数组的过程</li>
<li>解码：字符数组转化为字符串的过程</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public class MainTest {
</span></span><span class="line"><span class="cl">    /**
</span></span><span class="line"><span class="cl">     * 编码与解码
</span></span><span class="line"><span class="cl">     *
</span></span><span class="line"><span class="cl">     * @param args args
</span></span><span class="line"><span class="cl">     */
</span></span><span class="line"><span class="cl">    public static void main(String[] args) {
</span></span><span class="line"><span class="cl">        Charset cs1 = Charset.forName(&#34;GBK&#34;);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        //获取编码器
</span></span><span class="line"><span class="cl">        CharsetEncoder ce = cs1.newEncoder();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        //获取解码器
</span></span><span class="line"><span class="cl">        CharsetDecoder cd = cs1.newDecoder();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        CharBuffer cBuf = CharBuffer.allocate(1024);
</span></span><span class="line"><span class="cl">        cBuf.put(&#34;阿伟死了&#34;);
</span></span><span class="line"><span class="cl">        cBuf.flip();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        ByteBuffer bBuf;
</span></span><span class="line"><span class="cl">        try {
</span></span><span class="line"><span class="cl">            //编码
</span></span><span class="line"><span class="cl">            bBuf = ce.encode(cBuf);
</span></span><span class="line"><span class="cl">            for (int i = 0; i &lt; 8; i++) {
</span></span><span class="line"><span class="cl">                System.out.println(bBuf.get());
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">            bBuf.flip();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            //解码
</span></span><span class="line"><span class="cl">            CharBuffer cBuf2 = cd.decode(bBuf);
</span></span><span class="line"><span class="cl">            System.out.println(cBuf2.toString());
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        } catch (CharacterCodingException e) {
</span></span><span class="line"><span class="cl">            e.printStackTrace();
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><h3 id="阻塞与非阻塞网络通信">阻塞与非阻塞网络通信</h3>
<h4 id="阻塞">阻塞</h4>
<p>传统的 IO 流都是阻塞式的。
就是说，当一个线程调用 <code>read()</code> 或 <code>write()</code> 时，该线程被阻塞，直到有一些数据被读取或写入，该线程在此期间不能执行其他任务。
因此，在完成网络通信进行 IO 操作时，由于线程会阻塞，所以服务器端必须为每个客户端都提供一个独立的线程进行处理，当服务器端需要处理大量客户端时，性能急剧下降。</p>
<p>阻塞式IO,代码演示</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">class Client {
</span></span><span class="line"><span class="cl">    public static void main(String[] args) throws IOException {
</span></span><span class="line"><span class="cl">        System.out.println(&#34;启动客户端 ...&#34;);
</span></span><span class="line"><span class="cl">        client();
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    /**
</span></span><span class="line"><span class="cl">     * 阻塞NIO 客户端
</span></span><span class="line"><span class="cl">     */
</span></span><span class="line"><span class="cl">    public static void client() throws IOException {
</span></span><span class="line"><span class="cl">        SocketChannel sChannel=SocketChannel.open(new InetSocketAddress(&#34;127.0.0.1&#34;,9898));
</span></span><span class="line"><span class="cl">        FileChannel inChannel=FileChannel.open(Paths.get(&#34;/Users/whitepure/Desktop/1.txt&#34;), StandardOpenOption.READ);
</span></span><span class="line"><span class="cl">        ByteBuffer buf=ByteBuffer.allocate(1024);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        while(inChannel.read(buf)!=-1){
</span></span><span class="line"><span class="cl">            buf.flip();
</span></span><span class="line"><span class="cl">            sChannel.write(buf);
</span></span><span class="line"><span class="cl">            buf.clear();
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        //关闭发送通道，表明发送完毕
</span></span><span class="line"><span class="cl">        sChannel.shutdownOutput();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        //接收服务端的反馈
</span></span><span class="line"><span class="cl">        int len=0;
</span></span><span class="line"><span class="cl">        while((len=sChannel.read(buf))!=-1){
</span></span><span class="line"><span class="cl">            buf.flip();
</span></span><span class="line"><span class="cl">            System.out.println(new String(buf.array(),0,len));
</span></span><span class="line"><span class="cl">            buf.clear();
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        inChannel.close();
</span></span><span class="line"><span class="cl">        sChannel.close();
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">class Server {
</span></span><span class="line"><span class="cl">    public static void main(String[] args) throws IOException {
</span></span><span class="line"><span class="cl">        System.out.println(&#34;启动服务端 ...&#34;);
</span></span><span class="line"><span class="cl">        server();
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    /**
</span></span><span class="line"><span class="cl">     * 阻塞IO 服务器方
</span></span><span class="line"><span class="cl">     */
</span></span><span class="line"><span class="cl">    public static void server() throws IOException{
</span></span><span class="line"><span class="cl">        ServerSocketChannel ssChannel=ServerSocketChannel.open();
</span></span><span class="line"><span class="cl">        FileChannel outChannel=FileChannel.open(Paths.get(&#34;/Users/whitepure/Desktop/2.txt&#34;), StandardOpenOption.WRITE,StandardOpenOption.CREATE);
</span></span><span class="line"><span class="cl">        ssChannel.bind(new InetSocketAddress(9898));
</span></span><span class="line"><span class="cl">        SocketChannel sChannel=ssChannel.accept();
</span></span><span class="line"><span class="cl">        ByteBuffer buf=ByteBuffer.allocate(1024);
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        while(sChannel.read(buf)!=-1){
</span></span><span class="line"><span class="cl">            buf.flip();
</span></span><span class="line"><span class="cl">            outChannel.write(buf);
</span></span><span class="line"><span class="cl">            buf.clear();
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        //发送反馈给客户端
</span></span><span class="line"><span class="cl">        buf.put(&#34;服务端接收数据成功&#34;.getBytes());
</span></span><span class="line"><span class="cl">        buf.flip();
</span></span><span class="line"><span class="cl">        sChannel.write(buf);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        sChannel.close();
</span></span><span class="line"><span class="cl">        outChannel.close();
</span></span><span class="line"><span class="cl">        ssChannel.close();
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><h4 id="非阻塞">非阻塞</h4>
<p>Java NIO 是非阻塞模式的。
当线程从某通道进行读写数据时，若没有数据可用时，该线程可以进行其他任务。线程通常将非阻塞 IO 的空闲时间用于在其他通道上执行 IO 操作，所以单独的线程可以管理多个输入和输出通道。
因此，NIO 可以让服务器端使用一个或有限几个线程来同时处理连接到服务器端的所有客户端。</p>
<p>非阻塞式IO,代码演示</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">class Client {
</span></span><span class="line"><span class="cl">    public static void main(String[] args) throws IOException {
</span></span><span class="line"><span class="cl">        System.out.println(&#34;启动客户端 ... 等待输入 ...&#34;);
</span></span><span class="line"><span class="cl">        client();
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    /**
</span></span><span class="line"><span class="cl">     * 非阻塞NIO 客户端
</span></span><span class="line"><span class="cl">     */
</span></span><span class="line"><span class="cl">    public static void client() throws IOException {
</span></span><span class="line"><span class="cl">        SocketChannel sChannel = SocketChannel.open(new InetSocketAddress(&#34;127.0.0.1&#34;, 9898));
</span></span><span class="line"><span class="cl">        ByteBuffer buf = ByteBuffer.allocate(1024);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        Scanner scanner = new Scanner(System.in);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        // 发送数据到服务方
</span></span><span class="line"><span class="cl">        while (scanner.hasNextLine()) {
</span></span><span class="line"><span class="cl">            buf.put((LocalDate.now() + &#34;\n&#34; + scanner.next()).getBytes());
</span></span><span class="line"><span class="cl">            buf.flip();
</span></span><span class="line"><span class="cl">            sChannel.write(buf);
</span></span><span class="line"><span class="cl">            buf.clear();
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        sChannel.close();
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">class Server {
</span></span><span class="line"><span class="cl">    public static void main(String[] args) throws IOException {
</span></span><span class="line"><span class="cl">        System.out.println(&#34;启动服务端 ... 等待客户端请求 ...&#34;);
</span></span><span class="line"><span class="cl">        server();
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    /**
</span></span><span class="line"><span class="cl">     * 非阻塞IO 服务器方
</span></span><span class="line"><span class="cl">     */
</span></span><span class="line"><span class="cl">    public static void server() throws IOException {
</span></span><span class="line"><span class="cl">        ServerSocketChannel ssChannel = ServerSocketChannel.open();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        // 切换为非阻塞模式
</span></span><span class="line"><span class="cl">        ssChannel.configureBlocking(false);
</span></span><span class="line"><span class="cl">        // 绑定链接
</span></span><span class="line"><span class="cl">        ssChannel.bind(new InetSocketAddress(9898));
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        // 获取选择器
</span></span><span class="line"><span class="cl">        Selector selector = Selector.open();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        /**
</span></span><span class="line"><span class="cl">         * 将通道注册到选择器上，并且指定“监听接收事件”
</span></span><span class="line"><span class="cl">         * 使用 SelectionKey 的四个常量 表示
</span></span><span class="line"><span class="cl">         *
</span></span><span class="line"><span class="cl">         * 读 : SelectionKey.OP_READ （1）
</span></span><span class="line"><span class="cl">         * 写 : SelectionKey.OP_WRITE （4）
</span></span><span class="line"><span class="cl">         * 连接 : SelectionKey.OP_CONNECT （8）
</span></span><span class="line"><span class="cl">         * 接收 : SelectionKey.OP_ACCEPT （16）
</span></span><span class="line"><span class="cl">         *
</span></span><span class="line"><span class="cl">         * 若注册时不止监听一个事件，则可以使用“位或”操作符连接。
</span></span><span class="line"><span class="cl">         */
</span></span><span class="line"><span class="cl">        SelectionKey selectionKey = ssChannel.register(selector, SelectionKey.OP_ACCEPT);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        // 轮巡获取 注册器上的接收事件
</span></span><span class="line"><span class="cl">        while (selector.select() &gt; 0) {
</span></span><span class="line"><span class="cl">            // 获取当前选择器中所有注册的“选择键（已就绪的监听事件）”
</span></span><span class="line"><span class="cl">            Iterator&lt;SelectionKey&gt; it = selector.selectedKeys().iterator();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            while (it.hasNext()) {
</span></span><span class="line"><span class="cl">                // 获取准备“就绪”的事件
</span></span><span class="line"><span class="cl">                SelectionKey sk = it.next();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                // 判断具体是什么时间准备就绪
</span></span><span class="line"><span class="cl">                if (sk.isAcceptable()) {
</span></span><span class="line"><span class="cl">                    // 若“接收就绪”，获取客户端连接
</span></span><span class="line"><span class="cl">                    SocketChannel sChannel = ssChannel.accept();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                    // 切换非阻塞模式
</span></span><span class="line"><span class="cl">                    sChannel.configureBlocking(false);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                    // 将该通道注册到选择器上
</span></span><span class="line"><span class="cl">                    sChannel.register(selector, SelectionKey.OP_READ);
</span></span><span class="line"><span class="cl">                } else if (sk.isReadable()) {
</span></span><span class="line"><span class="cl">                    // 获取当前选择器上“读就绪”状态的通道
</span></span><span class="line"><span class="cl">                    SocketChannel sChannel = (SocketChannel) sk.channel();
</span></span><span class="line"><span class="cl">                    // 读取数据
</span></span><span class="line"><span class="cl">                    ByteBuffer buf = ByteBuffer.allocate(1024);
</span></span><span class="line"><span class="cl">                    int len = 0;
</span></span><span class="line"><span class="cl">                    while ((len = sChannel.read(buf)) &gt; 0) {
</span></span><span class="line"><span class="cl">                        buf.flip();
</span></span><span class="line"><span class="cl">                        System.out.println(new String(buf.array(), 0, len));
</span></span><span class="line"><span class="cl">                        buf.clear();
</span></span><span class="line"><span class="cl">                    }
</span></span><span class="line"><span class="cl">                }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                // 移除注册的选择键，否则会一直轮巡获取
</span></span><span class="line"><span class="cl">                it.remove();
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><h4 id="通道-1">通道</h4>
<p>Java NIO 管道是2个线程之间的<strong>单向</strong>数据连接。Pipe有一个source通道和一个sink通道。数据会被写到sink通道，从source通道读取。</p>
<p>代码演示</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public class MainTest {
</span></span><span class="line"><span class="cl">    public static void main(String[] args) throws IOException {
</span></span><span class="line"><span class="cl">        //1.获取管道
</span></span><span class="line"><span class="cl">        Pipe pipe= Pipe.open();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        //2.将缓冲区中的数据写入管道
</span></span><span class="line"><span class="cl">        ByteBuffer buf= ByteBuffer.allocate(1024);
</span></span><span class="line"><span class="cl">        Pipe.SinkChannel sinkChannel=pipe.sink();
</span></span><span class="line"><span class="cl">        buf.put(&#34;通过单向管道发送数据&#34;.getBytes());
</span></span><span class="line"><span class="cl">        buf.flip();
</span></span><span class="line"><span class="cl">        sinkChannel.write(buf);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        //3.读取缓冲区中的数据
</span></span><span class="line"><span class="cl">        Pipe.SourceChannel sourceChannel=pipe.source();
</span></span><span class="line"><span class="cl">        buf.flip();
</span></span><span class="line"><span class="cl">        int len=sourceChannel.read(buf);
</span></span><span class="line"><span class="cl">        System.out.println(new String(buf.array(),0,len));
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        sourceChannel.close();
</span></span><span class="line"><span class="cl">        sinkChannel.close();
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div></div>
                    <div id="post_footer" class="post_footer">
                        <div class="meta">
                            
                            <div id="post_footer_info" class="info">
                                <span class="field tags">
                                    <i class="ri-stack-line"></i>
                                    
                                        
                                        <a href="https://whiteppure.github.io/iblog/tags/java/">Java</a>
                                    
                                        <a href="https://whiteppure.github.io/iblog/tags/java%E5%9F%BA%E7%A1%80/">Java基础</a>
                                    
                                    
                                </span>
                            </div>
                        </div>
                    </div>
                </div>
                
                
                
<div id="doc_comments" class="doc_comments">
    <div class="comments_block_title">发表评论</div>
    <div id="vcomments"></div>
</div>

<link rel="stylesheet" href="https://whiteppure.github.io/iblog/css/comments.css" />

<script src='//unpkg.com/valine/dist/Valine.min.js'></script>

<script type="text/javascript">
    new Valine({
        el: '#vcomments',
        appId: 'pRSrjsfbN6L1DUxgfqJWOMYP-gzGzoHsz',
        appKey: 'VPWpnDPGDM8Xhdlh5OvHOpak',
        placeholder: '说点什么吧...',
        visitor: 'true',
        
        emojiCDN: '//i0.hdslb.com/bfs/emote/',
        
        emojiMaps: {
            "tv_doge": "6ea59c827c414b4a2955fe79e0f6fd3dcd515e24.png",
            "tv_亲亲": "a8111ad55953ef5e3be3327ef94eb4a39d535d06.png",
            "tv_偷笑": "bb690d4107620f1c15cff29509db529a73aee261.png",
            "tv_再见": "180129b8ea851044ce71caf55cc8ce44bd4a4fc8.png",
            "tv_冷漠": "b9cbc755c2b3ee43be07ca13de84e5b699a3f101.png",
            "tv_发怒": "34ba3cd204d5b05fec70ce08fa9fa0dd612409ff.png",
            "tv_发财": "34db290afd2963723c6eb3c4560667db7253a21a.png",
            "tv_可爱": "9e55fd9b500ac4b96613539f1ce2f9499e314ed9.png",
            "tv_吐血": "09dd16a7aa59b77baa1155d47484409624470c77.png",
            "tv_呆": "fe1179ebaa191569b0d31cecafe7a2cd1c951c9d.png",
            "tv_呕吐": "9f996894a39e282ccf5e66856af49483f81870f3.png",
            "tv_困": "241ee304e44c0af029adceb294399391e4737ef2.png",
            "tv_坏笑": "1f0b87f731a671079842116e0991c91c2c88645a.png",
            "tv_大佬": "093c1e2c490161aca397afc45573c877cdead616.png",
            "tv_大哭": "23269aeb35f99daee28dda129676f6e9ea87934f.png",
            "tv_委屈": "d04dba7b5465779e9755d2ab6f0a897b9b33bb77.png",
            "tv_害羞": "a37683fb5642fa3ddfc7f4e5525fd13e42a2bdb1.png",
            "tv_尴尬": "7cfa62dafc59798a3d3fb262d421eeeff166cfa4.png",
            "tv_微笑": "70dc5c7b56f93eb61bddba11e28fb1d18fddcd4c.png",
            "tv_思考": "90cf159733e558137ed20aa04d09964436f618a1.png",
            "tv_惊吓": "0d15c7e2ee58e935adc6a7193ee042388adc22af.png",
            "tv_打脸": "56ab10b624063e966bfcb76ea5dc4794d87dfd47.png",
            "tv_抓狂": "fe31c08edad661d63762b04e17b8d5ae3c71a757.png",
            "tv_抠鼻": "c666f55e88d471e51bbd9fab9bb308110824a6eb.png",
            "tv_斜眼笑": "911f987aa8bc1bee12d52aafe62bc41ef4474e6c.png",
            "tv_无奈": "ea8ed89ee9878f2fece2dda0ea8a5dbfe21b5751.png",
            "tv_晕": "5443c22b4d07fb1907ccc610c8e6db254f2461b7.png",
            "tv_流汗": "cead1c351ab8d79e9f369605beb90148db0fbed3.png",
            "tv_流泪": "7e71cde7858f0cd50d74b0264aa26db612a8a167.png",
            "tv_流鼻血": "c32d39db2737f89b904ca32700d140a9241b0767.png",
            "tv_点赞": "f85c354995bd99e28fc76c869bfe42ba6438eff4.png",
            "tv_生气": "26702dcafdab5e8225b43ffd23c94ac1ff932654.png",
            "tv_生病": "8b0ec90e6b86771092a498c54f09fc94621c1900.png",
            "tv_疑问": "0793d949b18d7be716078349c202c15ff166f314.png",
            "tv_白眼": "c1d59f439e379ee50eef488bcb5e5378e5044ea4.png",
            "tv_皱眉": "72ccad6679fea0d14cce648b4d818e09b8ffea2d.png",
            "tv_目瞪口呆": "0b8cb81a68de5d5365212c99375e7ace3e7891b7.png",
            "tv_睡着": "8b196675b53af58264f383c50ad0945048290b33.png",
            "tv_笑哭": "1abc628f6d4f4caf9d0e7800878f4697abbc8273.png",
            "tv_腼腆": "89712c0d4af73e67f89e35cbc518420380a7f6f4.png",
            "tv_色": "61822c7e9aae5da76475e7892534545336b23a6f.png",
            "tv_调侃": "4bc022533ef31544ca0d72c12c808cf4a1cce3e3.png",
            "tv_调皮": "b9c41de8e82dd7a8515ae5e3cb63e898bf245186.png",
            "tv_鄙视": "6e72339f346a692a495b123174b49e4e8e781303.png",
            "tv_闭嘴": "c9e990da7f6e93975e25fd8b70e2e290aa4086ef.png",
            "tv_难过": "87f46748d3f142ebc6586ff58860d0e2fc8263ba.png",
            "tv_馋": "fc7e829b845c43c623c8b490ee3602b7f0e76a31.png",
            "tv_鬼脸": "0ffbbddf8a94d124ca2f54b360bbc04feb6bbfea.png",
            "tv_黑人问号": "45821a01f51bc867da9edbaa2e070410819a95b2.png",
            "tv_鼓掌": "1d21793f96ef4e6f48b23e53e3b9e42da833a0f6.png"
        }
    })
</script>

                
            </div>
        </div>
    </div>
    
<a id="search-btn" style="display: inline-block;" href="javascript:void(0);">
    <span class="ri-search-line"></span>
</a>
<div id="fastSearch">
    <input id="searchInput" tabindex="0" autocomplete="off">
    <ul id="searchResults"></ul>
</div>
<div class="side_nav">
    
    <a id="top_to_back" href="#" class="top_to_back">
        <svg t="1688614744062" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2152" width="16" height="16"><path d="M966.4 323.2c-9.6-9.6-25.6-9.6-35.2 0l-416 416-425.6-416c-9.6-9.6-25.6-9.6-35.2 0-9.6 9.6-9.6 25.6 0 35.2l441.6 432c9.6 9.6 25.6 9.6 35.2 0l435.2-432C976 345.6 976 332.8 966.4 323.2z" p-id="2153" fill="#424242"></path></svg>    </a>
    
    <div>
        <a id="content_display" class="content_display">
            <svg t="1688606941910" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="57753" width="18" height="18"><path d="M192 448c10.9 0 21.8-4.2 30.2-12.5L497 160.8c5.4-5.4 11.8-6.2 15.1-6.2 3.3 0 9.6 0.8 15.1 6.2l274.7 274.7c16.7 16.7 43.7 16.7 60.3 0 16.7-16.7 16.7-43.7 0-60.3L587.4 100.4c-41.6-41.6-109.3-41.6-150.9 0L161.8 375.2c-16.7 16.7-16.7 43.7 0 60.3 8.4 8.3 19.3 12.5 30.2 12.5zM801.8 588.5L527.1 863.2c-5.4 5.4-11.8 6.2-15.1 6.2-3.3 0-9.7-0.8-15.1-6.2L222.2 588.5c-16.7-16.7-43.7-16.7-60.3 0-16.7 16.7-16.7 43.7 0 60.3l274.8 274.8c20.8 20.8 48.1 31.2 75.4 31.2 27.3 0 54.6-10.4 75.4-31.2l274.7-274.8c16.7-16.7 16.7-43.7 0-60.3-16.7-16.7-43.7-16.7-60.4 0z" fill="#424242" p-id="57754"></path></svg>
        </a>
        <a id="content_hidden" class="content_hidden">
            <svg t="1688603143752" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="15592" width="18" height="18"><path d="M479.004101 645.938677L165.25229 958.480465a37.510709 37.510709 0 0 0 0 54.059551 36.47863 36.47863 0 0 0 53.063061 0l293.679668-292.576411 293.715256 292.576411a36.443042 36.443042 0 0 0 53.063061 0 37.510709 37.510709 0 0 0 0-54.059551l-313.751811-312.541788c-21.210989-22.349834-36.514219-24.698702-66.017424 0z m66.053013-267.877709l312.577377-312.541789a37.510709 37.510709 0 0 0 0-54.059551 36.443042 36.443042 0 0 0-53.063061 0l-292.505234 292.576411L219.560963 11.459628a36.47863 36.47863 0 0 0-53.063061 0 37.510709 37.510709 0 0 0 0 54.059551l312.577377 312.541789a46.58588 46.58588 0 0 0 65.981835-0.035589z" p-id="15593" fill="#424242"></path></svg>
        </a>
    </div>
    
    <a id="back_to_top" href="#" class="back_to_top">
        <svg t="1688628374733" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3166" width="16" height="16"><path d="M966.4 668.8l-435.2-432c-9.6-9.6-25.6-9.6-35.2 0l-441.6 432c-9.6 9.6-9.6 25.6 0 35.2 9.6 9.6 25.6 9.6 35.2 0l425.6-416 416 416c9.6 9.6 25.6 9.6 35.2 0S976 678.4 966.4 668.8z" p-id="3167" fill="#424242"></path></svg>
    </a>
</div>
    <footer class="footer">
    <div id="footer_powered_by" class="powered_by">
        <a href="https://varkai.com">Designed by VarKai,</a>
        <a href="http://www.gohugo.io/">Proudly published with Hugo</a>
    </div>

    <div id="footer_slogan" class="footer_slogan">
        <span>from 2021</span>
    </div>
</footer>
    <script src="https://whiteppure.github.io/iblog/js/jquery-3.5.1.min.js"></script>
<link href="https://whiteppure.github.io/iblog/css/fancybox.min.css" rel="stylesheet">
<script src="https://whiteppure.github.io/iblog/js/fancybox.min.js"></script>
<script src="https://whiteppure.github.io/iblog/js/darkmode.js"></script>
<script src="https://whiteppure.github.io/iblog/js/zozo.js"></script>
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="https://whiteppure.github.io/iblog/js/busuanzi_2.3_busuanzi.pure.mini.js"></script>
<script src="https://whiteppure.github.io/iblog/js/html2canvas.js"></script>
<script src="https://whiteppure.github.io/iblog/js/utils.js"></script>
<script src="https://whiteppure.github.io/iblog/js/html2md.js"></script>
<script src="https://whiteppure.github.io/iblog/js/htmlexport.js"></script>

<script src="https://whiteppure.github.io/iblog/js/fastsearch.js"></script>
<script src="https://whiteppure.github.io/iblog/js/fuse.js"></script>


<script>
    new Darkmode({
        right: '32px', 
        bottom: 'unset', 
        
        time: '0.15s', 
        mixColor: '#f7f7f7', 
        backgroundColor: '#f7f7f7', 
        buttonColorDark: '#212121', 
        buttonColorLight: '#f7f7f7', 
        saveInCookies: false, 
        autoMatchOsTheme: true 
    }).showWidget();

    function addDarkmodeWidget(){
        const hours = new Date().getHours();
        if (hours >= 19 || hours <= 5){
            new Darkmode({
                right: '32px', 
                bottom: 'unset', 
                
                time: '0.3s', 
                mixColor: '#f7f7f7', 
                backgroundColor: '#f7f7f7', 
                buttonColorDark: '#212121', 
                buttonColorLight: '#f7f7f7', 
                saveInCookies: false, 
                autoMatchOsTheme: true 
            }).toggle();
        }
    }
    
    
</script>









</body>

</html>