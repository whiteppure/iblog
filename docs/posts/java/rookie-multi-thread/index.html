<!DOCTYPE html>
<html lang="zh" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="whitepure" />
	
	
	
	<title>Java多线程 ｜ 脚踏实地</title>
	
    
    
    <meta name="description" content="相关概念 线程与进程 进程是一个具有一定独立功能的程序关于某个数据集合的一次运行活动。例如，一个正在运行的程序的实例就是一个进程。 线程是操作系统能够进行运算调度的最" />
    

    
    
    <meta name="keywords" content="whitepure博客, whiteppure, whitepure, 李济芝, Java, 博客, 技术博客" />
    

	

    <link rel="shortcut icon" href="https://whiteppure.github.io/iblog/images/favicon.ico" />

    <link rel="stylesheet" type="text/css" media="screen" href="https://whiteppure.github.io/iblog/css/normalize.css" />

    <link rel="stylesheet" type="text/css" media="screen" href="https://whiteppure.github.io/iblog/css/animate.min.css" />
    <link rel="stylesheet" type="text/css" media="screen" href="https://whiteppure.github.io/iblog/css/zozo.css" />
	<link rel="stylesheet" type="text/css" media="screen" href="https://cdn.jsdelivr.net/npm/remixicon@2.5.0/fonts/remixicon.css" />
    <link rel="stylesheet" type="text/css" media="screen" href="https://whiteppure.github.io/iblog/css/highlight.css" />

    <link rel="stylesheet" type="text/css" media="screen" href="https://whiteppure.github.io/iblog/css/toc.css" />
    <link rel="stylesheet" type="text/css" media="screen" href="https://whiteppure.github.io/iblog/css/search.css" />
    <link rel="stylesheet" type="text/css" media="screen" href="https://whiteppure.github.io/iblog/css/img.css" />

    
    
</head>

<body>
    <div class="post-password">
        
    </div>

    
    
    









<div id="post_content_toc" class="toc">
    <div class="page-header"><strong></strong></div>
    <div id="page-scrollspy" class="toc-nav">

        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e7%9b%b8%e5%85%b3%e6%a6%82%e5%bf%b5">
                    相关概念
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e7%ba%bf%e7%a8%8b%e4%b8%8e%e8%bf%9b%e7%a8%8b">
                    线程与进程
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e5%b9%b6%e8%a1%8c%e4%b8%b2%e8%a1%8c%e5%b9%b6%e5%8f%91">
                    并行、串行、并发
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e5%90%8c%e6%ad%a5%e4%b8%8e%e5%bc%82%e6%ad%a5">
                    同步与异步
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e5%ae%88%e6%8a%a4%e7%ba%bf%e7%a8%8b">
                    守护线程
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e7%ba%bf%e7%a8%8b%e7%9a%84%e7%8a%b6%e6%80%81">
                    线程的状态
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e7%ba%bf%e7%a8%8b%e7%9b%b8%e5%85%b3%e6%96%b9%e6%b3%95">
                    线程相关方法
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e5%88%9b%e5%bb%ba%e7%ba%bf%e7%a8%8b">
                    创建线程
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#thread%e7%b1%bb">
                    Thread类
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#runnable%e6%8e%a5%e5%8f%a3">
                    Runnable接口
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#callable%e6%8e%a5%e5%8f%a3">
                    Callable接口
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e7%ba%bf%e7%a8%8b%e6%b1%a0">
                    线程池
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e5%88%9b%e5%bb%ba%e6%96%b9%e5%bc%8f">
                    创建方式
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e8%87%aa%e5%ae%9a%e4%b9%89%e7%ba%bf%e7%a8%8b%e6%b1%a0">
                    自定义线程池
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e7%ba%bf%e7%a8%8b%e6%b1%a0%e5%b7%a5%e4%bd%9c%e5%8e%9f%e7%90%86">
                    线程池工作原理
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e9%98%bb%e5%a1%9e%e9%98%9f%e5%88%97">
                    阻塞队列
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e7%ba%bf%e7%a8%8b%e6%b1%a0%e5%8f%82%e6%95%b0">
                    线程池参数
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e5%90%88%e7%90%86%e9%85%8d%e7%bd%ae%e7%ba%bf%e7%a8%8b%e6%b1%a0%e5%8f%82%e6%95%b0">
                    合理配置线程池参数
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e9%94%81">
                    锁
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e5%85%ac%e5%b9%b3%e9%94%81%e4%b8%8e%e9%9d%9e%e5%85%ac%e5%b9%b3%e9%94%81">
                    公平锁与非公平锁
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e5%8f%af%e9%87%8d%e5%85%a5%e9%94%81%e4%b8%8e%e4%b8%8d%e5%8f%af%e9%87%8d%e5%85%a5%e9%94%81">
                    可重入锁与不可重入锁
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e5%85%b1%e4%ba%ab%e9%94%81%e4%b8%8e%e7%8b%ac%e5%8d%a0%e9%94%81">
                    共享锁与独占锁
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e6%82%b2%e8%a7%82%e9%94%81%e4%b8%8e%e4%b9%90%e8%a7%82%e9%94%81">
                    悲观锁与乐观锁
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e8%87%aa%e6%97%8b%e9%94%81%e4%b8%8e%e9%80%82%e5%ba%94%e6%80%a7%e8%87%aa%e6%97%8b%e9%94%81">
                    自旋锁与适应性自旋锁
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e5%81%8f%e5%90%91%e9%94%81">
                    偏向锁
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e8%bd%bb%e9%87%8f%e7%ba%a7%e9%94%81%e4%b8%8e%e9%87%8d%e9%87%8f%e7%ba%a7%e9%94%81">
                    轻量级锁与重量级锁
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e5%8f%af%e4%b8%ad%e6%96%ad%e9%94%81">
                    可中断锁
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e4%ba%92%e6%96%a5%e9%94%81">
                    互斥锁
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e6%ad%bb%e9%94%81">
                    死锁
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e4%bd%bf%e7%94%a8%e8%b5%84%e6%ba%90%e6%9c%89%e5%ba%8f%e5%88%86%e9%85%8d%e6%b3%95%e9%81%bf%e5%85%8d%e6%ad%bb%e9%94%81">
                    使用资源有序分配法避免死锁
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e4%bd%bf%e7%94%a8%e9%93%b6%e8%a1%8c%e5%ae%b6%e7%ae%97%e6%b3%95%e9%81%bf%e5%85%8d%e6%ad%bb%e9%94%81">
                    使用银行家算法避免死锁
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e4%bd%bf%e7%94%a8trylock%e8%bf%9b%e8%a1%8c%e8%b6%85%e6%97%b6%e9%94%81%e5%ae%9a">
                    使用tryLock进行超时锁定
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e7%ba%bf%e7%a8%8b%e5%ae%89%e5%85%a8">
                    线程安全
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e4%b8%89%e5%a4%a7%e7%89%b9%e6%80%a7">
                    三大特性
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e5%86%85%e5%ad%98%e6%a8%a1%e5%9e%8b">
                    内存模型
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#volatile">
                    volatile
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e4%bd%bf%e7%94%a8%e6%a1%88%e4%be%8b">
                    使用案例
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e5%8e%9f%e7%90%86">
                    原理
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#volatile%e4%b8%8e%e5%8f%af%e8%a7%81%e6%80%a7">
                    volatile与可见性
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#volatile%e4%b8%8e%e5%8e%9f%e5%ad%90%e6%80%a7">
                    volatile与原子性
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#volatile%e4%b8%8e%e6%9c%89%e5%ba%8f%e6%80%a7">
                    volatile与有序性
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#cas">
                    CAS
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e5%8e%9f%e7%90%86-1">
                    原理
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e5%a6%82%e4%bd%95%e4%bf%9d%e8%af%81%e6%95%b0%e6%8d%ae%e4%b8%80%e8%87%b4%e6%80%a7">
                    如何保证数据一致性
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#cas%e4%b8%8eunsafe%e5%85%b3%e7%b3%bb">
                    CAS与Unsafe关系
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e7%bc%ba%e7%82%b9">
                    缺点
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#juc">
                    J.U.C.
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e4%bd%bf%e7%94%a8">
                    使用
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#locksupport">
                    LockSupport
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#aqs">
                    AQS
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#reentrantlock%e5%8e%9f%e7%90%86">
                    ReentrantLock原理
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#countdownlatch">
                    CountDownLatch
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#cyclicbarrier">
                    CyclicBarrier
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#semaphore">
                    Semaphore
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#synchronized">
                    synchronized
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e4%bd%bf%e7%94%a8-1">
                    使用
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e5%8e%9f%e7%90%86-2">
                    原理
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e9%94%81%e7%9a%84%e5%8d%87%e7%ba%a7">
                    锁的升级
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#synchronized%e4%b8%8e%e5%8f%af%e8%a7%81%e6%80%a7">
                    synchronized与可见性
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#synchronized%e4%b8%8e%e5%8e%9f%e5%ad%90%e6%80%a7">
                    synchronized与原子性
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#synchronized%e4%b8%8e%e6%9c%89%e5%ba%8f%e6%80%a7">
                    synchronized与有序性
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#synchronized%e4%b8%8ereentrantlock">
                    synchronized与ReentrantLock
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#threadlocal">
                    ThreadLocal
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e4%bd%bf%e7%94%a8-2">
                    使用
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e4%b8%8e%e5%90%8c%e6%ad%a5%e6%9c%ba%e5%88%b6">
                    与同步机制
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e5%8e%9f%e7%90%86-3">
                    原理
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e5%86%85%e5%ad%98%e6%b3%84%e6%bc%8f%e9%97%ae%e9%a2%98">
                    内存泄漏问题
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e5%b8%b8%e7%94%a8%e7%9a%84%e7%ba%bf%e7%a8%8b%e5%ae%89%e5%85%a8%e7%9a%84%e9%9b%86%e5%90%88">
                    常用的线程安全的集合
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#arraylist">
                    ArrayList
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#copywritearraylist">
                    CopyWriteArrayList
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#hashset">
                    HashSet
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#hashmap">
                    HashMap
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#hashtable">
                    HashTable
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#concurrenthashmap">
                    ConcurrentHashMap
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e5%8f%82%e8%80%83%e6%96%87%e7%ab%a0">
                    参考文章
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        
        
        

    </div>

</div>



    

    
    <div class="main animate__animated animate__fadeInDown" id="main_content">
        <div class="nav_container animated fadeInDown">
    <div class="site_nav" id="site_nav">
        <ul><li class="">
                <a href="https://whiteppure.github.io/iblog/">首页</a>
            </li><li class="">
                <a href="https://whiteppure.github.io/iblog/posts/">归档</a>
            </li><li class="">
                <a href="https://whiteppure.github.io/iblog/tags/">标签</a>
            </li><li class="">
                <a href="https://whiteppure.github.io/iblog/about/">关于</a>
            </li>
        </ul>
    </div>
    <div class="menu_icon">
        <a id="menu_icon"><i class="ri-menu-line"></i></a>
    </div>
</div>
        <div id="post_header" class="header animated fadeInDown">
    <div class="site_title_container">
        <div class="site_title">
            <h1>
                <a href="https://whiteppure.github.io/iblog/">
                    <span>脚踏实地</span>
                </a>
            </h1>
        </div>
        <div class="description">
            <p class="sub_title">
                
            </p>

            
            <div class="my_socials">
                
                    
                    <a href="https://github.com/whiteppure/" title="github" target="_blank">
                        <i class="ri-github-fill"></i>
                    </a>
                    
                
                <a href="https://whiteppure.github.io/iblog/index.xml" type="application/rss+xml" title="rss" target="_blank">
                    <i class="ri-rss-fill"></i>
                </a>
                
                
                <span id="sys_function" class="sys_function display_none">
                    <a id="export_pdf"  title="导出pdf" style="border: none; background-color: #ffffff; cursor: pointer; margin-left: 10px">
                        <svg t="1688701481347" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3517" width="16" height="16"><path d="M425.610455 85.814544H149.05897A42.303635 42.303635 0 0 0 106.6274 128.075535V896.492068c0 23.326702 18.976933 42.26099 42.43157 42.26099h682.743143a42.559504 42.559504 0 0 0 42.431569-42.559504v-384.016365a42.644793 42.644793 0 0 1 85.289587 0v384.016365A127.849091 127.849091 0 0 1 831.802113 1024H149.05897A127.635867 127.635867 0 0 1 21.337813 896.449423V128.03289A127.593222 127.593222 0 0 1 149.101614 0.524957h276.466196a42.644793 42.644793 0 0 1 0 85.289587z m564.062683 158.08425l-170.579174 170.579173a42.644793 42.644793 0 1 1-60.299738-60.299738L856.578738 256.393718H618.364922a42.644793 42.644793 0 1 1 0-85.289587h238.213816l-97.784512-97.784511A42.644793 42.644793 0 1 1 819.093964 13.019882l170.579174 170.579174a42.644793 42.644793 0 0 1 0 60.299738zM149.272194 597.552066a42.644793 42.644793 0 0 1 42.644793-42.644794h51.514911c59.190973 0 107.891327 23.284057 107.976617 97.102195 0 71.003581-49.46796 102.347504-106.185536 102.347504h-31.343923v66.781747a32.282109 32.282109 0 0 1-64.606862 0V597.552066z m92.709781 100.215264c31.429213 0 46.568114-16.46089 46.568114-45.757863 0-30.064579-17.313786-40.512554-48.359196-40.512554h-26.311837v86.270417h28.145563z m232.414124-142.860058c81.878003 0 136.036891 43.710913 136.036891 147.67892S556.231457 853.420826 477.935617 853.420826h-38.16709a42.644793 42.644793 0 0 1-42.644794-42.644793v-213.223967a42.644793 42.644793 0 0 1 42.644794-42.644794h34.542282z m-4.008611 240.729859c43.32711 0 73.988717-22.047358 73.988717-93.050939 0-71.046226-30.704251-90.705476-73.988717-90.705476h-8.699538v183.79906h8.699538zM692.481573 853.420826a32.282109 32.282109 0 0 1-32.282109-32.282108V597.552066a42.644793 42.644793 0 0 1 42.644793-42.644794h99.063855a29.680776 29.680776 0 1 1 0 59.404197h-77.144431v65.374469h61.749661a29.894 29.894 0 1 1 0 59.788h-61.749661v81.66478a32.282109 32.282109 0 0 1-32.282108 32.282108z" fill="#5f5f5f" p-id="3518"></path></svg>
                    </a>
                    <a id="export_pic" title="导出图片" style="border: none; background-color: #ffffff; cursor: pointer; margin-left: 10px">
                        <svg t="1689071509720" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4564" width="16" height="16"><path d="M909.132886 0.037506h-184.960611a33.909445 33.909445 0 0 0-32.368107 33.909445 33.909445 33.909445 0 0 0 33.909445 33.395666h158.244078l-200.373995 199.346437a33.395666 33.395666 0 0 0 0 47.781491 31.854327 31.854327 0 0 0 23.633856 9.76181 33.909445 33.909445 0 0 0 24.147635-9.76181l198.832657-199.346437V272.340628a33.909445 33.909445 0 0 0 69.874009 0V88.921355A88.37007 88.37007 0 0 0 909.132886 0.037506zM216.558153 347.866211a107.37991 107.37991 0 1 0 107.37991-107.379911 107.89369 107.89369 0 0 0-107.37991 107.379911z m154.133843 0a51.377948 51.377948 0 0 1-97.618101 0 51.377948 51.377948 0 1 1 97.618101 0z" p-id="4565" fill="#424242"></path><path d="M963.079731 437.777619a34.423225 34.423225 0 0 0-33.909446 33.909445v265.110209a1811.07265 1811.07265 0 0 0-137.692899-193.181082 106.352351 106.352351 0 0 0-78.60826-36.478343 123.820854 123.820854 0 0 0-82.204716 35.964563l-3.596456 3.082677-188.557068 176.74014c-11.816928-13.358266-47.781491-51.377948-82.204716-87.856291a83.232275 83.232275 0 0 0-85.801172-21.578738 105.324792 105.324792 0 0 0-38.019681 19.52362l-141.289356 121.765736V89.948914a22.092517 22.092517 0 0 1 22.606297-22.606297h417.702713a33.395666 33.395666 0 0 0 33.395666-33.909445 33.395666 33.395666 0 0 0-33.395666-33.395666H113.802258A89.911408 89.911408 0 0 0 23.89085 89.948914v844.139678a89.911408 89.911408 0 0 0 89.911408 89.911408h793.27551a89.911408 89.911408 0 0 0 89.397629-89.911408v-462.401528a33.909445 33.909445 0 0 0-33.395666-33.909445z m-33.909446 496.310973a22.606297 22.606297 0 0 1-22.092517 22.606297H113.802258a22.606297 22.606297 0 0 1-22.606297-22.606297v-88.37007l183.933052-160.812976a43.157476 43.157476 0 0 1 15.413385-7.192912 15.927164 15.927164 0 0 1 17.982281 5.137794c37.505902 36.478343 78.60826 83.232275 82.718496 87.856291a61.653537 61.653537 0 0 0 42.643696 22.092517 62.681096 62.681096 0 0 0 51.377948-20.037399c8.220472-8.220472 134.610223-125.875971 194.208641-181.877935a57.029522 57.029522 0 0 1 34.423225-16.440943 45.212594 45.212594 0 0 1 29.79921 15.927164 2954.231982 2954.231982 0 0 1 186.501949 256.889738z" p-id="4566" fill="#424242"></path></svg>
                    </a>
                    <a id="export_markdown" title="导出markdown" style="border: none; background-color: #ffffff; cursor: pointer; margin-left: 10px">
                        <svg t="1689071035200" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="13570" width="16" height="16"><path d="M178.073367 843.957262V461.158929h107.121045l107.121045 140.734874 107.125433-140.734874h107.116657v382.798333h-107.116657v-219.54307l-107.125433 140.730486-107.116657-140.730486v219.54307zM737.783131 892.148786l-131.221196-209.156132h87.479334V461.158929h87.479335v221.833725h87.483722z" p-id="13571" fill="#424242"></path><path d="M911.9958 217.142709c10.672172 10.663395 19.812851 25.144549 27.430816 43.430297 7.617965 18.285748 11.431335 35.044392 11.431336 50.28471V969.140255c0 15.235929-5.336086 28.18998-15.999481 38.853375-10.667783 10.667783-23.621834 16.003869-38.857763 16.003869H127.994904c-15.240317 0-28.18998-5.336086-38.857763-16.003869-10.663395-10.663395-15.999481-23.617446-15.999481-38.853375V54.852856c0-15.240317 5.331698-28.18998 15.999481-38.857763C99.804925 5.336086 112.758975 0 127.999292 0h512.000944c15.235929 0 31.998962 3.808982 50.28471 11.426947 18.285748 7.622353 32.762514 16.763033 43.430297 27.426428zM658.290372 77.715526v214.856442h214.856442c-3.808982-11.049559-7.99974-18.856218-12.572275-23.43314l-178.855415-178.851027c-4.572534-4.572534-12.383581-8.763292-23.43314-12.572275z m219.428976 873.143369V365.71496h-237.714724c-15.240317 0-28.18998-5.336086-38.857763-15.999481-10.663395-10.667783-15.999481-23.621834-15.999481-38.857763V73.142992H146.28504v877.715903z" p-id="13572" fill="#424242"></path></svg>
                    </a>
                    <a id="export_doc" title="导出文档" style="border: none; background-color: #ffffff; cursor: pointer; margin-left: 10px">
                        <svg t="1689246982401" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="6825" width="16" height="16"><path d="M270.76864 608.32h180.8a31.68 31.68 0 0 0 0-62.976H270.76864a31.68 31.68 0 0 0 0 62.976zM271.34464 458.56h457.92a33.472 33.472 0 0 0 31.552-34.752 33.28 33.28 0 0 0-31.552-34.624H271.34464a34.816 34.816 0 0 0 0 69.376zM271.34464 293.504h457.92a33.344 33.344 0 0 0 31.552-34.688 33.216 33.216 0 0 0-31.552-34.624H271.34464a33.28 33.28 0 0 0-31.616 34.624 33.28 33.28 0 0 0 31.616 34.688z" p-id="6826" fill="#424242"></path><path d="M869.87264 0H153.77664A70.4 70.4 0 0 0 84.65664 70.912V953.6A69.952 69.952 0 0 0 153.77664 1024h370.048a32 32 0 0 0 0-63.68H147.12064V64h729.6v468.672a31.296 31.296 0 1 0 62.528 0V70.912A70.4 70.4 0 0 0 869.87264 0z" p-id="6827" fill="#424242"></path><path d="M482.16064 730.624h337.664L715.82464 625.216a28.864 28.864 0 0 1-7.936-28.736 29.184 29.184 0 0 1 20.608-21.184 29.632 29.632 0 0 1 29.12 8.128l174.784 177.216-174.784 176.96a29.184 29.184 0 0 1-49.728-13.312 29.248 29.248 0 0 1 8-28.8l103.936-105.344H482.16064a29.696 29.696 0 0 1-29.504-29.76 29.632 29.632 0 0 1 29.504-29.76z" p-id="6828" fill="#424242"></path></svg>
                    </a>
                </span>
                <a  id="icon_more" title="更多" >
                    <svg t="1688715321313" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5356" width="16" height="16"><path d="M483.555556 199.111111m-85.333334 0a85.333333 85.333333 0 1 0 170.666667 0 85.333333 85.333333 0 1 0-170.666667 0Z" fill="#424242" p-id="5357"></path><path d="M483.555556 540.444444m-85.333334 0a85.333333 85.333333 0 1 0 170.666667 0 85.333333 85.333333 0 1 0-170.666667 0Z" fill="#424242" p-id="5358"></path><path d="M483.555556 881.777778m-85.333334 0a85.333333 85.333333 0 1 0 170.666667 0 85.333333 85.333333 0 1 0-170.666667 0Z" fill="#424242" p-id="5359"></path></svg>
                </a>
                <a  id="icon_less" class="display_none">
                    <svg t="1688723160472" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="15872" width="16" height="16"><path d="M300.105143 592.676571h423.789714a80.676571 80.676571 0 1 0 0-161.353142H300.105143a80.676571 80.676571 0 0 0 0 161.353142z" fill="#8a8a8a" p-id="15873"></path></svg>
                </a>
                
            </div>

            
            <div class="post">
                <div class="post_title post_detail_title">
                    <span class="date" id="busuanzi_container_site_pv">访问量 <span id="busuanzi_value_site_pv"></span>次</span>
                </div>
                <div class="post_title post_detail_title">
                    <span class="date" id="busuanzi_container_site_uv">访客数 <span id="busuanzi_value_site_uv"></span>人</span>
                </div>
            </div>
            
        </div>
    </div>
</div>
        <div class="content">
            <div class="post_page">
                <div class="post animate__animated animate__fadeInDown">
                    <div class="post_title post_detail_title">
                        <h2 id="post_single_title">Java多线程</h2>
                        <span id="post_page_title_date" class="date">2021.05.05</span>
                        
                        <span id="busuanzi_container_page_pv" class="m-l-10">
                          阅读量<span id="busuanzi_value_page_pv"></span>次
                        </span>
                        
                    </div>
                    <div class="post_content markdown"><h2 id="相关概念">相关概念</h2>
<h3 id="线程与进程">线程与进程</h3>
<ul>
<li>进程是一个具有一定独立功能的程序关于某个数据集合的一次运行活动。例如，一个正在运行的程序的实例就是一个进程。</li>
<li>线程是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。</li>
</ul>
<p>进程是操作系统资源分配的基本单位，而线程是处理器任务调度和执行的基本单位。
一条线程指的是进程中的一个单一顺序的控制流，一个进程至少有一个线程，一个进程中可以并发多个线程，多个线程可共享数据，每条线程并行执行不同的任务。</p>
<p>Java程序是多线程程序，每启动一个Java程序，至少我们知道的都会包含一个主线程和一个垃圾回收线程。
而且启动的时候，每条线程可以并行执行不同的任务。</p>
<p><img alt="线程与进程的关系" src="/iblog/posts/annex/images/essays/%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%85%B3%E7%B3%BB.jpg"></p>
<h3 id="并行串行并发">并行、串行、并发</h3>
<ul>
<li>并行：前提是在多核CPU，多个线程同时被多个CPU执行，同时执行的线程并不会抢占CPU资源。</li>
<li>串行：前提是在单核CPU条件下，单线程程序执行，不能同时执行，也不能去切换执行，也就是在同一时间段只能做一件事，如果需要做多件事情需要排队执行。</li>
<li>并发：前提是多线程条件下，多个线程抢占一个CPU资源，多个线程被交替执行。因为CPU运算速度很快，所以用户感觉不到线程切换的卡顿。</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th style="text-align:center">单线程</th>
<th>多线程</th>
</tr>
</thead>
<tbody>
<tr>
<td>单CPU</td>
<td style="text-align:center">串行</td>
<td>并发</td>
</tr>
<tr>
<td>多CPU</td>
<td style="text-align:center">串行</td>
<td>并行</td>
</tr>
</tbody>
</table>
<p>无论并行、并发，都可以有多个线程执行，如果是多个线程抢占一个CPU，交替执行，并且CPU通过时间片轮转等机制切换执行线程，这种情况下称为并发执行。
多个线程同时被多个CPU执行，并且各个线程之间不会互相抢占CPU资源，这种情况下称为并行执行。每个线程都在自己的CPU核心上独立执行，互不干扰。</p>
<p>对于单CPU的计算机来说，同一时间是只能干一件事儿的，如果是单线程就是串行，如果是多个线程就是并发。
而对于多CPU的计算机说，同一时间能干多个事，如果多个CPU同时执行多个线程就是并行，如果一个CPU同时执行多个线程就是并行。</p>
<p>并行与并发区别图解
<img alt="并行与并发区别" src="/iblog/posts/annex/images/essays/%E5%B9%B6%E8%A1%8C%E4%B8%8E%E5%B9%B6%E5%8F%91%E5%8C%BA%E5%88%AB.png"></p>
<p>并发是两个队列交替使用一台咖啡机，并行是两个队列同时使用两台咖啡机；
如果串行，一个队列使用一台咖啡机，那么哪怕前面那个人便秘了去厕所呆半天，后面的人也只能死等着他回来才能去接咖啡，这种效率无疑是最低的。</p>
<h3 id="同步与异步">同步与异步</h3>
<p>同步、异步是描述程序执行模式的两个重要概念。在Java中，同步和异步通常来描述方法。</p>
<ul>
<li>同步通常指的是线程的同步执行。同步方法调用一旦开始，调用者必须等到方法调用返回后，才能继续后续的行为；
例如，使用关键字<code>synchronized</code>或<code>Lock</code>接口可以实现多线程的同步，确保多个线程按照特定的顺序或条件执行。</li>
<li>异步方法调用更像一个消息传递，一旦开始，方法调用就会立即返回，调用者就可以继续后续的操作；
异步方法通常会在另外一个线程中执行着，整个过程，不会阻碍调用者的后续工作。异步在Java中通常通过多线程、回调函数或<code>Future</code>、<code>CompletableFuture</code>等方式实现。</li>
</ul>
<p>只有多线程环境下才会异步调用方法，换言之异步调用方法则需要单独创建一个线程。</p>
<table>
<thead>
<tr>
<th></th>
<th style="text-align:center">单线程</th>
<th>多线程</th>
</tr>
</thead>
<tbody>
<tr>
<td>同步</td>
<td style="text-align:center">只能同步</td>
<td>可以同步</td>
</tr>
<tr>
<td>异步</td>
<td style="text-align:center">不能异步</td>
<td>可以异步</td>
</tr>
</tbody>
</table>
<h3 id="守护线程">守护线程</h3>
<p>守护线程是指为其他线程服务的线程。守护线程也称“服务线程”，在没有用户线程可服务时会自动离开。因为作用是服务其他线程，所以在程序中的优先级比较低。
在JVM中，所有非守护线程都执行完毕后，无论有没有守护线程，虚拟机都会自动退出。</p>
<p>举例，垃圾回收线程就是一个经典的守护线程，当我们的程序中不再有任何运行的线程，程序就不会再产生垃圾，垃圾回收器也就无事可做。
所以当垃圾回收线程是JVM上仅剩的线程时，垃圾回收线程会自动离开。它始终在低级别的状态中运行，用于实时监控和管理系统中的可回收资源。
守护线程在程序中的操作演示：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">MainTest</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="o">[]</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">0</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="kc">true</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">Thread</span><span class="w"> </span><span class="n">daemon</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Thread</span><span class="p">(()</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&#34;启动线程---&gt;&#34;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">Thread</span><span class="p">.</span><span class="na">currentThread</span><span class="p">().</span><span class="na">getName</span><span class="p">());</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">});</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">daemon</span><span class="p">.</span><span class="na">setDaemon</span><span class="p">(</span><span class="n">i</span><span class="o">==</span><span class="n">3</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">daemon</span><span class="p">.</span><span class="na">start</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="kt">boolean</span><span class="w"> </span><span class="n">isDaemon</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">daemon</span><span class="p">.</span><span class="na">isDaemon</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&#34;当前线程是否是守护线程：&#34;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">isDaemon</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">isDaemon</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="k">break</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">i</span><span class="o">++</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><h2 id="线程的状态">线程的状态</h2>
<p>线程状态共包含6种，通过<code>Thread.State</code>枚举类表示的。6种状态又可以互相的转换，线程状态转换关系：</p>
<p><img alt="线程状态转换" src="/iblog/posts/annex/images/essays/%E7%BA%BF%E7%A8%8B%E8%BD%AC%E6%8D%A2%E5%9B%BE.jpg"></p>
<ol>
<li>新建状态(New): 线程被创建但尚未启动。例如，<code>Thread t = new Thread();</code> 状态为NEW；调用线程对象的<code>start()</code>方法会使线程从NEW状态转变为RUNNABLE状态。</li>
<li>可运行状态(Runnable): 线程在Java虚拟机中执行中。这包括运行状态和就绪状态，线程可能正在运行，也可能等待操作系统为其分配CPU时间。
<ul>
<li>就绪（Ready）：线程已经被创建，等待被调度执行。此时可能有多个线程处于就绪状态，但只有一个线程能够获取CPU时间片执行。</li>
<li>运行中（Running）：就绪的线程获得了CPU时间片，开始执行程序代码。</li>
</ul>
</li>
<li>阻塞状态(Blocked): 当一个线程试图进入一个同步代码块或方法，但该同步块已经被其他线程持有时，线程将进入阻塞状态。阻塞状态的线程将等待获取同步锁，一旦获取到锁就可以转变为RUNNABLE状态。</li>
<li>无限期等待(Waiting): 当线程调用<code>Object.wait()</code>、<code>Thread.join()</code>或<code>LockSupport.park()</code>方法时，它会进入WAITING状态，直到被其他线程显式唤醒。线程被唤醒后可以转变为RUNNABLE状态。</li>
<li>限期等待(Timed Waiting): 当线程调用带有超时参数的等待方法，如<code>sleep()</code>、<code>wait(timeout)</code>、<code>join(timeout)</code>、<code>LockSupport.parkNanos()</code>或<code>LockSupport.parkUntil()</code>时，它会进入TIMED_WAITING状态，直到超时时间到达或被其他线程唤醒。
超时时间到达或被唤醒后可以转变为RUNNABLE状态。</li>
<li>死亡(Terminated): 线程完成<code>run()</code>方法的执行或者因异常而终止时，会进入TERMINATED状态。一旦线程的<code>run()</code>方法执行完成或抛出未捕获的异常，线程将进入终止状态。</li>
</ol>
<p>阻塞和等待的区别在于，阻塞是被动的，它是在等待获取一个排它锁。而等待是主动的，通过调用<code>Thread.sleep()</code>和<code>Object.wait()</code>等方法进入等待。</p>
<h2 id="线程相关方法">线程相关方法</h2>
<ul>
<li><code>start()</code>：启动一个新线程，调用线程的<code>run()</code>方法。
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">Thread t = new Thread(() -&gt; {
</span></span><span class="line"><span class="cl">    System.out.println(&#34;Thread is running&#34;);
</span></span><span class="line"><span class="cl">});
</span></span><span class="line"><span class="cl">t.start();
</span></span></code></pre></div></li>
<li><code>run()</code>：运行线程中的代码。可以通过继承<code>Thread</code>类并重写<code>run()</code>方法，或通过实现<code>Runnable</code>接口并传递给<code>Thread</code>类的构造函数。
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">public class MyThread extends Thread {
</span></span><span class="line"><span class="cl">    public void run() {
</span></span><span class="line"><span class="cl">        System.out.println(&#34;Thread is running&#34;);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">MyThread t = new MyThread();
</span></span><span class="line"><span class="cl">t.start();
</span></span></code></pre></div></li>
<li><code>sleep(long millis)</code>：让当前线程休眠指定的毫秒数。
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">try {
</span></span><span class="line"><span class="cl">    Thread.sleep(1000); // 休眠1秒
</span></span><span class="line"><span class="cl">} catch (InterruptedException e) {
</span></span><span class="line"><span class="cl">    e.printStackTrace();
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div></li>
<li><code>join()</code>：当有新的线程加入时，主线程会进入等待状态，一直到调用<code>join()</code>方法的线程执行结束为止。<code>join()</code>方法的实现依赖于对象的<code>wait()</code>方法。
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">Thread t = new Thread(() -&gt; {
</span></span><span class="line"><span class="cl">    try {
</span></span><span class="line"><span class="cl">        Thread.sleep(2000);
</span></span><span class="line"><span class="cl">    } catch (InterruptedException e) {
</span></span><span class="line"><span class="cl">        e.printStackTrace();
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">});
</span></span><span class="line"><span class="cl">t.start();
</span></span><span class="line"><span class="cl">try {
</span></span><span class="line"><span class="cl">    t.join();
</span></span><span class="line"><span class="cl">} catch (InterruptedException e) {
</span></span><span class="line"><span class="cl">    e.printStackTrace();
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div></li>
<li><code>yield()</code>：用于让当前正在执行的线程暂时让出CPU的执行权，使其他线程有机会运行。它不会使线程进入阻塞或等待状态，只是让出当前的CPU时间片，让同等优先权的线程运行。
如果没有同等优先权的线程，那么<code>yield()</code>方法将不会起作用。
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">public void run() {
</span></span><span class="line"><span class="cl">    for (int i = 0; i &lt; 5; i++) {
</span></span><span class="line"><span class="cl">        System.out.println(threadName + &#34; is running, iteration: &#34; + i);
</span></span><span class="line"><span class="cl">        // 暂时让出CPU执行权，给其他线程机会
</span></span><span class="line"><span class="cl">        Thread.yield();
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    System.out.println(threadName + &#34; has finished execution.&#34;);
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">public static void main(String[] args) {
</span></span><span class="line"><span class="cl">    Thread thread1 = new Thread(new YieldExample(&#34;Thread 1&#34;));
</span></span><span class="line"><span class="cl">    Thread thread2 = new Thread(new YieldExample(&#34;Thread 2&#34;));
</span></span><span class="line"><span class="cl">    thread1.start();
</span></span><span class="line"><span class="cl">    thread2.start();
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div></li>
<li><code>wait()</code>：使当前线程等待，直到另一个线程调用该对象的<code>notify()</code>或<code>notifyAll()</code>方法。<code>wait()</code>必须在同步<code>synchronized</code>块里使用。
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">synchronized (lock) {
</span></span><span class="line"><span class="cl">    lock.wait();
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div></li>
<li><code>notify()</code>：唤醒一个正在等待该对象的<code>wait()</code>方法的线程。如果多个线程都在该对象的监视器上等待，则任意选择一个线程被唤醒。
<code>notify()</code>方法必须与<code>wait()</code>方法一起使用，否则会抛出<code>IllegalMonitorStateException</code>异常。<code>notify()</code>方法必须在同步代码块或同步方法中调用，因为它依赖于对象的监视器锁。
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span><span class="w"> </span><span class="kd">synchronized</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">doWaitNotify</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">Thread</span><span class="w"> </span><span class="n">waitingThread</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Thread</span><span class="p">(()</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">try</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&#34;Thread is waiting...&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">wait</span><span class="p">();</span><span class="w"> </span><span class="c1">// 进入等待状态</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&#34;Thread is notified and resumed.&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">catch</span><span class="w"> </span><span class="p">(</span><span class="n">InterruptedException</span><span class="w"> </span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">e</span><span class="p">.</span><span class="na">printStackTrace</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">});</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">waitingThread</span><span class="p">.</span><span class="na">start</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">try</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">Thread</span><span class="p">.</span><span class="na">sleep</span><span class="p">(</span><span class="n">1000</span><span class="p">);</span><span class="w"> </span><span class="c1">// 模拟一些操作延迟</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">catch</span><span class="w"> </span><span class="p">(</span><span class="n">InterruptedException</span><span class="w"> </span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">e</span><span class="p">.</span><span class="na">printStackTrace</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">synchronized</span><span class="w"> </span><span class="p">(</span><span class="k">this</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&#34;Notifying waiting thread...&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">notify</span><span class="p">();</span><span class="w"> </span><span class="c1">// 唤醒等待的线程</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div></li>
</ul>
<p>需要注意区分<code>wait</code>方法与<code>sleep</code>方法，很多人分不清。<code>sleep</code>和<code>wait</code>方法异同点：</p>
<ul>
<li><code>sleep()</code>属于<code>Thread</code>类，<code>wait()</code>属于<code>Object</code>类；</li>
<li><code>sleep()</code>和<code>wait()</code>都会抛出<code>InterruptedException</code>异常，这个异常属于<code>checkedException</code>是不可避免；</li>
<li>两者比较的共同之处是，都是使程序等待多长时间。不同的是调用<code>sleep()</code>不会释放锁，会使线程堵塞，而调用<code>wait()</code>会释放锁，让线程进入等待状态，用 <code>notify()</code>、<code>notifyall()</code>可以唤醒，或者等待时间到了；这是因为，如果没有释放锁，那么其它线程就无法进入对象的同步方法或者同步控制块中，那么就无法执行 <code>notify()</code> 或者 <code>notifyAll()</code> 来唤醒挂起的线程，造成死锁。</li>
<li><code>wait()</code>必须在同步<code>synchronized</code>块里使用，<code>sleep()</code>可以在任意地方使用；</li>
</ul>
<p>其中&quot;<code>wait()</code>必须在同步<code>synchronized</code>块里使用&quot;，不止<code>wait</code>方法，<code>notify、notifyAll</code>也和<code>wait</code>方法一样，必须在<code>synchronized</code>块里使用，为什么呢？</p>
<p>是为了避免丢失唤醒问题。假设没有<code>synchronized</code>修饰，使用了<code>wait</code>方法而没有设置等待时间，也没有调用唤醒方法或者唤醒方法调用的时机不对，这个线程将会永远的堵塞下去。
<code>wait</code>、<code>notify</code>、<code>notifyAll</code>方法调用的时候要释放锁，你都没给它加锁，他怎么释放锁。所以如果没在<code>synchronized</code>块中调用<code>wait()、notify、notifyAll</code>方法是肯定抛异常的。</p>
<h2 id="创建线程">创建线程</h2>
<p>在Java中创建一个线程，有且仅有一种方式，创建一个<code>Thread</code>类实例，并调用它的<code>start</code>方法。</p>
<h3 id="thread类">Thread类</h3>
<p>最经典也是最常见的方式是通过继承<code>Thread</code>类，重写<code>run()</code>方法来创建线程。适用于需要直接控制线程生命周期的情况。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">MainTest</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="o">[]</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">ThreadDemo</span><span class="w"> </span><span class="n">thread1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ThreadDemo</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">thread1</span><span class="p">.</span><span class="na">start</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">class</span> <span class="nc">ThreadDemo</span><span class="w"> </span><span class="kd">extends</span><span class="w"> </span><span class="n">Thread</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nd">@Override</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">run</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">printf</span><span class="p">(</span><span class="s">&#34;通过继承Thread类的方式创建线程,线程 %s 启动&#34;</span><span class="p">,</span><span class="n">Thread</span><span class="p">.</span><span class="na">currentThread</span><span class="p">().</span><span class="na">getName</span><span class="p">());</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><h3 id="runnable接口">Runnable接口</h3>
<p>实现<code>Runnale</code>接口，将它作为<code>target</code>参数传递给<code>Thread</code>类构造函数的方式创建线程。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">MainTest</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="o">[]</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">new</span><span class="w"> </span><span class="n">Thread</span><span class="p">(()</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">printf</span><span class="p">(</span><span class="s">&#34;通过实现Runnable接口的方式，重写run方法创建线程；线程 %s 启动&#34;</span><span class="p">,</span><span class="n">Thread</span><span class="p">.</span><span class="na">currentThread</span><span class="p">().</span><span class="na">getName</span><span class="p">());</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}).</span><span class="na">start</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><h3 id="callable接口">Callable接口</h3>
<p><code>Callable</code>接口与<code>Runnable</code>类似，但它可以返回结果，并且可以抛出异常，需要配合<code>Future</code>接口使用。通过实现<code>Callable</code>接口，来创建一个带有返回值的线程。
在<code>Callable</code>执行完之前的这段时间，主线程可以先去做一些其他的事情，事情都做完之后，再获取<code>Callable</code>的返回结果。可以通过<code>isDone()</code>来判断子线程是否执行完。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">MainTest</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="o">[]</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="kd">throws</span><span class="w"> </span><span class="n">ExecutionException</span><span class="p">,</span><span class="w"> </span><span class="n">InterruptedException</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">FutureTask</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span><span class="w"> </span><span class="n">futureTask</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">FutureTask</span><span class="o">&lt;&gt;</span><span class="p">(()</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">printf</span><span class="p">(</span><span class="s">&#34;通过实现Callable接口的方式，重写call方法创建线程；线程 %s 启动&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">Thread</span><span class="p">.</span><span class="na">currentThread</span><span class="p">().</span><span class="na">getName</span><span class="p">());</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">Thread</span><span class="p">.</span><span class="na">sleep</span><span class="p">(</span><span class="n">10000</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="s">&#34;我是call方法返回值&#34;</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">});</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">new</span><span class="w"> </span><span class="n">Thread</span><span class="p">(</span><span class="n">futureTask</span><span class="p">).</span><span class="na">start</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&#34;主线程工作中 ...&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">String</span><span class="w"> </span><span class="n">callRet</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">null</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">callRet</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kc">null</span><span class="p">){</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="n">futureTask</span><span class="p">.</span><span class="na">isDone</span><span class="p">()){</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">callRet</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">futureTask</span><span class="p">.</span><span class="na">get</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&#34;主线程继续工作 ...&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&#34;获取call方法返回值：&#34;</span><span class="o">+</span><span class="w"> </span><span class="n">callRet</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>在实际开发中，通常使用异步编程工具，如<code>CompletableFuture</code>。
<code>CompletableFuture</code>是JDK8的新特性。<code>CompletableFuture</code>实现了<code>CompletionStage</code>接口和<code>Future</code>接口，前者是对后者的一个扩展，增加了异步会点、流式处理、多个<code>Future</code>组合处理的能力，使Java在处理多任务的协同工作时更加顺畅便利。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">CompletableFutureRunAsyncExample</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="o">[]</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">CompletableFuture</span><span class="o">&lt;</span><span class="n">Void</span><span class="o">&gt;</span><span class="w"> </span><span class="n">future</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CompletableFuture</span><span class="p">.</span><span class="na">runAsync</span><span class="p">(()</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="c1">// 异步执行的任务，没有返回值</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&#34;Running asynchronously&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">});</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">future</span><span class="p">.</span><span class="na">thenRun</span><span class="p">(()</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&#34;After running asynchronously&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">});</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">future</span><span class="p">.</span><span class="na">join</span><span class="p">();</span><span class="w"> </span><span class="c1">// 等待任务完成</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">CompletableFuture</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span><span class="w"> </span><span class="n">future</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CompletableFuture</span><span class="p">.</span><span class="na">supplyAsync</span><span class="p">(()</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="s">&#34;Hello&#34;</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="p">.</span><span class="na">thenApply</span><span class="p">(</span><span class="n">result</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">&#34; CompletableFuture!&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><h3 id="线程池">线程池</h3>
<p>线程池做的工作主要是控制运行的线程的数量，处理过程中将任务放入队列，然后在线程创建后启动这些任务。如果线程数量超过了最大数量超出数量的线程排队等候，等其它线程执行完毕，再从队列中取出任务来执行。
线程池是一种用于管理和复用线程的机制，可以有效地提高应用程序的性能和资源利用率。它的主要特点为：线程复用，提高响应速度，管理线程。</p>
<ul>
<li>降低资源消耗，通过重复利用己创建的线程降低线程创建和销毁造成的消耗。</li>
<li>提高响应速度，当任务到达时，任务可以不需要的等到线程创建就能立即执行。</li>
<li>提高线程的管理性，线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li>
</ul>
<h4 id="创建方式">创建方式</h4>
<p>在Java中，使用<code>java.util.concurrent</code>包中的<code>Executor</code>来创建和管理线程池。几种常见的线程池创建方式：</p>
<ul>
<li><code>Executors.newSingleThreadExecutor()</code>：创建只有一个线程的线程池。</li>
<li><code>Executors.newFixedThreadPool(int)</code>：创建固定线程的线程池。</li>
<li><code>Executors.newCachedThreadPool()</code>：创建一个可缓存的线程池，线程数量随着处理业务数量变化。</li>
</ul>
<p>这三种常用创建线程池的方式，底层代码都是用<code>ThreadPoolExecutor</code>创建的。</p>
<ol>
<li>
<p>使用<code>Executors.newSingleThreadExecutor()</code>创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序执行。
<code>newSingleThreadExecutor</code>将<code>corePoolSize</code>和<code>maximumPoolSize</code>都设置为1，它使用的<code>LinkedBlockingQueue</code>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="n">ExecutorService</span><span class="w"> </span><span class="nf">newSingleThreadExecutor</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">FinalizableDelegatedExecutorService</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">ThreadPoolExecutor</span><span class="p">(</span><span class="n">1</span><span class="p">,</span><span class="w"> </span><span class="n">1</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                                </span><span class="n">0L</span><span class="p">,</span><span class="w"> </span><span class="n">TimeUnit</span><span class="p">.</span><span class="na">MILLISECONDS</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                                </span><span class="k">new</span><span class="w"> </span><span class="n">LinkedBlockingQueue</span><span class="o">&lt;</span><span class="n">Runnable</span><span class="o">&gt;</span><span class="p">()));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">MainTest</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="o">[]</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">ExecutorService</span><span class="w"> </span><span class="n">executor1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">null</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">try</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">executor1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Executors</span><span class="p">.</span><span class="na">newSingleThreadExecutor</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">10</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">executor1</span><span class="p">.</span><span class="na">execute</span><span class="p">(()</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">Thread</span><span class="p">.</span><span class="na">currentThread</span><span class="p">().</span><span class="na">getName</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">&#34;执行了&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="p">});</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">finally</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">executor1</span><span class="p">.</span><span class="na">shutdown</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div></li>
<li>
<p>使用<code>Executors.newFixedThreadPool(int)</code>创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。
<code>newFixedThreadPool</code>创建的线程池<code>corePoolSize</code>和<code>maximumPoolSize</code>值是相等的，它使用的<code>LinkedBlockingQueue</code>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="n">ExecutorService</span><span class="w"> </span><span class="nf">newFixedThreadPool</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">nThreads</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ThreadPoolExecutor</span><span class="p">(</span><span class="n">nThreads</span><span class="p">,</span><span class="w"> </span><span class="n">nThreads</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                                  </span><span class="n">0L</span><span class="p">,</span><span class="w"> </span><span class="n">TimeUnit</span><span class="p">.</span><span class="na">MILLISECONDS</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                                  </span><span class="k">new</span><span class="w"> </span><span class="n">LinkedBlockingQueue</span><span class="o">&lt;</span><span class="n">Runnable</span><span class="o">&gt;</span><span class="p">());</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">MainTest</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="o">[]</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">ExecutorService</span><span class="w"> </span><span class="n">executor1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">null</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">try</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">executor1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Executors</span><span class="p">.</span><span class="na">newFixedThreadPool</span><span class="p">(</span><span class="n">10</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">10</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">executor1</span><span class="p">.</span><span class="na">execute</span><span class="p">(()</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">Thread</span><span class="p">.</span><span class="na">currentThread</span><span class="p">().</span><span class="na">getName</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">&#34;执行了&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="p">});</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">finally</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">executor1</span><span class="p">.</span><span class="na">shutdown</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div></li>
<li>
<p>使用<code>Executors.newCachedThreadPool()</code>创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收则新建线程。
<code>newCachedThreadPool</code>将<code>corePoolSize</code>设置为0，将<code>maximumPoolSize</code>设置为<code>Integer.MAX_VALUE</code>，使用的 <code>SynchronousQueue</code>，也就是说来了任务就创建线程运行，当线程空闲超过60秒，就销毁线程。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="n">ExecutorService</span><span class="w"> </span><span class="nf">newCachedThreadPool</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ThreadPoolExecutor</span><span class="p">(</span><span class="n">0</span><span class="p">,</span><span class="w"> </span><span class="n">Integer</span><span class="p">.</span><span class="na">MAX_VALUE</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                                  </span><span class="n">60L</span><span class="p">,</span><span class="w"> </span><span class="n">TimeUnit</span><span class="p">.</span><span class="na">SECONDS</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                                  </span><span class="k">new</span><span class="w"> </span><span class="n">SynchronousQueue</span><span class="o">&lt;</span><span class="n">Runnable</span><span class="o">&gt;</span><span class="p">());</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">MainTest</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="o">[]</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">ExecutorService</span><span class="w"> </span><span class="n">executor1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">null</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">try</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">executor1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Executors</span><span class="p">.</span><span class="na">newCachedThreadPool</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">10</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">executor1</span><span class="p">.</span><span class="na">execute</span><span class="p">(()</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">Thread</span><span class="p">.</span><span class="na">currentThread</span><span class="p">().</span><span class="na">getName</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">&#34;执行了&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="p">});</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">finally</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">executor1</span><span class="p">.</span><span class="na">shutdown</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div></li>
</ol>
<h4 id="自定义线程池">自定义线程池</h4>
<p>在实际开发中用哪个线程池？上面的三种一个都不用，我们生产上只能使用自定义的。<code>Executors</code>类中已经给你提供了，为什么不用？</p>
<blockquote>
<p>摘自<a href="https://developer.aliyun.com/topic/download?spm=a2c6h.15028928.J_5293118740.2&id=805">《阿里巴巴开发手册》</a>
【强制】线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。
说明：线程池的好处是减少在创建和销毁线程上所消耗的时间以及系统资源的开销，解决资源不足的问题。 如果不使用线程池，有可能造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题。
【强制】线程池不允许使用 <code>Executors</code> 去创建，而是通过 <code>ThreadPoolExecutor</code> 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。</p>
</blockquote>
<blockquote>
<p>说明：<code>Executors</code> 返回的线程池对象的弊端如下：
1） <code>FixedThreadPool</code> 和 <code>SingleThreadPool</code>： 允许的请求队列长度为 <code>Integer.MAX_VALUE</code>，可能会堆积大量的请求，从而导致OOM。
2） <code>CachedThreadPool</code>： 允许的创建线程数量为 <code>Integer.MAX_VALUE</code>，可能会创建大量的线程，从而导致 OOM。</p>
</blockquote>
<p>自定义线程池代码演示：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">MainTest</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="o">[]</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">ExecutorService</span><span class="w"> </span><span class="n">executor1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">null</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">try</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">executor1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ThreadPoolExecutor</span><span class="p">(</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="n">2</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="n">5</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="n">1L</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="n">TimeUnit</span><span class="p">.</span><span class="na">SECONDS</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="k">new</span><span class="w"> </span><span class="n">LinkedBlockingQueue</span><span class="o">&lt;&gt;</span><span class="p">(</span><span class="n">3</span><span class="p">),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="n">Executors</span><span class="p">.</span><span class="na">defaultThreadFactory</span><span class="p">(),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="k">new</span><span class="w"> </span><span class="n">ThreadPoolExecutor</span><span class="p">.</span><span class="na">CallerRunsPolicy</span><span class="p">());</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">20</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">executor1</span><span class="p">.</span><span class="na">execute</span><span class="p">(()</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">Thread</span><span class="p">.</span><span class="na">currentThread</span><span class="p">().</span><span class="na">getName</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">&#34;执行了&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="p">});</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">finally</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">executor1</span><span class="p">.</span><span class="na">shutdown</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>SpringBoot异步配置，自定义线程池代码演示：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@EnableAsync</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nd">@Configuration</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">AsyncConfig</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 线程空闲存活的时间 单位: TimeUnit.SECONDS
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kd">final</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">KEEP_ALIVE_TIME</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">60</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">60</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * CPU 核心数量
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kd">final</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">CPU_COUNT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Runtime</span><span class="p">.</span><span class="na">getRuntime</span><span class="p">().</span><span class="na">availableProcessors</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 核心线程数量
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kd">final</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">CORE_POOL_SIZE</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Math</span><span class="p">.</span><span class="na">max</span><span class="p">(</span><span class="n">2</span><span class="p">,</span><span class="w"> </span><span class="n">Math</span><span class="p">.</span><span class="na">min</span><span class="p">(</span><span class="n">CPU_COUNT</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">1</span><span class="p">,</span><span class="w"> </span><span class="n">4</span><span class="p">));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 线程池最大容纳线程数量
</span></span></span><span class="line"><span class="cl"><span class="cm">     * IO密集型:即存在大量堵塞; 公式: CPU核心数量 / 1- 阻塞系数 (阻塞系统在 0.8~0.9 之间)
</span></span></span><span class="line"><span class="cl"><span class="cm">     * CPU密集型: 需要大量运算,没有堵塞或很少有; 公式:CPU核心数量 + 1
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kd">final</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">IO_MAXIMUM_POOL_SIZE</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">CPU_COUNT</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="n">1</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">0</span><span class="p">.</span><span class="na">9</span><span class="p">));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kd">final</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">CPU_MAXIMUM_POOL_SIZE</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CPU_COUNT</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">2</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 执行写入请求时的线程池
</span></span></span><span class="line"><span class="cl"><span class="cm">     *
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @return 线程池
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nd">@Bean</span><span class="p">(</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&#34;iSaveTaskThreadPool&#34;</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="n">Executor</span><span class="w"> </span><span class="nf">iSaveTaskThreadPool</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">getThreadPoolTaskExecutor</span><span class="p">(</span><span class="s">&#34;iSaveTaskThreadPool-&#34;</span><span class="p">,</span><span class="n">IO_MAXIMUM_POOL_SIZE</span><span class="p">,</span><span class="n">100000</span><span class="p">,</span><span class="k">new</span><span class="w"> </span><span class="n">ThreadPoolExecutor</span><span class="p">.</span><span class="na">CallerRunsPolicy</span><span class="p">());</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 执行读请求时的线程池
</span></span></span><span class="line"><span class="cl"><span class="cm">     *
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @return 线程池
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nd">@Bean</span><span class="p">(</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&#34;iQueryThreadPool&#34;</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="n">Executor</span><span class="w"> </span><span class="nf">iQueryThreadPool</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">getThreadPoolTaskExecutor</span><span class="p">(</span><span class="s">&#34;iQueryThreadPool-&#34;</span><span class="p">,</span><span class="n">CPU_MAXIMUM_POOL_SIZE</span><span class="p">,</span><span class="n">10000</span><span class="p">,</span><span class="k">new</span><span class="w"> </span><span class="n">ThreadPoolExecutor</span><span class="p">.</span><span class="na">CallerRunsPolicy</span><span class="p">());</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 创建一个线程池对象
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @param threadNamePrefix 线程名称
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @param queueCapacity 堵塞队列长度
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @param refusePolicy 拒绝策略
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="n">ThreadPoolTaskExecutor</span><span class="w"> </span><span class="nf">getThreadPoolTaskExecutor</span><span class="p">(</span><span class="n">String</span><span class="w"> </span><span class="n">threadNamePrefix</span><span class="p">,</span><span class="kt">int</span><span class="w"> </span><span class="n">maxPoolSize</span><span class="p">,</span><span class="kt">int</span><span class="w"> </span><span class="n">queueCapacity</span><span class="p">,</span><span class="n">ThreadPoolExecutor</span><span class="p">.</span><span class="na">CallerRunsPolicy</span><span class="w"> </span><span class="n">refusePolicy</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">ThreadPoolTaskExecutor</span><span class="w"> </span><span class="n">taskExecutor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ThreadPoolTaskExecutor</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">taskExecutor</span><span class="p">.</span><span class="na">setCorePoolSize</span><span class="p">(</span><span class="n">CORE_POOL_SIZE</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">taskExecutor</span><span class="p">.</span><span class="na">setMaxPoolSize</span><span class="p">(</span><span class="n">maxPoolSize</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">taskExecutor</span><span class="p">.</span><span class="na">setKeepAliveSeconds</span><span class="p">(</span><span class="n">KEEP_ALIVE_TIME</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">taskExecutor</span><span class="p">.</span><span class="na">setThreadNamePrefix</span><span class="p">(</span><span class="n">threadNamePrefix</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// 拒绝策略; 既不会抛弃任务,也不会抛出异常,而是将某些任务回退到调用者,从而降低新任务的流量</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">taskExecutor</span><span class="p">.</span><span class="na">setRejectedExecutionHandler</span><span class="p">(</span><span class="n">refusePolicy</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// 阻塞队列 长度</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">taskExecutor</span><span class="p">.</span><span class="na">setQueueCapacity</span><span class="p">(</span><span class="n">queueCapacity</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">taskExecutor</span><span class="p">.</span><span class="na">setWaitForTasksToCompleteOnShutdown</span><span class="p">(</span><span class="kc">true</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">taskExecutor</span><span class="p">.</span><span class="na">setAwaitTerminationSeconds</span><span class="p">(</span><span class="n">60</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">taskExecutor</span><span class="p">.</span><span class="na">initialize</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">taskExecutor</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><h4 id="线程池工作原理">线程池工作原理</h4>
<p><img alt="线程池工作原理" src="/iblog/posts/annex/images/essays/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.png"></p>
<p>在创建了线程池后，等待提交过来的任务请求，当调用<code>execute</code>方法添加一个请求任务时，线程池会做如下判断：</p>
<ol>
<li>如果当前运行的线程数小于<code>corePoolSize</code>，那么马上创建线程运行该任务。</li>
<li>如果当前运行的线程数大于等于<code>corePoolSize</code>，那么该任务会被放入任务队列。</li>
<li>如果这时候任务队列满了且正在运行的线程数还小于<code>maximumPoolSize</code>，那么要创建非核心线程立刻运行这个任务扩容。</li>
<li>如果任务队列满了且正在运行的线程数等于<code>maximumPoolSize</code>，那么线程池会启动饱和拒绝策略来执行。</li>
<li>随着时间的推移，业务量越来越少，线程池中出现了空闲线程。当一个线程无事可做超过一定的时间时，线程池会进行判断，如果当前运行的线程数大于<code>corePoolSize</code>，那么这个线程就被停掉，所以线程池的所有任务完成后它最终会收缩到<code>corePoolSize</code>的大小。</li>
</ol>
<h4 id="阻塞队列">阻塞队列</h4>
<p>阻塞队列，顾名思义，首先它是一个队列，一个阻塞队列在数据结构中所起的作用：</p>
<ul>
<li>当阻塞队列是空时，从队列中获取元素的操作将会被阻塞。</li>
<li>当阻塞队列是满时，往队列里添加元素的操作将会被阻塞。</li>
</ul>
<p><img alt="阻塞队列" src="/iblog/posts/annex/images/essays/%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E7%BB%93%E6%9E%84.jpeg"></p>
<p>在多线程编程中，阻塞队列扮演着重要角色，特别适用于生产者-消费者模式，确保线程之间的同步和有序执行。阻塞队列的本质是一种数据结构，用于存储待执行的任务。
当任务提交给线程池时，如果核心线程已满或任务队列达到容量上限，新任务将被放入阻塞队列中，等待执行条件的满足。</p>
<p>阻塞在多线程领域指的是线程因某些条件而暂停执行，一旦条件满足，线程会被自动唤醒继续执行。这种机制保证了线程池的任务按照预期顺序执行，有效地管理并发任务的执行流程。</p>
<p>在Java中，常见的线程池阻塞队列包括：</p>
<ul>
<li><code>ArrayBlockingQueue</code>: 由数组结构组成的有界阻塞队列。它按照 FIFO（先进先出）的顺序对元素进行排序。</li>
<li><code>LinkedBlockingQueue</code>: 由链表结构组成的有界（默认大小为 <code>Integer.MAX_VALUE</code>，大约21亿）阻塞队列。同样按照 FIFO 的顺序对元素进行排序。</li>
<li><code>PriorityBlockingQueue</code>: 支持优先级排序的无界阻塞队列。元素按照它们的优先级顺序被处理，具有最高优先级的元素总是被队列中的下一个要处理的元素。</li>
<li><code>DelayQueue</code>: 使用优先级队列实现的延迟无界阻塞队列。队列中的元素只有在其指定的延迟时间到达时才能被取出。</li>
<li><code>SynchronousQueue</code>: 不存储元素的阻塞队列，每个插入操作必须等待一个对应的移除操作。用于直接传递任务的场景。</li>
<li><code>LinkedTransferQueue</code>: 由链表结构组成的无界阻塞队列，支持生产者-消费者的传输机制。与其他队列不同，它支持优先级传输。</li>
<li><code>LinkedBlockingDeque</code>: 由链表结构组成的双向阻塞队列。它支持在队列的两端进行插入和移除操作，是一种双端队列。</li>
</ul>
<p>当你自定义线程池时，选择合适的阻塞队列是非常重要的。阻塞队列就像一个存放任务的“箱子”，线程池中的任务先放到这里，然后线程池的线程再从这里取出来执行。
如果你的系统可能会有很多任务一起提交，可以考虑用能存很多任务的队列，比如<code>LinkedBlockingQueue</code>。这样即使任务多了，也不会丢失。
如果你的任务有优先级，比如有些任务比其他的更重要，那就选<code>PriorityBlockingQueue</code>。它会按照任务的优先级来决定哪个任务先执行。
如果应用程序需要限制内存使用，并希望在达到容量限制时阻塞新任务提交，可以选择<code>ArrayBlockingQueue</code>。</p>
<h4 id="线程池参数">线程池参数</h4>
<p>在Java中，线程池的创建和管理通过<code>java.util.concurrent.ThreadPoolExecutor</code>类完成。理解这个类构造函数的参数可以帮助我们更好地配置和优化线程池的运行效果。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span><span class="w"> </span><span class="nf">ThreadPoolExecutor</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">corePoolSize</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                          </span><span class="kt">int</span><span class="w"> </span><span class="n">maximumPoolSize</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                          </span><span class="kt">long</span><span class="w"> </span><span class="n">keepAliveTime</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                          </span><span class="n">TimeUnit</span><span class="w"> </span><span class="n">unit</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                          </span><span class="n">BlockingQueue</span><span class="o">&lt;</span><span class="n">Runnable</span><span class="o">&gt;</span><span class="w"> </span><span class="n">workQueue</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                          </span><span class="n">ThreadFactory</span><span class="w"> </span><span class="n">threadFactory</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                          </span><span class="n">RejectedExecutionHandler</span><span class="w"> </span><span class="n">handler</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">             </span><span class="c1">// ...</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><ul>
<li><code>corePoolSize</code>: 核心线程数。当提交一个新任务时，如果当前运行的线程少于<code>corePoolSize</code>，则即使有空闲的工作线程，也会创建一个新线程来执行任务。
核心线程在<code>ThreadPoolExecutor</code>的生命周期内始终存活，除非设置了<code>allowCoreThreadTimeOut</code>。</li>
<li><code>maximumPoolSize</code>：线程池能够容纳同时执行的最大线程数，此值必须大于等于1。当任务队列满时，如果当前运行的线程数少于<code>maximumPoolSize</code>，则会创建新的线程来执行任务。</li>
<li><code>threadFactory</code>：线程工厂，一般用默认的即可。用于创建新线程，通常用来给线程设置名称、设置为守护线程等。</li>
<li><code>workQueue</code>：任务队列，用于保存等待执行任务的队列。随着业务量的增多，线程开始慢慢处理不过来，这时候需要放到任务队列中去等待线程处理。</li>
<li><code>rejectedExecutionHandler</code>：拒绝策略。如果业务越来越多，线程池首先会扩容，扩容后发现还是处理不过来，任务队列已经满了，处理被拒绝任务的策略。
<ol>
<li><code>AbortPolicy</code>: 默认拒绝策略；直接抛出<code>java.util.concurrent.RejectedExecutionException</code>异常，阻止系统的正常运行；</li>
<li><code>CallerRunsPolicy</code>：调用这运行，一种调节机制，该策略既不会抛弃任务，也不会抛出异常，而是将某些任务回退到调用者，从而降低新任务的流量；</li>
<li><code>DiscardOldestPolicy</code>：抛弃队列中等待最久的任务，然后把当前任务加入到队列中；</li>
<li><code>DiscardPolicy</code>：直接丢弃任务，不给予任何处理也不会抛出异常；如果允许任务丢失，这是一种最好的解决方案；</li>
</ol>
</li>
<li><code>keepAliveTime</code>：多余的空闲线程的存活时间。如果线程池扩容后，能处理过来，而且数据量并没有那么大，用最初的线程数量就能处理过来，剩下的线程被叫做空闲线程。
<code>keepAliveTime</code>指的是当线程数超过<code>corePoolSize</code>时，多余的空闲线程在等待新任务到来之前可以存活的最长时间。如果设置为0，则超出核心线程数的空闲线程会立即终止。</li>
<li><code>unit</code>：<code>keepAliveTime</code>参数的时间单位，可以是<code>TimeUnit.SECONDS</code>、<code>TimeUnit.MILLISECONDS</code>等。</li>
</ul>
<h4 id="合理配置线程池参数">合理配置线程池参数</h4>
<p>合理配置线程池参数，可以分为以下两种情况：</p>
<ul>
<li>CPU密集型：CPU密集的意思是该任务需要大量的运算，而没有阻塞，CPU一直全速运行；CPU密集型任务配置尽可能少的线程数量：<code>参考公式：（CPU核数+1）</code></li>
<li>IO密集型：即该任务需要大量的IO，即大量的阻塞；在IO密集型任务中使用多线程可以大大的加速程序运行，故需要多配置线程数：参考公式：<code>CPU核数/ (1-阻塞系数) 阻塞系数在0.8~0.9之间</code></li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">MainTest</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="o">[]</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">ExecutorService</span><span class="w"> </span><span class="n">executor1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">null</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">try</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="c1">// 获取CPU核心数</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="kt">int</span><span class="w"> </span><span class="n">coreNum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Runtime</span><span class="p">.</span><span class="na">getRuntime</span><span class="p">().</span><span class="na">availableProcessors</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm">             * 1. IO密集型: CPU核数/ (1-阻塞系数) 阻塞系数在0.8~0.9之间
</span></span></span><span class="line"><span class="cl"><span class="cm">             * 2. CPU密集型: CPU核数+1
</span></span></span><span class="line"><span class="cl"><span class="cm">             */</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">//            int maximumPoolSize = coreNum + 1;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="kt">int</span><span class="w"> </span><span class="n">maximumPoolSize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">coreNum</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="n">1</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">0</span><span class="p">.</span><span class="na">9</span><span class="p">));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&#34;当前线程池最大允许存放：&#34;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">maximumPoolSize</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">&#34;个线程&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">executor1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ThreadPoolExecutor</span><span class="p">(</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="n">2</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="n">maximumPoolSize</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="n">1L</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="n">TimeUnit</span><span class="p">.</span><span class="na">SECONDS</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="k">new</span><span class="w"> </span><span class="n">LinkedBlockingQueue</span><span class="o">&lt;&gt;</span><span class="p">(</span><span class="n">3</span><span class="p">),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="n">Executors</span><span class="p">.</span><span class="na">defaultThreadFactory</span><span class="p">(),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="k">new</span><span class="w"> </span><span class="n">ThreadPoolExecutor</span><span class="p">.</span><span class="na">CallerRunsPolicy</span><span class="p">());</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">20</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">executor1</span><span class="p">.</span><span class="na">execute</span><span class="p">(()</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">Thread</span><span class="p">.</span><span class="na">currentThread</span><span class="p">().</span><span class="na">getName</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">&#34;执行了&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="p">});</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">finally</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">executor1</span><span class="p">.</span><span class="na">shutdown</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><h2 id="锁">锁</h2>
<p>在Java中根据锁的特性来划分可以分为很多，锁的主要作用是确保多线程环境下的数据安全，从而保证程序的正确执行。
在Java中具体&quot;锁&quot;的实现，通常可以归纳为三种，使用<code>synchronized</code>关键字、调用<code>juc.locks</code>包下相关接口、使用<code>CAS</code>思想。</p>
<table>
<thead>
<tr>
<th>锁的类型与概念</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>公平锁</td>
<td>线程按照请求的顺序获取锁。</td>
</tr>
<tr>
<td>非公平锁</td>
<td>线程获取锁的顺序不受控制，有可能插队。</td>
</tr>
<tr>
<td>可重入锁</td>
<td>允许同一个线程多次获取同一把锁，避免死锁。</td>
</tr>
<tr>
<td>不可重入锁</td>
<td>不允许同一个线程多次获取同一把锁。</td>
</tr>
<tr>
<td>共享锁</td>
<td>多个线程可以同时获取同一把锁。</td>
</tr>
<tr>
<td>独占锁</td>
<td>同一时间只允许一个线程获取该锁。</td>
</tr>
<tr>
<td>悲观锁</td>
<td>假设会有并发冲突，每次操作时都加锁。</td>
</tr>
<tr>
<td>乐观锁</td>
<td>假设不会有并发冲突，操作时不加锁，提交时检查是否冲突。</td>
</tr>
<tr>
<td>偏向锁</td>
<td>当只有一个线程访问同步块时，为该线程加锁，减少获取锁的操作成本。</td>
</tr>
<tr>
<td>轻量级锁</td>
<td>针对竞争不激烈的情况下进行优化，通过CAS操作来避免互斥。</td>
</tr>
<tr>
<td>重量级锁</td>
<td>竞争激烈时，锁的持有和释放会导致线程阻塞和唤醒。</td>
</tr>
<tr>
<td>可中断锁</td>
<td>允许在等待锁的过程中可以响应中断信号。</td>
</tr>
<tr>
<td>互斥锁</td>
<td>控制对共享资源的访问，同一时间只有一个线程可以获取锁。</td>
</tr>
<tr>
<td>死锁</td>
<td>几个线程因互相持有对方所需的资源而无法继续执行的状态。</td>
</tr>
</tbody>
</table>
<h3 id="公平锁与非公平锁">公平锁与非公平锁</h3>
<p>根据线程获取锁的顺序来划分可分为公平锁和非公平锁。</p>
<ul>
<li>公平锁：公平锁是指多个线程按照申请锁的顺序来获取锁。即先到先得的原则，先请求锁的线程会先获取到锁，后到的线程会排队等待。
优点是等待锁的线程不会饿死。缺点是整体吞吐效率相对非公平锁要低，等待队列中除第一个线程以外的所有线程都会阻塞，CPU唤醒阻塞线程的开销比非公平锁大。
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">ReentrantLock</span><span class="w"> </span><span class="n">fairLock</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ReentrantLock</span><span class="p">(</span><span class="kc">true</span><span class="p">);</span><span class="w"> </span><span class="c1">// true 表示使用公平锁</span><span class="w">
</span></span></span></code></pre></div></li>
<li>非公平锁：非公平锁是指多个线程获取锁的顺序是不确定的，是随机竞争的。即线程获取锁的顺序是不固定的，有可能新来的线程比等待时间长的线程先获取到锁。
优点是可以通过减少线程切换的开销来提高并发性能，整体的吞吐效率高。缺点是处于等待队列中的线程可能会饿死，或者等很久才会获得锁。
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">ReentrantLock</span><span class="w"> </span><span class="n">nonfairLock</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ReentrantLock</span><span class="p">(</span><span class="kc">false</span><span class="p">);</span><span class="w"> </span><span class="c1">// false 表示使用非公平锁（默认）</span><span class="w">
</span></span></span></code></pre></div></li>
</ul>
<p>通常情况下，如果不特别需要公平性，非公平锁能够提供更高的性能。但是在某些需要严格控制线程执行顺序的场景下，公平锁可能更为适合。
在Java中公平锁和非公平锁的实现为<code>ReentrantLock</code>、<code>synchronized</code>。
其中<code>synchronized</code>是非公平锁，<code>ReentrantLock</code>默认是非公平锁，但是可以指定<code>ReentrantLock</code>的构造函数创建公平锁。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * Creates an instance of {@code ReentrantLock}.
</span></span></span><span class="line"><span class="cl"><span class="cm"> * This is equivalent to using {@code ReentrantLock(false)}.
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">public</span><span class="w"> </span><span class="nf">ReentrantLock</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">sync</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">NonfairSync</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * Creates an instance of {@code ReentrantLock} with the
</span></span></span><span class="line"><span class="cl"><span class="cm"> * given fairness policy.
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param fair {@code true} if this lock should use a fair ordering policy
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">public</span><span class="w"> </span><span class="nf">ReentrantLock</span><span class="p">(</span><span class="kt">boolean</span><span class="w"> </span><span class="n">fair</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">sync</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fair</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">FairSync</span><span class="p">()</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">NonfairSync</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><h3 id="可重入锁与不可重入锁">可重入锁与不可重入锁</h3>
<p>根据一个线程是否可以多次获得同一把锁来划分，可分为可重入锁和不可重入锁。</p>
<ul>
<li>可重入锁：可重入锁是指同一个线程在外层方法获取锁之后，在内层方法仍然能够获取该锁的锁。即同一个线程可以多次获得同一把锁，可重入锁最大的作用就是避免死锁。所以可重入锁又叫做递归锁。</li>
<li>不可重入锁：所谓不可重入锁，就是与可冲入锁作用相悖；不可重入锁是指一个线程在持有锁的情况下再次请求锁时，会被阻塞或导致死锁。即同一个线程不能多次获得同一把锁。</li>
</ul>
<p>举个例子，当你进入你家时门外会有锁，进入房间后厨房卫生间都可以随便进出，这个叫可重入锁。当你进入房间时，发现厨房、卫生间都上锁而且你拿不到钥匙，这个叫不可重入锁。
在Java中<code>ReentrantLock</code>和<code>synchronized</code>都是可重入锁。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">ReentrantExample</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">synchronized</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">outerMethod</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&#34;Outer method&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">innerMethod</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">synchronized</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">innerMethod</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&#34;Inner method&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="o">[]</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">ReentrantExample</span><span class="w"> </span><span class="n">example</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ReentrantExample</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">example</span><span class="p">.</span><span class="na">outerMethod</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">ReentrantLockExample</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kd">final</span><span class="w"> </span><span class="n">ReentrantLock</span><span class="w"> </span><span class="n">lock</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ReentrantLock</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">outerMethod</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">lock</span><span class="p">.</span><span class="na">lock</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">try</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&#34;Outer method&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">innerMethod</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">finally</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">lock</span><span class="p">.</span><span class="na">unlock</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">innerMethod</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">lock</span><span class="p">.</span><span class="na">lock</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">try</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&#34;Inner method&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">finally</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">lock</span><span class="p">.</span><span class="na">unlock</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="o">[]</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">ReentrantLockExample</span><span class="w"> </span><span class="n">example</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ReentrantLockExample</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">example</span><span class="p">.</span><span class="na">outerMethod</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><h3 id="共享锁与独占锁">共享锁与独占锁</h3>
<p>根据锁的访问权限可划分为共享锁和独占锁。</p>
<ul>
<li>独占锁：独占锁又称排它锁，指一次只能有一个线程获得锁，其他所有尝试获取锁的线程都会被阻塞，直到持有锁的线程释放锁。
只有一个线程能访问受保护的资源，从而确保资源的独占访问，适用于写操作等需要完全独占资源的场景。</li>
<li>共享锁：共享锁允许多个线程同时获得锁，多个线程可以并发地访问受保护的资源。适用于读操作等可以并发访问的场景。
多个线程可以同时持有锁，但如果某个线程需要进行写操作，则必须等到所有持有共享锁的线程释放锁。</li>
</ul>
<p>在Java中，对于<code>ReentrantLock</code>和<code>synchronized</code>都是独占锁。对于<code>ReentrantReadWriteLock</code>其读锁是共享锁而写锁是独占锁，读锁的共享可保证并发读是非常高效的。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">SharedLockExample</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kd">final</span><span class="w"> </span><span class="n">ReentrantReadWriteLock</span><span class="w"> </span><span class="n">rwLock</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ReentrantReadWriteLock</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kd">final</span><span class="w"> </span><span class="n">ReentrantReadWriteLock</span><span class="p">.</span><span class="na">ReadLock</span><span class="w"> </span><span class="n">readLock</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rwLock</span><span class="p">.</span><span class="na">readLock</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kd">final</span><span class="w"> </span><span class="n">ReentrantReadWriteLock</span><span class="p">.</span><span class="na">WriteLock</span><span class="w"> </span><span class="n">writeLock</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rwLock</span><span class="p">.</span><span class="na">writeLock</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">readMethod</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">readLock</span><span class="p">.</span><span class="na">lock</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">try</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">Thread</span><span class="p">.</span><span class="na">currentThread</span><span class="p">().</span><span class="na">getName</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">&#34; acquired the read lock&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="c1">// Read-only critical section</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">finally</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">readLock</span><span class="p">.</span><span class="na">unlock</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">Thread</span><span class="p">.</span><span class="na">currentThread</span><span class="p">().</span><span class="na">getName</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">&#34; released the read lock&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">writeMethod</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">writeLock</span><span class="p">.</span><span class="na">lock</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">try</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">Thread</span><span class="p">.</span><span class="na">currentThread</span><span class="p">().</span><span class="na">getName</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">&#34; acquired the write lock&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="c1">// Write critical section</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">finally</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">writeLock</span><span class="p">.</span><span class="na">unlock</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">Thread</span><span class="p">.</span><span class="na">currentThread</span><span class="p">().</span><span class="na">getName</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">&#34; released the write lock&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="o">[]</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">SharedLockExample</span><span class="w"> </span><span class="n">example</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">SharedLockExample</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">Runnable</span><span class="w"> </span><span class="n">readTask</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">3</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">example</span><span class="p">.</span><span class="na">readMethod</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">};</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">Runnable</span><span class="w"> </span><span class="n">writeTask</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">3</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">example</span><span class="p">.</span><span class="na">writeMethod</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">};</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">Thread</span><span class="w"> </span><span class="n">t1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Thread</span><span class="p">(</span><span class="n">readTask</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">Thread</span><span class="w"> </span><span class="n">t2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Thread</span><span class="p">(</span><span class="n">readTask</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">Thread</span><span class="w"> </span><span class="n">t3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Thread</span><span class="p">(</span><span class="n">writeTask</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">t1</span><span class="p">.</span><span class="na">start</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">t2</span><span class="p">.</span><span class="na">start</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">t3</span><span class="p">.</span><span class="na">start</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><h3 id="悲观锁与乐观锁">悲观锁与乐观锁</h3>
<p>根据对数据并发访问来划分，可分为悲观锁和乐观锁。乐观锁与悲观锁是一种广义上的概念，可以理解为一种标准类似于Java中的接口。</p>
<ul>
<li>对于多线程并发操作，加了悲观锁的线程认为每一次修改数据时都会有其他线程来跟它一起修改数据，所以在修改数据之前先会加锁，确保其他线程不会修改该数据。
由于悲观锁在修改数据前先加锁的特性，能保证写操作时数据正确，所以悲观锁更适合写多读少的场景。</li>
<li>乐观锁则与悲观锁相反，每一次修改数据时，都认为没有其他线程来跟它一起修改，所以在修改数据之前不会去添加锁，如果这个数据没有被更新，当前线程将自己修改的数据成功写入。如果数据已经被其他线程更新，则根据不同的实现方式执行不同的操作。
由于乐观锁是一种无锁操作，所以在使用乐观锁的场景中读的性能会大幅度提升，适合读多写少。</li>
</ul>
<p>在Java中悲观锁的实现有，<code>synchronized</code>、<code>Lock</code>实现类，乐观锁的实现有<code>CAS</code>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">SynchronizedExample</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">0</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">synchronized</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">increment</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">count</span><span class="o">++</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">synchronized</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">getCount</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">count</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="o">[]</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">SynchronizedExample</span><span class="w"> </span><span class="n">example</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">SynchronizedExample</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">example</span><span class="p">.</span><span class="na">increment</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&#34;Count: &#34;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">example</span><span class="p">.</span><span class="na">getCount</span><span class="p">());</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">CASExample</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kd">final</span><span class="w"> </span><span class="n">AtomicInteger</span><span class="w"> </span><span class="n">count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">AtomicInteger</span><span class="p">(</span><span class="n">0</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">increment</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="kc">true</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="kt">int</span><span class="w"> </span><span class="n">existingValue</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">count</span><span class="p">.</span><span class="na">get</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="kt">int</span><span class="w"> </span><span class="n">newValue</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">existingValue</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">1</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">count</span><span class="p">.</span><span class="na">compareAndSet</span><span class="p">(</span><span class="n">existingValue</span><span class="p">,</span><span class="w"> </span><span class="n">newValue</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="k">break</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">getCount</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">count</span><span class="p">.</span><span class="na">get</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="o">[]</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">CASExample</span><span class="w"> </span><span class="n">example</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">CASExample</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">example</span><span class="p">.</span><span class="na">increment</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&#34;Count: &#34;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">example</span><span class="p">.</span><span class="na">getCount</span><span class="p">());</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><h3 id="自旋锁与适应性自旋锁">自旋锁与适应性自旋锁</h3>
<p>自旋锁是一种特殊的锁，它不会让线程立即阻塞。
当一个线程尝试获取某个锁时，如果该锁已被其他线程占用，就一直循环检测锁是否被释放，而不是进入线程挂起或睡眠状态，直到获取到某个锁超过一定的自旋次数后才会阻塞线程。
自旋锁本身是有缺点的，它不能代替阻塞。如果锁被占用的时间很长，那么自旋的线程只会白白浪费处理器资源，带来性能上的浪费，所以使用自旋锁时需要根据具体的应用场景来权衡其利弊。</p>
<p>在Java中，可以使用<code>java.util.concurrent.atomic</code>包下的原子类来实现自旋锁，其中<code>AtomicInteger</code>常被用来实现简单的自旋锁。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">SpinLock</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kd">volatile</span><span class="w"> </span><span class="kt">boolean</span><span class="w"> </span><span class="n">locked</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">false</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">lock</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// 自旋等待获取锁</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">locked</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// 获取到锁后，将 locked 设置为 true</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">locked</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">true</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">unlock</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// 释放锁</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">locked</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">false</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="o">[]</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">SpinLock</span><span class="w"> </span><span class="n">spinLock</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">SpinLock</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// 线程1</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">new</span><span class="w"> </span><span class="n">Thread</span><span class="p">(()</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">spinLock</span><span class="p">.</span><span class="na">lock</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">try</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&#34;Thread 1 in critical section&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">Thread</span><span class="p">.</span><span class="na">sleep</span><span class="p">(</span><span class="n">1000</span><span class="p">);</span><span class="w"> </span><span class="c1">// 模拟临界区代码执行</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w"> </span><span class="k">catch</span><span class="w"> </span><span class="p">(</span><span class="n">InterruptedException</span><span class="w"> </span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">e</span><span class="p">.</span><span class="na">printStackTrace</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w"> </span><span class="k">finally</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">spinLock</span><span class="p">.</span><span class="na">unlock</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}).</span><span class="na">start</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// 线程2</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">new</span><span class="w"> </span><span class="n">Thread</span><span class="p">(()</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">spinLock</span><span class="p">.</span><span class="na">lock</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">try</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&#34;Thread 2 in critical section&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">Thread</span><span class="p">.</span><span class="na">sleep</span><span class="p">(</span><span class="n">1000</span><span class="p">);</span><span class="w"> </span><span class="c1">// 模拟临界区代码执行</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w"> </span><span class="k">catch</span><span class="w"> </span><span class="p">(</span><span class="n">InterruptedException</span><span class="w"> </span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">e</span><span class="p">.</span><span class="na">printStackTrace</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w"> </span><span class="k">finally</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">spinLock</span><span class="p">.</span><span class="na">unlock</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}).</span><span class="na">start</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>为什么要使用自旋锁？在许多场景中，同步资源的锁定时间很短，为了这一小段时间去切换线程，线程挂起和恢复现场的花费可能会让系统得不偿失。
简单来说就是，避免切换线程带来的开销。自旋等待虽然避免了线程切换的开销，但它要占用处理器时间。如果锁被占用的时间很短，自旋等待的效果就会非常好。
反之，如果锁被占用的时间很长，那么自旋的线程只会白浪费处理器资源。所以自旋等待的时间必须要有一定的限度，如果自旋超过了限定次数（默认是10次，可以使用<code>-XX:PreBlockSpin</code>来更改）没有成功获得锁，就应当挂起线程。</p>
<blockquote>
<p>自旋锁在JDK 1.4中引入，默认关闭，但是可以使用<code>-XX:+UseSpinning</code>开启。在JDK1.6中默认开启，同时自旋的默认次数为10次，可以通过参数<code>-XX:PreBlockSpin</code>来调整。</p>
</blockquote>
<p>如果通过参数<code>-XX:PreBlockSpin</code>来调整自旋锁的自旋次数会带来诸多不便。假如将参数调整为10，但是系统很多线程都是等你刚刚退出的时候就释放了锁，假如多自旋一两次就可以获取锁。于是JDK1.6引入适应性自旋锁。</p>
<p>适应性自旋锁是对自旋的升级、优化，自旋的时间不再固定，它根据当前锁的使用情况动态调整自旋等待时间。
如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也是很有可能再次成功，进而它将允许自旋等待持续相对更长的时间。
如果对于某个锁，自旋很少成功获得过，那在以后尝试获取这个锁时将可能省略掉自旋过程，直接阻塞线程，避免浪费处理器资源。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">AdaptiveSpinLock</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kd">final</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">MIN_SPIN_COUNT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">10</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kd">final</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">MAX_SPIN_COUNT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">1000</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="n">AtomicBoolean</span><span class="w"> </span><span class="n">locked</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">AtomicBoolean</span><span class="p">(</span><span class="kc">false</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">spinCount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MIN_SPIN_COUNT</span><span class="p">;</span><span class="w"> </span><span class="c1">// 初始自旋等待次数设定为最小值</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">lock</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">spins</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">spinCount</span><span class="p">;</span><span class="w"> </span><span class="c1">// 获取当前自旋次数</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">locked</span><span class="p">.</span><span class="na">compareAndSet</span><span class="p">(</span><span class="kc">false</span><span class="p">,</span><span class="w"> </span><span class="kc">true</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">spins</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">MAX_SPIN_COUNT</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">spins</span><span class="o">++</span><span class="p">;</span><span class="w"> </span><span class="c1">// 自旋次数递增</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="c1">// 在真实场景中，可能需要添加短暂的延时，避免过多占用CPU资源</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">spins</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">Thread</span><span class="p">.</span><span class="na">onSpinWait</span><span class="p">();</span><span class="w"> </span><span class="c1">// 在Java 9及以上版本中，可以使用Thread.onSpinWait()来优化自旋等待</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">spinCount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">spins</span><span class="p">;</span><span class="w"> </span><span class="c1">// 更新自旋次数</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">unlock</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">locked</span><span class="p">.</span><span class="na">set</span><span class="p">(</span><span class="kc">false</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="o">[]</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">AdaptiveSpinLock</span><span class="w"> </span><span class="n">spinLock</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">AdaptiveSpinLock</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// 线程1</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">new</span><span class="w"> </span><span class="n">Thread</span><span class="p">(()</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">spinLock</span><span class="p">.</span><span class="na">lock</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">try</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&#34;Thread 1 in critical section&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">Thread</span><span class="p">.</span><span class="na">sleep</span><span class="p">(</span><span class="n">1000</span><span class="p">);</span><span class="w"> </span><span class="c1">// 模拟临界区代码执行</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w"> </span><span class="k">catch</span><span class="w"> </span><span class="p">(</span><span class="n">InterruptedException</span><span class="w"> </span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">e</span><span class="p">.</span><span class="na">printStackTrace</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w"> </span><span class="k">finally</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">spinLock</span><span class="p">.</span><span class="na">unlock</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}).</span><span class="na">start</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// 线程2</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">new</span><span class="w"> </span><span class="n">Thread</span><span class="p">(()</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">spinLock</span><span class="p">.</span><span class="na">lock</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">try</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&#34;Thread 2 in critical section&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">Thread</span><span class="p">.</span><span class="na">sleep</span><span class="p">(</span><span class="n">1000</span><span class="p">);</span><span class="w"> </span><span class="c1">// 模拟临界区代码执行</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w"> </span><span class="k">catch</span><span class="w"> </span><span class="p">(</span><span class="n">InterruptedException</span><span class="w"> </span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">e</span><span class="p">.</span><span class="na">printStackTrace</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w"> </span><span class="k">finally</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">spinLock</span><span class="p">.</span><span class="na">unlock</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}).</span><span class="na">start</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><h3 id="偏向锁">偏向锁</h3>
<p>偏向锁是Java中针对加锁操作进行的一种优化机制，主要针对只有一个线程访问同步块的场景。它的设计初衷是在无竞争的情况下，减少不必要的同步原语的性能消耗。</p>
<blockquote>
<p>《深入理解Java虚拟机》对偏向锁的解释：
<code>Hotspot</code> 的作者经过以往的研究发现大多数情况下锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。
当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程 ID，以后该线程在进入和退出同步块时不需要花费CAS操作来加锁和解锁，而只需简单的测试一下对象头的 <code>MarkWord</code> 里是否存储着指向当前线程的偏向锁，如果测试成功，表示线程已经获得了锁，如果测试失败，则需要再测试下 <code>MarkWord</code> 中偏向锁的标识是否设置成 1（表示当前是偏向锁），如果没有设置，则使用 CAS 竞争锁，如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程。</p>
</blockquote>
<p>之所以叫偏向锁是因为偏向于第一个获取到他的线程，如果在程序执行中该锁没有被其他的线程获取，则持有偏向锁的线程将永远不需要再进行同步。
但是如果线程间存在锁竞争，偏向锁会失效，此时会涉及到锁的撤销，将锁状态升级为适合多线程竞争的轻量级锁或者重量级锁，这个过程可能会引入额外的开销，影响性能。</p>
<p>当一个线程访问同步块时，首先会尝试获取偏向锁。如果同步块之前没有被其他线程锁定，当前线程会尝试获取偏向锁，并将对象头的标记位设置为偏向锁。
如果其他线程尝试访问该同步块，会检测到该同步块已经被偏向锁定，会尝试撤销偏向锁，升级为轻量级锁或者重量级锁。
如果偏向线程已经不再访问该同步块，那么该对象头的标记位会被设置成无锁状态，接着是无锁状态。</p>
<h3 id="轻量级锁与重量级锁">轻量级锁与重量级锁</h3>
<p>根据锁的竞争情况来划分可以分为重量级锁和轻量级锁。</p>
<ul>
<li>重量级锁：重量级锁适用于多线程竞争激烈的情况下，它的实现通常依赖于操作系统的底层特性，重量级锁会导致线程堵塞。传统的重量级锁，使用的是系统互斥量实现的。</li>
<li>轻量级锁：相对于重量级锁而言的。轻量级锁适用于多线程竞争不激烈的情况下，它的设计目标是在减少传统重量级锁在竞争时带来的性能损耗。</li>
</ul>
<p>在Java中轻量级锁的经典实现是CAS中的自旋锁。优点是竞争的线程不会阻塞，提高了程序的响应速度；缺点是如果始终得不到锁竞争的线程，使用自旋会消耗CPU。所以轻量级锁适合，追求响应时间，同步块执行速度非常快的场景。
重量级锁依赖于操作系统提供的底层同步机制。优点是线程竞争不使用自旋，不会消耗CPU；缺点是当多个线程竞争同一个锁时，会直接阻塞等待，直到获取到锁的线程释放锁资源。适合追求吞吐量、同步块执行时间较长也就是线程竞争激烈的场景。</p>
<p>轻量级锁不是在任何情况下都比重量级锁快的，要看同步块执行期间有没有多个线程抢占资源的情况。如果有，那么轻量级线程要承担CAS+互斥锁的性能消耗，就会比重量锁执行的更慢。</p>
<h3 id="可中断锁">可中断锁</h3>
<p>可中断锁顾名思义，就是可以中断的锁。
如果某一线程A正在执行锁中的代码，另一线程B正在等待获取该锁，可能由于等待时间过长，线程B不想等待了，想先处理其他事情，我们可以让它中断自己或者在别的线程中中断它，这种就是可中断锁。</p>
<p>在Java中<code>synchronized</code>就是不可中断锁，<code>Lock</code>是可中断锁。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">SynchronizedExample</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kd">final</span><span class="w"> </span><span class="n">Object</span><span class="w"> </span><span class="n">lock</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Object</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="o">[]</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="kd">throws</span><span class="w"> </span><span class="n">InterruptedException</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">Thread</span><span class="w"> </span><span class="n">thread1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Thread</span><span class="p">(()</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="kd">synchronized</span><span class="w"> </span><span class="p">(</span><span class="n">lock</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">Thread</span><span class="p">.</span><span class="na">currentThread</span><span class="p">().</span><span class="na">getName</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">&#34; acquired the lock&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="k">try</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="n">Thread</span><span class="p">.</span><span class="na">sleep</span><span class="p">(</span><span class="n">5000</span><span class="p">);</span><span class="w"> </span><span class="c1">// 模拟线程持有锁的操作</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="p">}</span><span class="w"> </span><span class="k">catch</span><span class="w"> </span><span class="p">(</span><span class="n">InterruptedException</span><span class="w"> </span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="n">e</span><span class="p">.</span><span class="na">printStackTrace</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">},</span><span class="w"> </span><span class="s">&#34;Thread-1&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">Thread</span><span class="w"> </span><span class="n">thread2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Thread</span><span class="p">(()</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="kd">synchronized</span><span class="w"> </span><span class="p">(</span><span class="n">lock</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">Thread</span><span class="p">.</span><span class="na">currentThread</span><span class="p">().</span><span class="na">getName</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">&#34; acquired the lock&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">},</span><span class="w"> </span><span class="s">&#34;Thread-2&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">thread1</span><span class="p">.</span><span class="na">start</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">Thread</span><span class="p">.</span><span class="na">sleep</span><span class="p">(</span><span class="n">1000</span><span class="p">);</span><span class="w"> </span><span class="c1">// 让Thread-1先获取锁</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">thread2</span><span class="p">.</span><span class="na">start</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// 等待线程执行完成</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">thread1</span><span class="p">.</span><span class="na">join</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">thread2</span><span class="p">.</span><span class="na">join</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">LockExample</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kd">final</span><span class="w"> </span><span class="n">Lock</span><span class="w"> </span><span class="n">lock</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ReentrantLock</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="o">[]</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="kd">throws</span><span class="w"> </span><span class="n">InterruptedException</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">Thread</span><span class="w"> </span><span class="n">thread1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Thread</span><span class="p">(()</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">lock</span><span class="p">.</span><span class="na">lock</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">try</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">Thread</span><span class="p">.</span><span class="na">currentThread</span><span class="p">().</span><span class="na">getName</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">&#34; acquired the lock&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">Thread</span><span class="p">.</span><span class="na">sleep</span><span class="p">(</span><span class="n">5000</span><span class="p">);</span><span class="w"> </span><span class="c1">// 模拟线程持有锁的操作</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w"> </span><span class="k">catch</span><span class="w"> </span><span class="p">(</span><span class="n">InterruptedException</span><span class="w"> </span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">e</span><span class="p">.</span><span class="na">printStackTrace</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w"> </span><span class="k">finally</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">lock</span><span class="p">.</span><span class="na">unlock</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">},</span><span class="w"> </span><span class="s">&#34;Thread-1&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">Thread</span><span class="w"> </span><span class="n">thread2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Thread</span><span class="p">(()</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">try</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">lock</span><span class="p">.</span><span class="na">tryLock</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// 可中断地尝试获取锁</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="k">try</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                        </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">Thread</span><span class="p">.</span><span class="na">currentThread</span><span class="p">().</span><span class="na">getName</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">&#34; acquired the lock&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="p">}</span><span class="w"> </span><span class="k">finally</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                        </span><span class="n">lock</span><span class="p">.</span><span class="na">unlock</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">Thread</span><span class="p">.</span><span class="na">currentThread</span><span class="p">().</span><span class="na">getName</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">&#34; unable to acquire the lock&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w"> </span><span class="k">catch</span><span class="w"> </span><span class="p">(</span><span class="n">InterruptedException</span><span class="w"> </span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">e</span><span class="p">.</span><span class="na">printStackTrace</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">},</span><span class="w"> </span><span class="s">&#34;Thread-2&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">thread1</span><span class="p">.</span><span class="na">start</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">Thread</span><span class="p">.</span><span class="na">sleep</span><span class="p">(</span><span class="n">1000</span><span class="p">);</span><span class="w"> </span><span class="c1">// 让Thread-1先获取锁</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">thread2</span><span class="p">.</span><span class="na">start</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// 等待线程执行完成</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">thread1</span><span class="p">.</span><span class="na">join</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">thread2</span><span class="p">.</span><span class="na">join</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><h3 id="互斥锁">互斥锁</h3>
<p>互斥锁是一种用于多线程编程中的同步原语，用于确保在任何时刻，只有一个线程可以访问共享资源，从而避免数据竞争和并发访问的冲突。
在编程中，引入了对象互斥锁的概念，来保证共享数据操作的完整性。每个对象都对应于一个可称为&quot;互斥锁&quot;的标记，这个标记用来保证在任一时刻，只能有一个线程访问该对象。</p>
<p>互斥锁在访问共享资源之前对对象进行加锁操作，在访问完成之后进行解锁操作。加锁后，任何其他试图再次加锁的线程会被阻塞，直到当前线程解锁其他线程才能访问公共资源。
如果在解锁时有多个线程在等待获取锁，一旦锁被释放，它们将竞争重新获取锁。只有第一个竞争到锁的线程会变为就绪状态并开始执行，其他线程将继续等待。</p>
<p>在Java里最基本的互斥手段就是使用<code>synchronized</code>关键字、<code>ReentrantLock</code>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">SynchronizedMutexExample</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">counter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">0</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kd">final</span><span class="w"> </span><span class="n">Object</span><span class="w"> </span><span class="n">lock</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Object</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="o">[]</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="kd">throws</span><span class="w"> </span><span class="n">InterruptedException</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">Runnable</span><span class="w"> </span><span class="n">task</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="kd">synchronized</span><span class="w"> </span><span class="p">(</span><span class="n">lock</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">10000</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="n">counter</span><span class="o">++</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">};</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">Thread</span><span class="w"> </span><span class="n">thread1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Thread</span><span class="p">(</span><span class="n">task</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">Thread</span><span class="w"> </span><span class="n">thread2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Thread</span><span class="p">(</span><span class="n">task</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">thread1</span><span class="p">.</span><span class="na">start</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">thread2</span><span class="p">.</span><span class="na">start</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">thread1</span><span class="p">.</span><span class="na">join</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">thread2</span><span class="p">.</span><span class="na">join</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&#34;Counter: &#34;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">counter</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><h3 id="死锁">死锁</h3>
<p>死锁并不是Java程序中通俗意义上的&quot;锁&quot;，而是程序中出现的一种问题。之所以放到“锁”这个标题下是为了方便类比，就类似谐音梗吧。</p>
<p>死锁是指两个或多个线程在执行过程中，由于竞争资源或者互相等待释放资源而造成的一种僵局，使得所有参与的线程无法继续执行。
举个例子，当线程A持有锁a并尝试获取锁b，线程B持有锁b并尝试获取锁a时，就会出现死锁。简单来说，死锁问题的产生是由两个或者以上线程并行执行的时候，争夺资源而互相等待造成的。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="w"> </span><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">MainTest</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"> 
</span></span></span><span class="line"><span class="cl"><span class="w">     </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="o">[]</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">          </span><span class="n">String</span><span class="w"> </span><span class="n">lockA</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&#34;lockA&#34;</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">          </span><span class="n">String</span><span class="w"> </span><span class="n">lockB</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&#34;lockB&#34;</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">         </span><span class="k">new</span><span class="w"> </span><span class="n">Thread</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">ThreadHolderLock</span><span class="p">(</span><span class="n">lockA</span><span class="p">,</span><span class="n">lockB</span><span class="p">),</span><span class="s">&#34;线程AAA&#34;</span><span class="p">).</span><span class="na">start</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">         </span><span class="k">new</span><span class="w"> </span><span class="n">Thread</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">ThreadHolderLock</span><span class="p">(</span><span class="n">lockB</span><span class="p">,</span><span class="n">lockA</span><span class="p">),</span><span class="s">&#34;线程BBB&#34;</span><span class="p">).</span><span class="na">start</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">     </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"> </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"> 
</span></span></span><span class="line"><span class="cl"><span class="w"> </span><span class="kd">class</span> <span class="nc">ThreadHolderLock</span><span class="w"> </span><span class="kd">implements</span><span class="w"> </span><span class="n">Runnable</span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"> 
</span></span></span><span class="line"><span class="cl"><span class="w">     </span><span class="kd">private</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="n">lockA</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">     </span><span class="kd">private</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="n">lockB</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"> 
</span></span></span><span class="line"><span class="cl"><span class="w">     </span><span class="kd">public</span><span class="w"> </span><span class="nf">ThreadHolderLock</span><span class="p">(</span><span class="n">String</span><span class="w"> </span><span class="n">lockA</span><span class="p">,</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="n">lockB</span><span class="p">){</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">         </span><span class="k">this</span><span class="p">.</span><span class="na">lockA</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lockA</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">         </span><span class="k">this</span><span class="p">.</span><span class="na">lockB</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lockB</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">     </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"> 
</span></span></span><span class="line"><span class="cl"><span class="w">     </span><span class="nd">@Override</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">     </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">run</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">         </span><span class="kd">synchronized</span><span class="w"> </span><span class="p">(</span><span class="n">lockA</span><span class="p">){</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">             </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">Thread</span><span class="p">.</span><span class="na">currentThread</span><span class="p">().</span><span class="na">getName</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">&#34;\t 持有锁 &#34;</span><span class="o">+</span><span class="w"> </span><span class="n">lockA</span><span class="o">+</span><span class="s">&#34;, 尝试获得&#34;</span><span class="o">+</span><span class="w"> </span><span class="n">lockB</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"> 
</span></span></span><span class="line"><span class="cl"><span class="w">             </span><span class="k">try</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                 </span><span class="n">Thread</span><span class="p">.</span><span class="na">sleep</span><span class="p">(</span><span class="n">1000</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">             </span><span class="p">}</span><span class="w"> </span><span class="k">catch</span><span class="w"> </span><span class="p">(</span><span class="n">InterruptedException</span><span class="w"> </span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                 </span><span class="n">e</span><span class="p">.</span><span class="na">printStackTrace</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">             </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"> 
</span></span></span><span class="line"><span class="cl"><span class="w">             </span><span class="kd">synchronized</span><span class="w"> </span><span class="p">(</span><span class="n">lockB</span><span class="p">){</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                 </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">Thread</span><span class="p">.</span><span class="na">currentThread</span><span class="p">().</span><span class="na">getName</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">&#34;\t 持有锁 &#34;</span><span class="o">+</span><span class="w"> </span><span class="n">lockB</span><span class="o">+</span><span class="s">&#34;, 尝试获得&#34;</span><span class="o">+</span><span class="w"> </span><span class="n">lockA</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">             </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">         </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">     </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"> </span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><h4 id="使用资源有序分配法避免死锁">使用资源有序分配法避免死锁</h4>
<p>想要如何避免死锁，就要弄清楚死锁出现的原因，造成死锁必须达成的4个条件：</p>
<ul>
<li>互斥条件：一个资源每次只能被一个线程使用。例如，如果线程 A 已经持有的资源，不能再同时被线程 B 持有，如果线程 B 请求获取线程 A 已经占用的资源，那线程 B 只能等待，直到线程 A 释放了资源。</li>
<li>请求与保持条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放。例如，当线程 A 已经持有了资源 1，又想申请资源 2，而资源 2 已经被线程 C 持有了，所以线程 A 就会处于等待状态，但是线程 A 在等待资源 2 的同时并不会释放自己已经持有的资源 1。</li>
<li>不剥夺条件：线程已获得的资源，在未使用完之前，不能强行剥夺。例如，当线程A已经持有了资源 ，在自己使用完之前不能被其他线程获取，线程 B 如果也想使用此资源，则只能在线程 A 使用完并释放后才能获取。</li>
<li>循环等待条件：若干线程之间形成一种头尾相接的循环等待资源关系。比如，线程 A 已经持有资源 2，而想请求资源 1， 线程 B 已经获取了资源 1，而想请求资源 2，这就形成资源请求等待的环。</li>
</ul>
<p>避免死锁的产生就只需要破环其中一个条件就可以，最常见的并且可行的就是使用资源有序分配法，来破循环等待条件。
资源有序分配法指的是，线程 A 和 线程 B 获取资源的顺序要一样，当线程 A 先尝试获取资源 A，然后尝试获取资源 B 的时候，线程 B 同样也是先尝试获取资源 A，然后尝试获取资源 B。也就是说，线程 A 和 线程 B 总是以相同的顺序申请自己想要的资源。
给资源分配一个全局的唯一编号，进程必须按资源编号的顺序请求资源。这种方法可以避免循环等待，从而防止死锁。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">class</span> <span class="nc">Resource</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kd">final</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">id</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="nf">Resource</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">id</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="na">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">id</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">getId</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">id</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">class</span> <span class="nc">Process</span><span class="w"> </span><span class="kd">extends</span><span class="w"> </span><span class="n">Thread</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kd">final</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">id</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kd">final</span><span class="w"> </span><span class="n">Resource</span><span class="o">[]</span><span class="w"> </span><span class="n">resources</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="nf">Process</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">Resource</span><span class="o">[]</span><span class="w"> </span><span class="n">resources</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="na">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">id</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="na">resources</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">resources</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nd">@Override</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">run</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">try</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">acquireResources</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="c1">// 模拟处理</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">Thread</span><span class="p">.</span><span class="na">sleep</span><span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">Math</span><span class="p">.</span><span class="na">random</span><span class="p">()</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">1000</span><span class="p">));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">releaseResources</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">catch</span><span class="w"> </span><span class="p">(</span><span class="n">InterruptedException</span><span class="w"> </span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">e</span><span class="p">.</span><span class="na">printStackTrace</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">acquireResources</span><span class="p">()</span><span class="w"> </span><span class="kd">throws</span><span class="w"> </span><span class="n">InterruptedException</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">Resource</span><span class="w"> </span><span class="n">resource</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">resources</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="kd">synchronized</span><span class="w"> </span><span class="p">(</span><span class="n">resource</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&#34;Process &#34;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">&#34; acquired Resource &#34;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">resource</span><span class="p">.</span><span class="na">getId</span><span class="p">());</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">releaseResources</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">Resource</span><span class="w"> </span><span class="n">resource</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">resources</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="kd">synchronized</span><span class="w"> </span><span class="p">(</span><span class="n">resource</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&#34;Process &#34;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">&#34; released Resource &#34;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">resource</span><span class="p">.</span><span class="na">getId</span><span class="p">());</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">ResourceOrderingExample</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="o">[]</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">Resource</span><span class="w"> </span><span class="n">resource1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Resource</span><span class="p">(</span><span class="n">1</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">Resource</span><span class="w"> </span><span class="n">resource2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Resource</span><span class="p">(</span><span class="n">2</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">Resource</span><span class="w"> </span><span class="n">resource3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Resource</span><span class="p">(</span><span class="n">3</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">Process</span><span class="w"> </span><span class="n">process1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Process</span><span class="p">(</span><span class="n">1</span><span class="p">,</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Resource</span><span class="o">[]</span><span class="p">{</span><span class="n">resource1</span><span class="p">,</span><span class="w"> </span><span class="n">resource2</span><span class="p">});</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">Process</span><span class="w"> </span><span class="n">process2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Process</span><span class="p">(</span><span class="n">2</span><span class="p">,</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Resource</span><span class="o">[]</span><span class="p">{</span><span class="n">resource2</span><span class="p">,</span><span class="w"> </span><span class="n">resource3</span><span class="p">});</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">Process</span><span class="w"> </span><span class="n">process3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Process</span><span class="p">(</span><span class="n">3</span><span class="p">,</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Resource</span><span class="o">[]</span><span class="p">{</span><span class="n">resource3</span><span class="p">,</span><span class="w"> </span><span class="n">resource1</span><span class="p">});</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">process1</span><span class="p">.</span><span class="na">start</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">process2</span><span class="p">.</span><span class="na">start</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">process3</span><span class="p">.</span><span class="na">start</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><h4 id="使用银行家算法避免死锁">使用银行家算法避免死锁</h4>
<p><img alt="银行家算法" src="/iblog/posts/annex/images/essays/%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95.png"></p>
<p>银行家算法：一个避免死锁的著名算法，是由艾兹格·迪杰斯特拉在1965年为T.H.E系统设计的一种避免死锁产生的算法。它以银行借贷系统的分配策略为基础，判断并保证系统的安全运行。</p>
<p>在银行中，客户申请贷款的数量是有限的，每个客户在第一次申请贷款时要声明完成该项目所需的最大资金量，在满足所有贷款要求时，客户应及时归还。银行家在客户申请的贷款数量不超过自己拥有的最大值时，都应尽量满足客户的需要。通过判断借贷是否安全，然后决定借不借。
举例，现有公司B、公司A、公司T，想要从银行分别贷款70亿、40亿、50亿，假设银行只有100亿供放贷，如果借不到企业最大需求的钱，钱将不会归还，怎么才能合理的放贷？</p>
<table>
<thead>
<tr>
<th>公司</th>
<th>最大需求</th>
<th>已借走</th>
<th>最多还借</th>
</tr>
</thead>
<tbody>
<tr>
<td>B</td>
<td>70</td>
<td>20</td>
<td>50</td>
</tr>
<tr>
<td>A</td>
<td>40</td>
<td>10</td>
<td>30</td>
</tr>
<tr>
<td>T</td>
<td>50</td>
<td>30</td>
<td>20</td>
</tr>
</tbody>
</table>
<p>此时公司B、A、T已经从银行借走60亿，银行还剩40亿。此时银行可放贷金额组合：</p>
<ul>
<li>借给公司B10亿、公司A10亿、公司T20亿，等待公司T还钱再将10亿借给公司A，等待公司A还钱，再将钱借给公司B；</li>
<li>借给公司T20亿，等公司T还钱再将钱借给公司A，等待公司A还钱再将钱借给公司B；</li>
<li>借给公司A10亿，等待公司A还钱再将钱借给公司T，公司T还钱再将钱借给公司B；</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">class</span> <span class="nc">Banker</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kt">int</span><span class="o">[]</span><span class="w"> </span><span class="n">available</span><span class="p">;</span><span class="w">  </span><span class="c1">// 系统可用资源</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kt">int</span><span class="o">[][]</span><span class="w"> </span><span class="n">maximum</span><span class="p">;</span><span class="w">  </span><span class="c1">// 每个进程的最大资源需求</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kt">int</span><span class="o">[][]</span><span class="w"> </span><span class="n">allocation</span><span class="p">;</span><span class="w"> </span><span class="c1">// 每个进程当前已分配的资源</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kt">int</span><span class="o">[][]</span><span class="w"> </span><span class="n">need</span><span class="p">;</span><span class="w">      </span><span class="c1">// 每个进程剩余的资源需求</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="nf">Banker</span><span class="p">(</span><span class="kt">int</span><span class="o">[]</span><span class="w"> </span><span class="n">available</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">[][]</span><span class="w"> </span><span class="n">maximum</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="na">available</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">available</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="na">maximum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">maximum</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">numProcesses</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">maximum</span><span class="p">.</span><span class="na">length</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">numResources</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">available</span><span class="p">.</span><span class="na">length</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">allocation</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="kt">int</span><span class="o">[</span><span class="n">numProcesses</span><span class="o">][</span><span class="n">numResources</span><span class="o">]</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">need</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="kt">int</span><span class="o">[</span><span class="n">numProcesses</span><span class="o">][</span><span class="n">numResources</span><span class="o">]</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">numProcesses</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">0</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">numResources</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">need</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">maximum</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span><span class="p">;</span><span class="w"> </span><span class="c1">// 初始时，Need等于Maximum</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// 请求资源的方法</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">synchronized</span><span class="w"> </span><span class="kt">boolean</span><span class="w"> </span><span class="nf">requestResources</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">processId</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">[]</span><span class="w"> </span><span class="n">request</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">isRequestValid</span><span class="p">(</span><span class="n">processId</span><span class="p">,</span><span class="w"> </span><span class="n">request</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="kc">false</span><span class="p">;</span><span class="w"> </span><span class="c1">// 请求不合法，拒绝请求</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// 试探性分配</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">available</span><span class="p">.</span><span class="na">length</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">available</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="n">request</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">allocation</span><span class="o">[</span><span class="n">processId</span><span class="o">][</span><span class="n">i</span><span class="o">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">request</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">need</span><span class="o">[</span><span class="n">processId</span><span class="o">][</span><span class="n">i</span><span class="o">]</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="n">request</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// 安全性检查</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kt">boolean</span><span class="w"> </span><span class="n">safe</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">isSafeState</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">safe</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="c1">// 如果不安全，恢复试探性分配前的状态</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">available</span><span class="p">.</span><span class="na">length</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">available</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">request</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">allocation</span><span class="o">[</span><span class="n">processId</span><span class="o">][</span><span class="n">i</span><span class="o">]</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="n">request</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">need</span><span class="o">[</span><span class="n">processId</span><span class="o">][</span><span class="n">i</span><span class="o">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">request</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">safe</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kt">boolean</span><span class="w"> </span><span class="nf">isRequestValid</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">processId</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">[]</span><span class="w"> </span><span class="n">request</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">request</span><span class="p">.</span><span class="na">length</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">request</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">need</span><span class="o">[</span><span class="n">processId</span><span class="o">][</span><span class="n">i</span><span class="o">]</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">request</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">available</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="kc">false</span><span class="p">;</span><span class="w"> </span><span class="c1">// 请求超出需求或可用资源</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="kc">true</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kt">boolean</span><span class="w"> </span><span class="nf">isSafeState</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kt">int</span><span class="o">[]</span><span class="w"> </span><span class="n">work</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">available</span><span class="p">.</span><span class="na">clone</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kt">boolean</span><span class="o">[]</span><span class="w"> </span><span class="n">finish</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="kt">boolean</span><span class="o">[</span><span class="n">allocation</span><span class="p">.</span><span class="na">length</span><span class="o">]</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="kc">true</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="kt">boolean</span><span class="w"> </span><span class="n">found</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">false</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">allocation</span><span class="p">.</span><span class="na">length</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">finish</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="kt">boolean</span><span class="w"> </span><span class="n">canProceed</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">true</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">0</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">work</span><span class="p">.</span><span class="na">length</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">need</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">work</span><span class="o">[</span><span class="n">j</span><span class="o">]</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                            </span><span class="n">canProceed</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">false</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                            </span><span class="k">break</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">canProceed</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">0</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">work</span><span class="p">.</span><span class="na">length</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                            </span><span class="n">work</span><span class="o">[</span><span class="n">j</span><span class="o">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">allocation</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                        </span><span class="n">finish</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">true</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                        </span><span class="n">found</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">true</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">found</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="k">break</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">boolean</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">finish</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="kc">false</span><span class="p">;</span><span class="w"> </span><span class="c1">// 存在未完成的进程，系统不安全</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="kc">true</span><span class="p">;</span><span class="w"> </span><span class="c1">// 所有进程都完成，系统安全</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">BankerExample</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="o">[]</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kt">int</span><span class="o">[]</span><span class="w"> </span><span class="n">available</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="n">3</span><span class="p">,</span><span class="w"> </span><span class="n">3</span><span class="p">,</span><span class="w"> </span><span class="n">2</span><span class="p">};</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kt">int</span><span class="o">[][]</span><span class="w"> </span><span class="n">maximum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">{</span><span class="n">7</span><span class="p">,</span><span class="w"> </span><span class="n">5</span><span class="p">,</span><span class="w"> </span><span class="n">3</span><span class="p">},</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">{</span><span class="n">3</span><span class="p">,</span><span class="w"> </span><span class="n">2</span><span class="p">,</span><span class="w"> </span><span class="n">2</span><span class="p">},</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">{</span><span class="n">9</span><span class="p">,</span><span class="w"> </span><span class="n">0</span><span class="p">,</span><span class="w"> </span><span class="n">2</span><span class="p">},</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">{</span><span class="n">2</span><span class="p">,</span><span class="w"> </span><span class="n">2</span><span class="p">,</span><span class="w"> </span><span class="n">2</span><span class="p">},</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">{</span><span class="n">4</span><span class="p">,</span><span class="w"> </span><span class="n">3</span><span class="p">,</span><span class="w"> </span><span class="n">3</span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">};</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">Banker</span><span class="w"> </span><span class="n">banker</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Banker</span><span class="p">(</span><span class="n">available</span><span class="p">,</span><span class="w"> </span><span class="n">maximum</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kt">int</span><span class="o">[]</span><span class="w"> </span><span class="n">request1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="n">1</span><span class="p">,</span><span class="w"> </span><span class="n">0</span><span class="p">,</span><span class="w"> </span><span class="n">2</span><span class="p">};</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kt">boolean</span><span class="w"> </span><span class="n">granted1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">banker</span><span class="p">.</span><span class="na">requestResources</span><span class="p">(</span><span class="n">1</span><span class="p">,</span><span class="w"> </span><span class="n">request1</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&#34;Request 1 granted: &#34;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">granted1</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kt">int</span><span class="o">[]</span><span class="w"> </span><span class="n">request2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="n">3</span><span class="p">,</span><span class="w"> </span><span class="n">3</span><span class="p">,</span><span class="w"> </span><span class="n">0</span><span class="p">};</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kt">boolean</span><span class="w"> </span><span class="n">granted2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">banker</span><span class="p">.</span><span class="na">requestResources</span><span class="p">(</span><span class="n">4</span><span class="p">,</span><span class="w"> </span><span class="n">request2</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&#34;Request 2 granted: &#34;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">granted2</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kt">int</span><span class="o">[]</span><span class="w"> </span><span class="n">request3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="n">2</span><span class="p">,</span><span class="w"> </span><span class="n">0</span><span class="p">,</span><span class="w"> </span><span class="n">0</span><span class="p">};</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kt">boolean</span><span class="w"> </span><span class="n">granted3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">banker</span><span class="p">.</span><span class="na">requestResources</span><span class="p">(</span><span class="n">0</span><span class="p">,</span><span class="w"> </span><span class="n">request3</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&#34;Request 3 granted: &#34;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">granted3</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><h4 id="使用trylock进行超时锁定">使用tryLock进行超时锁定</h4>
<p>使用 <code>java.util.concurrent.locks.ReentrantLock</code> 的 <code>tryLock</code>方法可以尝试获取锁，并设置超时时间，避免长时间等待造成的死锁。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">class</span> <span class="nc">Process</span><span class="w"> </span><span class="kd">extends</span><span class="w"> </span><span class="n">Thread</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kd">final</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">id</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kd">final</span><span class="w"> </span><span class="n">Lock</span><span class="w"> </span><span class="n">lock1</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kd">final</span><span class="w"> </span><span class="n">Lock</span><span class="w"> </span><span class="n">lock2</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="nf">Process</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">Lock</span><span class="w"> </span><span class="n">lock1</span><span class="p">,</span><span class="w"> </span><span class="n">Lock</span><span class="w"> </span><span class="n">lock2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="na">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">id</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="na">lock1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lock1</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="na">lock2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lock2</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nd">@Override</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">run</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">try</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="kc">true</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">lock1</span><span class="p">.</span><span class="na">tryLock</span><span class="p">(</span><span class="n">50</span><span class="p">,</span><span class="w"> </span><span class="n">TimeUnit</span><span class="p">.</span><span class="na">MILLISECONDS</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="k">try</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">lock2</span><span class="p">.</span><span class="na">tryLock</span><span class="p">(</span><span class="n">50</span><span class="p">,</span><span class="w"> </span><span class="n">TimeUnit</span><span class="p">.</span><span class="na">MILLISECONDS</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                            </span><span class="k">try</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                                </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&#34;Process &#34;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">&#34; acquired both locks&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                                </span><span class="c1">// 模拟处理</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                                </span><span class="n">Thread</span><span class="p">.</span><span class="na">sleep</span><span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">Math</span><span class="p">.</span><span class="na">random</span><span class="p">()</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">1000</span><span class="p">));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                                </span><span class="k">return</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                            </span><span class="p">}</span><span class="w"> </span><span class="k">finally</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                                </span><span class="n">lock2</span><span class="p">.</span><span class="na">unlock</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                            </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="p">}</span><span class="w"> </span><span class="k">finally</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                        </span><span class="n">lock1</span><span class="p">.</span><span class="na">unlock</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="c1">// 等待一段时间再重试</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">Thread</span><span class="p">.</span><span class="na">sleep</span><span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">Math</span><span class="p">.</span><span class="na">random</span><span class="p">()</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">50</span><span class="p">));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">catch</span><span class="w"> </span><span class="p">(</span><span class="n">InterruptedException</span><span class="w"> </span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">e</span><span class="p">.</span><span class="na">printStackTrace</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">TryLockExample</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="o">[]</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">Lock</span><span class="w"> </span><span class="n">lock1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ReentrantLock</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">Lock</span><span class="w"> </span><span class="n">lock2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ReentrantLock</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">Process</span><span class="w"> </span><span class="n">process1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Process</span><span class="p">(</span><span class="n">1</span><span class="p">,</span><span class="w"> </span><span class="n">lock1</span><span class="p">,</span><span class="w"> </span><span class="n">lock2</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">Process</span><span class="w"> </span><span class="n">process2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Process</span><span class="p">(</span><span class="n">2</span><span class="p">,</span><span class="w"> </span><span class="n">lock2</span><span class="p">,</span><span class="w"> </span><span class="n">lock1</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">process1</span><span class="p">.</span><span class="na">start</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">process2</span><span class="p">.</span><span class="na">start</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><h2 id="线程安全">线程安全</h2>
<p>什么是线程安全？如果只有一个线程才可以操作此数据，则必是线程安全的。如果有多个线程操作，则此数据是共享数据，如果不考虑共享机制，则为线程不安全。
如果对象是在内部产生，并在内部消亡，没有返回到外部，那么它就是线程安全的，反之则是线程不安全的。</p>
<p>在多线程并发的环境中，多个线程共同操作同一个数据，如果最后数据的值和期待值不一样，这时候就出现了线程不安全问题。
在Java中保证线程安全，最常用的就是加锁。当一个线程修改某个数据的时候，其他线程不能进行访问直到该线程操作该数据结束释放锁，其他线程才可以继续操作该数据。
一个对象是否安全取决于它是否被多个线程访问，要使对象线程安全，那么需要采用同步的机制来协同对对象可变状态的访问。</p>
<h3 id="三大特性">三大特性</h3>
<p>在保证线程安全之前要先弄明白线程安全的三大特性，即原子性、可见性、有序性。</p>
<ul>
<li>原子性，即不可分割，完整性.当某个线程正在做某个业务时，中间不能被打断、加塞，不能被分割.需要整体完整。要么同时成功，要么同时失败.与数据库中的原子性类似。</li>
<li>可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即获取到修改的值。</li>
<li>有序性即程序执行的顺序按照代码的先后顺序执行。</li>
</ul>
<p>关于有序性肯定会有人有疑问，程序执行的顺序难道不是从上到下按照顺序来执行吗？</p>
<p>在多线程环境下，Java语句可能会不按照顺序执行，所以要注意数据的依赖性。计算机在执行程序时，为了提高性能，编译器和处理器常常会做指令重排，一把分为以下两种：</p>
<ul>
<li>单线程环境里面确保程序最终执行结果和代码顺序执行的结果一致。处理器在进行重新排序是必须要考虑指令之间的数据依赖；</li>
<li>多线程环境中线程交替执行，由于编译器优化重排的存在，两个线程使用的变量能否保持一致性是无法确定的，结果无法预测；</li>
</ul>
<p><strong>多线程并发出问题的根本原因：</strong></p>
<ul>
<li>CPU切换线程执导致的原子性问题；</li>
<li>由于CPU、内存、IO 设备读写速度差异巨大，为了减少CPU等待IO的时间，在CPU和IO之间建立高速缓存，在多核CPU的情况下，会导致高速缓存与主内存之间的数据不一致，即缓存可见性问题；</li>
<li>指令优化重排序问题；</li>
</ul>
<h3 id="内存模型">内存模型</h3>
<blockquote>
<p>为了保证并发编程中可以满足原子性、可见性及有序性。内存模型定义了共享内存系统中多线程程序读写操作行为的规范。
通过这些规则来规范对内存的读写操作，从而保证指令执行的正确性。它与处理器有关、与缓存有关、与并发有关、与编译器也有关。
他解决了CPU多级缓存、处理器优化、指令重排等导致的内存访问问题，保证了并发场景下的一致性、原子性和有序性。</p>
</blockquote>
<p>内存模型解决并发问题主要采用两种方式：限制处理器优化和使用内存屏障。</p>
<p><strong><a href="http://www.cs.umd.edu/~pugh/java/memoryModel/jsr133.pdf">Java内存模型</a></strong></p>
<p>Java内存模型，即JMM（Java Memory Model）本身是一种抽象的概念,并不真实存在,它描述的是一组规则或规范通过规范定制了程序中各个变量(包括实例字段,静态字段和构成数组对象的元素)的访问方式。
屏蔽了各种硬件和操作系统的访问差异的，保证了Java程序在各种平台下对内存的访问都能保证效果一致的机制及规范。</p>
<p>JMM就作用于工作内存和主存之间数据同步过程。他规定了如何做数据同步以及什么时候做数据同步。</p>
<p><img alt="Java内存模型" src="/iblog/posts/annex/images/essays/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.jpg"></p>
<p><strong>那么在Java中是如何保证原子性、可见性及有序性的呢？</strong></p>
<ul>
<li>原子性：在Java中，为了保证原子性，提供了两个高级的字节码指令 <code>monitorenter</code> 和 <code>monitorexit</code>。对应的就是Java中的关键字 <code>synchronized</code>,在Java中只要被<code>synchronized</code>修饰就能保证原子性。</li>
<li>可见性：在Java中，为了保证线程间的可见性，可以使用<code>volatile</code>、<code>synchronized</code>、<code>final</code>来修饰。</li>
<li>有序性：在Java中，可以使用 <code>synchronized</code> 和 <code>volatile</code> 来保证多线程之间操作的有序性。其中，<code>volatile</code> 关键字会禁止编译器指令重排，来保证；<code>synchronized</code> 关键字保证同一时刻只允许一条线程操作，而不能禁止指令重排，指令重排并不会影响单线程的顺序，它影响的是多线程并发执行的顺序性，从而保证了有序性。</li>
</ul>
<h3 id="volatile">volatile</h3>
<p><code>volatile</code>通常被比喻成轻量级的锁，也是Java并发编程中比较重要的一个关键字。</p>
<p><code>volatile</code>特点：</p>
<ul>
<li>保证线程之间的可见性；</li>
<li>禁止指令重排；</li>
<li><strong>不保证原子性，也就是线程不安全；</strong></li>
</ul>
<h4 id="使用案例">使用案例</h4>
<p>在Java中<code>volatile</code> 是一个变量修饰符，只能用来修饰变量。</p>
<p><code>volatile</code> 典型的使用就是单例模式中的DCL双重检查锁。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">/**
</span></span><span class="line"><span class="cl">多线程下的单例模式 DCL(double check lock)
</span></span><span class="line"><span class="cl">**/
</span></span><span class="line"><span class="cl">class SingletonDemo {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // volatile 此处作用 禁止指令重排
</span></span><span class="line"><span class="cl">    public static volatile SingletonDemo singleton = null;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    private SingletonDemo() {
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public static SingletonDemo getInstance() {
</span></span><span class="line"><span class="cl">        if (singleton == null) {
</span></span><span class="line"><span class="cl">            synchronized (SingletonDemo.class) {
</span></span><span class="line"><span class="cl">                if (singleton == null) {
</span></span><span class="line"><span class="cl">                    singleton = new SingletonDemo();
</span></span><span class="line"><span class="cl">                }
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        return singleton;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><p><strong>为什么在此处要使用<code>volatile</code>修饰<code>singleton</code>？</strong></p>
<p>多线程下的DCL单例模式，如果不加 <code>volatile</code> 修饰不是绝对安全的，因为在创建对象的时候JVM底层会进行三个步骤:</p>
<ol>
<li>分配对象的内存空间</li>
<li>初始化对象</li>
<li>设置对象指向刚刚分配的内存地址</li>
</ol>
<p>其中步骤2和步骤3是没有数据依赖关系的，而且无论重排前还是重排后的程序执行结果在单线程中并没有改变，因此这种重排优化是允许的。
所以有可能先执行步骤3在执行步骤2，导致分配的对象不为 <code>null</code>，但对象没有被初始化;</p>
<p>所以当一个线程获取对象不为 <code>null</code> 时，由于对象未必已经完成初始化，会存在线程不安全的风险。</p>
<h4 id="原理">原理</h4>
<p>《深入理解JVM》中对 <code>volatile</code> 的描述:</p>
<blockquote>
<p>一旦一个共享变量（类的成员变量、类的静态成员变量）被 <code>volatile</code> 修饰之后，那么就具备了两层语义：</p>
<ul>
<li>保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的；</li>
<li>禁止进行指令重排序，即有序性；</li>
</ul>
<p><code>volatile</code>只提供了保证访问该变量时，每次都是从内存中读取最新值，并不会使用寄存器缓存该值——每次都会从内存中读取。
而对该变量的修改，<code>volatile</code> 并不提供原子性(线程不安全)的保证;由于及时更新，很可能导致另一线程访问最新变量值，无法跳出循环的情况，多线程下计数器必须使用锁保护.</p>
</blockquote>
<p>将<a href="/iblog/posts/java/rookie-multi-thread/#使用案例">上面的代码</a>用<code>javap -v SingletonDemo.class &gt;test.txt</code>命令执行，将反编译后的字节码指令写入到test文件中，可以看到<code>ACC_VOLATILE</code></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">  public static volatile content.posts.rookie.SingletonDemo singleton;
</span></span><span class="line"><span class="cl">    descriptor: Lcontent/posts/rookie/SingletonDemo;
</span></span><span class="line"><span class="cl">    flags: ACC_PUBLIC, ACC_STATIC, ACC_VOLATILE
</span></span></code></pre></div><p><code>volatile</code> 在字节码层面，就是使用访问标志：<code>ACC_VOLATILE</code> 来表示，供后续操作此变量时判断访问标志是否为 <code>ACC_VOLATILE</code>，来决定是否遵循 <code>volatile</code> 的语义处理。</p>
<p>可以从<code>openjdk8</code>中找到对应的源码文件</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">路径：openjdk8/hotspot/src/share/vm/interpreter/bytecodeInterpreter.cpp
</span></span></code></pre></div><p><img alt="volitile字节码" src="/iblog/posts/annex/images/essays/volitile%E5%AD%97%E8%8A%82%E7%A0%81.png"></p>
<p>重点是<code>cache-&gt;is_volatile()</code>方法，调用栈</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">bytecodeInterpreter.cpp&gt;is_volatile() 
</span></span><span class="line"><span class="cl">==&gt; accessFlags.hpp&gt;is_volatile 
</span></span><span class="line"><span class="cl">==&gt; bytecodeInterpreter.cpprelease_byte_field_put
</span></span><span class="line"><span class="cl">==&gt; oop.inline.hpp&gt;(oopDesc::byte_field_acquire、oopDesc::release_byte_field_put)
</span></span><span class="line"><span class="cl">==&gt; orderAccess.hpp
</span></span><span class="line"><span class="cl">&gt;&gt; orderAccess_linux_x86.inline.hpp.OrderAccess::release_store
</span></span></code></pre></div><p>最终调用了<code>OrderAccess::release_store</code></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">inline void     OrderAccess::release_store(volatile jbyte*   p, jbyte   v) { *p = v; }
</span></span><span class="line"><span class="cl">inline void     OrderAccess::release_store(volatile jshort*  p, jshort  v) { *p = v; }
</span></span></code></pre></div><p>可以从上面看到，到C++的实现层面，又使用C++中的 <code>volatile</code> 关键字，用来修饰变量，通常用于建立语言级别的内存屏障<code>memory barrier</code>。
在《C++ Programming Language》一书中对 <code>volatile</code> 修饰词的解释：</p>
<blockquote>
<p>A volatile specifier is a hint to a compiler that an object may change its value in ways not specified by the language so that aggressive optimizations must be avoided.</p>
</blockquote>
<ul>
<li><code>volatile</code> 修饰的类型变量表示可以被某些编译器未知的因素更改;</li>
<li>使用 <code>volatile</code> 变量时，避免激进的优化; 系统总是重新从内存读取数据，即使它前面的指令刚从内存中读取被缓存，防止出现未知更改和主内存中不一致。</li>
</ul>
<p>其在64位系统的实现<code>orderAccess_linux_x86.inline.hpp.OrderAccess::release_store</code></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kr">inline</span> <span class="kt">void</span> <span class="n">OrderAccess</span><span class="o">::</span><span class="nf">fence</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">os</span><span class="o">::</span><span class="nf">is_MP</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// always use locked addl since mfence is sometimes expensive
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#ifdef AMD64
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>    <span class="n">__asm__</span> <span class="k">volatile</span> <span class="p">(</span><span class="s">&#34;lock; addl $0,0(%%rsp)&#34;</span> <span class="o">:</span> <span class="o">:</span> <span class="o">:</span> <span class="s">&#34;cc&#34;</span><span class="p">,</span> <span class="s">&#34;memory&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="cp">#else
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>    <span class="n">__asm__</span> <span class="k">volatile</span> <span class="p">(</span><span class="s">&#34;lock; addl $0,0(%%esp)&#34;</span> <span class="o">:</span> <span class="o">:</span> <span class="o">:</span> <span class="s">&#34;cc&#34;</span><span class="p">,</span> <span class="s">&#34;memory&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="cp">#endif
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>代码<code>lock; addl $0,0(%%rsp)</code>就是lock前缀；</p>
<blockquote>
<p>lock前缀，会保证某个处理器对共享内存的独占使用。
它将本处理器缓存写入内存，该写入操作会引起其他处理器或内核对应的缓存失效。
通过独占内存、使其他处理器缓存失效，达到了“指令重排序无法越过内存屏障”的作用。</p>
</blockquote>
<p>对于 <code>volatile</code>修饰的变量，当对 <code>volatile</code> 修饰的变量进行写操作的时候，JVM会向处理器发送一条带有 <code>lock</code> 前缀的指令，将这个缓存中的变量回写到系统主存中。
但是就算写回到内存，如果其他处理器缓存的值还是旧的，再执行计算操作就会有问题，所以在多处理器下，为了保证各个处理器的缓存是一致的，就会实现 <strong>缓存一致性协议</strong></p>
<blockquote>
<p>缓存一致性协议: 每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器要对这个数据进行修改操作的时候，会强制重新从系统内存里把数据读到处理器缓存里。</p>
</blockquote>
<p>为了提高CPU处理器的执行速度，在处理器和内存之间增加了多级缓存来提升。但是由于引入了多级缓存，就存在缓存数据不一致问题。</p>
<p><img alt="CPU多级缓存" src="/iblog/posts/annex/images/essays/CPU%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98.jpg"></p>
<p>所以，如果一个变量被 <code>volatile</code> 所修饰的话，在每次数据变化之后，其值都会被强制刷入主存。而其他处理器的缓存由于遵守了缓存一致性协议，也会把这个变量的值从主存加载到自己的缓存中。这就保证了一个 <code>volatile</code> 在并发编程中，其值在多个缓存中是可见的。</p>
<h4 id="volatile与可见性">volatile与可见性</h4>
<p>各个线程对主内存中共享变量的操作，都是各个线程各自拷贝到自己的工作内存操作后再写回主内存中的。
这就可能存在一个线程AAA修改了共享变量X的值还未写回主内存中时 ，另外一个线程BBB又对内存中的一个共享变量X进行操作，但此时A线程工作内存中的共享比那里X对线程B来说并不不可见。
这种工作内存与主内存同步延迟现象就造成了可见性问题。</p>
<p>这种变量的可见性问题可以用<code>volatile</code>来解决。<code>volatile</code>的作用简单来说就是当一个线程修改了数据，并且写回主物理内存，其他线程都会得到通知获取最新的数据。</p>
<p><code>volatile</code>可见性，代码演示</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public class MainTest {
</span></span><span class="line"><span class="cl">    public static void main(String[] args) {
</span></span><span class="line"><span class="cl">        A a = new A();
</span></span><span class="line"><span class="cl">        // thread1
</span></span><span class="line"><span class="cl">        new Thread(() -&gt; {
</span></span><span class="line"><span class="cl">            System.out.println(Thread.currentThread().getName() + &#34; is come in&#34;);
</span></span><span class="line"><span class="cl">            try {
</span></span><span class="line"><span class="cl">                // 模拟执行其他业务
</span></span><span class="line"><span class="cl">                Thread.sleep(3);
</span></span><span class="line"><span class="cl">            } catch (InterruptedException e) {
</span></span><span class="line"><span class="cl">                e.printStackTrace();
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">            // 用该线程改变A类中 number 变量的值
</span></span><span class="line"><span class="cl">            a.numberTo100();
</span></span><span class="line"><span class="cl">        }， &#34;thread1&#34;).start();
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        // 如果number 等于0，则其他线程会一直等待 则证明 volatile 没有保证变量的可见性；相反则保证了变量的可见性
</span></span><span class="line"><span class="cl">        while (a.number == 0) {
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        System.out.println(Thread.currentThread().getName() + &#34; thread is over&#34;);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">class A {
</span></span><span class="line"><span class="cl">    // 注意: 此时变量要加 volatile 关键字修饰； 可以去掉 volatile 来进行对比测试
</span></span><span class="line"><span class="cl">    volatile int number = 0;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public void numberTo100() {
</span></span><span class="line"><span class="cl">        System.out.println(Thread.currentThread().getName() + &#34; update number&#34;);
</span></span><span class="line"><span class="cl">        this.number = 100;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><h4 id="volatile与原子性">volatile与原子性</h4>
<p><code>volatile</code>原子性，代码演示</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public class MainTest {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public static void main(String[] args) {
</span></span><span class="line"><span class="cl">        A a = new A();
</span></span><span class="line"><span class="cl">        /**
</span></span><span class="line"><span class="cl">         * 创建20个线程 每个线程让 number++ 1000次；
</span></span><span class="line"><span class="cl">         * number 变量用 volatile 修饰
</span></span><span class="line"><span class="cl">         * 如果 volatile 保证变量的原子性，则最后结果为 20 * 1000，反之则不保证。
</span></span><span class="line"><span class="cl">         * 当然不排除偶然事件，建议反复多试几次。
</span></span><span class="line"><span class="cl">         */
</span></span><span class="line"><span class="cl">        for (int i = 0; i &lt; 20; i++) {
</span></span><span class="line"><span class="cl">            new Thread(() -&gt; {
</span></span><span class="line"><span class="cl">                for (int j = 0; j &lt; 1000; j++) {
</span></span><span class="line"><span class="cl">                    a.addPlusplus();
</span></span><span class="line"><span class="cl">                }
</span></span><span class="line"><span class="cl">            }, String.valueOf(i)).start();
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        // 如果当前存活线程大于 2 个(包括main线程) 礼让线程继续执行上边的线程
</span></span><span class="line"><span class="cl">        while (Thread.activeCount() &gt; 2) {
</span></span><span class="line"><span class="cl">            Thread.yield();
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        System.out.println(Thread.currentThread().getName() + &#34; Thread is over\t&#34; + a.number);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">class A {
</span></span><span class="line"><span class="cl">    volatile int number = 0;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public void addPlusplus() {
</span></span><span class="line"><span class="cl">        this.number++;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><p><strong>不保证原子性的原因</strong></p>
<p>由于各个线程之间都是复制主内存的数据到自己的工作空间里边修改数据，CPU的轮询反复切换线程，会导致数据丢失。
即某个线程修改了数据，准备回主内存，此时CPU切换到另一个线程修改了数据，并且写回到了主内存，此时其他的线程不知道主内存的数据已经被更改，还会执行将之前从主内存复制的数据修改后的，写到主内存，这就导致了数据被覆盖、丢失。</p>
<p><strong>解决</strong></p>
<p>如果要解决原子性的问题，在Java中只能控制线程，在修改的时候不能被中断，即加锁。
上面的例子可以使用<a href="/iblog/posts/java/rookie-multi-thread/#CAS">CAS</a>的实现<code>AtomicInteger</code>来解决。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public class MainTest {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public static void main(String[] args) {
</span></span><span class="line"><span class="cl">        A a = new A();
</span></span><span class="line"><span class="cl">        /**
</span></span><span class="line"><span class="cl">         * 创建20个线程 每个线程让 number++ 1000次；
</span></span><span class="line"><span class="cl">         * number 变量用 volatile 修饰
</span></span><span class="line"><span class="cl">         * 如果 volatile 保证变量的原子性，则最后结果为 20 * 1000，反之则不保证。
</span></span><span class="line"><span class="cl">         * 当然不排除偶然事件，建议反复多试几次。
</span></span><span class="line"><span class="cl">         */
</span></span><span class="line"><span class="cl">        for (int i = 0; i &lt; 20; i++) {
</span></span><span class="line"><span class="cl">            new Thread(() -&gt; {
</span></span><span class="line"><span class="cl">                for (int j = 0; j &lt; 1000; j++) {
</span></span><span class="line"><span class="cl">                    a.addPlusplus();
</span></span><span class="line"><span class="cl">                }
</span></span><span class="line"><span class="cl">            }, String.valueOf(i)).start();
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        // 如果当前存活线程大于 2 个(包括main线程) 礼让线程继续执行上边的线程
</span></span><span class="line"><span class="cl">        while (Thread.activeCount() &gt; 2) {
</span></span><span class="line"><span class="cl">            Thread.yield();
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        System.out.println(Thread.currentThread().getName() + &#34; Thread is over\t&#34; + a.number);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">class A {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    int number = 0;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    /**
</span></span><span class="line"><span class="cl">     * 如果要解决原子性的问题可以用synchronized 关键字(这种太浪费性能)
</span></span><span class="line"><span class="cl">     * 可用JUC下的 AtomicInteger 来解决
</span></span><span class="line"><span class="cl">     **/
</span></span><span class="line"><span class="cl">    AtomicInteger atomicInteger = new AtomicInteger(number);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public void addPlusplus() {
</span></span><span class="line"><span class="cl">        number = atomicInteger.incrementAndGet();
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><p>对于<code>AtomicInteger.incrementAndGet</code>方法来说，原理就是<code>volatile</code> + <code>do...while()</code> + <code>CAS</code>;</p>
<p><code>AtomicInteger.incrementAndGet</code>源码</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="n">public</span> <span class="n">final</span> <span class="ne">int</span> <span class="n">incrementAndGet</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">unsafe</span><span class="o">.</span><span class="n">getAndAddInt</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="n">valueOffset</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="o">//=========================</span>
</span></span><span class="line"><span class="cl"><span class="n">public</span> <span class="n">final</span> <span class="ne">int</span> <span class="n">getAndAddInt</span><span class="p">(</span><span class="ne">Object</span> <span class="n">var1</span><span class="p">,</span> <span class="n">long</span> <span class="n">var2</span><span class="p">,</span> <span class="ne">int</span> <span class="n">var4</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="ne">int</span> <span class="n">var5</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">do</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">var5</span> <span class="o">=</span> <span class="n">this</span><span class="o">.</span><span class="n">getIntVolatile</span><span class="p">(</span><span class="n">var1</span><span class="p">,</span> <span class="n">var2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">this</span><span class="o">.</span><span class="n">compareAndSwapInt</span><span class="p">(</span><span class="n">var1</span><span class="p">,</span> <span class="n">var2</span><span class="p">,</span> <span class="n">var5</span><span class="p">,</span> <span class="n">var5</span> <span class="o">+</span> <span class="n">var4</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">var5</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>用<code>volatile</code>修饰该变量，保证该变量被某个线程修改时，保证其他线程中的这个变量的可见性；
在多线程环境下，CPU轮流切换线程执行，有可能某个线程修改了数据，准备回主内存，此时CPU切换到另一个线程修改了数据，并且写回到了主内存，此时就导致数据的不准确；
<code>do...while()</code> + <code>CAS</code>的作用就是，当某个线程工作内存中的值与主内存中的值，如果不相同就会一直<code>while</code>循环下去，之所以用<code>do..while</code>是考虑到做自增操作。</p>
<h4 id="volatile与有序性">volatile与有序性</h4>
<p>有序性，指的就是代码按照顺序执行，这个就是对比指令重排来说的；计算机在执行程序时，为了提高性能，编译器和处理器常常会做指令重排。</p>
<p>在上面的<a href="/iblog/posts/java/rookie-multi-thread/#使用案例">使用案例</a>中的代码，DCL就是一个使用禁止指令重排的案例。</p>
<p><strong><code>volatile</code> 禁止指令重排原因</strong></p>
<p>由于编译器和处理器都能执行指令重排的优化，如果在指令键加入一条内存屏障(<code>Memory barrier</code>)，就会告诉编译器和CPU不管什么指令都不能和这条加入<code>Memory barrier</code>指令键重新排序，也就是说<strong>通过内存屏障禁止在内存屏障前后的指令重新排序优化</strong>。
内存屏障的另一个作用就是强制刷出各种CPU缓存数据，因此任何CPU上的线程都能读取到这些数据的最新值，即可见性。</p>
<h3 id="cas">CAS</h3>
<p>CAS全称为<code>Compare and Swap</code>被译为比较并交换。是一种无锁算法。在不使用锁（没有线程被阻塞）的情况下实现多线程之间的变量同步。
<code>java.util.concurrent.atomic</code> 并发包下的所有原子类都是基于 <code>CAS</code> 来实现的。</p>
<h4 id="原理-1">原理</h4>
<p>以 <code>AtomicInteger</code> 原子整型类为例，来看一下CAS实现原理。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public class MainTest {
</span></span><span class="line"><span class="cl">    public static void main(String[] args) {
</span></span><span class="line"><span class="cl">        new AtomicInteger().compareAndSet(1,2);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><p>以上面的代码为例，调用栈如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">compareAndSet --&gt; unsafe.compareAndSwapInt ---&gt; unsafe.compareAndSwapInt --&gt; (C++) cmpxchg
</span></span></code></pre></div><p><code>AtomicInteger</code> 内部方法都是基于 <code>Unsafe</code> 类实现的。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public final boolean compareAndSet(int expect, int update) {
</span></span><span class="line"><span class="cl">    return unsafe.compareAndSwapInt(this, valueOffset, expect, update);
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><p>参数:</p>
<ul>
<li><code>this</code>: <code>Unsafe</code> 对象本身，需要通过这个类来获取 <code>value</code> 的内存偏移地址;</li>
<li><code>valueOffset</code>: <code>value</code> 变量的内存偏移地址;</li>
<li><code>expect</code>: 期望更新的值;</li>
<li><code>update</code>: 要更新的最新值;</li>
</ul>
<p>偏移量<code>valueOffset</code></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">// setup to use Unsafe.compareAndSwapInt for updates
</span></span><span class="line"><span class="cl">    private static final Unsafe unsafe = Unsafe.getUnsafe();
</span></span><span class="line"><span class="cl">    private static final long valueOffset;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    static {
</span></span><span class="line"><span class="cl">        try {
</span></span><span class="line"><span class="cl">            valueOffset = unsafe.objectFieldOffset
</span></span><span class="line"><span class="cl">                (AtomicInteger.class.getDeclaredField(&#34;value&#34;));
</span></span><span class="line"><span class="cl">        } catch (Exception ex) { throw new Error(ex); }
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    private volatile int value;
</span></span></code></pre></div><ol>
<li><code>Unsafe</code> 是CAS的核心类，Java无法直接访问底层操作系统，而是通过 <code>native</code> 方法来访问。不过尽管如此，JVM还是开了一个后门，JDK中有一个类 <code>Unsafe</code>，它提供了硬件级别的原子操作。</li>
<li><code>valueOffset</code> 表示的是变量值在内存中的偏移地址，因为 <code>Unsafe</code> 就是根据内存偏移地址获取数据的原值的。</li>
<li><code>value</code> 是用 <code>volatile</code> 修饰的，保证了多线程之间看到的 <code>value</code> 值是同一份。</li>
</ol>
<p>继续向底层深入，就会看到<code>Unsafe</code>类中的一些方法，同时也是CAS的核心方法：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="n">public</span> <span class="n">final</span> <span class="k">class</span> <span class="n">Unsafe</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="o">//</span> <span class="o">...</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">public</span> <span class="n">final</span> <span class="n">native</span> <span class="n">boolean</span> <span class="n">compareAndSwapObject</span><span class="p">(</span><span class="ne">Object</span> <span class="n">var1</span><span class="p">,</span> <span class="n">long</span> <span class="n">var2</span><span class="p">,</span> <span class="ne">Object</span> <span class="n">var4</span><span class="p">,</span> <span class="ne">Object</span> <span class="n">var5</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">public</span> <span class="n">final</span> <span class="n">native</span> <span class="n">boolean</span> <span class="n">compareAndSwapInt</span><span class="p">(</span><span class="ne">Object</span> <span class="n">var1</span><span class="p">,</span> <span class="n">long</span> <span class="n">var2</span><span class="p">,</span> <span class="ne">int</span> <span class="n">var4</span><span class="p">,</span> <span class="ne">int</span> <span class="n">var5</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">public</span> <span class="n">final</span> <span class="n">native</span> <span class="n">boolean</span> <span class="n">compareAndSwapLong</span><span class="p">(</span><span class="ne">Object</span> <span class="n">var1</span><span class="p">,</span> <span class="n">long</span> <span class="n">var2</span><span class="p">,</span> <span class="n">long</span> <span class="n">var4</span><span class="p">,</span> <span class="n">long</span> <span class="n">var6</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="o">//</span> <span class="o">...</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>上面的三个方法的原理，可以对应去查看 <code>openjdk</code> 的 <code>hotspot</code>源码：<code>src/share/vm/prims/unsafe.cpp</code></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">#define FN_PTR(f) CAST_FROM_FN_PTR(void*, &amp;f)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">{CC&#34;compareAndSwapObject&#34;, CC&#34;(&#34;OBJ&#34;J&#34;OBJ&#34;&#34;OBJ&#34;)Z&#34;,  FN_PTR(Unsafe_CompareAndSwapObject)},
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">{CC&#34;compareAndSwapInt&#34;,  CC&#34;(&#34;OBJ&#34;J&#34;&#34;I&#34;&#34;I&#34;&#34;)Z&#34;,      FN_PTR(Unsafe_CompareAndSwapInt)},
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">{CC&#34;compareAndSwapLong&#34;, CC&#34;(&#34;OBJ&#34;J&#34;&#34;J&#34;&#34;J&#34;&#34;)Z&#34;,      FN_PTR(Unsafe_CompareAndSwapLong)},
</span></span></code></pre></div><p>最终在 <code>hotspot</code> 源码实现中都会调用统一的 <code>cmpxchg</code> 函数，<code>/src/share/vm/runtime/Atomic.cpp</code></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">jbyte Atomic::cmpxchg(jbyte exchange_value, volatile jbyte*dest, jbyte compare_value) {
</span></span><span class="line"><span class="cl">         assert (sizeof(jbyte) == 1,&#34;assumption.&#34;);
</span></span><span class="line"><span class="cl">         uintptr_t dest_addr = (uintptr_t) dest;
</span></span><span class="line"><span class="cl">         uintptr_t offset = dest_addr % sizeof(jint);
</span></span><span class="line"><span class="cl">         volatile jint*dest_int = ( volatile jint*)(dest_addr - offset);
</span></span><span class="line"><span class="cl">         // 对象当前值
</span></span><span class="line"><span class="cl">         jint cur = *dest_int;
</span></span><span class="line"><span class="cl">         // 当前值cur的地址
</span></span><span class="line"><span class="cl">         jbyte * cur_as_bytes = (jbyte *) ( &amp; cur);
</span></span><span class="line"><span class="cl">         // new_val地址
</span></span><span class="line"><span class="cl">         jint new_val = cur;
</span></span><span class="line"><span class="cl">         jbyte * new_val_as_bytes = (jbyte *) ( &amp; new_val);
</span></span><span class="line"><span class="cl">          // new_val存exchange_value，后面修改则直接从new_val中取值
</span></span><span class="line"><span class="cl">         new_val_as_bytes[offset] = exchange_value;
</span></span><span class="line"><span class="cl">         // 比较当前值与期望值，如果相同则更新，不同则直接返回
</span></span><span class="line"><span class="cl">         while (cur_as_bytes[offset] == compare_value) {
</span></span><span class="line"><span class="cl">          // 调用汇编指令cmpxchg执行CAS操作，期望值为cur，更新值为new_val
</span></span><span class="line"><span class="cl">             jint res = cmpxchg(new_val, dest_int, cur);
</span></span><span class="line"><span class="cl">             if (res == cur) break;
</span></span><span class="line"><span class="cl">             cur = res;
</span></span><span class="line"><span class="cl">             new_val = cur;
</span></span><span class="line"><span class="cl">             new_val_as_bytes[offset] = exchange_value;
</span></span><span class="line"><span class="cl">         }
</span></span><span class="line"><span class="cl">         // 返回当前值
</span></span><span class="line"><span class="cl">         return cur_as_bytes[offset];
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><p>从上述源码可以看出CAS的原理就是调用了汇编指令 <code>cmpxchg</code> ，最终其实也就调用了CPU的某些指令。</p>
<p>CAS作用也一目了然，在多线程环境中，就是比较当前线程工作内存中的值和主内存中的值，如果相同则执行规定操作，否则继续比较，直到主内存和当前线程工作内存中的值一致为止。</p>
<p>例如代码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="n">public</span> <span class="n">final</span> <span class="ne">int</span> <span class="n">getAndAddInt</span><span class="p">(</span><span class="ne">Object</span> <span class="n">var1</span><span class="p">,</span> <span class="n">long</span> <span class="n">var2</span><span class="p">,</span> <span class="ne">int</span> <span class="n">var4</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="ne">int</span> <span class="n">var5</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">do</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">var5</span> <span class="o">=</span> <span class="n">this</span><span class="o">.</span><span class="n">getIntVolatile</span><span class="p">(</span><span class="n">var1</span><span class="p">,</span> <span class="n">var2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span> <span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">this</span><span class="o">.</span><span class="n">compareAndSwapInt</span><span class="p">(</span><span class="n">var1</span><span class="p">,</span> <span class="n">var2</span><span class="p">,</span> <span class="n">var5</span><span class="p">,</span> <span class="n">var5</span> <span class="o">+</span> <span class="n">var4</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">var5</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h4 id="如何保证数据一致性">如何保证数据一致性</h4>
<p>从源码可以看出，CAS是通过<code>Unsafe</code>调用CPU指令，当CPU中某个处理器对缓存中的共享变量进行了操作，其他处理器会有个嗅探机制，将其他处理器的该共享变量的缓存失效，待其他线程读取时会重新从主内存中读取最新的数据，基于 <code>MESI</code> 缓存一致性协议来实现的。</p>
<p>简述，就是通过CPU的缓存一致性协议来保证线程之间的数据一致性的。</p>
<blockquote>
<p>CPU 处理器速度远远大于在主内存中的，为了解决速度差异，在他们之间架设了多级缓存，如 L1、L2、L3 级别的缓存，这些缓存离CPU越近就越快，将频繁操作的数据缓存到这里，加快访问速度。</p>
</blockquote>
<p><img alt="CPU多级缓存" src="/iblog/posts/annex/images/essays/CPU%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98.jpg"></p>
<h4 id="cas与unsafe关系">CAS与Unsafe关系</h4>
<p>CAS的作用是比较并交换，就是先拿这个期望值，与主内存的值比较，判断主内存中该位置是否存在期望值，如果存在，则改为新的值，这个修改的过程是具有原子性的。</p>
<p>因为CAS是CPU并发源语，并发源语体现在<code>Java sun.misc.Unsafa</code>类上，调用Unsafe类中的CAS方法，JVM会帮我们实现CAS汇编指令。这是一种完全依赖于硬件的功能，通过他实现了原子操作。
由于CAS是一种系统原语，原语属于操作系统用语范畴，是由若干条指令组成的，用于完成某个功能的一个过程，并且原语的执行必须是连续的，在执行过程中不允许被中断，也就是说CAS是一条CPU的原子指令，不会造成数据不一致问题。</p>
<blockquote>
<p>Unsafe类
CAS其实是调用了 <code>Unsafe</code> 类的方法 <code>Unsafa</code> 类是CAS核心类，由于Java方法无法直接访问底层系统，需要通过本地（<code>native</code>）方法来访问，<code>Unsafe</code> 相当于一个后门，基于该类可以直接操作特定内存数据。
Unsafe类存在于sun.misc包中，其内部方法操作可以像C的指针(内存地址)一样直接操作内存，因此Java中CAS操作的执行依赖于Unsafe类的方法。
Unsafe类中的所有方法都是<strong>native</strong>修饰的，也就是说Unsafe类中的方法都直接<strong>调用操作系统底层资源执行相应任务</strong>。</p>
</blockquote>
<h4 id="缺点">缺点</h4>
<h5 id="循环时间长开销">循环时间长开销</h5>
<p>因为是采用自旋锁的方式来实现所以，自然有自旋锁的缺点，循环时间长开销大，例如：<code>getAndAddInt</code> 方法执行，有个<code>do while</code>循环，如果CAS失败，一直会进行尝试，如果CAS长时间不成功，可能会给CPU带来很大的开销。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="n">public</span> <span class="n">final</span> <span class="ne">int</span> <span class="n">getAndAddInt</span><span class="p">(</span><span class="ne">Object</span> <span class="n">var1</span><span class="p">,</span> <span class="n">long</span> <span class="n">var2</span><span class="p">,</span> <span class="ne">int</span> <span class="n">var4</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="ne">int</span> <span class="n">var5</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">do</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">var5</span> <span class="o">=</span> <span class="n">this</span><span class="o">.</span><span class="n">getIntVolatile</span><span class="p">(</span><span class="n">var1</span><span class="p">,</span> <span class="n">var2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span> <span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">this</span><span class="o">.</span><span class="n">compareAndSwapInt</span><span class="p">(</span><span class="n">var1</span><span class="p">,</span> <span class="n">var2</span><span class="p">,</span> <span class="n">var5</span><span class="p">,</span> <span class="n">var5</span> <span class="o">+</span> <span class="n">var4</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">var5</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h5 id="多个变量原子性">多个变量原子性</h5>
<p>只能保证一个共享变量的原子操作，对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁来保证原子性。
但是Java从1.5开始JDK提供了<code>AtomicReference</code>类来保证引用对象之间的原子性，可以把多个变量放在一个对象里来进行CAS操作。</p>
<h5 id="aba问题">ABA问题</h5>
<p>ABA问题示例代码:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public class MainTest {
</span></span><span class="line"><span class="cl">    static AtomicReference&lt;Integer&gt; atomicReference = new AtomicReference&lt;&gt;(100);
</span></span><span class="line"><span class="cl">    public static void main(String[] args) {
</span></span><span class="line"><span class="cl">        new Thread(() -&gt; {
</span></span><span class="line"><span class="cl">            // 先改到101在改回来，CAS会认为value没有被修改过
</span></span><span class="line"><span class="cl">            atomicReference.compareAndSet(100, 101);
</span></span><span class="line"><span class="cl">            atomicReference.compareAndSet(101, 100);
</span></span><span class="line"><span class="cl">        }, &#34;Thread 1&#34;).start();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        new Thread(() -&gt; {
</span></span><span class="line"><span class="cl">            try {
</span></span><span class="line"><span class="cl">                //保证线程1完成一次ABA操作
</span></span><span class="line"><span class="cl">                TimeUnit.SECONDS.sleep(1);
</span></span><span class="line"><span class="cl">            } catch (InterruptedException e) {
</span></span><span class="line"><span class="cl">                e.printStackTrace();
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">            System.out.println(atomicReference.compareAndSet(100, 2019) + &#34;\t&#34; + atomicReference.get());
</span></span><span class="line"><span class="cl">        }, &#34;Thread 2&#34;).start();
</span></span><span class="line"><span class="cl">        try {
</span></span><span class="line"><span class="cl">            TimeUnit.SECONDS.sleep(2);
</span></span><span class="line"><span class="cl">        } catch (InterruptedException e) {
</span></span><span class="line"><span class="cl">            e.printStackTrace();
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><p>CAS算法实现一个重要前提是，需要去除内存中某个时刻的数据并在当下时刻比较并替换，那么在这个时间差类会导致数据的变化。</p>
<p>比如，线程1从内存位置V取出A，线程2同时也从内存取出A，并且线程2进行一些操作将值改为B，然后线程2又将V位置数据改成A，这时候线程1进行CAS操作发现内存中的值依然时A，然后线程1操作成功。
尽管线程1的CAS操作成功，但是不代表这个过程没有问题。</p>
<p>简单说，如果一个线程改了一个值，最后又改回到初始值了，这时候CAS会认为它没有被修改过。简而言之就是只比较结果，不比较过程。</p>
<p><strong>ABA问题解决</strong></p>
<p>利用 <code>AtomicReference</code> 类进行原子引用</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public class AtomicRefrenceDemo {
</span></span><span class="line"><span class="cl">    public static void main(String[] args) {
</span></span><span class="line"><span class="cl">        User z3 = new User(&#34;张三&#34;, 22);
</span></span><span class="line"><span class="cl">        User l4 = new User(&#34;李四&#34;, 23);
</span></span><span class="line"><span class="cl">        AtomicReference&lt;User&gt; atomicReference = new AtomicReference&lt;&gt;();
</span></span><span class="line"><span class="cl">        atomicReference.set(z3);
</span></span><span class="line"><span class="cl">        System.out.println(atomicReference.compareAndSet(z3, l4) + &#34;\t&#34; + atomicReference.get().toString());
</span></span><span class="line"><span class="cl">        System.out.println(atomicReference.compareAndSet(z3, l4) + &#34;\t&#34; + atomicReference.get().toString());
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">@Getter
</span></span><span class="line"><span class="cl">@ToString
</span></span><span class="line"><span class="cl">@AllArgsConstructor
</span></span><span class="line"><span class="cl">class User {
</span></span><span class="line"><span class="cl">    String userName;
</span></span><span class="line"><span class="cl">    int age;
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">// 输出结果
</span></span><span class="line"><span class="cl">true	User(userName=李四, age=23)
</span></span><span class="line"><span class="cl">false	User(userName=李四, age=23)
</span></span></code></pre></div><p>使用时间戳的原子引用<code>AtomicStampedReference</code>修改版本号，主要是在对象中额外再增加一个标记来标识对象是否有过变更。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">static AtomicStampedReference&lt;Integer&gt; atomicStampedReference = new AtomicStampedReference&lt;&gt;(100, 1);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">public static void main(String[] args) {
</span></span><span class="line"><span class="cl">    new Thread(() -&gt; {
</span></span><span class="line"><span class="cl">            int stamp = atomicStampedReference.getStamp();
</span></span><span class="line"><span class="cl">            System.out.println(Thread.currentThread().getName() + &#34;\t第1次版本号&#34; + stamp);
</span></span><span class="line"><span class="cl">            try {
</span></span><span class="line"><span class="cl">                TimeUnit.SECONDS.sleep(2);
</span></span><span class="line"><span class="cl">            } catch (InterruptedException e) {
</span></span><span class="line"><span class="cl">                e.printStackTrace();
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">            atomicStampedReference.compareAndSet(100, 101, atomicStampedReference.getStamp(), atomicStampedReference.getStamp() + 1);
</span></span><span class="line"><span class="cl">            System.out.println(Thread.currentThread().getName() + &#34;\t第2次版本号&#34; + atomicStampedReference.getStamp());
</span></span><span class="line"><span class="cl">            atomicStampedReference.compareAndSet(101, 100, atomicStampedReference.getStamp(), atomicStampedReference.getStamp() + 1);
</span></span><span class="line"><span class="cl">            System.out.println(Thread.currentThread().getName() + &#34;\t第3次版本号&#34; + atomicStampedReference.getStamp());
</span></span><span class="line"><span class="cl">        }, &#34;Thread 3&#34;).start();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        new Thread(() -&gt; {
</span></span><span class="line"><span class="cl">            int stamp = atomicStampedReference.getStamp();
</span></span><span class="line"><span class="cl">            System.out.println(Thread.currentThread().getName() + &#34;\t第1次版本号&#34; + stamp);
</span></span><span class="line"><span class="cl">            try {
</span></span><span class="line"><span class="cl">                TimeUnit.SECONDS.sleep(4);
</span></span><span class="line"><span class="cl">            } catch (InterruptedException e) {
</span></span><span class="line"><span class="cl">                e.printStackTrace();
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">            boolean result = atomicStampedReference.compareAndSet(100, 2019, stamp, stamp + 1);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            System.out.println(Thread.currentThread().getName() + &#34;\t修改是否成功&#34; + result + &#34;\t当前最新实际版本号：&#34; + atomicStampedReference.getStamp());
</span></span><span class="line"><span class="cl">            System.out.println(Thread.currentThread().getName() + &#34;\t当前最新实际值：&#34; + atomicStampedReference.getReference());
</span></span><span class="line"><span class="cl">        }, &#34;Thread 4&#34;).start();
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">Thread 3	第1次版本号1
</span></span><span class="line"><span class="cl">Thread 4	第1次版本号1
</span></span><span class="line"><span class="cl">Thread 3	第2次版本号2
</span></span><span class="line"><span class="cl">Thread 3	第3次版本号3
</span></span><span class="line"><span class="cl">Thread 4	修改是否成功false	当前最新实际版本号：3
</span></span><span class="line"><span class="cl">Thread 4	当前最新实际值：100
</span></span></code></pre></div><h3 id="juc">J.U.C.</h3>
<p><code>java.util.concurrent.locks</code>包下常用的类与接口是<code>JDK1.5</code>后新增的。<code>lock</code>的出现是为了弥补<code>synchronized</code>关键字解决不了的一些问题。</p>
<p>例如：当一个代码块被<code>synchronized</code>修饰了，一个线程获取了对应的锁，并执行该代码块时，其他线程只能一直等待，等待获取锁的线程释放锁，如果这个线程因为某些原因被堵塞了，没有释放锁，那么其他线程只能一直等待下去。导致效率很低。</p>
<p>因此就需要有一种机制可以不让等待的线程一直无期限地等待下去（比如只等待一定的时间或者能够响应中断），通过Lock就可以办到。</p>
<p><code>lock</code>与<code>synchronized</code>最大的区别就是<code>lock</code>能够手动控制锁，而<code>synchronized</code>是JVM控制的。所以<code>lock</code>更加灵活。<code>lock</code>锁的粒度要优于<code>synchronized</code>。
在实际使用中，自然是能够替代<code>synchronized</code>关键字的。</p>
<h4 id="使用">使用</h4>
<p>在实际使用过程中，<code>lock</code>也是比较简单的。
<code>Lock</code>和<code>ReadWriteLock</code>是两大锁的根接口，<code>Lock</code>代表实现类是<code>ReentrantLock</code>（可重入锁），<code>ReadWriteLock</code>（读写锁）的代表实现类是<code>ReentrantReadWriteLock</code>。</p>
<p><img alt="juc.locks" src="/iblog/posts/annex/images/essays/juc.locks.png"></p>
<h5 id="lock">Lock</h5>
<p><strong>lock()</strong></p>
<p><code>lock()</code>方法是平常使用得最多的一个方法，就是用来获取锁。如果锁已被其他线程获取，则进行等待。
如果采用<code>Lock</code>，必须主动去释放锁，并且在发生异常时，不会自动释放锁。
因此，一般来说，使用<code>Lock</code>必须在<code>try…catch…</code>块中进行，并且将释放锁的操作放在<code>finally</code>块中进行，以保证锁一定被被释放，防止死锁的发生。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">  Lock l = ...;
</span></span><span class="line"><span class="cl">  l.lock();
</span></span><span class="line"><span class="cl">  try {
</span></span><span class="line"><span class="cl">    // access the resource protected by this lock
</span></span><span class="line"><span class="cl">  } finally {
</span></span><span class="line"><span class="cl">    l.unlock();
</span></span><span class="line"><span class="cl">  }
</span></span></code></pre></div><p><strong>trylock()</strong></p>
<p>尝试获取锁，如果锁可用则返回true，不可用则返回false。也就是说，这个方法无论如何都会立即返回，在拿不到锁时不会一直在那等待。</p>
<blockquote>
<p><code>tryLock(long time, TimeUnit unit)</code>方法和<code>tryLock()</code>方法是类似的，只不过区别在于这个方法在拿不到锁时会等待一定的时间，在时间期限之内如果还拿不到锁，就返回false，同时可以响应中断。
如果一开始拿到锁或者在等待期间内拿到了锁，则返回true。</p>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">  Lock lock = ...;
</span></span><span class="line"><span class="cl">  if (lock.tryLock()) {
</span></span><span class="line"><span class="cl">    try {
</span></span><span class="line"><span class="cl">      // manipulate protected state
</span></span><span class="line"><span class="cl">    } finally {
</span></span><span class="line"><span class="cl">      lock.unlock();
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">  } else {
</span></span><span class="line"><span class="cl">    // perform alternative actions
</span></span><span class="line"><span class="cl">  }
</span></span></code></pre></div><p><strong>lockInterruptibly()</strong></p>
<p>当通过这个方法去获取锁时，如果线程正在等待获取锁，则这个线程能够响应中断，即中断线程的等待状态。
例如，当两个线程同时通过<code>lock.lockInterruptibly()</code>想获取某个锁时，假若此时线程A获取到了锁，而线程B只有在等待，那么对线程B调用<code>threadB.interrupt()</code>能够中断线程B的等待过程。</p>
<p>注意，当一个线程获取了锁之后，是不会被<code>interrupt()</code>方法中断的。因为<code>interrupt()</code>方法只能中断阻塞过程中的线程而不能中断正在运行过程中的线程。因此，当通过 <code>lockInterruptibly()</code> 方法获取某个锁时，如果不能获取到，那么只有进行等待的情况下，才可以响应中断的。
与 <code>synchronized</code> 相比，当一个线程处于等待某个锁的状态，是无法被中断的，只有一直等待下去。</p>
<p>由于<code>lockInterruptibly()</code>的声明中抛出了异常，所以<code>lock.lockInterruptibly()</code>必须放在try块中或者在调用<code>lockInterruptibly()</code>的方法外声明抛出 <code>InterruptedException</code></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public void method() throws InterruptedException {
</span></span><span class="line"><span class="cl">    lock.lockInterruptibly();
</span></span><span class="line"><span class="cl">    try {  
</span></span><span class="line"><span class="cl">     //.....
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    finally {
</span></span><span class="line"><span class="cl">        lock.unlock();
</span></span><span class="line"><span class="cl">    }  
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><p><strong>newCondition</strong></p>
<p><code>Lock</code>接口提供了方法<code>Condition newCondition();</code>，<code>Condition</code>也是一个接口，可以理解为<code>synchronized</code>锁的监视器的概念；
对于<code>synchronized</code>是借助于锁与监视器，从而进行线程的同步与通信协作;而<code>Lock</code>接口也提供了<code>synchronized</code>的语意，对于监视器的概念，则借助于<code>Condition</code>。</p>
<p>在<code>lock</code>中可以定义多个<code>Condition</code>，也就是一个锁，可以对应多个监视器，可以更加细粒度的进行同步协作的处理。</p>
<h5 id="readwritelock">ReadWriteLock</h5>
<p>该接口有两个方法：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">//返回用于读取操作的锁    
</span></span><span class="line"><span class="cl">Lock readLock()   
</span></span><span class="line"><span class="cl">//返回用于写入操作的锁  
</span></span><span class="line"><span class="cl">Lock writeLock() 
</span></span></code></pre></div><p><code>ReadWriteLock</code>管理一组锁，一个是只读的锁，一个是写锁。<a href="/iblog/posts/java/rookie-multi-thread/#共享锁与独占锁">共享锁与独占锁</a>的实现是读写锁。
Java并发库中<code>ReetrantReadWriteLock</code>实现了<code>ReadWriteLock</code>接口并添加了可重入的特性。</p>
<p>对于<code>ReetrantReadWriteLock</code>其读锁是共享锁而写锁是独占锁，读锁的共享可保证并发读是非常高效的；
需要注意的是，<strong>读写、写读和写写的过程是互斥的，只有读读不是互斥的</strong>。</p>
<p>读写锁使用示例</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public class MainTest {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public static void main(String[] args) {
</span></span><span class="line"><span class="cl">        MyCache myCache = new MyCache();
</span></span><span class="line"><span class="cl">        for (int i = 0; i &lt; 10; i++) {
</span></span><span class="line"><span class="cl">            int finalI = i;
</span></span><span class="line"><span class="cl">            new Thread(() -&gt; {
</span></span><span class="line"><span class="cl">                myCache.put(finalI + &#34;&#34;, finalI + &#34;&#34;);
</span></span><span class="line"><span class="cl">            }, String.valueOf(i)).start();
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        System.out.println(&#34;---------------&#34;);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        for (int i = 0; i &lt; 10; i++) {
</span></span><span class="line"><span class="cl">            int finalI = i;
</span></span><span class="line"><span class="cl">            new Thread(() -&gt; {
</span></span><span class="line"><span class="cl">                myCache.get(finalI + &#34;&#34;);
</span></span><span class="line"><span class="cl">            }, String.valueOf(i)).start();
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">class MyCache {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    private volatile Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    private ReentrantReadWriteLock rwLock = new ReentrantReadWriteLock();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // 写操作
</span></span><span class="line"><span class="cl">    public void put(String key, Object value) {
</span></span><span class="line"><span class="cl">        rwLock.writeLock().lock();
</span></span><span class="line"><span class="cl">        try {
</span></span><span class="line"><span class="cl">            System.out.println(&#34;开始 写入 ...&#34; + key);
</span></span><span class="line"><span class="cl">            map.put(key, value);
</span></span><span class="line"><span class="cl">            System.out.println(&#34;写入完成 ...&#34;);
</span></span><span class="line"><span class="cl">        } catch (Exception e) {
</span></span><span class="line"><span class="cl">            e.printStackTrace();
</span></span><span class="line"><span class="cl">        } finally {
</span></span><span class="line"><span class="cl">            rwLock.writeLock().unlock();
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // 读操作
</span></span><span class="line"><span class="cl">    public Object get(String key) {
</span></span><span class="line"><span class="cl">        Object obj = null;
</span></span><span class="line"><span class="cl">        rwLock.readLock().lock();
</span></span><span class="line"><span class="cl">        try {
</span></span><span class="line"><span class="cl">            System.out.println(&#34;开始读取 ...&#34; + key);
</span></span><span class="line"><span class="cl">            obj = map.get(key);
</span></span><span class="line"><span class="cl">            System.out.println(&#34;读取完成 ...&#34; + obj);
</span></span><span class="line"><span class="cl">        } catch (Exception e) {
</span></span><span class="line"><span class="cl">            e.printStackTrace();
</span></span><span class="line"><span class="cl">        } finally {
</span></span><span class="line"><span class="cl">            rwLock.readLock().unlock();
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        return obj;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><h4 id="locksupport">LockSupport</h4>
<p><code>LockSupport</code>是<code>java.util.concurrent.locks</code>包下的一个工具类。
<code>LockSupport</code>类使用了一种名为<code>Permit</code>(许可）的概念来做到阻塞和唤醒线程的功能，每个线程都有一个许可(permit)，<code>permit</code>只有两个值1和零，默认是零。</p>
<p>官网解释:<code>LockSupport</code>是用来创建锁和其他同步类的基本线程阻塞原语;</p>
<p>其中有两个重要的方法，通过<code>park()</code>和<code>unpark()</code>方法来实现阻塞和唤醒线程的操作；可以理解为<code>wait()</code>和<code>notify</code>的加强版。</p>
<p>传统等待唤醒机制：</p>
<ol>
<li>使用<code>Object</code>中的<code>wait()</code>方法让线程等待，使用<code>Object</code>中的<code>notify</code>方法唤醒线程</li>
<li>使用JUC包中<code>Condition</code>的<code>await()</code>方法让线程等待，使用<code>signal()</code>方法唤醒线程</li>
</ol>
<p>传统等待唤醒机制的弊端：</p>
<ul>
<li><code>wait</code>和<code>notify</code>/<code>await()</code>和<code>signal()</code>方法必须要在同步块或同步方法里且成对出现使用，如果没有在<code>synchronized</code>代码块使用则抛出<code>java.lang.IllegalMonitorStateException</code>;</li>
<li>必须先<code>wait</code>/<code>await()</code>后<code>notify</code>/<code>signal()</code>，如果先<code>notify</code>后<code>wait</code>会出现另一个线程一直处于等待状态；</li>
</ul>
<p><code>LockSupport</code>对比传统等待唤醒机制，能够解决上面的弊端：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public class MainTest {
</span></span><span class="line"><span class="cl">    public static void main(String[] args) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        Thread t1=new Thread(()-&gt;{
</span></span><span class="line"><span class="cl">//            try { TimeUnit.SECONDS.sleep(3);  } catch (InterruptedException e) {e.printStackTrace();}
</span></span><span class="line"><span class="cl">            System.out.println(Thread.currentThread().getName()+&#34;\t&#34;+&#34;coming....&#34;);
</span></span><span class="line"><span class="cl">            LockSupport.park();
</span></span><span class="line"><span class="cl">            /*
</span></span><span class="line"><span class="cl">            如果这里有两个LockSupport.park(),因为permit的值为1,上一行已经使用了permit
</span></span><span class="line"><span class="cl">            所以下一行被注释的打开会导致程序处于一直等待的状态
</span></span><span class="line"><span class="cl">            * */
</span></span><span class="line"><span class="cl">            //LockSupport.park();
</span></span><span class="line"><span class="cl">            System.out.println(Thread.currentThread().getName()+&#34;\t&#34;+&#34;被B唤醒了&#34;);
</span></span><span class="line"><span class="cl">        },&#34;A&#34;);
</span></span><span class="line"><span class="cl">        t1.start();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        Thread t2=new Thread(()-&gt;{
</span></span><span class="line"><span class="cl">            System.out.println(Thread.currentThread().getName()+&#34;\t&#34;+&#34;唤醒A线程&#34;);
</span></span><span class="line"><span class="cl">            //有两个LockSupport.unpark(t1),由于permit的值最大为1,所以只能给park一个通行证
</span></span><span class="line"><span class="cl">            LockSupport.unpark(t1);
</span></span><span class="line"><span class="cl">            //LockSupport.unpark(t1);
</span></span><span class="line"><span class="cl">        },&#34;B&#34;);
</span></span><span class="line"><span class="cl">        t2.start();
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><p><code>LockSupport</code>原理是调用的<code>Unsafe</code>中的<code>native</code>代码。以<code>unpark、park</code>为例：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">    public static void unpark(Thread thread) {
</span></span><span class="line"><span class="cl">        if (thread != null)
</span></span><span class="line"><span class="cl">            UNSAFE.unpark(thread);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public static void park(Object blocker) {
</span></span><span class="line"><span class="cl">        Thread t = Thread.currentThread();
</span></span><span class="line"><span class="cl">        setBlocker(t, blocker);
</span></span><span class="line"><span class="cl">        UNSAFE.park(false, 0L);
</span></span><span class="line"><span class="cl">        setBlocker(t, null);
</span></span><span class="line"><span class="cl">    }
</span></span></code></pre></div><p>理解：</p>
<ul>
<li>线程堵塞需要消耗凭证，这个凭证最多只有一个；</li>
<li>当调用<code>park</code>方法时，如果有凭证则会直接消耗这张凭证然后退出；如果没有凭证就必须堵塞等待凭证可用；</li>
<li><code>unpark</code>方法则相反，调用该方法会增加一个凭证，连续调用两次<code>unpark()</code>和调用一次一样，只会增加一个凭证；</li>
</ul>
<p><strong>为什么可以先唤醒线程后阻塞线程?</strong></p>
<p>因为<code>unpark</code>获得了一个凭证，之后再调用<code>park</code>方法，就可以名正言顺的凭证消费，所以不会阻塞。</p>
<p><strong>为什么唤醒两次后阻塞两次，但最终结果还会阻塞线程?</strong></p>
<p>因为凭证的数量最多为1，连续调用两次<code>unpark</code>和调用一次<code>unpark</code>效果一样，只会增加一个凭证;
而调用两次park却需要消费两个凭证，证不够，不能放行。</p>
<h4 id="aqs">AQS</h4>
<p>AQS是指<code>java.util.concurrent.locks</code>包下的一个抽象类<code>AbstractQueuedSynchronizer</code>译为：抽象的队列同步器。</p>
<p>在JUC包下，能够看到有许多类都继承了AQS，例如，<code>ReentrantLock 、CountDownLatch 、 ReentrantReadWriteLock 、 Semaphore </code>；
所以AQS是JUC内容中重要的基础。</p>
<p><img alt="JUC.locks包UML" src="/iblog/posts/annex/images/essays/JUC.locks%E5%8C%85UML.png"></p>
<blockquote>
<p>同步、同步器？
同步，面向锁的使用者，定义了程序员和锁交互的使用层API；
同步器，面向锁的实现者，统一规范，实现锁 自定义等待唤醒机制等等；</p>
</blockquote>
<p>AQS是用来构建锁或者其它同步器组件的重量级基础框架及整个JUC体系的基石，通过内置的<code>CLH(FIFO)</code>队列的变种来完成资源获取线程的排队工作；
将每条将要去抢占资源的线程封装成一个<code>Node</code>节点来实现锁的分配，有一个<code>int</code>类变量表示持有锁的状态，通过CAS完成对<code>status</code>值的修改。</p>
<p><img alt="AQS" src="/iblog/posts/annex/images/essays/AQS.png"></p>
<p>在多线程并发环境下，使用lock加锁，当处在加锁与解锁之间的代码，只能有一个线程来执行；这时候其他线程不能够获取锁，如果不处理线程就会造成了堵塞；
在AQS框架中，会将暂时获取不到锁的线程加入到队列里，这个队列就是AQS的抽象表现。它会将这些线程封装成队列的结点，通过CAS、自旋以及<code>LockSuport.park()</code>的方式，维护<code>state</code>变量的状态，使并发达到同步的效果。</p>
<p>AQS中的队列，是指CLH队列（Craig， Landin， and Hagerste[三个人名组成]）锁队列的变体，是一个双向队列。
队列中的元素即<code>Node</code>结点，每个<code>Node</code>中包含：头结点、尾结点、等待状态、存放的线程等；<code>Node</code>遵循从尾部入队，从头部出队的规则，即先进先出原则。</p>
<blockquote>
<p>详细可查看 java.util.concurrent.locks; 包下 AbstractQueuedSynchronizer 类。</p>
</blockquote>
<p>AQS可以理解为一个框架，因为它定义了一些JUC包下常用&quot;锁&quot;的标准。
AQS简单来说，包含一个<code>status</code>和一个队列；<code>status</code>保存线程持有锁的状态，用于判断该线程获没获取到锁，没获取到锁就去队列中排队。
队列是由<code>Node</code>结点构成，每个<code>Node</code>结点里面主要包含一个<code>waitStatus</code>和保存的线程。</p>
<p><img alt="AQS简单理解" src="/iblog/posts/annex/images/essays/AQS%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3.png"></p>
<h4 id="reentrantlock原理">ReentrantLock原理</h4>
<p><code>ReentrantLock</code>译为，可重入锁，它的原理用到了AQS。</p>
<blockquote>
<p>AQS里面有个变量叫State，它的值有3种状态：没占用是0，占用了是1，大于1是可重入锁
如果A、B两个线程进来了以后，请问这个总共有多少个Node节点？答案是3个，其中队列的第一个是傀儡节点(哨兵节点)</p>
</blockquote>
<p><code>ReentrantLock</code>原理说简单一点，就是加锁解锁的过程。</p>
<p>在多线程并发环境下，某个线程持有锁，将<code>state</code>由0设置为1，如果在有其他线程再次进入，线程则会经过一系列判断，然后构建Node结点，最终形成双向链表结构。
最后在执行<code>LockSupport.park()</code>方法，将等待的线程挂起，如果当前持有锁的线程释放了锁，则将<code>state</code>变量设置为0，调用<code>LockSpoort.unpark()</code>方法指定唤醒等待队列中的某个线程。</p>
<p><code>ReentrantLock</code>使用</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public class AQSDemo {
</span></span><span class="line"><span class="cl">    public static void main(String[] args) {
</span></span><span class="line"><span class="cl">        ReentrantLock lock = new ReentrantLock();
</span></span><span class="line"><span class="cl">        new Thread(() -&gt; {
</span></span><span class="line"><span class="cl">                lock.lock();
</span></span><span class="line"><span class="cl">                try{
</span></span><span class="line"><span class="cl">                    System.out.println(&#34;-----A thread come in&#34;);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                    try { TimeUnit.MINUTES.sleep(20); }catch (Exception e) {e.printStackTrace();}
</span></span><span class="line"><span class="cl">                }finally {
</span></span><span class="line"><span class="cl">                    lock.unlock();
</span></span><span class="line"><span class="cl">                }
</span></span><span class="line"><span class="cl">        },&#34;A&#34;).start();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        new Thread(() -&gt; {
</span></span><span class="line"><span class="cl">            lock.lock();
</span></span><span class="line"><span class="cl">            try{
</span></span><span class="line"><span class="cl">                System.out.println(&#34;-----B thread come in&#34;);
</span></span><span class="line"><span class="cl">            }finally {
</span></span><span class="line"><span class="cl">                lock.unlock();
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">        },&#34;B&#34;).start();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        new Thread(() -&gt; {
</span></span><span class="line"><span class="cl">            lock.lock();
</span></span><span class="line"><span class="cl">            try{
</span></span><span class="line"><span class="cl">                System.out.println(&#34;-----C thread come in&#34;);
</span></span><span class="line"><span class="cl">            }finally {
</span></span><span class="line"><span class="cl">                lock.unlock();
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">        },&#34;C&#34;).start();
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><p><strong>ReentrantLock加锁</strong></p>
<p><code>ReentrantLock</code>原理用到了AQS，而AQS包括一个线程队列和一个state变量；所以<code>ReentrantLock</code>加锁过程，可以简单理解为<code>state</code>变量的变化。
如果在多线程并发的环境下，还要有其他线程被保存到AQS的队列中。加锁过程，如图所示：</p>
<p><img alt="reentrantLock加锁" src="/iblog/posts/annex/images/essays/reentrantLock%E5%8A%A0%E9%94%81.png"></p>
<p><code>ReentrantLock</code>加锁，有两种形式，默认是<a href="/iblog/posts/java/rookie-multi-thread/#公平锁与非公平锁">非公平锁</a>，但可以通过构造方法来指定为<a href="/iblog/posts/java/rookie-multi-thread/#公平锁与非公平锁">公平锁</a>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">    public static void main(String[] args) {
</span></span><span class="line"><span class="cl">        ReentrantLock reentrantLock = new ReentrantLock(true);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    //⬇⬇⬇⬇⬇⬇⬇⬇⬇⬇⬇⬇⬇⬇⬇⬇⬇⬇⬇⬇⬇⬇⬇⬇⬇⬇⬇⬇⬇⬇⬇⬇⬇⬇
</span></span><span class="line"><span class="cl">    /**
</span></span><span class="line"><span class="cl">     * Creates an instance of {@code ReentrantLock} with the
</span></span><span class="line"><span class="cl">     * given fairness policy.
</span></span><span class="line"><span class="cl">     *
</span></span><span class="line"><span class="cl">     * @param fair {@code true} if this lock should use a fair ordering policy
</span></span><span class="line"><span class="cl">     */
</span></span><span class="line"><span class="cl">    public ReentrantLock(boolean fair) {
</span></span><span class="line"><span class="cl">        sync = fair ? new FairSync() : new NonfairSync();
</span></span><span class="line"><span class="cl">    }
</span></span></code></pre></div><p>无论是公平锁还是非公平锁，由于用到了AQS框架，所以底层实现的逻辑大致是差不多的，<code>ReentrantLock</code>加锁方法调用栈：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">lock() --&gt; acquire() --&gt; tryAcquire() --&gt; addWaiter() --&gt; acquireQueued() --&gt; selfInterrupt()
</span></span></code></pre></div><p>虽然大致逻辑差不多，但是区别总是有的，总的来说非公平锁比非公平锁在代码里面多了几行判断；</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">// ===========重写 lock 方法对比===========
</span></span><span class="line"><span class="cl">    // 公平锁
</span></span><span class="line"><span class="cl">    final void lock() {
</span></span><span class="line"><span class="cl">        acquire(1);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // 非公平锁
</span></span><span class="line"><span class="cl">    final void lock() {
</span></span><span class="line"><span class="cl">        if (compareAndSetState(0, 1))
</span></span><span class="line"><span class="cl">            setExclusiveOwnerThread(Thread.currentThread());
</span></span><span class="line"><span class="cl">        else
</span></span><span class="line"><span class="cl">            acquire(1);
</span></span><span class="line"><span class="cl">    }
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">// ===========重写 tryAcquire 方法对比===========
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // 公平锁
</span></span><span class="line"><span class="cl">    protected final boolean tryAcquire(int acquires) {
</span></span><span class="line"><span class="cl">        final Thread current = Thread.currentThread();
</span></span><span class="line"><span class="cl">        int c = getState();
</span></span><span class="line"><span class="cl">        if (c == 0) {
</span></span><span class="line"><span class="cl">            if (!hasQueuedPredecessors() &amp;&amp;
</span></span><span class="line"><span class="cl">                compareAndSetState(0, acquires)) {
</span></span><span class="line"><span class="cl">                setExclusiveOwnerThread(current);
</span></span><span class="line"><span class="cl">                return true;
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        else if (current == getExclusiveOwnerThread()) {
</span></span><span class="line"><span class="cl">            int nextc = c + acquires;
</span></span><span class="line"><span class="cl">            if (nextc &lt; 0)
</span></span><span class="line"><span class="cl">                throw new Error(&#34;Maximum lock count exceeded&#34;);
</span></span><span class="line"><span class="cl">            setState(nextc);
</span></span><span class="line"><span class="cl">            return true;
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        return false;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // 非公平锁
</span></span><span class="line"><span class="cl">    protected final boolean tryAcquire(int acquires) {
</span></span><span class="line"><span class="cl">        return nonfairTryAcquire(acquires);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    final boolean nonfairTryAcquire(int acquires) {
</span></span><span class="line"><span class="cl">        final Thread current = Thread.currentThread();
</span></span><span class="line"><span class="cl">        int c = getState();
</span></span><span class="line"><span class="cl">        if (c == 0) {
</span></span><span class="line"><span class="cl">            if (compareAndSetState(0, acquires)) {
</span></span><span class="line"><span class="cl">                setExclusiveOwnerThread(current);
</span></span><span class="line"><span class="cl">                return true;
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        else if (current == getExclusiveOwnerThread()) {
</span></span><span class="line"><span class="cl">            int nextc = c + acquires;
</span></span><span class="line"><span class="cl">            if (nextc &lt; 0) // overflow
</span></span><span class="line"><span class="cl">                throw new Error(&#34;Maximum lock count exceeded&#34;);
</span></span><span class="line"><span class="cl">            setState(nextc);
</span></span><span class="line"><span class="cl">            return true;
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        return false;
</span></span><span class="line"><span class="cl">    }
</span></span></code></pre></div><p>在重写的<code>tryAcquire</code>方法里，公平锁在获取同步状态时多了一个限制条件:<code>hasQueuedPredecessors()</code> ;</p>
<p>该方法作用：保证等待队列中的线程按照从头到尾的顺序排队获取锁。
举个例子，目前队列中有两个线程A、B，线程A，在线程B的前面；在当前线程释放锁的时候，线程B获取到了锁，该方法会判断当前头结点的下一个结点中存放的线程跟当前线程相不相同；</p>
<p>在这里头结点的下一个结点存放的线程是傀儡结点线程为<code>null</code>，而当前线程是线程B，所以返回<code>true</code>，回到上一个方法<code>true</code>取反就是<code>false</code>，则获取锁失败。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">    public final boolean hasQueuedPredecessors() {
</span></span><span class="line"><span class="cl">        // The correctness of this depends on head being initialized
</span></span><span class="line"><span class="cl">        // before tail and on head.next being accurate if the current
</span></span><span class="line"><span class="cl">        // thread is first in queue.
</span></span><span class="line"><span class="cl">        Node t = tail; // Read fields in reverse initialization order
</span></span><span class="line"><span class="cl">        Node h = head;
</span></span><span class="line"><span class="cl">        Node s;
</span></span><span class="line"><span class="cl">        return h != t &amp;&amp;
</span></span><span class="line"><span class="cl">            ((s = h.next) == null || s.thread != Thread.currentThread());
</span></span><span class="line"><span class="cl">    }
</span></span></code></pre></div><p>在执行完<code>tryAcquire</code>方法之后就会执行<code>addWaiter</code>方法。</p>
<p><code>addWaiter</code>方法作用；当第一次将等待的线程添加到队列时，先会调用enq方法；如果不是第一次调用，即尾结点不为空，队列中已经有了其他线程结点，则会直接将当前线程的前结点指向尾结点，即队列中最后一个线程结点;
然后用CAS将前一个结点的下一个结点指向当前结点，最后返回添加到队列中的结点。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">    private Node addWaiter(Node mode) {
</span></span><span class="line"><span class="cl">        Node node = new Node(Thread.currentThread(), mode);
</span></span><span class="line"><span class="cl">        // Try the fast path of enq; backup to full enq on failure
</span></span><span class="line"><span class="cl">        Node pred = tail;
</span></span><span class="line"><span class="cl">        if (pred != null) {
</span></span><span class="line"><span class="cl">            node.prev = pred;
</span></span><span class="line"><span class="cl">            if (compareAndSetTail(pred, node)) {
</span></span><span class="line"><span class="cl">                pred.next = node;
</span></span><span class="line"><span class="cl">                return node;
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        enq(node);
</span></span><span class="line"><span class="cl">        return node;
</span></span><span class="line"><span class="cl">    }
</span></span></code></pre></div><p>enq方法作用是，将等待获取锁的线程封装成Node结点，并将Node结点串联起来，形成双向链表结构；简而言之就是将线程添加到等待队列中去。</p>
<p>该方法运用自旋机制，如果添加的结点为第一个结点，则会在第一个实际结点之前，先生成一个“傀儡结点”；
头结点指向指向傀儡结点，傀儡结点的后结点则指向添加的第一个结点；添加的第一个结点的前结点指向傀儡结点，尾结点指向实际结点。然后将处理好的实际结点返回。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">    private Node enq(final Node node) {
</span></span><span class="line"><span class="cl">        for (;;) {
</span></span><span class="line"><span class="cl">            Node t = tail;
</span></span><span class="line"><span class="cl">            if (t == null) { // Must initialize
</span></span><span class="line"><span class="cl">                if (compareAndSetHead(new Node()))
</span></span><span class="line"><span class="cl">                    tail = head;
</span></span><span class="line"><span class="cl">            } else {
</span></span><span class="line"><span class="cl">                node.prev = t;
</span></span><span class="line"><span class="cl">                if (compareAndSetTail(t, node)) {
</span></span><span class="line"><span class="cl">                    t.next = node;
</span></span><span class="line"><span class="cl">                    return t;
</span></span><span class="line"><span class="cl">                }
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    }
</span></span></code></pre></div><p>之后在执行<code>acquireQueued</code>方法。该方法用到了自旋机制；首先先判断当前结点是否为头结点，如果是头结点，就让头结点中的线程尝试获取锁，之后执行异常结点的操作。
如果不是头结点，就会尝试让当前线程挂起，直到持有锁的线程释放锁，唤醒等待的线程，之后再去尝试获取锁。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">    final boolean acquireQueued(final Node node, int arg) {
</span></span><span class="line"><span class="cl">        boolean failed = true;
</span></span><span class="line"><span class="cl">        try {
</span></span><span class="line"><span class="cl">            boolean interrupted = false;
</span></span><span class="line"><span class="cl">            for (;;) {
</span></span><span class="line"><span class="cl">                final Node p = node.predecessor();
</span></span><span class="line"><span class="cl">                if (p == head &amp;&amp; tryAcquire(arg)) {
</span></span><span class="line"><span class="cl">                    setHead(node);
</span></span><span class="line"><span class="cl">                    p.next = null; // help GC
</span></span><span class="line"><span class="cl">                    failed = false;
</span></span><span class="line"><span class="cl">                    return interrupted;
</span></span><span class="line"><span class="cl">                }
</span></span><span class="line"><span class="cl">                if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;
</span></span><span class="line"><span class="cl">                    parkAndCheckInterrupt())
</span></span><span class="line"><span class="cl">                    interrupted = true;
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">        } finally {
</span></span><span class="line"><span class="cl">            if (failed)
</span></span><span class="line"><span class="cl">                cancelAcquire(node);
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    }
</span></span></code></pre></div><p>如果不是头结点，则会执行<code>shouldParkAfterFailedAcquire</code>方法：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">    private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {
</span></span><span class="line"><span class="cl">        int ws = pred.waitStatus;
</span></span><span class="line"><span class="cl">        if (ws == Node.SIGNAL)
</span></span><span class="line"><span class="cl">            return true;
</span></span><span class="line"><span class="cl">        if (ws &gt; 0) {
</span></span><span class="line"><span class="cl">            do {
</span></span><span class="line"><span class="cl">                node.prev = pred = pred.prev;
</span></span><span class="line"><span class="cl">            } while (pred.waitStatus &gt; 0);
</span></span><span class="line"><span class="cl">            pred.next = node;
</span></span><span class="line"><span class="cl">        } else {
</span></span><span class="line"><span class="cl">            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        return false;
</span></span><span class="line"><span class="cl">    }
</span></span></code></pre></div><p>执行该方法，首先判断上一个结点的<code>waitStatus</code>；
如果该队列只有一个结点，则上一个结点为头结点，此时头结点的<code>waitStatus=0</code>，经过该方法会将上一个结点的<code>waitStatus</code>通过CAS，设置为-1；
因为最外部是一个自旋机制，会一直循环，当第二次进入该方法，则会直接返回true。返回true，则意味着当前线程将进入堵塞状态，会执行<code>parkAndCheckInterrupt()</code>方法。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">    private final boolean parkAndCheckInterrupt() {
</span></span><span class="line"><span class="cl">        LockSupport.park(this);
</span></span><span class="line"><span class="cl">        return Thread.interrupted();
</span></span><span class="line"><span class="cl">    }
</span></span></code></pre></div><p>调用<code>LockSupport.park()</code>方法让线程挂起，直到持有锁的线程将它们唤醒。</p>
<p><strong>ReentrantLock解锁</strong>
<img alt="reentrantLock解锁" src="/iblog/posts/annex/images/essays/reentrantLock%E8%A7%A3%E9%94%81.png"></p>
<p><code>ReentrantLock</code>释放锁调用栈：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">unlock() --&gt; release() --&gt; tryRelease() --&gt; unparkSuccessor()
</span></span></code></pre></div><p><code>release</code>方法，如果<code>tryRelease</code>方法返回true，则判队列中的头结点中的<code>waitStatus</code>，如果不等于0则，执行<code>unparkSuccessor</code>方法，按唤醒队列中等待的线程。</p>
<p>核心就是调用<code>tryRelease</code>方法和<code>unparkSuccessor</code>方法:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">    public final boolean release(int arg) {
</span></span><span class="line"><span class="cl">        if (tryRelease(arg)) {
</span></span><span class="line"><span class="cl">            Node h = head;
</span></span><span class="line"><span class="cl">            if (h != null &amp;&amp; h.waitStatus != 0)
</span></span><span class="line"><span class="cl">                unparkSuccessor(h);
</span></span><span class="line"><span class="cl">            return true;
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        return false;
</span></span><span class="line"><span class="cl">    }
</span></span></code></pre></div><p><code>tryRelease</code>方法作用是尝试释放锁；首先获取当前持有锁线程的<code>state</code>，并使其减1;
如果减一后的<code>state</code>值等于0，则认为该线程马上要释放锁，将当前持有锁的线程为null，将0设置为<code>state</code>的新值，返回true。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">    protected final boolean tryRelease(int releases) {
</span></span><span class="line"><span class="cl">        int c = getState() - releases;
</span></span><span class="line"><span class="cl">        if (Thread.currentThread() != getExclusiveOwnerThread())
</span></span><span class="line"><span class="cl">            throw new IllegalMonitorStateException();
</span></span><span class="line"><span class="cl">        boolean free = false;
</span></span><span class="line"><span class="cl">        if (c == 0) {
</span></span><span class="line"><span class="cl">            free = true;
</span></span><span class="line"><span class="cl">            setExclusiveOwnerThread(null);
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        setState(c);
</span></span><span class="line"><span class="cl">        return free;
</span></span><span class="line"><span class="cl">    }
</span></span></code></pre></div><p>由于之前加锁等待队列中是自旋机制，由于持有锁的线程唤醒队列中排队的线程，队列中的线程则会尝试再次获取锁。</p>
<p>首先，将头结点从前向后移动一个结点，随后清空该结点的线程对象、该结点的前结点、后结点，即将该结点设置成新的傀儡结点(哨兵结点)，最后结束循环。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">private void unparkSuccessor(Node node) {
</span></span><span class="line"><span class="cl">    int ws = node.waitStatus;
</span></span><span class="line"><span class="cl">    if (ws &lt; 0)
</span></span><span class="line"><span class="cl">        compareAndSetWaitStatus(node, ws, 0);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    Node s = node.next;
</span></span><span class="line"><span class="cl">    if (s == null || s.waitStatus &gt; 0) {
</span></span><span class="line"><span class="cl">        s = null;
</span></span><span class="line"><span class="cl">        for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev)
</span></span><span class="line"><span class="cl">            if (t.waitStatus &lt;= 0)
</span></span><span class="line"><span class="cl">                s = t;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    if (s != null)
</span></span><span class="line"><span class="cl">        LockSupport.unpark(s.thread);
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><p><strong>总结</strong></p>
<p><code>ReentrantLock</code> 在采用非公平锁构造时，首先检查锁状态，如果锁可用，直接通过CAS设置成持有状态，且把当前线程设置为锁的拥有者。
如果当前锁已经被持有，那么接下来进行可重入检查，如果可重入，需要为锁状态加上请求数。如果不属于上面两种情况，那么说明锁是被其他线程持有，
当前线程应该放入等待队列。</p>
<p>在放入等待队列的过程中，首先要检查队列是否为空队列，如果为空队列，需要创建虚拟的头节点，然后把对当前线程封装的节点加入到队列尾部。
由于设置尾部节点采用了CAS，为了保证尾节点能够设置成功，这里采用了无限循环的方式，直到设置成功为止。</p>
<p>在完成放入等待队列任务后，则需要维护节点的状态，以及及时清除处于<code>Cancel</code>状态的节点，以帮助垃圾收集器及时回收。
如果当前节点之前的节点的等待状态小于1，说明当前节点之前的线程处于等待状态(挂起)，那么当前节点的线程也应处于等待状态(挂起)。
挂起的工作是由 <code>LockSupport</code> 类支持的，<code>LockSupport</code> 通过JNI调用本地操作系统来完成挂起的任务。
在当前等待的线程，被唤起后，检查中断状态，如果处于中断状态，那么需要中断当前线程。</p>
<h4 id="countdownlatch">CountDownLatch</h4>
<p><code>count down latch</code>直译为：倒计时门闩，也可以叫做闭锁。</p>
<blockquote>
<p>门闩，汉语词汇。拼音：mén shuān 释义：指门关上后，插在门内使门推不开的滑动插销。</p>
</blockquote>
<p><code>CountDownLatch</code>JDK文档注释：</p>
<blockquote>
<p>A synchronization aid that allows one or more threads to wait until a set of operations being performed in other threads completes.</p>
</blockquote>
<p>大意：一种同步辅助工具，允许一个或多个线程等待，直到在其他线程中执行的一组操作完成。</p>
<p>举个例子，晚上教室关门，要同学都离开之后，再关门：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public class MainTest {
</span></span><span class="line"><span class="cl">    public static void main(String[] args) throws InterruptedException {
</span></span><span class="line"><span class="cl">        CountDownLatch countDownLatch = new CountDownLatch(7);
</span></span><span class="line"><span class="cl">        for (int i = 0; i &lt; 7; i++){
</span></span><span class="line"><span class="cl">            new Thread(() -&gt; {
</span></span><span class="line"><span class="cl">                System.out.println(&#34;同学&#34;+Thread.currentThread().getName() + &#34;\t 离开&#34;);
</span></span><span class="line"><span class="cl">                countDownLatch.countDown();
</span></span><span class="line"><span class="cl">            },String.valueOf(i)).start();
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        countDownLatch.await();
</span></span><span class="line"><span class="cl">        System.out.println(&#34;关门...&#34;);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><p>再比如，跑步比赛，裁判的发令枪一响，参赛者就开始跑步：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public class MainTest {
</span></span><span class="line"><span class="cl">    public static void main(String[] args) throws InterruptedException {
</span></span><span class="line"><span class="cl">        CountDownLatch countDownLatch = new CountDownLatch(1);
</span></span><span class="line"><span class="cl">        for (int i = 0; i &lt; 5; i++) {
</span></span><span class="line"><span class="cl">            new Thread(() -&gt; {
</span></span><span class="line"><span class="cl">                try {
</span></span><span class="line"><span class="cl">                    //准备完毕……运动员都阻塞在这，等待号令
</span></span><span class="line"><span class="cl">                    countDownLatch.await();
</span></span><span class="line"><span class="cl">                    String parter = &#34;【&#34; + Thread.currentThread().getName() + &#34;】&#34;;
</span></span><span class="line"><span class="cl">                    System.out.println(parter + &#34;开始执行……&#34;);
</span></span><span class="line"><span class="cl">                } catch (InterruptedException e) {
</span></span><span class="line"><span class="cl">                    e.printStackTrace();
</span></span><span class="line"><span class="cl">                }
</span></span><span class="line"><span class="cl">            }).start();
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        Thread.sleep(2000);// 裁判准备发令
</span></span><span class="line"><span class="cl">        countDownLatch.countDown();// 发令枪：执行发令
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><p><code>CountDownLatch</code>是通过一个计数器来实现的，计数器的初始值为线程的数量；
可以通过<code>CountDownLatch</code>的构造函数，可以指定，不能小于0：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">    public CountDownLatch(int count) {
</span></span><span class="line"><span class="cl">        if (count &lt; 0) throw new IllegalArgumentException(&#34;count &lt; 0&#34;);
</span></span><span class="line"><span class="cl">        this.sync = new Sync(count);
</span></span><span class="line"><span class="cl">    }
</span></span></code></pre></div><p>每次调用<code>countDown()</code>方法可以让计数器减1，底层是<a href="/iblog/posts/java/rookie-multi-thread/#AQS">AQS</a>框架，这里就不写了。
调用了<code>await()</code>进行阻塞等待的线程，当计数器减到0后，再执行<code>await()</code>之后的代码。</p>
<h4 id="cyclicbarrier">CyclicBarrier</h4>
<p><code>Cyclic Barrier</code>直译为：循环屏障，是Java中关于线程的计数器，也可以叫它栅栏。</p>
<p>它与<code>CountDownLatch</code>的作用是相反的，<code>CountDownLatch</code>是定义一个次数，然后减，直到减到0，在去执行一些任务；
而<code>CyclicBarrier</code>是定义一个上限次数，然后从零开始加，直到加到定义的上限次数，在去执行一些任务。</p>
<blockquote>
<p>CyclicBarrier与CountDownLatch作用是相反的，CountDownLatch的计数器只能使用一次，而CyclicBarrier的计数器可以使用reset()方法重置，可以使用多次，所以CyclicBarrier能够处理更为复杂的场景。</p>
</blockquote>
<p><code>CyclicBarrier</code>JDK文档注释：</p>
<blockquote>
<p>A synchronization aid that allows a set of threads to all wait for each other to reach a common barrier point.  CyclicBarriers are useful in programs involving a fixed sized party of threads that must occasionally wait for each other. The barrier is called <em>cyclic</em> because it can be re-used after the waiting threads are released.</p>
</blockquote>
<p>大意：一种同步辅助工具，允许一组线程相互等待到达一个共同的障碍点。<code>cyclicbarrier</code>在包含固定大小的线程组的程序中非常有用，这些线程必须偶尔相互等待。
这个屏障被称为<code>cyclic·</code>，因为它可以在等待的线程被释放后被重用。</p>
<p>它要做的事情是，让一组线程达到一个屏障（同步点）时被阻塞，直到最后一个线程达到屏障时，所有被屏障拦截的线程才会继续干活线程进入屏障通过<code>CyclicBarrier.await()</code>方法。</p>
<p>简单说就是让一组线程相互等待，当达到一个共同点时，所有之前等待的线程再继续执行，且 <code>CyclicBarrier</code> 功能可重复使用。</p>
<p><img alt="CyclicBarrier" src="/iblog/posts/annex/images/essays/CyclicBarrier.gif"></p>
<p>例如，凑齐七颗龙珠召唤神龙：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public class MainTest {
</span></span><span class="line"><span class="cl">    public static void main(String[] args) {
</span></span><span class="line"><span class="cl">        CyclicBarrier cyclicBarrier = new CyclicBarrier(7,() -&gt; {
</span></span><span class="line"><span class="cl">            System.out.println(&#34;凑齐七颗龙珠，召唤神龙！&#34;);
</span></span><span class="line"><span class="cl">        });
</span></span><span class="line"><span class="cl">        for (int i = 1; i &lt;= 7;i++){
</span></span><span class="line"><span class="cl">            new Thread(() -&gt; {
</span></span><span class="line"><span class="cl">                System.out.println(&#34;拿到&#34;+Thread.currentThread().getName() + &#34;星龙珠&#34;);
</span></span><span class="line"><span class="cl">                try {
</span></span><span class="line"><span class="cl">                    cyclicBarrier.await();
</span></span><span class="line"><span class="cl">                } catch (InterruptedException | BrokenBarrierException e) {
</span></span><span class="line"><span class="cl">                    e.printStackTrace();
</span></span><span class="line"><span class="cl">                }
</span></span><span class="line"><span class="cl">            },String.valueOf(i)).start();
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><p><code>CyclicBarrier</code>原理简单说明：</p>
<p><code>CyclicBarrier</code> 是基于 <a href="/iblog/posts/java/rookie-multi-thread/#ReentrantLock原理">ReentrantLock</a> 实现的，其底层也是基于 <a href="/iblog/posts/java/rookie-multi-thread/#AQS">AQS</a> 的。</p>
<p>在 <code>CyclicBarrier</code> 类的内部有一个计数器 <code>count</code>，当 <code>count</code> 不为 0 时，每个线程在到达屏障点会先调用 <code>await</code> 方法将自己阻塞，此时计数器会减 1，直到计数器减为 0 的时候，所有因调用 <code>await</code> 方法而被阻塞的线程就会被唤醒继续执行。
当 <code>count</code> 计数器变成 0 之后，就会进入下一轮阻塞，此时 <code>parties</code>(<code>parties</code> 是在 <code>new CyclicBarrier(parties)</code> 时设置的值)会将它的值赋值给 <code>count</code> 从而实现复用。</p>
<p><code>CyclicBarrier</code>内部使用了<code>ReentrantLock</code>和<code>Condition</code>两个类。它有两个构造函数：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public CyclicBarrier(int parties) {
</span></span><span class="line"><span class="cl">    this(parties, null);
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">public CyclicBarrier(int parties, Runnable barrierAction) {
</span></span><span class="line"><span class="cl">    if (parties &lt;= 0) throw new IllegalArgumentException();
</span></span><span class="line"><span class="cl">    this.parties = parties;
</span></span><span class="line"><span class="cl">    this.count = parties;
</span></span><span class="line"><span class="cl">    this.barrierCommand = barrierAction;
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><p>调用<code>await</code>方法的线程告诉<code>CyclicBarrier</code>已经到达同步点，然后当前线程被阻塞。
直到达到定义上限个数的线程都到达了屏障；</p>
<p>参与线程调用了<code>await</code>方法，<code>CyclicBarrier</code>同样提供带超时时间的<code>await</code>和不带超时时间的<code>await</code>方法：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public int await() throws InterruptedException, BrokenBarrierException {
</span></span><span class="line"><span class="cl">    try {
</span></span><span class="line"><span class="cl">        // 不超时等待
</span></span><span class="line"><span class="cl">        return dowait(false, 0L);
</span></span><span class="line"><span class="cl">    } catch (TimeoutException toe) {
</span></span><span class="line"><span class="cl">        throw new Error(toe); // cannot happen
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">public int await(long timeout, TimeUnit unit)
</span></span><span class="line"><span class="cl">    throws InterruptedException,
</span></span><span class="line"><span class="cl">            BrokenBarrierException,
</span></span><span class="line"><span class="cl">            TimeoutException {
</span></span><span class="line"><span class="cl">    return dowait(true, unit.toNanos(timeout));
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><p>这两个方法最终都会调用<code>dowait(boolean, long)</code>方法，它也是<code>CyclicBarrier</code>的核心方法：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">private int dowait(boolean timed, long nanos)
</span></span><span class="line"><span class="cl">    throws InterruptedException, BrokenBarrierException,
</span></span><span class="line"><span class="cl">            TimeoutException {
</span></span><span class="line"><span class="cl">    // 获取独占锁
</span></span><span class="line"><span class="cl">    final ReentrantLock lock = this.lock;
</span></span><span class="line"><span class="cl">    lock.lock();
</span></span><span class="line"><span class="cl">    try {
</span></span><span class="line"><span class="cl">        // 当前代
</span></span><span class="line"><span class="cl">        final Generation g = generation;
</span></span><span class="line"><span class="cl">        // 如果这代损坏了，抛出异常
</span></span><span class="line"><span class="cl">        if (g.broken)
</span></span><span class="line"><span class="cl">            throw new BrokenBarrierException();
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">        // 如果线程中断了，抛出异常
</span></span><span class="line"><span class="cl">        if (Thread.interrupted()) {
</span></span><span class="line"><span class="cl">            // 将损坏状态设置为true
</span></span><span class="line"><span class="cl">            // 并通知其他阻塞在此栅栏上的线程
</span></span><span class="line"><span class="cl">            breakBarrier();
</span></span><span class="line"><span class="cl">            throw new InterruptedException();
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">        // 获取下标
</span></span><span class="line"><span class="cl">        int index = --count;
</span></span><span class="line"><span class="cl">        // 如果是 0，说明最后一个线程调用了该方法
</span></span><span class="line"><span class="cl">        if (index == 0) {  // tripped
</span></span><span class="line"><span class="cl">            boolean ranAction = false;
</span></span><span class="line"><span class="cl">            try {
</span></span><span class="line"><span class="cl">                final Runnable command = barrierCommand;
</span></span><span class="line"><span class="cl">                // 执行栅栏任务
</span></span><span class="line"><span class="cl">                if (command != null)
</span></span><span class="line"><span class="cl">                    command.run();
</span></span><span class="line"><span class="cl">                ranAction = true;
</span></span><span class="line"><span class="cl">                // 更新一代，将count重置，将generation重置
</span></span><span class="line"><span class="cl">                // 唤醒之前等待的线程
</span></span><span class="line"><span class="cl">                nextGeneration();
</span></span><span class="line"><span class="cl">                return 0;
</span></span><span class="line"><span class="cl">            } finally {
</span></span><span class="line"><span class="cl">                // 如果执行栅栏任务的时候失败了，就将损坏状态设置为true
</span></span><span class="line"><span class="cl">                if (!ranAction)
</span></span><span class="line"><span class="cl">                    breakBarrier();
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">        // loop until tripped, broken, interrupted, or timed out
</span></span><span class="line"><span class="cl">        for (;;) {
</span></span><span class="line"><span class="cl">            try {
</span></span><span class="line"><span class="cl">                 // 如果没有时间限制，则直接等待，直到被唤醒
</span></span><span class="line"><span class="cl">                if (!timed)
</span></span><span class="line"><span class="cl">                    trip.await();
</span></span><span class="line"><span class="cl">                // 如果有时间限制，则等待指定时间
</span></span><span class="line"><span class="cl">                else if (nanos &gt; 0L)
</span></span><span class="line"><span class="cl">                    nanos = trip.awaitNanos(nanos);
</span></span><span class="line"><span class="cl">            } catch (InterruptedException ie) {
</span></span><span class="line"><span class="cl">                // 当前代没有损坏
</span></span><span class="line"><span class="cl">                if (g == generation &amp;&amp; ! g.broken) {
</span></span><span class="line"><span class="cl">                    // 让栅栏失效
</span></span><span class="line"><span class="cl">                    breakBarrier();
</span></span><span class="line"><span class="cl">                    throw ie;
</span></span><span class="line"><span class="cl">                } else {
</span></span><span class="line"><span class="cl">                    // 上面条件不满足，说明这个线程不是这代的
</span></span><span class="line"><span class="cl">                    // 就不会影响当前这代栅栏的执行，所以，就打个中断标记
</span></span><span class="line"><span class="cl">                    Thread.currentThread().interrupt();
</span></span><span class="line"><span class="cl">                }
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">            // 当有任何一个线程中断了，就会调用breakBarrier方法
</span></span><span class="line"><span class="cl">            // 就会唤醒其他的线程，其他线程醒来后，也要抛出异常
</span></span><span class="line"><span class="cl">            if (g.broken)
</span></span><span class="line"><span class="cl">                throw new BrokenBarrierException();
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">            // g != generation表示正常换代了，返回当前线程所在栅栏的下标
</span></span><span class="line"><span class="cl">            // 如果 g == generation，说明还没有换代，那为什么会醒了？
</span></span><span class="line"><span class="cl">            // 因为一个线程可以使用多个栅栏，当别的栅栏唤醒了这个线程，就会走到这里，所以需要判断是否是当前代。
</span></span><span class="line"><span class="cl">            // 正是因为这个原因，才需要generation来保证正确。
</span></span><span class="line"><span class="cl">            if (g != generation)
</span></span><span class="line"><span class="cl">                return index;
</span></span><span class="line"><span class="cl">            
</span></span><span class="line"><span class="cl">            // 如果有时间限制，且时间小于等于0，销毁栅栏并抛出异常
</span></span><span class="line"><span class="cl">            if (timed &amp;&amp; nanos &lt;= 0L) {
</span></span><span class="line"><span class="cl">                breakBarrier();
</span></span><span class="line"><span class="cl">                throw new TimeoutException();
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    } finally {
</span></span><span class="line"><span class="cl">        // 释放独占锁
</span></span><span class="line"><span class="cl">        lock.unlock();
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><p><code>dowait</code>方法作用，如果该线程不是最后一个调用<code>await</code>方法的线程，则它会一直处于等待状态，除非发生以下情况：</p>
<ul>
<li>最后一个线程到达，即<code>index == 0</code>;</li>
<li>某个参与线程等待超时;</li>
<li>某个参与线程被中断;</li>
<li>调用了<code>CyclicBarrier的reset()</code>方法。该方法会将屏障重置为初始状态;</li>
</ul>
<h4 id="semaphore">Semaphore</h4>
<p><code>Semaphore</code>译为信号量，有时被称为信号灯。可以用来控制同时访问特定资源的线程数量，通过协调各个线程，以保证合理的使用资源。</p>
<blockquote>
<p>信号量主要用于两个目的，一个是用于多个共享资源的互斥使用，另一个用于并发线程数量的控制。</p>
</blockquote>
<p><code>Semaphore</code>JDK文档注释：</p>
<blockquote>
<p>A counting semaphore.  Conceptually, a semaphore maintains a set of permits.  Each {@link #acquire} blocks if necessary until a permit is available, and then takes it.  Each {@link #release} adds a permit, potentially releasing a blocking acquirer.</p>
</blockquote>
<p>大意：计数信号量。从概念上讲，信号量维护一组许可。如果需要，每个<code>{@link #acquire}</code>块，直到有一个许可可用，然后获取它。
每个<code>{@link #release}</code>添加一个许可，可能释放一个阻塞的获取者。
但是，没有实际的permit对象被使用;<code>{@code Semaphore}</code>只保留可用数量的计数，并相应地执行操作。</p>
<p>简单理解，使用<code>acquire</code>方法获取一个令牌(许可)，进入堵塞状态，使用<code>release</code>方法则释放一个令牌(许可)唤醒一个堵塞的线程。</p>
<p>举个例子，抢车位，九辆车抢三个车位，车位满了之后只有等里面的车离开停车场外面的车才可以进入:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public class MainTest {
</span></span><span class="line"><span class="cl">    public static void main(String[] args) {
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        Semaphore semaphore = new Semaphore(3);
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        for (int i = 1; i &lt;= 9; i++) {
</span></span><span class="line"><span class="cl">            new Thread(() -&gt; {
</span></span><span class="line"><span class="cl">                try {
</span></span><span class="line"><span class="cl">                    semaphore.acquire();
</span></span><span class="line"><span class="cl">                    System.out.println(&#34;第&#34; + Thread.currentThread().getName() + &#34;辆车，抢到车位&#34;);
</span></span><span class="line"><span class="cl">                    Thread.sleep(2000);
</span></span><span class="line"><span class="cl">                    System.out.println(&#34;停车结束.&#34;);
</span></span><span class="line"><span class="cl">                } catch (InterruptedException e) {
</span></span><span class="line"><span class="cl">                    e.printStackTrace();
</span></span><span class="line"><span class="cl">                }finally {
</span></span><span class="line"><span class="cl">                    semaphore.release();
</span></span><span class="line"><span class="cl">                }
</span></span><span class="line"><span class="cl">            }, String.valueOf(i)).start();
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><p><code>Semaphore</code>有两个构造方法，可以通过其中一个构造方法来指定锁的类型，是公平锁还是非公平锁：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">    // 设置令牌（许可）数量
</span></span><span class="line"><span class="cl">    public Semaphore(int permits) {
</span></span><span class="line"><span class="cl">        sync = new NonfairSync(permits);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // 可以设置锁的类型，是否是公平锁
</span></span><span class="line"><span class="cl">    public Semaphore(int permits, boolean fair) {
</span></span><span class="line"><span class="cl">        sync = fair ? new FairSync(permits) : new NonfairSync(permits);
</span></span><span class="line"><span class="cl">    }
</span></span></code></pre></div><p><code>Semaphore</code>的底层也用到了<a href="/iblog/posts/java/rookie-multi-thread/#AQS">AQS</a>。</p>
<p><code>Semaphore</code> 是用来保护一个或者多个共享资源的访问，<code>Semaphore</code> 内部维护了一个计数器，其值为可以访问的共享资源的个数。
一个线程要访问共享资源，先获得信号量，如果信号量的计数器值大于1，意味着有共享资源可以访问，则使其计数器值减去1，再访问共享资源。</p>
<p>如果计数器值为0，线程进入休眠。当某个线程使用完共享资源后，释放信号量，并将信号量内部的计数器加1，之前进入休眠的线程将被唤醒并再次试图获得信号量。</p>
<p>当调用<code>semaphore.acquire()</code>方法时:</p>
<ul>
<li>当前线程会尝试去同步队列获取一个令牌，获取令牌的过程也就是使用原子操作去修改同步队列的<code>state</code> ，获取一个令牌则修改为<code>state=state-1</code>;</li>
<li>当计算出来的<code>state&lt;0</code>，则代表令牌数量不足，此时会创建一个<code>Node</code>节点加入阻塞队列，挂起当前线程;</li>
<li>当计算出来的<code>state&gt;=0</code>，则代表获取令牌成功;</li>
</ul>
<p>当调用<code>semaphore.release()</code>方法时:</p>
<ul>
<li>线程会尝试释放一个令牌，释放令牌的过程也就是把同步队列的<code>state</code>修改为<code>state=state+1</code>的过程;</li>
<li>释放令牌成功之后，同时会唤醒同步队列中的一个线程;</li>
<li>被唤醒的节点会重新尝试去修改<code>state=state-1</code>的操作，如果<code>state&gt;=0</code>则获取令牌成功，否则重新进入阻塞队列，挂起线程;</li>
</ul>
<h3 id="synchronized">synchronized</h3>
<p><code>synchronized</code>是Java提供的关键字，可译为同步。可用来给对象、方法或者代码块加锁，当它锁定一个方法或者一个代码块的时候，同一时刻最多只有一个线程执行这段代码。</p>
<blockquote>
<p><code>synchronized</code>关键字在需要原子性、可见性和有序性这三种特性的时候都可以作为其中一种解决方案，看起来是“万能”的。的确，大部分并发控制操作都能使用<code>synchronized</code>来完成。</p>
</blockquote>
<h4 id="使用-1">使用</h4>
<table>
<thead>
<tr>
<th>修饰的对象</th>
<th>作用范围</th>
<th>作用对象</th>
</tr>
</thead>
<tbody>
<tr>
<td>同步一个实例方法</td>
<td>整个实例方法</td>
<td>调用此方法的对象</td>
</tr>
<tr>
<td>同步一个静态方法</td>
<td>整个静态方法</td>
<td>此类的所有对象</td>
</tr>
<tr>
<td>同步代码块-对象</td>
<td>整个代码块</td>
<td>调用此代码块的对象</td>
</tr>
<tr>
<td>同步代码块-类</td>
<td>整个代码块</td>
<td>此类的所有对象</td>
</tr>
</tbody>
</table>
<h5 id="同步一个方法">同步一个方法</h5>
<p>代码演示</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public class MainTest {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    //共享资源
</span></span><span class="line"><span class="cl">    static int i = 0;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public static void main(String[] args) throws InterruptedException {
</span></span><span class="line"><span class="cl">        MainTest mainTest = new MainTest();
</span></span><span class="line"><span class="cl">        Thread thread1 = new Thread(() -&gt; {
</span></span><span class="line"><span class="cl">            for (int j = 0; j &lt; 1000000; j++) {
</span></span><span class="line"><span class="cl">                mainTest.increase();
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">        }， &#34;线程1&#34;);
</span></span><span class="line"><span class="cl">        Thread thread2 = new Thread(() -&gt; {
</span></span><span class="line"><span class="cl">            for (int j = 0; j &lt; 1000000; j++) {
</span></span><span class="line"><span class="cl">                mainTest.increase();
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">        }, &#34;线程2&#34;);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        thread1.start();
</span></span><span class="line"><span class="cl">        thread2.start();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        // join方法的作用是调用线程等待该线程完成后，才能继续用下运行。
</span></span><span class="line"><span class="cl">        thread1.join();
</span></span><span class="line"><span class="cl">        thread2.join();
</span></span><span class="line"><span class="cl">        System.out.println(i);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public synchronized void increase() {
</span></span><span class="line"><span class="cl">        i++;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // 通过是否使用synchronized来体会
</span></span><span class="line"><span class="cl">//    public  void increase() {
</span></span><span class="line"><span class="cl">//        i++;
</span></span><span class="line"><span class="cl">//    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><p>对于上面的代码如果加上<code>synchronized</code>最后输出的结果为2000000；
如果没有加，最后的结果很大程度上是小于2000000的，当然不排除偶然情况，所以这里不是肯定句。</p>
<p>由此可见，当某个线程运行到这个方法时，都要检查有没有其它线程正在用这个方法(或者该类的其他同步方法)，有的话要等待正在使用 <code>synchronized</code> 方法的线程运行完这个方法后再运行此线程，没有的话，锁定调用者，然后直接运行。</p>
<h5 id="同步一个静态方法">同步一个静态方法</h5>
<p>当 <code>synchronized</code> 作用于静态方法时，其锁就是当前类的class对象锁。由于静态成员不专属于任何一个实例对象，是类成员，因此通过class对象锁可以控制静态 成员的并发操作。</p>
<p>需要注意的是如果一个线程A调用一个实例对象的非<code>static synchronized</code>方法，而线程B需要调用这个实例对象所属类的静态 <code>synchronized</code> 方法，是允许的，不会发生互斥现象;
因为访问静态 <code>synchronized</code> 方法占用的锁是当前类的class对象，而访问非静态 <code>synchronized</code> 方法占用的锁是当前实例对象锁。</p>
<p>代码演示</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public class MainTest {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    //共享资源
</span></span><span class="line"><span class="cl">    static int i = 0;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public static void main(String[] args) throws InterruptedException {
</span></span><span class="line"><span class="cl">        MainTest mainTest = new MainTest();
</span></span><span class="line"><span class="cl">        Thread thread1 = new Thread(() -&gt; {
</span></span><span class="line"><span class="cl">            for (int j = 0; j &lt; 1000000; j++) {
</span></span><span class="line"><span class="cl">//                increase();
</span></span><span class="line"><span class="cl">                mainTest.increaseNoneStatic();
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">        }， &#34;线程1&#34;);
</span></span><span class="line"><span class="cl">        Thread thread2 = new Thread(() -&gt; {
</span></span><span class="line"><span class="cl">            for (int j = 0; j &lt; 1000000; j++) {
</span></span><span class="line"><span class="cl">//                increase();
</span></span><span class="line"><span class="cl">//                mainTest.increaseNoneStatic();
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">        }, &#34;线程2&#34;);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        thread1.start();
</span></span><span class="line"><span class="cl">        thread2.start();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        // join方法的作用是调用线程等待该线程完成后，才能继续用下运行。
</span></span><span class="line"><span class="cl">        thread1.join();
</span></span><span class="line"><span class="cl">        thread2.join();
</span></span><span class="line"><span class="cl">        System.out.println(i);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // static修饰 锁住的是类对象
</span></span><span class="line"><span class="cl">    public static synchronized void increase() {
</span></span><span class="line"><span class="cl">        i++;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // 无static修饰 锁住的是调用该方法的 当前对象
</span></span><span class="line"><span class="cl">    public synchronized void increaseNoneStatic() {
</span></span><span class="line"><span class="cl">        i++;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><p>同步一个静态方法，作用于当前类对象加锁，进入同步代码前要获得当前类对象的锁。也就是给当前类加锁，会作用于类的所有对象实例，因为静态成员不属于任何一个实例对象，是类成员（static表明这是该类的一个静态资源，不管new了多少个对象，只有一份，所以对该类的所有对象都加了锁）。
所以如果一个线程A调用一个实例对象的非静态<code>synchronized</code>方法，而线程B需要调用这个实例对象所属类的静态<code>synchronized</code>方法，是允许的，不会发生互斥现象，因为访问静态<code>synchronized</code>方法占用的锁是当前类的锁，而访问非静态<code>synchronized</code>方法占用的锁是当前实例对象锁。</p>
<h5 id="同步代码块">同步代码块</h5>
<p>在某些情况下，我们编写的方法体可能比较大，同时存在一些比较耗时的操作，而需要同步的代码又只有一小部分，如果直接对整个方法进行同步操作，这样做就有点浪费；
此时我们可以使用同步代码块的方式对需要同步的代码进行包裹。</p>
<p>代码演示</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public class MainTest {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    //共享资源
</span></span><span class="line"><span class="cl">    static int i = 0;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public static void main(String[] args) throws InterruptedException {
</span></span><span class="line"><span class="cl">        MainTest mainTest = new MainTest();
</span></span><span class="line"><span class="cl">        Thread thread1 = new Thread(() -&gt; {
</span></span><span class="line"><span class="cl">            for (int j = 0; j &lt; 1000000; j++) {
</span></span><span class="line"><span class="cl">                mainTest.increase();
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">        }, &#34;线程1&#34;);
</span></span><span class="line"><span class="cl">        Thread thread2 = new Thread(() -&gt; {
</span></span><span class="line"><span class="cl">            for (int j = 0; j &lt; 1000000; j++) {
</span></span><span class="line"><span class="cl">                mainTest.increase();
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">        }, &#34;线程2&#34;);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        thread1.start();
</span></span><span class="line"><span class="cl">        thread2.start();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        // join方法的作用是调用线程等待该线程完成后，才能继续用下运行。
</span></span><span class="line"><span class="cl">        thread1.join();
</span></span><span class="line"><span class="cl">        thread2.join();
</span></span><span class="line"><span class="cl">        System.out.println(i);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public  void increase() {
</span></span><span class="line"><span class="cl">        synchronized (this){
</span></span><span class="line"><span class="cl">            i++;
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">//    public  void increase() {
</span></span><span class="line"><span class="cl">//        i++;
</span></span><span class="line"><span class="cl">//    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><p>除了使用<code>synchronized (this)</code>锁定，当然静态方法是没有this对象的；也可以使用<code>class</code>对象，和程序中创建的一些对象来做为锁。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">// class类对象锁
</span></span><span class="line"><span class="cl">synchronized(MainTest.class){
</span></span><span class="line"><span class="cl">    // ...
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">// 
</span></span></code></pre></div><p>当没有明确的对象作为锁，只是想让一段代码同步时，可以创建一个特殊的对象来充当锁;</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">private byte[] lock = new byte[0];
</span></span><span class="line"><span class="cl">public void method(){
</span></span><span class="line"><span class="cl">  synchronized(lock) {
</span></span><span class="line"><span class="cl">     // .....
</span></span><span class="line"><span class="cl">  }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><p>零长度的<code>byte</code>数组对象创建起来将比任何对象都经济――查看编译后的字节码：生成零长度的<code>byte[]</code>对象只需3条操作码，而<code>Object lock = new Object()</code>则需要7行操作码。</p>
<p>当一个线程访问对象的一个<code>synchronized(this)</code>同步代码块时，另一个线程仍然可以访问该对象中的非<code>synchronized(this)</code>同步代码块。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public class MainTest {
</span></span><span class="line"><span class="cl">    public static void main(String[] args) {
</span></span><span class="line"><span class="cl">        Counter counter = new Counter();
</span></span><span class="line"><span class="cl">        Thread thread1 = new Thread(counter, &#34;A&#34;);
</span></span><span class="line"><span class="cl">        Thread thread2 = new Thread(counter, &#34;B&#34;);
</span></span><span class="line"><span class="cl">        thread1.start();
</span></span><span class="line"><span class="cl">        thread2.start();
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">class Counter implements Runnable{
</span></span><span class="line"><span class="cl">    private int count;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public Counter() {
</span></span><span class="line"><span class="cl">        count = 0;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public void countAdd() {
</span></span><span class="line"><span class="cl">        synchronized(this) {
</span></span><span class="line"><span class="cl">            for (int i = 0; i &lt; 5; i ++) {
</span></span><span class="line"><span class="cl">                try {
</span></span><span class="line"><span class="cl">                    System.out.println(Thread.currentThread().getName() + &#34;:&#34; + (count++));
</span></span><span class="line"><span class="cl">                    Thread.sleep(100);
</span></span><span class="line"><span class="cl">                } catch (InterruptedException e) {
</span></span><span class="line"><span class="cl">                    e.printStackTrace();
</span></span><span class="line"><span class="cl">                }
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    //非synchronized代码块，未对count进行读写操作，所以可以不用synchronized
</span></span><span class="line"><span class="cl">    public void printCount() {
</span></span><span class="line"><span class="cl">        for (int i = 0; i &lt; 5; i ++) {
</span></span><span class="line"><span class="cl">            try {
</span></span><span class="line"><span class="cl">                System.out.println(Thread.currentThread().getName() + &#34; count:&#34; + count);
</span></span><span class="line"><span class="cl">                Thread.sleep(100);
</span></span><span class="line"><span class="cl">            } catch (InterruptedException e) {
</span></span><span class="line"><span class="cl">                e.printStackTrace();
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    public void run() {
</span></span><span class="line"><span class="cl">        String threadName = Thread.currentThread().getName();
</span></span><span class="line"><span class="cl">        if (threadName.equals(&#34;A&#34;)) {
</span></span><span class="line"><span class="cl">            countAdd();
</span></span><span class="line"><span class="cl">        } else if (threadName.equals(&#34;B&#34;)) {
</span></span><span class="line"><span class="cl">            printCount();
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><h4 id="原理-2">原理</h4>
<p>阅读前建议先了解<a href="https://whiteppure.github.io/iblog/posts/jvm/java-object/#%E5%AF%B9%E8%B1%A1%E5%A4%B4">Java对象头</a>。
如果你对对象头有了解，你就知道在Java中<code>synchronized</code>锁对象时，其实就是改变对象中的对象头的<code>markword</code>的锁的标志位来实现的。</p>
<p>通过上面的使用，可以体会到被<code>synchronized</code>修饰的代码块及方法，在同一时间，只能被单个线程访问。</p>
<p>用<code>javap -v MainTest.class</code> 命令反编译下面代码，我们就能了解到JVM对<code>synchronized</code>是怎么处理的了。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public class MainTest {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    synchronized void demo01() {
</span></span><span class="line"><span class="cl">        System.out.println(&#34;demo 01&#34;);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    void demo02() {
</span></span><span class="line"><span class="cl">        synchronized (MainTest.class) {
</span></span><span class="line"><span class="cl">            System.out.println(&#34;demo 02&#34;);
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl">  <span class="n">synchronized</span> <span class="n">void</span> <span class="n">demo01</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">descriptor</span><span class="p">:</span> <span class="p">()</span><span class="n">V</span>
</span></span><span class="line"><span class="cl">    <span class="n">flags</span><span class="p">:</span> <span class="n">ACC_SYNCHRONIZED</span>
</span></span><span class="line"><span class="cl">    <span class="n">Code</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">      <span class="n">stack</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">locals</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">args_size</span><span class="o">=</span><span class="mi">1</span>
</span></span><span class="line"><span class="cl">         <span class="mi">0</span><span class="p">:</span> <span class="n">getstatic</span>     <span class="c1">#2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span>
</span></span><span class="line"><span class="cl">         <span class="mi">3</span><span class="p">:</span> <span class="n">ldc</span>           <span class="c1">#3                  // String demo 01</span>
</span></span><span class="line"><span class="cl">         <span class="mi">5</span><span class="p">:</span> <span class="n">invokevirtual</span> <span class="c1">#4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span>
</span></span><span class="line"><span class="cl">         <span class="mi">8</span><span class="p">:</span> <span class="k">return</span>
</span></span><span class="line"><span class="cl"><span class="o">//</span> <span class="o">...</span>
</span></span><span class="line"><span class="cl"><span class="n">void</span> <span class="n">demo02</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">descriptor</span><span class="p">:</span> <span class="p">()</span><span class="n">V</span>
</span></span><span class="line"><span class="cl">    <span class="n">flags</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">Code</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">      <span class="n">stack</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">locals</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">args_size</span><span class="o">=</span><span class="mi">1</span>
</span></span><span class="line"><span class="cl">         <span class="mi">0</span><span class="p">:</span> <span class="n">ldc</span>           <span class="c1">#5                  // class content/posts/rookie/MainTest</span>
</span></span><span class="line"><span class="cl">         <span class="mi">2</span><span class="p">:</span> <span class="n">dup</span>
</span></span><span class="line"><span class="cl">         <span class="mi">3</span><span class="p">:</span> <span class="n">astore_1</span>
</span></span><span class="line"><span class="cl">         <span class="mi">4</span><span class="p">:</span> <span class="n">monitorenter</span>
</span></span><span class="line"><span class="cl">         <span class="mi">5</span><span class="p">:</span> <span class="n">getstatic</span>     <span class="c1">#2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span>
</span></span><span class="line"><span class="cl">         <span class="mi">8</span><span class="p">:</span> <span class="n">ldc</span>           <span class="c1">#6                  // String demo 02</span>
</span></span><span class="line"><span class="cl">        <span class="mi">10</span><span class="p">:</span> <span class="n">invokevirtual</span> <span class="c1">#4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span>
</span></span><span class="line"><span class="cl">        <span class="mi">13</span><span class="p">:</span> <span class="n">aload_1</span>
</span></span><span class="line"><span class="cl">        <span class="mi">14</span><span class="p">:</span> <span class="n">monitorexit</span>
</span></span><span class="line"><span class="cl">        <span class="mi">15</span><span class="p">:</span> <span class="n">goto</span>          <span class="mi">23</span>
</span></span><span class="line"><span class="cl">        <span class="mi">18</span><span class="p">:</span> <span class="n">astore_2</span>
</span></span><span class="line"><span class="cl">        <span class="mi">19</span><span class="p">:</span> <span class="n">aload_1</span>
</span></span><span class="line"><span class="cl">        <span class="mi">20</span><span class="p">:</span> <span class="n">monitorexit</span>
</span></span><span class="line"><span class="cl">        <span class="mi">21</span><span class="p">:</span> <span class="n">aload_2</span>
</span></span><span class="line"><span class="cl">        <span class="mi">22</span><span class="p">:</span> <span class="n">athrow</span>
</span></span><span class="line"><span class="cl">        <span class="mi">23</span><span class="p">:</span> <span class="k">return</span>
</span></span><span class="line"><span class="cl"><span class="o">//</span> <span class="o">...</span>
</span></span></code></pre></div><p>通过反编译后代码可以看出：</p>
<ul>
<li>对于同步方法，JVM采用<code>ACC_SYNCHRONIZED</code>标记符来实现同步；</li>
<li>对于同步代码块，JVM采用<code>monitorenter</code>、<code>monitorexit</code>两个指令来实现同步;</li>
</ul>
<p>其中同步代码块，有两个<code>monitorexit</code>指令的原因是，为了保证抛异常的情况下也能释放锁，所以<code>javac</code>为同步代码块添加了一个隐式的<code>try-finally</code>，在<code>finally</code>中会调用<code>monitorexit</code>命令释放锁。</p>
<p><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.11.10">官方文档</a>中关于同步方法和同步代码块的实现原理描述</p>
<blockquote>
<p>方法级的同步是隐式的。同步方法的常量池中会有一个 <code>ACC_SYNCHRONIZED</code> 标志。当某个线程要访问某个方法的时候，会检查是否有 <code>ACC_SYNCHRONIZED</code>，如果有设置，则需要先获得监视器锁，然后开始执行方法，方法执行之后再释放监视器锁。这时如果其他线程来请求执行方法，会因为无法获得监视器锁而被阻断住。值得注意的是，如果在方法执行过程中，发生了异常，并且方法内部并没有处理该异常，那么在异常被抛到方法外面之前监视器锁会被自动释放。</p>
</blockquote>
<blockquote>
<p>同步代码块使用 <code>monitorenter</code> 和 <code>monitorexit</code> 两个指令实现。可以把执行 <code>monitorenter</code> 指令理解为加锁，执行 <code>monitorexit</code> 理解为释放锁。 每个对象维护着一个记录着被锁次数的计数器。未被锁定的对象的该计数器为0，当一个线程获得锁（执行 <code>monitorenter</code>）后，该计数器自增变为 1 ，当同一个线程再次获得该对象的锁的时候，计数器再次自增。当同一个线程释放锁（执行 <code>monitorexit</code> 指令）的时候，计数器再自减。当计数器为0的时候。锁将被释放，其他线程便可以获得锁。</p>
</blockquote>
<p>其实无论是<code>ACC_SYNCHRONIZED</code>还是<code>monitorenter</code>、<code>monitorexit</code>都是基于<code>Monitor</code>实现的，每一个锁都对应一个<code>monitor</code>对象;
在Java虚拟机(HotSpot)中，<code>Monitor</code> 是基于C++实现的，由<code>ObjectMonitor</code>实现。</p>
<p>在<code>/hotspot/src/share/vm/runtime/objectMonitor.hpp</code>中有<code>ObjectMonitor</code>的实现</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">// initialize the monitor, exception the semaphore, all other fields
</span></span><span class="line"><span class="cl">// are simple integers or pointers
</span></span><span class="line"><span class="cl">ObjectMonitor() {
</span></span><span class="line"><span class="cl">    _header       = NULL;
</span></span><span class="line"><span class="cl">    _count        = 0; //记录个数
</span></span><span class="line"><span class="cl">    _waiters      = 0,
</span></span><span class="line"><span class="cl">    _recursions   = 0;
</span></span><span class="line"><span class="cl">    _object       = NULL;
</span></span><span class="line"><span class="cl">    _owner        = NULL;
</span></span><span class="line"><span class="cl">    _WaitSet      = NULL; //处于wait状态的线程，会被加入到_WaitSet
</span></span><span class="line"><span class="cl">    _WaitSetLock  = 0 ;
</span></span><span class="line"><span class="cl">    _Responsible  = NULL ;
</span></span><span class="line"><span class="cl">    _succ         = NULL ;
</span></span><span class="line"><span class="cl">    _cxq          = NULL ;
</span></span><span class="line"><span class="cl">    FreeNext      = NULL ;
</span></span><span class="line"><span class="cl">    _EntryList    = NULL ; //处于等待锁block状态的线程，会被加入到该列表
</span></span><span class="line"><span class="cl">    _SpinFreq     = 0 ;
</span></span><span class="line"><span class="cl">    _SpinClock    = 0 ;
</span></span><span class="line"><span class="cl">    OwnerIsThread = 0 ;
</span></span><span class="line"><span class="cl">  }
</span></span></code></pre></div><ul>
<li><code>_owner</code>：指向持有<code>ObjectMonitor</code>对象的线程</li>
<li><code>_WaitSet</code>：存放处于<code>wait</code>状态的线程队列</li>
<li><code>_EntryList</code>：存放处于等待锁<code>block</code>状态的线程队列</li>
<li><code>_recursions</code>：锁的重入次数</li>
<li><code>_count</code>：用来记录该线程获取锁的次数</li>
</ul>
<p>当多个线程同时访问一段同步代码时，首先会进入<code>_EntryList</code>队列中，当某个线程获取到对象的<code>monitor</code>后进入<code>_Owner</code>区域并把<code>monitor</code>中的<code>_owner</code>变量设置为当前线程，同时<code>monitor</code>中的计数器<code>_count</code>加1。即获得对象锁。</p>
<p><img alt="synchronized原理" src="/iblog/posts/annex/images/essays/synchronized%E5%8E%9F%E7%90%86.gif"></p>
<p>若此时持有<code>monitor</code>的线程调用<code>wait()</code>方法，将释放当前对象持有的<code>monitor</code>，<code>_owner</code>变量恢复为<code>null</code>，<code>_count</code>自减1，同时该线程进入<code>_WaitSet</code>集合中等待被唤醒。若当前线程执行完毕也将释放<code>monitor</code>并复位变量的值，以便其他线程进入获取<code>monitor</code>。</p>
<p>由此看来，<code>monitor</code>对象存在于每个Java对象的对象头中(存储的是指针)，<code>synchronized</code>锁便是通过这种方式获取锁的，也是为什么Java中任意对象可以作为锁的原因。</p>
<p><code>ObjectMonitor</code>中其他方法：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">  bool      try_enter (TRAPS) ;
</span></span><span class="line"><span class="cl">  void      enter(TRAPS);
</span></span><span class="line"><span class="cl">  void      exit(bool not_suspended, TRAPS);
</span></span><span class="line"><span class="cl">  void      wait(jlong millis, bool interruptable, TRAPS);
</span></span><span class="line"><span class="cl">  void      notify(TRAPS);
</span></span><span class="line"><span class="cl">  void      notifyAll(TRAPS);
</span></span></code></pre></div><p><code>sychronized</code>加锁的时候，会调用<code>objectMonitor</code>的<code>enter</code>方法，解锁的时候会调用<code>exit</code>方法。
在JDK1.6之前，<code>synchronized</code> 的实现才会直接调用 <code>ObjectMonitor</code>的<code>enter</code>和<code>exit</code>，这种锁被称之为重量级锁。</p>
<blockquote>
<p>早期的<code>synchronized</code>效率低的原因：
Java的线程是映射到操作系统原生线程之上的，如果要阻塞或唤醒一个线程就需要操作系统的帮忙，监视器锁<code>monitor</code>是依赖于底层的操作系统的<code>Mutex Lock</code>来实现的，而操作系统实现线程之间的切换时需要从用户态转换到核心态。因此状态转换需要花费很多的处理器时间。
对于代码简单的同步块（如被<code>synchronized</code>修饰的<code>get</code>、<code>set</code>方法）状态转换消耗的时间有可能比用户代码执行的时间还要长，所以说<code>synchronized</code>是java语言中一个重量级的操作。也是为什么早期的<code>synchronized</code>效率低的原因。</p>
</blockquote>
<p>所以，在JDK1.6中出现对锁进行了很多的优化，进而出现轻量级锁，偏向锁，锁消除，适应性自旋锁，锁粗化。</p>
<h4 id="锁的升级">锁的升级</h4>
<p><a href="https://oss.stupidzhang.com/img/blog/%E9%94%81%E5%8D%87%E7%BA%A7%E8%BF%87%E7%A8%8B.png">锁的升级</a></p>
<p>在JDK1.6之前，使用<code>synchronized</code>被称作重量级锁，重量级锁的实现是基于底层操作系统的<code>mutex</code>互斥原语的，这个开销是很大的。所以在JDK1.6时JVM对<code>synchronized</code>做了优化。</p>
<p>对象头中<code>markword</code>锁状态的表示：</p>
<blockquote>
<ul>
<li><code>biased_lock</code> ：0 <code>lock</code>： 01： 表示无锁状态</li>
<li><code>biased_lock</code> ：1 <code>lock</code>： 01： 表示偏向锁状态</li>
<li><code>lock</code>： 00： 表示轻量级锁状态</li>
<li><code>lock</code>： 10： 表示重量级锁状态</li>
<li><code>lock</code>： 11： 表示被垃圾回收器标记的状态</li>
</ul>
</blockquote>
<p>对象的锁状态，可以分为4种，级别从低到高依次是：无锁状态、<a href="/iblog/posts/java/rookie-multi-thread/#偏向锁">偏向锁状态</a>、<a href="/iblog/posts/java/rookie-multi-thread/#轻量级锁与重量级锁">轻量级锁状态</a>和<a href="/iblog/posts/java/rookie-multi-thread/#轻量级锁与重量级锁">重量级锁状态</a>。
其中这几个锁只有重量级锁是需要使用操作系统底层<code>mutex</code>互斥原语来实现，其他的锁都是使用对象头来实现的。
随着锁的竞争，锁可以从偏向锁升级到轻量级锁，再升级的重量级锁。</p>
<p>锁升级过程：</p>
<ul>
<li>无锁状态：<code>markword</code>锁的标志位0，偏向锁的标志位为1；例如：刚被创建出来的对象；</li>
<li>偏向锁：如果一个线程获取了锁，此时<code>markword</code>的结构变为偏向锁结构，当这个线程再次请求锁时，无需再做任何同步操作，直接可以获取锁。
省去了大量有关锁申请的操作，从而也就提供程序的性能。</li>
<li>轻量级锁：当锁是偏向锁的时候，被另外的线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，从而提高性能；</li>
<li>重量级锁：升级为重量级锁时，锁标志的状态值变为“10”，此时<code>MarkWord</code>中存储的是指向重量级锁的指针，此时等待锁的线程都会进入阻塞状态。所以开销是很大;</li>
</ul>
<ol>
<li>
<p>无锁状态升级为偏向锁：
一个对象刚开始实例化的时候，没有任何线程来访问它的时候。它是可偏向的，意味着，它现在认为只可能有一个线程来访问它，所以当第一个线程来访问它的时候，它会偏向这个线程，此时，对象持有偏向锁。
偏向第一个线程，这个线程在修改对象头成为偏向锁的时候使用CAS操作，并将对象头中的 <code>ThreadID</code> 改成自己的ID，之后再次访问这个对象时，只需要对比ID，不需要再使用CAS在进行操作。</p>
</li>
<li>
<p>偏向锁升级为轻量级锁：
一旦有第二个线程访问这个对象，因为偏向锁不会主动释放，所以第二个线程可以看到对象的偏向状态；
这时表明在这个对象上已经存在竞争了，JVM会检查原来持有该对象锁的线程是否依然存活，如果不存活，则可以将对象变为无锁状态，然后重新偏向新的线程，如果原来的线程依然存活，则马上执行那个线程的操作栈，检查该对象的使用情况，如果仍然需要持有偏向锁，则偏向锁升级为轻量级锁。
如果不存在使用了，则可以将对象回复成无锁状态，然后重新偏向。</p>
</li>
<li>
<p>轻量级锁升级为重量级锁：
轻量级锁认为竞争存在，但是竞争的程度很轻，一般两个线程对于同一个锁的操作都会错开，或者说稍微等待一下（自旋），另一个线程就会释放锁。
但是当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁膨胀为重量级锁，重量级锁使除了拥有锁的线程以外的线程都阻塞，防止CPU空转。</p>
</li>
</ol>
<p>在所有的锁都启用的情况下线程进入临界区时会先去获取偏向锁，如果已经存在偏向锁了，则会尝试获取轻量级锁，启用自旋锁，如果自旋也没有获取到锁，则使用重量级锁，将没有获取到锁的线程阻塞挂起，直到持有锁的线程执行完同步块唤醒他们；</p>
<p>偏向锁是在无锁争用的情况下使用的，也就是同步代码块在当前线程没有执行完之前，没有其它线程会执行该同步块，一旦有了第二个线程的争用，偏向锁就会升级为轻量级锁，如果轻量级锁自旋到达阈值后，没有获取到锁，就会升级为重量级锁；</p>
<p>锁可以升级，但是不可以降级。有的观点认为 Java 不会进行锁降级。
实际上，锁降级确实是会发生的，当 JVM 进入<a href="https://whiteppure.github.io/iblog/posts/jvm/jvm-about/#%E5%AE%89%E5%85%A8%E7%82%B9">安全点</a>（<code>SafePoint</code>）的时候，会检查是否有闲置的 <code>Monitor</code>，然后试图进行降级。</p>
<p>在 <code>HotSpot</code> 虚拟机中是有锁降级的，但是仅仅只发生在 <a href="https://whiteppure.github.io/iblog/posts/jvm/jvm-about/#stw">STW</a> 的时候，只有垃圾回收线程能够观测到它，也就是说，在我们正常使用的过程中是不会发生锁降级的，只有在 GC 的时候才会降级。</p>
<h4 id="synchronized与可见性">synchronized与可见性</h4>
<p>可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。</p>
<p>Java内存模型规定了所有的变量都存储在主内存中，每条线程还有自己的工作内存，线程的工作内存中保存了该线程中是用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存。
不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量的传递均需要自己的工作内存和主存之间进行数据同步进行。所以，就可能出现线程1改了某个变量的值，但是线程2不可见的情况。
被<code>synchronized</code>修饰的代码，在开始执行时会加锁，执行完成后会进行解锁。而为了保证可见性，有一条规则是这样的：对一个变量解锁之前，必须先把此变量同步回主存中。这样解锁后，后续线程就可以访问到被修改后的值。</p>
<p>所以，<code>synchronized</code>关键字锁住的对象，其值是具有可见性的.</p>
<h4 id="synchronized与原子性">synchronized与原子性</h4>
<p>原子性是指一个操作是不可中断的，要全部执行完成，要不就都不执行。</p>
<p>线程是CPU调度的基本单位。CPU有时间片的概念，会根据不同的调度算法进行线程调度。当一个线程获得时间片之后开始执行，在时间片耗尽之后，就会失去CPU使用权。所以在多线程场景下，由于时间片在线程间轮换，就会发生原子性问题。</p>
<p>在Java中，为了保证原子性，提供了两个高级的字节码指令<code>monitorenter</code>和<code>monitorexit</code>。
这两个字节码指令，在Java中对应的关键字就是<code>synchronized</code>。</p>
<p>通过下<code>monitorexit</code>和<code>monitorexit</code>指令，可以保证被<code>synchronized</code>修饰的代码在同一时间只能被一个线程访问，在锁未释放之前，无法被其他线程访问到。因此，在Java中可以使用<code>synchronized</code>来保证方法和代码块内的操作是原子性的。</p>
<blockquote>
<p>例如： 线程1在执行<code>monitorenter</code>指令的时候，会对Monitor进行加锁，加锁后其他线程无法获得锁，除非线程1主动解锁。
即使在执行过程中，由于某种原因，比如CPU时间片用完，线程1放弃了CPU，但是，他并没有进行解锁。
而由于<code>synchronized</code>的锁是可重入的，下一个时间片还是只能被他自己获取到，还是会继续执行代码。直到所有代码执行完。这就保证了原子性。</p>
</blockquote>
<h4 id="synchronized与有序性">synchronized与有序性</h4>
<p>有序性即程序执行的顺序按照代码的先后顺序执行。</p>
<p>除了引入了时间片以外，由于处理器优化和指令重排等，CPU还可能对输入代码进行乱序执行，比如<code>load-&gt;add-&gt;save</code> 有可能被优化成<code>load-&gt;save-&gt;add</code>这就是可能存在有序性问题。</p>
<p>这里需要注意的是，<code>synchronized</code>是无法禁止指令重排和处理器优化的。也就是说，<code>synchronized</code>无法避免上述提到的问题。</p>
<p>那么，为什么还说<code>synchronized</code>也提供了有序性保证呢？</p>
<blockquote>
<p>如果在本线程内观察，所有操作都是天然有序的。如果在一个线程中观察另一个线程，所有操作都是无序的。</p>
</blockquote>
<p>以上这句话也是，但是怎么理解呢？简单扩展一下，这其实和<code>as-if-serial</code>语义有关。</p>
<p><code>as-if-serial</code>语义的意思指：不管怎么重排序（编译器和处理器为了提高并行度），单线程程序的执行结果都不能被改变。
编译器和处理器无论如何优化，都必须遵守<code>as-if-serial</code>语义。</p>
<p>这里不对<code>as-if-serial</code>语义详细展开了，简单说就是<code>as-if-serial</code>语义保证了单线程中，指令重排是有一定的限制的，而只要编译器和处理器都遵守了这个语义，那么就可以认为单线程程序是按照顺序执行的。
当然，实际上还是有重排的，只不过我们无须关心这种重排的干扰。</p>
<p>所以呢，由于<code>synchronized</code>修饰的代码，同一时间只能被同一线程访问。那么也就是单线程执行的。所以，可以保证其有序性。</p>
<h3 id="synchronized与reentrantlock">synchronized与ReentrantLock</h3>
<p>Java 提供了两种锁机制来控制多个线程对共享资源的互斥访问，第一个是 JVM 实现的 <code>synchronized</code>，而另一个是 JDK 实现的 <code>ReentrantLock</code>。</p>
<table>
<thead>
<tr>
<th>比较</th>
<th>synchronized</th>
<th>ReentrantLock</th>
</tr>
</thead>
<tbody>
<tr>
<td>锁的实现</td>
<td>JVM 实现，监视器模式</td>
<td>JDK实现，依赖AQS</td>
</tr>
<tr>
<td>性能</td>
<td>新版本 Java 对 synchronized 进行锁的升级</td>
<td>synchronized 与 ReentrantLock 大致相同</td>
</tr>
<tr>
<td>等待可中断</td>
<td>不可中断</td>
<td>可中断</td>
</tr>
<tr>
<td>公平锁</td>
<td>非公平锁</td>
<td>默认非公平锁，也可以是公平锁</td>
</tr>
<tr>
<td>锁绑定多个条件</td>
<td>不能绑定</td>
<td>可以同时绑定多个 Condition 对象</td>
</tr>
<tr>
<td>可重入</td>
<td>可重入锁</td>
<td>可重入锁</td>
</tr>
<tr>
<td>释放锁</td>
<td>自动释放锁</td>
<td>调用 unlock() 释放锁</td>
</tr>
<tr>
<td>等待唤醒</td>
<td>搭配wait()、notify或notifyAll()使用</td>
<td>搭配await()/singal()使用</td>
</tr>
</tbody>
</table>
<p><code>synchronized</code> 与 <code>ReentrantLock</code>最直观的区别就是，在使用<code>ReentrantLock</code>的时候需要调用<code>unlock</code>方法释放锁，所以为了保证一定释放，通常都是和 <code>try~finally</code> 配合使用的。</p>
<p>除非需要使用 <code>ReentrantLock</code> 的高级功能，否则优先使用 <code>synchronized</code>。
这是因为 <code>synchronized</code> 是 JVM 实现的一种锁机制，JVM 原生地支持它，而 <code>ReentrantLock</code> 不是所有的 JDK 版本都支持。
并且使用 <code>synchronized</code> 不用担心没有释放锁而导致死锁问题，因为 JVM 会确保锁的释放。</p>
<h3 id="threadlocal">ThreadLocal</h3>
<p><code>ThreadLocal</code>文档注释：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="n">This</span> <span class="k">class</span> <span class="n">provides</span> <span class="n">thread</span><span class="o">-</span><span class="n">local</span> <span class="n">variables</span><span class="o">.</span>  <span class="n">These</span> <span class="n">variables</span> <span class="n">differ</span> <span class="n">from</span>
</span></span><span class="line"><span class="cl">  <span class="n">their</span> <span class="n">normal</span> <span class="n">counterparts</span> <span class="ow">in</span> <span class="n">that</span> <span class="n">each</span> <span class="n">thread</span> <span class="n">that</span> <span class="n">accesses</span> <span class="n">one</span> <span class="p">(</span><span class="n">via</span> <span class="n">its</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span><span class="err">@</span><span class="n">code</span> <span class="n">get</span><span class="p">}</span> <span class="ow">or</span> <span class="p">{</span><span class="err">@</span><span class="n">code</span> <span class="n">set</span><span class="p">}</span> <span class="n">method</span><span class="p">)</span> <span class="n">has</span> <span class="n">its</span> <span class="n">own</span><span class="p">,</span> <span class="n">independently</span> <span class="n">initialized</span>
</span></span><span class="line"><span class="cl">  <span class="n">copy</span> <span class="n">of</span> <span class="n">the</span> <span class="n">variable</span><span class="o">.</span> 
</span></span></code></pre></div><p>大意：这个类提供线程局部变量。这些变量与普通变量的不同之处在于，每个访问它们的线程(通过其get方法或set方法)都有自己的独立初始化的变量副本。</p>
<p>如文档注释所说，<code>ThraedLocal</code>为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。</p>
<p>从线程的角度看，目标变量就象是线程的本地变量，这也是类名中“Local”所要表达的意思。
说白了<code>ThreadLocal</code>就是存放线程的局部变量的。</p>
<h4 id="使用-2">使用</h4>
<p>在JDK5.0中，<code>ThreadLocal</code>已经支持泛型，该类的类名已经变为<code>ThreadLocal&lt;T&gt;</code>。API方法也相应进行了调整，新版本的API方法分别是<code>void set(T value)、T get()</code>以及<code>T initialValue()</code>。</p>
<blockquote>
<p>关于Object和T的区别：Object是个基类，是个真实存在的类；T是个占位符，表示某个具体的类，仅在编译器有效，最终会被擦除用Object代替。</p>
</blockquote>
<p>主要方法：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">// 返回该线程局部变量的初始值，该方法是一个protected的方法，显然是为了让子类覆盖而设计的。
</span></span><span class="line"><span class="cl">// 如果有人心急则吃不了热豆腐，在还没有set的情况下，调用get则返回null。
</span></span><span class="line"><span class="cl">protected T initialValue()
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">// 该方法返回当前线程所对应的线程局部变量
</span></span><span class="line"><span class="cl">public T get()
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">// 设置当前线程的线程局部变量的值
</span></span><span class="line"><span class="cl">public void set(T value)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">// 将当前线程局部变量的值删除，目的是为了减少内存的占用
</span></span><span class="line"><span class="cl">public void remove()
</span></span></code></pre></div><p><code>ThreadLocal</code>里设置的值，只有当前线程自己看得见:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public class MainTest {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    private static ThreadLocal&lt;Integer&gt; localInt = new ThreadLocal&lt;&gt;();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public static void main(String[] args) {
</span></span><span class="line"><span class="cl">        localInt.set(100);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        new Thread(() -&gt; {
</span></span><span class="line"><span class="cl">            localInt.set(200);
</span></span><span class="line"><span class="cl">            System.out.println(&#34;-----thead1-----&#34;);
</span></span><span class="line"><span class="cl">            System.out.println(context0());
</span></span><span class="line"><span class="cl">            System.out.println(context1());
</span></span><span class="line"><span class="cl">            System.out.println(context2());
</span></span><span class="line"><span class="cl">        },&#34;thread1&#34;).start();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        System.out.println(&#34;-----main-----&#34;);
</span></span><span class="line"><span class="cl">        System.out.println(context0());
</span></span><span class="line"><span class="cl">        System.out.println(context1());
</span></span><span class="line"><span class="cl">        System.out.println(context2());
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    static int context0() {
</span></span><span class="line"><span class="cl">        return localInt.get();
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    static int context1(){
</span></span><span class="line"><span class="cl">        return localInt.get();
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    static int context2(){
</span></span><span class="line"><span class="cl">        return localInt.get();
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><p>由于<code>ThreadLocal</code>里设置的值，只有当前线程自己看得见，这意味着你不可能通过其他线程为它初始化值。
为了弥补这一点，<code>ThreadLocal</code>提供了一个<code>withInitial()</code>方法统一初始化所有线程的<code>ThreadLocal</code>的值：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public class MainTest {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    private static final ThreadLocal&lt;Integer&gt; localInt = ThreadLocal.withInitial(() -&gt; 300);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public static void main(String[] args) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        new Thread(() -&gt; {
</span></span><span class="line"><span class="cl">            System.out.println(&#34;-----thead1-----&#34;);
</span></span><span class="line"><span class="cl">            System.out.println(context0());
</span></span><span class="line"><span class="cl">            System.out.println(context1());
</span></span><span class="line"><span class="cl">            System.out.println(context2());
</span></span><span class="line"><span class="cl">        },&#34;thread1&#34;).start();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        System.out.println(&#34;-----main-----&#34;);
</span></span><span class="line"><span class="cl">        System.out.println(context0());
</span></span><span class="line"><span class="cl">        System.out.println(context1());
</span></span><span class="line"><span class="cl">        System.out.println(context2());
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    static int context0() {
</span></span><span class="line"><span class="cl">        return localInt.get();
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    static int context1(){
</span></span><span class="line"><span class="cl">        return localInt.get();
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    static int context2(){
</span></span><span class="line"><span class="cl">        return localInt.get();
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><p>通过上面的代码，可以发现<code>ThreadLocal</code>是跨越几个方法的。为了在几个函数之间共用一个变量，所以才出现：线程变量，这种变量在Java中就是<code>ThreadLocal</code>变量。</p>
<p><code>ThreadLocal</code>是跨函数的，虽然全局变量也是跨函数的，但是跨所有的函数，而且不是动态的。跨哪些函数是由线程来定的，所以更灵活。</p>
<p>总之，<code>ThreadLocal</code>类是修饰变量的，是在控制它的作用域，是为了增加变量的种类而已，这才是<code>ThreadLocal</code>类诞生的初衷，它的初衷可不是解决线程冲突的。</p>
<h4 id="与同步机制">与同步机制</h4>
<p><code>ThreadLocal</code>类是修饰变量的，重点是在控制变量的作用域，初衷可不是为了解决线程并发和线程冲突的，而是为了让变量的种类变的更多更丰富，方便人们使用罢了。
很多开发语言在语言级别都提供这种作用域的变量类型。</p>
<p>要保证线程安全，并不一定就是要进行同步，两者没有因果关系。同步只是保证共享数据争用时的正确性的手段。
如果一个方法本来就不涉及共享数据，那它自然就无需任何同步措施去保证正确性。</p>
<p>总之，线程安全，并不一定就是要进行同步，<code>ThreadLocal</code>目的是线程安全，但不是同步手段。</p>
<p><code>ThreadLocal</code>和线程同步机制都可以解决多线程中共享变量的访问冲突问题。</p>
<p>在同步机制中，通过对象的锁机制保证同一时间只有一个线程访问变量。使用同步机制要求程序慎密地分析什么时候对变量进行读写，什么时候需要锁定某个对象，什么时候释放对象锁等繁杂的问题，程序设计和编写难度相对较大。</p>
<p>而<code>ThreadLocal</code> 则从另一个角度来解决多线程的并发访问。<code>ThreadLocal</code> 会为每一个线程提供一个独立的变量副本，从而隔离了多个线程对数据的访问冲突。因为每一个线程都拥有自己的变量副本，从而也就没有必要对该变量进行同步了。
<code>ThreadLocal</code> 提供了线程安全的共享对象，在编写多线程代码时，可以把不安全的变量封装进 <code>ThreadLocal</code>。</p>
<p>虽然<code>ThreadLocal</code>能够保证多线程访问数据安全，但是由于在每个线程中都创建了副本，所以要考虑它对资源的消耗，比如内存的占用会比不使用 <code>ThreadLocal</code> 要大。</p>
<p>对于多线程资源共享的问题，同步机制采用了“以时间换空间”的方式，而<code>ThreadLocal</code>采用了“以空间换时间”的方式。
前者仅提供一份变量，让不同的线程排队访问，而后者为每一个线程都提供了一份变量，因此可以同时访问而互不影响。</p>
<h4 id="原理-3">原理</h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">    public T get() {
</span></span><span class="line"><span class="cl">        // 获取当前线程
</span></span><span class="line"><span class="cl">        Thread t = Thread.currentThread();
</span></span><span class="line"><span class="cl">        // 每个线程 都有一个自己的ThreadLocalMap，
</span></span><span class="line"><span class="cl">        // ThreadLocalMap里就保存着所有的ThreadLocal变量
</span></span><span class="line"><span class="cl">        ThreadLocalMap map = getMap(t);
</span></span><span class="line"><span class="cl">        if (map != null) {
</span></span><span class="line"><span class="cl">            //ThreadLocalMap的key就是当前ThreadLocal对象实例，
</span></span><span class="line"><span class="cl">            //多个ThreadLocal变量都是放在这个map中的
</span></span><span class="line"><span class="cl">            ThreadLocalMap.Entry e = map.getEntry(this);
</span></span><span class="line"><span class="cl">            if (e != null) {
</span></span><span class="line"><span class="cl">                @SuppressWarnings(&#34;unchecked&#34;)
</span></span><span class="line"><span class="cl">                //从map里取出来的值就是我们需要的这个ThreadLocal变量
</span></span><span class="line"><span class="cl">                T result = (T)e.value;
</span></span><span class="line"><span class="cl">                return result;
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        // 如果map没有初始化，那么在这里初始化一下
</span></span><span class="line"><span class="cl">        return setInitialValue();
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public void set(T value) {
</span></span><span class="line"><span class="cl">        // 获取当前线程
</span></span><span class="line"><span class="cl">        Thread t = Thread.currentThread();
</span></span><span class="line"><span class="cl">        // 每个线程 都有一个自己的ThreadLocalMap
</span></span><span class="line"><span class="cl">        // ThreadLocalMap 里就保存着所有的ThreadLocal变量
</span></span><span class="line"><span class="cl">        ThreadLocalMap map = getMap(t);
</span></span><span class="line"><span class="cl">        if (map != null)
</span></span><span class="line"><span class="cl">            // 向map里添加值
</span></span><span class="line"><span class="cl">            map.set(this, value);
</span></span><span class="line"><span class="cl">        else
</span></span><span class="line"><span class="cl">            // map为null，创建一个 ThreadLocalMap
</span></span><span class="line"><span class="cl">            createMap(t, value);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // 全局定义的localMap
</span></span><span class="line"><span class="cl">   ThreadLocal.ThreadLocalMap threadLocals = null;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // 获取当前线程所持有的localMap
</span></span><span class="line"><span class="cl">    ThreadLocalMap getMap(Thread t) {
</span></span><span class="line"><span class="cl">        return t.threadLocals;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    // 创建，初始化 localMap 
</span></span><span class="line"><span class="cl">    void createMap(Thread t, T firstValue) {
</span></span><span class="line"><span class="cl">        t.threadLocals = new ThreadLocalMap(this, firstValue);
</span></span><span class="line"><span class="cl">    }
</span></span></code></pre></div><p><code>ThreadLocal</code>,<code>get()、set()</code>源码中可以看出，所谓的<code>ThreadLocal</code>变量就是保存在每个线程的map中的。这个map就是<code>Thread</code>对象中的<code>threadLocals</code>字段。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">ThreadLocal.ThreadLocalMap threadLocals = null;
</span></span></code></pre></div><p>首先，在每个线程 <code>Thread</code> 内部有一个 <code>ThreadLocal</code>.<code>ThreadLocalMap</code> 类型的成员变量 <code>threadLocals</code>，这个 <code>threadLocals</code> 就是用来存储实际的变量副本的，键值为当前 <code>ThreadLocal</code> 变量，value为变量副本,即T类型的变量。</p>
<p>初始时，在Thread里面，<code>threadLocals</code>为空，当通过<code>ThreadLocal</code>变量调用<code>get()</code>方法或者<code>set()</code>方法，就会对<code>Thread</code>类中的<code>threadLocals</code>进行初始化，并且以当前<code>ThreadLoca</code>变量为键值，以<code>ThreadLocal</code>要保存的副本变量为<code>value</code>，存到<code>threadLocals</code>。</p>
<p><code>ThreadLocal.ThreadLocalMap</code>是一个比较特殊的Map，它的每个<code>Entry的key</code>都是一个弱引用：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="k">static</span> <span class="k">class</span> <span class="n">Entry</span> <span class="k">extends</span> <span class="n">WeakReference</span><span class="o">&lt;</span><span class="n">ThreadLocal</span><span class="o">&lt;</span><span class="err">?</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="o">/**</span> <span class="n">The</span> <span class="n">value</span> <span class="n">associated</span> <span class="n">with</span> <span class="n">this</span> <span class="n">ThreadLocal</span><span class="o">.</span> <span class="o">*/</span>
</span></span><span class="line"><span class="cl">    <span class="ne">Object</span> <span class="n">value</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">//</span><span class="n">key就是一个弱引用</span>
</span></span><span class="line"><span class="cl">    <span class="n">Entry</span><span class="p">(</span><span class="n">ThreadLocal</span><span class="o">&lt;</span><span class="err">?</span><span class="o">&gt;</span> <span class="n">k</span><span class="p">,</span> <span class="ne">Object</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">super</span><span class="p">(</span><span class="n">k</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">value</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>这样设计的好处是，如果这个变量不再被其他对象使用时，可以自动回收这个<code>ThreadLoca</code>l对象，避免可能的<a href="https://whiteppure.github.io/iblog/posts/jvm/jvm-about/#%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F">内存泄露</a>。</p>
<h4 id="内存泄漏问题">内存泄漏问题</h4>
<p>虽然<code>ThreadLocalMap</code>中的key是弱引用，当不存在外部强引用的时候，就会自动被回收，但是<code>Entry</code>中的<code>value</code>依然是强引用。这个<code>value</code>的引用链条如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">Thrad --&gt; ThreadLocalMap --&gt; Entry --&gt; value
</span></span></code></pre></div><p>只有当<code>Thread</code>被回收时，这个<code>value</code>才有被回收的机会，否则，只要线程不退出，<code>value</code>总是会存在一个强引用。
但是，要求每个Thread都会退出，是一个极其苛刻的要求，对于线程池来说，大部分线程会一直存在在系统的整个生命周期内，那样的话，就会造成value对象出现泄漏的可能。
处理的方法是，在<code>ThreadLocalMap</code>进行<code>set()</code>，<code>get()</code>，<code>remove()</code>的时候，都会进行清理：</p>
<p>以<code>remove()</code>方法为例：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">// public remove
</span></span><span class="line"><span class="cl"> public void remove() {
</span></span><span class="line"><span class="cl">     ThreadLocalMap m = getMap(Thread.currentThread());
</span></span><span class="line"><span class="cl">     if (m != null)
</span></span><span class="line"><span class="cl">         m.remove(this);
</span></span><span class="line"><span class="cl"> }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">// private remove
</span></span><span class="line"><span class="cl">private void remove(ThreadLocal&lt;?&gt; key) {
</span></span><span class="line"><span class="cl">    Entry[] tab = table;
</span></span><span class="line"><span class="cl">    int len = tab.length;
</span></span><span class="line"><span class="cl">    int i = key.threadLocalHashCode &amp; (len-1);
</span></span><span class="line"><span class="cl">    for (Entry e = tab[i];
</span></span><span class="line"><span class="cl">         e != null;
</span></span><span class="line"><span class="cl">         e = tab[i = nextIndex(i， len)]) {
</span></span><span class="line"><span class="cl">        if (e.get() == key) {
</span></span><span class="line"><span class="cl">            e.clear();
</span></span><span class="line"><span class="cl">            expungeStaleEntry(i);
</span></span><span class="line"><span class="cl">            return;
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">// 核心方法
</span></span><span class="line"><span class="cl">private int expungeStaleEntry(int staleSlot) {
</span></span><span class="line"><span class="cl">    Entry[] tab = table;
</span></span><span class="line"><span class="cl">    int len = tab.length;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // expunge entry at staleSlot
</span></span><span class="line"><span class="cl">    tab[staleSlot].value = null;
</span></span><span class="line"><span class="cl">    tab[staleSlot] = null;
</span></span><span class="line"><span class="cl">    size--;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // Rehash until we encounter null
</span></span><span class="line"><span class="cl">    Entry e;
</span></span><span class="line"><span class="cl">    int i;
</span></span><span class="line"><span class="cl">    for (i = nextIndex(staleSlot, len);
</span></span><span class="line"><span class="cl">         (e = tab[i]) != null;
</span></span><span class="line"><span class="cl">         i = nextIndex(i, len)) {
</span></span><span class="line"><span class="cl">        ThreadLocal&lt;?&gt; k = e.get();
</span></span><span class="line"><span class="cl">        if (k == null) {
</span></span><span class="line"><span class="cl">            // 将 value 赋值为 null； help gc
</span></span><span class="line"><span class="cl">            e.value = null;
</span></span><span class="line"><span class="cl">            tab[i] = null;
</span></span><span class="line"><span class="cl">            size--;
</span></span><span class="line"><span class="cl">        } else {
</span></span><span class="line"><span class="cl">            int h = k.threadLocalHashCode &amp; (len - 1);
</span></span><span class="line"><span class="cl">            if (h != i) {
</span></span><span class="line"><span class="cl">                tab[i] = null;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                // Unlike Knuth 6.4 Algorithm R, we must scan until
</span></span><span class="line"><span class="cl">                // null because multiple entries could have been stale.
</span></span><span class="line"><span class="cl">                while (tab[h] != null)
</span></span><span class="line"><span class="cl">                    h = nextIndex(h, len);
</span></span><span class="line"><span class="cl">                tab[h] = e;
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    return i;
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><p>虽然<code>ThreadLocal</code>为了避免内存泄露，花了一番大心思，但是并不能100%保证不发生内存泄漏。</p>
<p>比如，你的get()方法总是访问固定几个一直存在的<code>ThreadLocal</code>，那么清理动作就不会执行，如果你没有机会调用<code>set()</code>和<code>remove()</code>，那么这个内存泄漏依然会发生。
所以，当你不需要这个<code>ThreadLoca</code>变量时，主动调用<code>remove()</code>，这样是能够避免内存泄漏的。</p>
<h2 id="常用的线程安全的集合">常用的线程安全的集合</h2>
<table>
<thead>
<tr>
<th>线程不安全</th>
<th>线程不安全解决方案</th>
</tr>
</thead>
<tbody>
<tr>
<td>ArrayList</td>
<td>使用Vector、Collections.synchronizedArrayList、CopyOnWriteArrayList</td>
</tr>
<tr>
<td>HashSet</td>
<td>使用Collections.synchronizedSet、CopyOnWriteArraySet</td>
</tr>
<tr>
<td>HashMap</td>
<td>使用HashTable、Collections.synchronizedMap、ConcurrentHashMap</td>
</tr>
</tbody>
</table>
<h3 id="arraylist">ArrayList</h3>
<p><code>ArrayList</code>线程不安全代码演示</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public class MainTest {
</span></span><span class="line"><span class="cl">    public static void main(String[] args) {
</span></span><span class="line"><span class="cl">        ArrayList&lt;String&gt; arrayList = new ArrayList&lt;&gt;();
</span></span><span class="line"><span class="cl">        for(int i=0; i&lt; 10; i++) {
</span></span><span class="line"><span class="cl">            new Thread(() -&gt; {
</span></span><span class="line"><span class="cl">                arrayList.add(UUID.randomUUID().toString());
</span></span><span class="line"><span class="cl">                System.out.println(arrayList);
</span></span><span class="line"><span class="cl">            }，String.valueOf(i)).start();
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><p>为避免偶然事件，请重复多试几次上面的代码，很大情况会出现<code>ConcurrentModificationException</code>&ldquo;同步修改异常&rdquo;</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">java.util.ConcurrentModificationException
</span></span></code></pre></div><p>出现该异常的原因是，当某个线程正在执行 <code>add()</code>方法时，被某个线程打断，添加到一半被打断，没有被添加完。</p>
<p>解决ArrayList线程不安全问题：</p>
<ul>
<li>可以使用 <code>Vector</code> 来代替 <code>ArrayList</code>，<code>Vector</code> 是线程安全的 <code>ArrayList</code>，但是由于，并发量太小，被淘汰;</li>
<li>使用 <code>Collections.synchronizedArrayList()</code> 来创建 <code>ArrayList</code>；使用 <code>Collections</code> 工具类来创建 <code>ArrayList</code> 的思路是，在 <code>ArrayList</code> 的外边套了一个<code>synchronized</code>外壳，来使 <code>ArrayList</code> 线程安全;</li>
<li>使用 <code>CopyOnWriteArrayList()</code>来保证 <code>ArrayList</code> 线程安全；</li>
</ul>
<p>下面详细说明<code>CopyOnWriteArrayList()</code>；使用<code>CopyOnWriteArrayList</code>演示代码</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public class MainTest {
</span></span><span class="line"><span class="cl">    public static void main(String[] args) {
</span></span><span class="line"><span class="cl">        CopyOnWriteArrayList&lt;String&gt; arrayList = new CopyOnWriteArrayList&lt;&gt;();
</span></span><span class="line"><span class="cl">        for(int i=0; i&lt; 10; i++) {
</span></span><span class="line"><span class="cl">            new Thread(() -&gt; {
</span></span><span class="line"><span class="cl">                arrayList.add(UUID.randomUUID().toString());
</span></span><span class="line"><span class="cl">                System.out.println(arrayList);
</span></span><span class="line"><span class="cl">            },String.valueOf(i)).start();
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><h4 id="copywritearraylist">CopyWriteArrayList</h4>
<p><code>CopyWriteArrayList</code> 字面意思就是在写的时候复制，思想就是读写分离的思想。以下是 <code>CopyOnWriteArrayList</code> 的 <code>add()</code> 方法源码</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">/** The array, accessed only via getArray/setArray. */
</span></span><span class="line"><span class="cl">    private transient volatile Object[] array;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">/** The lock protecting all mutators */
</span></span><span class="line"><span class="cl">    final transient ReentrantLock lock = new ReentrantLock();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  /**
</span></span><span class="line"><span class="cl">     * Gets the array.  Non-private so as to also be accessible
</span></span><span class="line"><span class="cl">     * from CopyOnWriteArraySet class.
</span></span><span class="line"><span class="cl">     */
</span></span><span class="line"><span class="cl">    final Object[] getArray() {
</span></span><span class="line"><span class="cl">        return array;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">/**
</span></span><span class="line"><span class="cl">     * Appends the specified element to the end of this list.
</span></span><span class="line"><span class="cl">     *
</span></span><span class="line"><span class="cl">     * @param e element to be appended to this list
</span></span><span class="line"><span class="cl">     * @return {@code true} (as specified by {@link Collection#add})
</span></span><span class="line"><span class="cl">     */
</span></span><span class="line"><span class="cl">    public boolean add(E e) {
</span></span><span class="line"><span class="cl">        final ReentrantLock lock = this.lock;
</span></span><span class="line"><span class="cl">        lock.lock();
</span></span><span class="line"><span class="cl">        try {
</span></span><span class="line"><span class="cl">            Object[] elements = getArray();
</span></span><span class="line"><span class="cl">            int len = elements.length;
</span></span><span class="line"><span class="cl">            Object[] newElements = Arrays.copyOf(elements, len + 1);
</span></span><span class="line"><span class="cl">            newElements[len] = e;
</span></span><span class="line"><span class="cl">            setArray(newElements);
</span></span><span class="line"><span class="cl">            return true;
</span></span><span class="line"><span class="cl">        } finally {
</span></span><span class="line"><span class="cl">            lock.unlock();
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    }
</span></span></code></pre></div><p><code>CopyWriteArrayList</code>之所以线程安全的原因是在源码里面使用 <code>ReentrantLock</code>，所以保证了某个线程在写的时候不会被打断。
可以看到源码开始先是复制了一份数组(因为同一时刻只有一个线程写，其余的线程会读)，在复制的数组上边进行写操作，写好以后在返回 <code>true</code>。
这样写的就把读写进行了分离.写好以后因为 <code>array</code> 加了 <code>volatile</code> 关键字，所以该数组是对于其他的线程是可见的，就会读取到最新的值.</p>
<h3 id="hashset">HashSet</h3>
<p><code>HashSet</code> 和 <code>ArrayList</code> 类似，也是线程不安全的集合类。代码演示线程不安全示例，与<code>ArrayList</code>类似</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public class MainTest {
</span></span><span class="line"><span class="cl">    public static void main(String[] args) {
</span></span><span class="line"><span class="cl">        HashSet&lt;String&gt; set = new HashSet&lt;&gt;();
</span></span><span class="line"><span class="cl">        for(int i=0; i&lt; 10; i++) {
</span></span><span class="line"><span class="cl">            new Thread(() -&gt; {
</span></span><span class="line"><span class="cl">                set.add(UUID.randomUUID().toString());
</span></span><span class="line"><span class="cl">                System.out.println(set);
</span></span><span class="line"><span class="cl">            },String.valueOf(i)).start();
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><p>也会报 <code>java.util.ConcurrentModificationException</code> 异常。</p>
<p>参照<code>ArrayList</code>解决方案，<code>HashSet</code>有两种解决方案：</p>
<ul>
<li><code>Collections.synchronizedSet()</code>使用集合工具类解决;</li>
<li>使用 <code>CopyOnWriteArraySet()</code>来保证集合线程安全;</li>
</ul>
<p>使用 <code>CopyOnWriteArraySet()</code>代码演示</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public class MainTest {
</span></span><span class="line"><span class="cl">    public static void main(String[] args) {
</span></span><span class="line"><span class="cl">        CopyOnWriteArraySet&lt;String&gt; set = new CopyOnWriteArraySet&lt;&gt;();
</span></span><span class="line"><span class="cl">        for(int i=0; i&lt; 10; i++) {
</span></span><span class="line"><span class="cl">            new Thread(() -&gt; {
</span></span><span class="line"><span class="cl">                set.add(UUID.randomUUID().toString());
</span></span><span class="line"><span class="cl">                System.out.println(set);
</span></span><span class="line"><span class="cl">            },String.valueOf(i)).start();
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><p><code>CopyOnWriteArraySet</code>底层调用的就是<code>CopyOnWriteArrayList</code>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">private final CopyOnWriteArrayList&lt;E&gt; al;
</span></span><span class="line"><span class="cl">/**
</span></span><span class="line"><span class="cl"> * Creates an empty set.
</span></span><span class="line"><span class="cl"> */
</span></span><span class="line"><span class="cl">public CopyOnWriteArraySet() {
</span></span><span class="line"><span class="cl">    al = new CopyOnWriteArrayList&lt;E&gt;();
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><h3 id="hashmap">HashMap</h3>
<p><code>HashMap</code>也是线程不安全的集合类，在多线程环境下使用同样会出现<code>java.util.ConcurrentModificationException</code>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">MainTest</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="o">[]</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">HashMap</span><span class="o">&lt;</span><span class="n">String</span><span class="p">,</span><span class="n">Object</span><span class="o">&gt;</span><span class="w"> </span><span class="n">map</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">HashMap</span><span class="o">&lt;&gt;</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="n">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="w"> </span><span class="n">10</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">new</span><span class="w"> </span><span class="n">Thread</span><span class="p">(()</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">map</span><span class="p">.</span><span class="na">put</span><span class="p">(</span><span class="n">UUID</span><span class="p">.</span><span class="na">randomUUID</span><span class="p">().</span><span class="na">toString</span><span class="p">(),</span><span class="n">Thread</span><span class="p">.</span><span class="na">currentThread</span><span class="p">().</span><span class="na">getName</span><span class="p">());</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">map</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">},</span><span class="n">String</span><span class="p">.</span><span class="na">valueOf</span><span class="p">(</span><span class="n">i</span><span class="p">)).</span><span class="na">start</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>在多线程环境下<code>HashMap</code>不仅会出现<code>ConcurrentModificationException</code>问题，更严重的是，当多个线程中的 <code>HashMap</code> 同时扩容时，再使用<code>put</code>方法添加元素，如果<code>hash</code>值相同，可能出现同时在同一数组下用链表表示，造成闭环，导致在<code>get</code>时会出现死循环，CPU飙升到100%。</p>
<p>解决方案：</p>
<ul>
<li>使用 <code>HashTable</code>来保证线程安全;</li>
<li><code>Collections.synchronizedMap()</code> 使用集合工具类;</li>
<li><code>ConcurrentHashMap</code> 来保证线程安全;</li>
</ul>
<h4 id="hashtable">HashTable</h4>
<p><code>HashTable</code>、<code>Collections.synchronizedMap()</code>因为性能的原因，在多线程环境下很少使用，一般都会使用<code>ConcurrentHashMap</code>。</p>
<p><code>HashTable</code>性能低的原因，就是直接加了<code>synchronized</code>修饰；
当使用<code>put</code>方法时，通过<code>hash</code>算法判断应该分配到哪一个数组上，如果分配到同一个数组上，即发生<code>hash</code>冲突，这个时候加锁是没问题的；但是一旦不发生<code>hash</code>冲突，再去加锁，性能就不太好了。
可理解为<code>HashTable</code>性能不好的原因就是锁的粒度太粗了。<code>HashTable``put</code>方法源码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span><span class="w"> </span><span class="kd">synchronized</span><span class="w"> </span><span class="n">V</span><span class="w"> </span><span class="nf">put</span><span class="p">(</span><span class="n">K</span><span class="w"> </span><span class="n">key</span><span class="p">,</span><span class="w"> </span><span class="n">V</span><span class="w"> </span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// Make sure the value is not null</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">value</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kc">null</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">throw</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">NullPointerException</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// Makes sure the key is not already in the hashtable.</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">Entry</span><span class="o">&lt;?</span><span class="p">,</span><span class="o">?&gt;</span><span class="w"> </span><span class="n">tab</span><span class="o">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">table</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">hash</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">key</span><span class="p">.</span><span class="na">hashCode</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">hash</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">0x7FFFFFFF</span><span class="p">)</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">tab</span><span class="p">.</span><span class="na">length</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nd">@SuppressWarnings</span><span class="p">(</span><span class="s">&#34;unchecked&#34;</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">Entry</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="n">V</span><span class="o">&gt;</span><span class="w"> </span><span class="n">entry</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">Entry</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="n">V</span><span class="o">&gt;</span><span class="p">)</span><span class="n">tab</span><span class="o">[</span><span class="n">index</span><span class="o">]</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">for</span><span class="p">(;</span><span class="w"> </span><span class="n">entry</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">null</span><span class="w"> </span><span class="p">;</span><span class="w"> </span><span class="n">entry</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">entry</span><span class="p">.</span><span class="na">next</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="n">entry</span><span class="p">.</span><span class="na">hash</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">hash</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">entry</span><span class="p">.</span><span class="na">key</span><span class="p">.</span><span class="na">equals</span><span class="p">(</span><span class="n">key</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">V</span><span class="w"> </span><span class="n">old</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">entry</span><span class="p">.</span><span class="na">value</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">entry</span><span class="p">.</span><span class="na">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">value</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="n">old</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">addEntry</span><span class="p">(</span><span class="n">hash</span><span class="p">,</span><span class="w"> </span><span class="n">key</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="n">index</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="kc">null</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><h4 id="concurrenthashmap">ConcurrentHashMap</h4>
<p><code>ConcurrentHashMap</code>原理简单理解为，<code>HashMap</code> + 分段锁。
因为<code>HashMap</code>在JDK1.7与JDK1.8结构上做了调整，所以<code>ConcurrentHashMap</code>在JDK1.7与JDK1.8结构上也有所不同。</p>
<h5 id="jdk17concurrenthashmap">JDK1.7ConcurrentHashMap</h5>
<p>JDK1.7采用<code>segment</code>的分段锁机制实现线程安全，其中<code>segment</code>类继承自<code>ReentrantLock</code>。用<code>ReentrantLock</code>、CAS来保证线程安全。</p>
<p><img alt="jdk1.7ConcurrentHashMap" src="/iblog/posts/annex/images/essays/jdk1.7ConcurrentHashMap.png"></p>
<p>JDK1.7的<code>ConcurrentHashMap</code>结构：</p>
<ul>
<li><code>segment</code>: 每一个<code>segment</code>数组就相当于一个<code>HashMap</code>；</li>
<li><code>HashEntry</code>: 等同于<code>HashMap</code>中<code>Entry</code>，用于存放K，V键值对；</li>
<li>节点：每个节点对应<code>ConcurrentHashMap</code>存放的值；</li>
</ul>
<p>JDK1.7<code>ConcurrentHashMap</code>之所以能够保证线程安全，主要原因是在每个<code>segment</code>数组上加了锁，俗称分段锁，细化了锁的粒度。</p>
<p>JDK1.7<code>ConcurrentHashMap.put</code>方法源码</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">    public V put(K key， V value) {
</span></span><span class="line"><span class="cl">        Segment&lt;K,V&gt; s;
</span></span><span class="line"><span class="cl">        if (value == null)
</span></span><span class="line"><span class="cl">            throw new NullPointerException();
</span></span><span class="line"><span class="cl">        int hash = hash(key.hashCode());
</span></span><span class="line"><span class="cl">        int j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;
</span></span><span class="line"><span class="cl">        if ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject          // nonvolatile; recheck
</span></span><span class="line"><span class="cl">             (segments, (j &lt;&lt; SSHIFT) + SBASE)) == null) //  in ensureSegment
</span></span><span class="line"><span class="cl">            s = ensureSegment(j);
</span></span><span class="line"><span class="cl">        return s.put(key, hash, value, false);
</span></span><span class="line"><span class="cl">    }
</span></span></code></pre></div><p>首先判空，计算hash值，计算put进来的元素分配到哪个<code>segment</code>数组上，判断当前<code>segments</code>数组上的元素是否为空，如果为空就会使用<code>ensureSegment</code>方法创建<code>segment</code>对象；
最后调用<code>Segment.put</code>方法，存放到对应的节点中。</p>
<p><code>Segment.ensureSegment</code>方法源码</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="o">/**</span>
</span></span><span class="line"><span class="cl"> <span class="o">*</span> <span class="n">Returns</span> <span class="n">the</span> <span class="n">segment</span> <span class="k">for</span> <span class="n">the</span> <span class="n">given</span> <span class="n">index</span><span class="p">,</span> <span class="n">creating</span> <span class="n">it</span> <span class="ow">and</span>
</span></span><span class="line"><span class="cl"> <span class="o">*</span> <span class="n">recording</span> <span class="ow">in</span> <span class="n">segment</span> <span class="n">table</span> <span class="p">(</span><span class="n">via</span> <span class="n">CAS</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">already</span> <span class="n">present</span><span class="o">.</span>
</span></span><span class="line"><span class="cl"> <span class="o">*</span>
</span></span><span class="line"><span class="cl"> <span class="o">*</span> <span class="err">@</span><span class="n">param</span> <span class="n">k</span> <span class="n">the</span> <span class="n">index</span>
</span></span><span class="line"><span class="cl"> <span class="o">*</span> <span class="err">@</span><span class="k">return</span> <span class="n">the</span> <span class="n">segment</span>
</span></span><span class="line"><span class="cl"> <span class="o">*/</span>
</span></span><span class="line"><span class="cl"><span class="n">private</span> <span class="n">Segment</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">ensureSegment</span><span class="p">(</span><span class="ne">int</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">final</span> <span class="n">Segment</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="n">V</span><span class="o">&gt;</span><span class="p">[]</span> <span class="n">ss</span> <span class="o">=</span> <span class="n">this</span><span class="o">.</span><span class="n">segments</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">long</span> <span class="n">u</span> <span class="o">=</span> <span class="p">(</span><span class="n">k</span> <span class="o">&lt;&lt;</span> <span class="n">SSHIFT</span><span class="p">)</span> <span class="o">+</span> <span class="n">SBASE</span><span class="p">;</span> <span class="o">//</span> <span class="n">raw</span> <span class="n">offset</span>
</span></span><span class="line"><span class="cl">        <span class="n">Segment</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">seg</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">((</span><span class="n">seg</span> <span class="o">=</span> <span class="p">(</span><span class="n">Segment</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="n">V</span><span class="o">&gt;</span><span class="p">)</span><span class="n">UNSAFE</span><span class="o">.</span><span class="n">getObjectVolatile</span><span class="p">(</span><span class="n">ss</span><span class="p">,</span> <span class="n">u</span><span class="p">))</span> <span class="o">==</span> <span class="n">null</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">Segment</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">proto</span> <span class="o">=</span> <span class="n">ss</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="o">//</span> <span class="n">use</span> <span class="n">segment</span> <span class="mi">0</span> <span class="n">as</span> <span class="n">prototype</span>
</span></span><span class="line"><span class="cl">            <span class="ne">int</span> <span class="n">cap</span> <span class="o">=</span> <span class="n">proto</span><span class="o">.</span><span class="n">table</span><span class="o">.</span><span class="n">length</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="ne">float</span> <span class="n">lf</span> <span class="o">=</span> <span class="n">proto</span><span class="o">.</span><span class="n">loadFactor</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="ne">int</span> <span class="n">threshold</span> <span class="o">=</span> <span class="p">(</span><span class="ne">int</span><span class="p">)(</span><span class="n">cap</span> <span class="o">*</span> <span class="n">lf</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">HashEntry</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="n">V</span><span class="o">&gt;</span><span class="p">[]</span> <span class="n">tab</span> <span class="o">=</span> <span class="p">(</span><span class="n">HashEntry</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="n">V</span><span class="o">&gt;</span><span class="p">[])</span><span class="n">new</span> <span class="n">HashEntry</span><span class="p">[</span><span class="n">cap</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">((</span><span class="n">seg</span> <span class="o">=</span> <span class="p">(</span><span class="n">Segment</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="n">V</span><span class="o">&gt;</span><span class="p">)</span><span class="n">UNSAFE</span><span class="o">.</span><span class="n">getObjectVolatile</span><span class="p">(</span><span class="n">ss</span><span class="p">,</span> <span class="n">u</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">                <span class="o">==</span> <span class="n">null</span><span class="p">)</span> <span class="p">{</span> <span class="o">//</span> <span class="n">recheck</span>
</span></span><span class="line"><span class="cl">                <span class="n">Segment</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">s</span> <span class="o">=</span> <span class="n">new</span> <span class="n">Segment</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="n">V</span><span class="o">&gt;</span><span class="p">(</span><span class="n">lf</span><span class="p">,</span> <span class="n">threshold</span><span class="p">,</span> <span class="n">tab</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="k">while</span> <span class="p">((</span><span class="n">seg</span> <span class="o">=</span> <span class="p">(</span><span class="n">Segment</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="n">V</span><span class="o">&gt;</span><span class="p">)</span><span class="n">UNSAFE</span><span class="o">.</span><span class="n">getObjectVolatile</span><span class="p">(</span><span class="n">ss</span><span class="p">,</span> <span class="n">u</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">                       <span class="o">==</span> <span class="n">null</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="k">if</span> <span class="p">(</span><span class="n">UNSAFE</span><span class="o">.</span><span class="n">compareAndSwapObject</span><span class="p">(</span><span class="n">ss</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">null</span><span class="p">,</span> <span class="n">seg</span> <span class="o">=</span> <span class="n">s</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">                        <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">seg</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span></code></pre></div><p>通过文档注释可以看到<code>ensureSegment</code>方法作用：返回指定索引的segment对象，通过CAS判断，如果还没有则创建它并记录在segment表中。</p>
<p>当多个线程同时执行该方法，同时通过<code>ensureSegment</code>方法创建<code>segment</code>对象时，只有一个线程能够创建成功；
其中创建的新<code>segment</code>对象中的加载因子、存放位置、扩容阈值与<code>segment[0]</code>元素保持一致。这样做性能更高，因为不用在计算了。</p>
<p>为了保证线程安全，在<code>ensureSegment</code>方法中用<code>Unsafe</code>类中的一些方法做了三次判断，其中最后一次也就是该方法保证线程安全的关键，用到了CAS操作;</p>
<p>当多个线程并发执行下面的代码，先执行CAS的线程，判断<code>segment</code>数组中某个位置是空的，然后就把这个线程自己创建的<code>segment</code>数组赋值给seg，即<code>seg = s</code>;然后<code>break</code>跳出循环；
后执行的线程会再次判断seg是否为空，因先执行的线程已经<code>seg = s</code>不为空了，所以循环条件不成立，也就不再执行了。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">while ((seg = (Segment&lt;K，V&gt;)UNSAFE.getObjectVolatile(ss, u))
</span></span><span class="line"><span class="cl">       == null) {
</span></span><span class="line"><span class="cl">    if (UNSAFE.compareAndSwapObject(ss, u, null, seg = s))
</span></span><span class="line"><span class="cl">        break;
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><p><code>Segment.put</code>方法源码；为了保证线程安全，执行put方法要保证要加到锁，如果没加到锁就会执行<code>scanAndLockForPut</code>方法；
这个方法就会保证一定要加到锁；</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">final V put(K key, int hash, V value, boolean onlyIfAbsent) {
</span></span><span class="line"><span class="cl">    HashEntry&lt;K,V&gt; node = tryLock() ? null :
</span></span><span class="line"><span class="cl">        scanAndLockForPut(key, hash, value);
</span></span><span class="line"><span class="cl">    // ... 插入节点操作 最后释放锁
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><p><code>scanAndLockForPut</code>方法的主要作用就是加锁，如果没有获取锁，就会一致遍历<code>segment</code>数组，直到遍历到最后一个元素；
每次遍历完都会尝试获取锁，如果还是获取不到锁，就会重试，最大次数为<code>MAX_SCAN_RETRIES</code>在CPU多核下为64次，如果大于64次就会强制加锁。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">private HashEntry&lt;K,V&gt; scanAndLockForPut(K key, int hash, V value) {
</span></span><span class="line"><span class="cl">    HashEntry&lt;K,V&gt; first = entryForHash(this, hash);
</span></span><span class="line"><span class="cl">    HashEntry&lt;K,V&gt; e = first;
</span></span><span class="line"><span class="cl">    HashEntry&lt;K,V&gt; node = null;
</span></span><span class="line"><span class="cl">    int retries = -1; // negative while locating node
</span></span><span class="line"><span class="cl">    while (!tryLock()) {
</span></span><span class="line"><span class="cl">        HashEntry&lt;K,V&gt; f; // to recheck first below
</span></span><span class="line"><span class="cl">        if (retries &lt; 0) {
</span></span><span class="line"><span class="cl">            if (e == null) {
</span></span><span class="line"><span class="cl">                if (node == null) // speculatively create node
</span></span><span class="line"><span class="cl">                    node = new HashEntry&lt;K,V&gt;(hash, key, value, null);
</span></span><span class="line"><span class="cl">                retries = 0;
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">            else if (key.equals(e.key))
</span></span><span class="line"><span class="cl">                retries = 0;
</span></span><span class="line"><span class="cl">            else
</span></span><span class="line"><span class="cl">                e = e.next;
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        else if (++retries &gt; MAX_SCAN_RETRIES) {
</span></span><span class="line"><span class="cl">            lock();
</span></span><span class="line"><span class="cl">            break;
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        else if ((retries &amp; 1) == 0 &amp;&amp;
</span></span><span class="line"><span class="cl">                 (f = entryForHash(this, hash)) != first) {
</span></span><span class="line"><span class="cl">            e = first = f; // re-traverse if entry changed
</span></span><span class="line"><span class="cl">            retries = -1;
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    return node;
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">static final int MAX_SCAN_RETRIES =
</span></span><span class="line"><span class="cl">            Runtime.getRuntime().availableProcessors() &gt; 1 ? 64 : 1;
</span></span></code></pre></div><h5 id="jdk18concurrenthashmap">JDK1.8ConcurrentHashMap</h5>
<p>JDK1.8的实现已经摒弃了 <code>Segment</code> 的概念，而是直接用 <code>Node数组+链表/红黑树</code>的数据结构来实现，并发控制使用 <code>synchronized</code> 和CAS来操作，整个看起来就像是优化过且线程安全的<code>HashMap</code>;
虽然在JDK1.8中还能看到 <code>Segment</code> 的数据结构，但是已经简化了属性，只是为了兼容旧版本。</p>
<p>JDK1.8中彻底放弃了<code>Segment</code>转而采用的是<code>Node</code>，其设计思想也不再是JDK1.7中的分段锁思想；
JDK1.8版本的<code>ConcurrentHashMap</code>的数据结构已经接近<code>HashMap</code>，相对而言，<code>ConcurrentHashMap</code> 只是增加了同步操作来控制并发。</p>
<p><img alt="jdk1.8ConcurrentHashMap" src="/iblog/posts/annex/images/essays/jdk1.8ConcurrentHashMap.png"></p>
<p>相关概念：</p>
<ul>
<li><code>sizeCtl</code> ：默认为0，用来控制<code>table</code>的初始化和扩容操作;用<code>volatile</code>修饰，保证了其可见性；</li>
</ul>
<p>JDK1.8<code>ConcurrentHashMap.put</code>方法源码;</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">final V putVal(K key， V value, boolean onlyIfAbsent) {
</span></span><span class="line"><span class="cl">    if (key == null || value == null) throw new NullPointerException();
</span></span><span class="line"><span class="cl">    int hash = spread(key.hashCode());
</span></span><span class="line"><span class="cl">    int binCount = 0;
</span></span><span class="line"><span class="cl">    for (Node&lt;K,V&gt;[] tab = table;;) {
</span></span><span class="line"><span class="cl">        Node&lt;K,V&gt; f; int n, i, fh;
</span></span><span class="line"><span class="cl">        if (tab == null || (n = tab.length) == 0)
</span></span><span class="line"><span class="cl">            tab = initTable();
</span></span><span class="line"><span class="cl">        else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) {
</span></span><span class="line"><span class="cl">            if (casTabAt(tab, i, null,
</span></span><span class="line"><span class="cl">                         new Node&lt;K,V&gt;(hash, key, value, null)))
</span></span><span class="line"><span class="cl">                break;                   // no lock when adding to empty bin
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        else if ((fh = f.hash) == MOVED)
</span></span><span class="line"><span class="cl">            tab = helpTransfer(tab, f);
</span></span><span class="line"><span class="cl">        else {
</span></span><span class="line"><span class="cl">            V oldVal = null;
</span></span><span class="line"><span class="cl">            synchronized (f) {
</span></span><span class="line"><span class="cl">                if (tabAt(tab, i) == f) {
</span></span><span class="line"><span class="cl">                    if (fh &gt;= 0) {
</span></span><span class="line"><span class="cl">                        binCount = 1;
</span></span><span class="line"><span class="cl">                        for (Node&lt;K,V&gt; e = f;; ++binCount) {
</span></span><span class="line"><span class="cl">                            K ek;
</span></span><span class="line"><span class="cl">                            if (e.hash == hash &amp;&amp;
</span></span><span class="line"><span class="cl">                                ((ek = e.key) == key ||
</span></span><span class="line"><span class="cl">                                 (ek != null &amp;&amp; key.equals(ek)))) {
</span></span><span class="line"><span class="cl">                                oldVal = e.val;
</span></span><span class="line"><span class="cl">                                if (!onlyIfAbsent)
</span></span><span class="line"><span class="cl">                                    e.val = value;
</span></span><span class="line"><span class="cl">                                break;
</span></span><span class="line"><span class="cl">                            }
</span></span><span class="line"><span class="cl">                            Node&lt;K,V&gt; pred = e;
</span></span><span class="line"><span class="cl">                            if ((e = e.next) == null) {
</span></span><span class="line"><span class="cl">                                pred.next = new Node&lt;K,V&gt;(hash, key,
</span></span><span class="line"><span class="cl">                                                          value, null);
</span></span><span class="line"><span class="cl">                                break;
</span></span><span class="line"><span class="cl">                            }
</span></span><span class="line"><span class="cl">                        }
</span></span><span class="line"><span class="cl">                    }
</span></span><span class="line"><span class="cl">                    else if (f instanceof TreeBin) {
</span></span><span class="line"><span class="cl">                        Node&lt;K,V&gt; p;
</span></span><span class="line"><span class="cl">                        binCount = 2;
</span></span><span class="line"><span class="cl">                        if ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,
</span></span><span class="line"><span class="cl">                                                       value)) != null) {
</span></span><span class="line"><span class="cl">                            oldVal = p.val;
</span></span><span class="line"><span class="cl">                            if (!onlyIfAbsent)
</span></span><span class="line"><span class="cl">                                p.val = value;
</span></span><span class="line"><span class="cl">                        }
</span></span><span class="line"><span class="cl">                    }
</span></span><span class="line"><span class="cl">                }
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">            if (binCount != 0) {
</span></span><span class="line"><span class="cl">                if (binCount &gt;= TREEIFY_THRESHOLD)
</span></span><span class="line"><span class="cl">                    treeifyBin(tab, i);
</span></span><span class="line"><span class="cl">                if (oldVal != null)
</span></span><span class="line"><span class="cl">                    return oldVal;
</span></span><span class="line"><span class="cl">                break;
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    addCount(1L, binCount);
</span></span><span class="line"><span class="cl">    return null;
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><p>首先调用<code>Node.initTable()</code>方法，初始化table;<code>sizeCtl</code> 默认为0，如果<code>ConcurrentHashMap</code>实例化时有传参数，<code>sizeCtl</code> 会是一个2的幂次方的值。
所以执行第一次put方法时操作的线程会执行<code>Unsafe.compareAndSwapInt</code>方法修改<code>sizeCtl=-1</code>，只有一个线程能够修改成功，其它线程通过<code>Thread.yield()</code>礼让线程让出CPU时间片，等待<code>table</code>初始化完成。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">private final Node&lt;K,V&gt;[] initTable() {
</span></span><span class="line"><span class="cl">    Node&lt;K,V&gt;[] tab; int sc;
</span></span><span class="line"><span class="cl">    while ((tab = table) == null || tab.length == 0) {
</span></span><span class="line"><span class="cl">        if ((sc = sizeCtl) &lt; 0)
</span></span><span class="line"><span class="cl">            Thread.yield(); // lost initialization race; just spin
</span></span><span class="line"><span class="cl">        else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) {
</span></span><span class="line"><span class="cl">            try {
</span></span><span class="line"><span class="cl">                if ((tab = table) == null || tab.length == 0) {
</span></span><span class="line"><span class="cl">                    int n = (sc &gt; 0) ? sc : DEFAULT_CAPACITY;
</span></span><span class="line"><span class="cl">                    @SuppressWarnings(&#34;unchecked&#34;)
</span></span><span class="line"><span class="cl">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n];
</span></span><span class="line"><span class="cl">                    table = tab = nt;
</span></span><span class="line"><span class="cl">                    sc = n - (n &gt;&gt;&gt; 2);
</span></span><span class="line"><span class="cl">                }
</span></span><span class="line"><span class="cl">            } finally {
</span></span><span class="line"><span class="cl">                sizeCtl = sc;
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">            break;
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    return tab;
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><p>调用put方法，通过hash算法计算，将要存放数组中的位置<code>(n - 1) &amp; hash</code>，如果该节点为空就通过CAS判断，创建一个Node放到该位置上。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">int hash = spread(key.hashCode());
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">// hash算法，计算存放在map中的位置；要保证尽可能的均匀分散，避免hash冲突
</span></span><span class="line"><span class="cl">static final int HASH_BITS = 0x7fffffff;
</span></span><span class="line"><span class="cl">static final int spread(int h) {
</span></span><span class="line"><span class="cl">    // 等同于： key.hashCode() ^ (key.hashCode() &gt;&gt;&gt; 16) &amp; 0x7fffffff
</span></span><span class="line"><span class="cl">    return (h ^ (h &gt;&gt;&gt; 16)) &amp; HASH_BITS;
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><p>如果该位置不为空就会继续判断当前线程的<code>ConcurrentHashMap</code>是否进行扩容</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">// MOVED = -1
</span></span><span class="line"><span class="cl">if ((fh = f.hash) == MOVED)
</span></span><span class="line"><span class="cl">tab = helpTransfer(tab, f);
</span></span></code></pre></div><p>插入之前，再次利用<code>tabAt(tab, i) == f</code>判断，防止被其它线程修改;
之后就会对这个将要添加到该位置的元素加锁，判断是链表还是树节点，做不同的操作;</p>
<ul>
<li>如果<code>f.hash &gt;= 0</code>，说明f是链表结构的头结点，遍历链表，如果找到对应的<code>node</code>节点，则修改<code>value</code>，否则在链表尾部加入节点。</li>
<li>如果f是<code>TreeBin</code>类型节点，说明f是红黑树根节点，则在树结构上遍历元素，更新或增加节点。</li>
<li>如果链表中节点数<code>binCount &gt;= TREEIFY_THRESHOLD(默认是8)</code>，则把链表转化为红黑树结构。</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">V oldVal = null;
</span></span><span class="line"><span class="cl">synchronized (f) {
</span></span><span class="line"><span class="cl">    if (tabAt(tab, i) == f) {
</span></span><span class="line"><span class="cl">        if (fh &gt;= 0) {
</span></span><span class="line"><span class="cl">            binCount = 1;
</span></span><span class="line"><span class="cl">            for (Node&lt;K,V&gt; e = f;; ++binCount) {
</span></span><span class="line"><span class="cl">                K ek;
</span></span><span class="line"><span class="cl">                if (e.hash == hash &amp;&amp;
</span></span><span class="line"><span class="cl">                    ((ek = e.key) == key ||
</span></span><span class="line"><span class="cl">                     (ek != null &amp;&amp; key.equals(ek)))) {
</span></span><span class="line"><span class="cl">                    oldVal = e.val;
</span></span><span class="line"><span class="cl">                    if (!onlyIfAbsent)
</span></span><span class="line"><span class="cl">                        e.val = value;
</span></span><span class="line"><span class="cl">                    break;
</span></span><span class="line"><span class="cl">                }
</span></span><span class="line"><span class="cl">                Node&lt;K,V&gt; pred = e;
</span></span><span class="line"><span class="cl">                if ((e = e.next) == null) {
</span></span><span class="line"><span class="cl">                    pred.next = new Node&lt;K,V&gt;(hash, key,
</span></span><span class="line"><span class="cl">                                              value, null);
</span></span><span class="line"><span class="cl">                    break;
</span></span><span class="line"><span class="cl">                }
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        else if (f instanceof TreeBin) {
</span></span><span class="line"><span class="cl">            Node&lt;K,V&gt; p;
</span></span><span class="line"><span class="cl">            binCount = 2;
</span></span><span class="line"><span class="cl">            if ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,
</span></span><span class="line"><span class="cl">                                           value)) != null) {
</span></span><span class="line"><span class="cl">                oldVal = p.val;
</span></span><span class="line"><span class="cl">                if (!onlyIfAbsent)
</span></span><span class="line"><span class="cl">                    p.val = value;
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">if (binCount != 0) {
</span></span><span class="line"><span class="cl">    if (binCount &gt;= TREEIFY_THRESHOLD)
</span></span><span class="line"><span class="cl">        treeifyBin(tab, i);
</span></span><span class="line"><span class="cl">    if (oldVal != null)
</span></span><span class="line"><span class="cl">        return oldVal;
</span></span><span class="line"><span class="cl">    break;
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><p>最后则进行扩容操作</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">//相当于size++
</span></span><span class="line"><span class="cl">addCount(1L, binCount);
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">private final void addCount(long x, int check) {
</span></span><span class="line"><span class="cl">    CounterCell[] as; long b, s;
</span></span><span class="line"><span class="cl">    if ((as = counterCells) != null ||
</span></span><span class="line"><span class="cl">        !U.compareAndSwapLong(this, BASECOUNT, b = baseCount, s = b + x)) {
</span></span><span class="line"><span class="cl">        CounterCell a; long v; int m;
</span></span><span class="line"><span class="cl">        boolean uncontended = true;
</span></span><span class="line"><span class="cl">        if (as == null || (m = as.length - 1) &lt; 0 ||
</span></span><span class="line"><span class="cl">            (a = as[ThreadLocalRandom.getProbe() &amp; m]) == null ||
</span></span><span class="line"><span class="cl">            !(uncontended =
</span></span><span class="line"><span class="cl">              U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) {
</span></span><span class="line"><span class="cl">            fullAddCount(x, uncontended);
</span></span><span class="line"><span class="cl">            return;
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        if (check &lt;= 1)
</span></span><span class="line"><span class="cl">            return;
</span></span><span class="line"><span class="cl">        s = sumCount();
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    if (check &gt;= 0) {
</span></span><span class="line"><span class="cl">        Node&lt;K,V&gt;[] tab, nt; int n, sc;
</span></span><span class="line"><span class="cl">        while (s &gt;= (long)(sc = sizeCtl) &amp;&amp; (tab = table) != null &amp;&amp;
</span></span><span class="line"><span class="cl">               (n = tab.length) &lt; MAXIMUM_CAPACITY) {
</span></span><span class="line"><span class="cl">            int rs = resizeStamp(n);
</span></span><span class="line"><span class="cl">            if (sc &lt; 0) {
</span></span><span class="line"><span class="cl">                if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 ||
</span></span><span class="line"><span class="cl">                    sc == rs + MAX_RESIZERS || (nt = nextTable) == null ||
</span></span><span class="line"><span class="cl">                    transferIndex &lt;= 0)
</span></span><span class="line"><span class="cl">                    break;
</span></span><span class="line"><span class="cl">                if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1))
</span></span><span class="line"><span class="cl">                    transfer(tab, nt);
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">            else if (U.compareAndSwapInt(this, SIZECTL, sc,
</span></span><span class="line"><span class="cl">                                         (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2))
</span></span><span class="line"><span class="cl">                transfer(tab, null);
</span></span><span class="line"><span class="cl">            s = sumCount();
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><p>节点从<code>table</code>移动到<code>nextTable</code>，大体思想是遍历、复制的过程。
通过<code>Unsafe.compareAndSwapInt</code>修改<code>sizeCtl</code>值，保证只有一个线程能够初始化<code>nextTable</code>，扩容后的数组长度为原来的两倍，但是容量是原来的1.5。</p>
<ul>
<li>首先根据运算得到需要遍历的次数i，然后利用<code>tabAt</code>方法获得i位置的元素f，初始化一个<code>forwardNode</code>实例fwd。</li>
<li>如果<code>f == null</code>，则在<code>table</code>中的i位置放入fwd，这个过程是采用<code>Unsafe.compareAndSwapObjectf</code>方法实现的，实现了节点的并发移动。</li>
<li>如果f是链表的头节点，就构造一个反序链表，把他们分别放在<code>nextTable</code>的i和i+n的位置上，移动完成，采用<code>Unsafe.putObjectVolatile</code>方法给<code>table</code>原位置赋值fwd。</li>
<li>如果f是<code>TreeBin</code>节点，也做一个反序处理，并判断是否需要<code>untreeify</code>，把处理的结果分别放在nextTable的i和i+n的位置上，移动完成，同样采用<code>Unsafe.putObjectVolatile</code>方法给<code>table</code>原位置赋值fwd。</li>
</ul>
<h2 id="参考文章">参考文章</h2>
<ul>
<li><a href="http://hollischuang.gitee.io/tobetopjavaer/#/basics/concurrent-coding/synchronized">http://hollischuang.gitee.io/tobetopjavaer/#/basics/concurrent-coding/synchronized</a></li>
<li><a href="http://www.threadlocal.cn">http://www.threadlocal.cn</a></li>
<li><a href="https://blog.csdn.net/lufeng20/article/details/24314381">https://blog.csdn.net/lufeng20/article/details/24314381</a></li>
<li><a href="https://blog.csdn.net/qq_35190492/article/details/116431270">https://blog.csdn.net/qq_35190492/article/details/116431270</a></li>
<li><a href="https://www.cnblogs.com/dolphin0520/p/3920407.html">https://www.cnblogs.com/dolphin0520/p/3920407.html</a></li>
<li><a href="https://www.jianshu.com/p/c0642afe03e0">https://www.jianshu.com/p/c0642afe03e0</a></li>
<li><a href="https://www.cnblogs.com/edisonchou/p/5061886.html">https://www.cnblogs.com/edisonchou/p/5061886.html</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/361475700">https://zhuanlan.zhihu.com/p/361475700</a></li>
<li><a href="http://www.cs.umd.edu/~pugh/java/memoryModel/jsr133.pdf">http://www.cs.umd.edu/~pugh/java/memoryModel/jsr133.pdf</a></li>
<li><a href="https://www.cnblogs.com/myseries/p/10784076.html">https://www.cnblogs.com/myseries/p/10784076.html</a></li>
<li><a href="http://www.blogjava.net/zhanglongsr/articles/356782.html">http://www.blogjava.net/zhanglongsr/articles/356782.html</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/290991898">https://zhuanlan.zhihu.com/p/290991898</a></li>
<li><a href="https://blog.csdn.net/choukekai/article/details/63688332">https://blog.csdn.net/choukekai/article/details/63688332</a></li>
<li><a href="https://blog.csdn.net/zqz_zqz/article/details/70233767">https://blog.csdn.net/zqz_zqz/article/details/70233767</a></li>
<li><a href="https://oss.stupidzhang.com/img/blog/">https://oss.stupidzhang.com/img/blog/</a>锁升级过程.png</li>
<li><a href="https://developer.aliyun.com/topic/download?spm=a2c6h.15028928.J_5293118740.2&id=805">https://developer.aliyun.com/topic/download?spm=a2c6h.15028928.J_5293118740.2&id=805</a></li>
<li><a href="https://tech.meituan.com/2018/11/15/java-lock.html">https://tech.meituan.com/2018/11/15/java-lock.html</a></li>
<li><a href="https://www.cnblogs.com/aspirant/p/11470858.html">https://www.cnblogs.com/aspirant/p/11470858.html</a></li>
<li><a href="https://www.bilibili.com/video/BV1xt411S7xy?p=159">https://www.bilibili.com/video/BV1xt411S7xy?p=159</a></li>
<li><a href="https://developer.51cto.com/art/202104/656540.htm">https://developer.51cto.com/art/202104/656540.htm</a></li>
<li><a href="https://blog.csdn.net/qq_38293564/article/details/80558157">https://blog.csdn.net/qq_38293564/article/details/80558157</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/98593407">https://zhuanlan.zhihu.com/p/98593407</a></li>
<li><a href="https://blog.csdn.net/zbc1090549839/article/details/53389602">https://blog.csdn.net/zbc1090549839/article/details/53389602</a></li>
<li><a href="https://www.hollischuang.com/archives/2030">https://www.hollischuang.com/archives/2030</a></li>
<li><a href="https://blog.csdn.net/javazejian/article/details/72828483">https://blog.csdn.net/javazejian/article/details/72828483</a></li>
<li><a href="https://blog.csdn.net/luoweifu/article/details/46613015">https://blog.csdn.net/luoweifu/article/details/46613015</a></li>
<li><a href="https://www.artima.com/insidejvm/ed2/threadsynch.html">https://www.artima.com/insidejvm/ed2/threadsynch.html</a></li>
<li><a href="https://xie.infoq.cn/article/d3afa3e6f9a70155106627ce5">https://xie.infoq.cn/article/d3afa3e6f9a70155106627ce5</a></li>
</ul>
</div>
                    <div id="post_footer" class="post_footer">
                        <div class="meta">
                            
                            <div id="post_footer_info" class="info">
                                <span class="field tags">
                                    <i class="ri-stack-line"></i>
                                    
                                        
                                        <a href="https://whiteppure.github.io/iblog/tags/java/">Java</a>
                                    
                                        <a href="https://whiteppure.github.io/iblog/tags/java%E5%9F%BA%E7%A1%80/">Java基础</a>
                                    
                                    
                                </span>
                            </div>
                        </div>
                    </div>
                </div>
                
                
                
<div id="doc_comments" class="doc_comments">
    <div class="comments_block_title">发表评论</div>
    <div id="vcomments"></div>
</div>

<link rel="stylesheet" href="https://whiteppure.github.io/iblog/css/comments.css" />

<script src='//unpkg.com/valine/dist/Valine.min.js'></script>

<script type="text/javascript">
    new Valine({
        el: '#vcomments',
        appId: 'pRSrjsfbN6L1DUxgfqJWOMYP-gzGzoHsz',
        appKey: 'VPWpnDPGDM8Xhdlh5OvHOpak',
        placeholder: '说点什么吧...',
        visitor: 'true',
        
        emojiCDN: '//i0.hdslb.com/bfs/emote/',
        
        emojiMaps: {
            "tv_doge": "6ea59c827c414b4a2955fe79e0f6fd3dcd515e24.png",
            "tv_亲亲": "a8111ad55953ef5e3be3327ef94eb4a39d535d06.png",
            "tv_偷笑": "bb690d4107620f1c15cff29509db529a73aee261.png",
            "tv_再见": "180129b8ea851044ce71caf55cc8ce44bd4a4fc8.png",
            "tv_冷漠": "b9cbc755c2b3ee43be07ca13de84e5b699a3f101.png",
            "tv_发怒": "34ba3cd204d5b05fec70ce08fa9fa0dd612409ff.png",
            "tv_发财": "34db290afd2963723c6eb3c4560667db7253a21a.png",
            "tv_可爱": "9e55fd9b500ac4b96613539f1ce2f9499e314ed9.png",
            "tv_吐血": "09dd16a7aa59b77baa1155d47484409624470c77.png",
            "tv_呆": "fe1179ebaa191569b0d31cecafe7a2cd1c951c9d.png",
            "tv_呕吐": "9f996894a39e282ccf5e66856af49483f81870f3.png",
            "tv_困": "241ee304e44c0af029adceb294399391e4737ef2.png",
            "tv_坏笑": "1f0b87f731a671079842116e0991c91c2c88645a.png",
            "tv_大佬": "093c1e2c490161aca397afc45573c877cdead616.png",
            "tv_大哭": "23269aeb35f99daee28dda129676f6e9ea87934f.png",
            "tv_委屈": "d04dba7b5465779e9755d2ab6f0a897b9b33bb77.png",
            "tv_害羞": "a37683fb5642fa3ddfc7f4e5525fd13e42a2bdb1.png",
            "tv_尴尬": "7cfa62dafc59798a3d3fb262d421eeeff166cfa4.png",
            "tv_微笑": "70dc5c7b56f93eb61bddba11e28fb1d18fddcd4c.png",
            "tv_思考": "90cf159733e558137ed20aa04d09964436f618a1.png",
            "tv_惊吓": "0d15c7e2ee58e935adc6a7193ee042388adc22af.png",
            "tv_打脸": "56ab10b624063e966bfcb76ea5dc4794d87dfd47.png",
            "tv_抓狂": "fe31c08edad661d63762b04e17b8d5ae3c71a757.png",
            "tv_抠鼻": "c666f55e88d471e51bbd9fab9bb308110824a6eb.png",
            "tv_斜眼笑": "911f987aa8bc1bee12d52aafe62bc41ef4474e6c.png",
            "tv_无奈": "ea8ed89ee9878f2fece2dda0ea8a5dbfe21b5751.png",
            "tv_晕": "5443c22b4d07fb1907ccc610c8e6db254f2461b7.png",
            "tv_流汗": "cead1c351ab8d79e9f369605beb90148db0fbed3.png",
            "tv_流泪": "7e71cde7858f0cd50d74b0264aa26db612a8a167.png",
            "tv_流鼻血": "c32d39db2737f89b904ca32700d140a9241b0767.png",
            "tv_点赞": "f85c354995bd99e28fc76c869bfe42ba6438eff4.png",
            "tv_生气": "26702dcafdab5e8225b43ffd23c94ac1ff932654.png",
            "tv_生病": "8b0ec90e6b86771092a498c54f09fc94621c1900.png",
            "tv_疑问": "0793d949b18d7be716078349c202c15ff166f314.png",
            "tv_白眼": "c1d59f439e379ee50eef488bcb5e5378e5044ea4.png",
            "tv_皱眉": "72ccad6679fea0d14cce648b4d818e09b8ffea2d.png",
            "tv_目瞪口呆": "0b8cb81a68de5d5365212c99375e7ace3e7891b7.png",
            "tv_睡着": "8b196675b53af58264f383c50ad0945048290b33.png",
            "tv_笑哭": "1abc628f6d4f4caf9d0e7800878f4697abbc8273.png",
            "tv_腼腆": "89712c0d4af73e67f89e35cbc518420380a7f6f4.png",
            "tv_色": "61822c7e9aae5da76475e7892534545336b23a6f.png",
            "tv_调侃": "4bc022533ef31544ca0d72c12c808cf4a1cce3e3.png",
            "tv_调皮": "b9c41de8e82dd7a8515ae5e3cb63e898bf245186.png",
            "tv_鄙视": "6e72339f346a692a495b123174b49e4e8e781303.png",
            "tv_闭嘴": "c9e990da7f6e93975e25fd8b70e2e290aa4086ef.png",
            "tv_难过": "87f46748d3f142ebc6586ff58860d0e2fc8263ba.png",
            "tv_馋": "fc7e829b845c43c623c8b490ee3602b7f0e76a31.png",
            "tv_鬼脸": "0ffbbddf8a94d124ca2f54b360bbc04feb6bbfea.png",
            "tv_黑人问号": "45821a01f51bc867da9edbaa2e070410819a95b2.png",
            "tv_鼓掌": "1d21793f96ef4e6f48b23e53e3b9e42da833a0f6.png"
        }
    })
</script>

                
            </div>
        </div>
    </div>
    
<a id="search-btn" style="display: inline-block;" href="javascript:void(0);">
    <span class="ri-search-line"></span>
</a>
<div id="fastSearch">
    <input id="searchInput" tabindex="0" autocomplete="off">
    <ul id="searchResults"></ul>
</div>
<div class="side_nav">
    
    <a id="top_to_back" href="#" class="top_to_back">
        <svg t="1688614744062" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2152" width="16" height="16"><path d="M966.4 323.2c-9.6-9.6-25.6-9.6-35.2 0l-416 416-425.6-416c-9.6-9.6-25.6-9.6-35.2 0-9.6 9.6-9.6 25.6 0 35.2l441.6 432c9.6 9.6 25.6 9.6 35.2 0l435.2-432C976 345.6 976 332.8 966.4 323.2z" p-id="2153" fill="#424242"></path></svg>    </a>
    
    <div>
        <a id="content_display" class="content_display">
            <svg t="1688606941910" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="57753" width="18" height="18"><path d="M192 448c10.9 0 21.8-4.2 30.2-12.5L497 160.8c5.4-5.4 11.8-6.2 15.1-6.2 3.3 0 9.6 0.8 15.1 6.2l274.7 274.7c16.7 16.7 43.7 16.7 60.3 0 16.7-16.7 16.7-43.7 0-60.3L587.4 100.4c-41.6-41.6-109.3-41.6-150.9 0L161.8 375.2c-16.7 16.7-16.7 43.7 0 60.3 8.4 8.3 19.3 12.5 30.2 12.5zM801.8 588.5L527.1 863.2c-5.4 5.4-11.8 6.2-15.1 6.2-3.3 0-9.7-0.8-15.1-6.2L222.2 588.5c-16.7-16.7-43.7-16.7-60.3 0-16.7 16.7-16.7 43.7 0 60.3l274.8 274.8c20.8 20.8 48.1 31.2 75.4 31.2 27.3 0 54.6-10.4 75.4-31.2l274.7-274.8c16.7-16.7 16.7-43.7 0-60.3-16.7-16.7-43.7-16.7-60.4 0z" fill="#424242" p-id="57754"></path></svg>
        </a>
        <a id="content_hidden" class="content_hidden">
            <svg t="1688603143752" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="15592" width="18" height="18"><path d="M479.004101 645.938677L165.25229 958.480465a37.510709 37.510709 0 0 0 0 54.059551 36.47863 36.47863 0 0 0 53.063061 0l293.679668-292.576411 293.715256 292.576411a36.443042 36.443042 0 0 0 53.063061 0 37.510709 37.510709 0 0 0 0-54.059551l-313.751811-312.541788c-21.210989-22.349834-36.514219-24.698702-66.017424 0z m66.053013-267.877709l312.577377-312.541789a37.510709 37.510709 0 0 0 0-54.059551 36.443042 36.443042 0 0 0-53.063061 0l-292.505234 292.576411L219.560963 11.459628a36.47863 36.47863 0 0 0-53.063061 0 37.510709 37.510709 0 0 0 0 54.059551l312.577377 312.541789a46.58588 46.58588 0 0 0 65.981835-0.035589z" p-id="15593" fill="#424242"></path></svg>
        </a>
    </div>
    
    <a id="back_to_top" href="#" class="back_to_top">
        <svg t="1688628374733" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3166" width="16" height="16"><path d="M966.4 668.8l-435.2-432c-9.6-9.6-25.6-9.6-35.2 0l-441.6 432c-9.6 9.6-9.6 25.6 0 35.2 9.6 9.6 25.6 9.6 35.2 0l425.6-416 416 416c9.6 9.6 25.6 9.6 35.2 0S976 678.4 966.4 668.8z" p-id="3167" fill="#424242"></path></svg>
    </a>
</div>
    <footer class="footer">
    <div id="footer_powered_by" class="powered_by">
        <a href="https://varkai.com">Designed by VarKai,</a>
        <a href="http://www.gohugo.io/">Proudly published with Hugo</a>
    </div>

    <div id="footer_slogan" class="footer_slogan">
        <span>from 2021</span>
    </div>
</footer>
    <script src="https://whiteppure.github.io/iblog/js/jquery-3.5.1.min.js"></script>
<link href="https://whiteppure.github.io/iblog/css/fancybox.min.css" rel="stylesheet">
<script src="https://whiteppure.github.io/iblog/js/fancybox.min.js"></script>
<script src="https://whiteppure.github.io/iblog/js/darkmode.js"></script>
<script src="https://whiteppure.github.io/iblog/js/zozo.js"></script>
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="https://whiteppure.github.io/iblog/js/busuanzi_2.3_busuanzi.pure.mini.js"></script>
<script src="https://whiteppure.github.io/iblog/js/html2canvas.js"></script>
<script src="https://whiteppure.github.io/iblog/js/utils.js"></script>
<script src="https://whiteppure.github.io/iblog/js/html2md.js"></script>
<script src="https://whiteppure.github.io/iblog/js/htmlexport.js"></script>

<script src="https://whiteppure.github.io/iblog/js/fastsearch.js"></script>
<script src="https://whiteppure.github.io/iblog/js/fuse.js"></script>


<script>
    new Darkmode({
        right: '32px', 
        bottom: 'unset', 
        
        time: '0.15s', 
        mixColor: '#f7f7f7', 
        backgroundColor: '#f7f7f7', 
        buttonColorDark: '#212121', 
        buttonColorLight: '#f7f7f7', 
        saveInCookies: false, 
        autoMatchOsTheme: true 
    }).showWidget();

    function addDarkmodeWidget(){
        const hours = new Date().getHours();
        if (hours >= 19 || hours <= 5){
            new Darkmode({
                right: '32px', 
                bottom: 'unset', 
                
                time: '0.3s', 
                mixColor: '#f7f7f7', 
                backgroundColor: '#f7f7f7', 
                buttonColorDark: '#212121', 
                buttonColorLight: '#f7f7f7', 
                saveInCookies: false, 
                autoMatchOsTheme: true 
            }).toggle();
        }
    }
    
    
</script>









</body>

</html>