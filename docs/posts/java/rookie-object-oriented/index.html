<!DOCTYPE html>
<html lang="zh" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="whitepure" />
	
	
	
	<title>面向对象 ｜ 唯手熟尔</title>
	
    
    
    <meta name="description" content="面向对象是一种编程思想，包括三大特性和六大原则，其中，三大特性指的是封装、继承和多态；六大原则指的是单一职责原则、开放封闭原则、迪米特原则、里氏替换原则、依赖倒置原则以及接口隔离原则，其中，单一职责原则是指一个类应该是一组相关性很高的函数和" />
    

    
    
    <meta name="keywords" content="whitepure博客, whiteppure, whitepure" />
    

	

    <link rel="shortcut icon" href="https://whiteppure.github.io/iblog/images/favicon.ico" />

    <link rel="stylesheet" type="text/css" media="screen" href="https://whiteppure.github.io/iblog/css/normalize.css" />

    <link rel="stylesheet" type="text/css" media="screen" href="https://whiteppure.github.io/iblog/css/animate.min.css" />
    <link rel="stylesheet" type="text/css" media="screen" href="https://whiteppure.github.io/iblog/css/zozo.css" />
	<link rel="stylesheet" type="text/css" media="screen" href="https://cdn.jsdelivr.net/npm/remixicon@2.5.0/fonts/remixicon.css" />
    <link rel="stylesheet" type="text/css" media="screen" href="https://whiteppure.github.io/iblog/css/highlight.css" />

    <link rel="stylesheet" type="text/css" media="screen" href="https://whiteppure.github.io/iblog/css/toc.css" />

    
    
</head>

<body>
    
    
    









<div id="post_content_toc" class="toc">
    <div class="page-header"><strong></strong></div>
    <div id="page-scrollspy" class="toc-nav">

        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e5%af%b9%e6%af%94%e9%9d%a2%e5%90%91%e8%bf%87%e7%a8%8b">
                    对比面向过程
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e8%bd%af%e4%bb%b6%e8%ae%be%e8%ae%a1%e5%8e%9f%e5%88%99">
                    软件设计原则
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e5%8d%95%e4%b8%80%e8%81%8c%e8%b4%a3%e5%8e%9f%e5%88%99">
                    单一职责原则
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e5%bc%80%e6%94%be%e5%b0%81%e9%97%ad%e5%8e%9f%e5%88%99">
                    开放封闭原则
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e4%be%9d%e8%b5%96%e5%80%92%e7%bd%ae%e5%8e%9f%e5%88%99">
                    依赖倒置原则
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e6%8e%a5%e5%8f%a3%e9%9a%94%e7%a6%bb%e5%8e%9f%e5%88%99">
                    接口隔离原则
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e9%87%8c%e6%b0%8f%e6%9b%bf%e6%8d%a2%e5%8e%9f%e5%88%99">
                    里氏替换原则
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e5%90%88%e6%88%90%e5%a4%8d%e7%94%a8%e5%8e%9f%e5%88%99">
                    合成复用原则
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e8%bf%aa%e7%b1%b3%e7%89%b9%e6%b3%95%e5%88%99">
                    迪米特法则
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e4%b8%89%e5%a4%a7%e7%89%b9%e6%80%a7">
                    三大特性
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e5%b0%81%e8%a3%85">
                    封装
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e4%bc%98%e7%82%b9">
                    优点
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e8%ae%bf%e9%97%ae%e6%9d%83%e9%99%90">
                    访问权限
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e7%bb%a7%e6%89%bf">
                    继承
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e7%bb%a7%e6%89%bf%e4%b8%8e%e7%bb%84%e5%90%88">
                    继承与组合
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#super">
                    super
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e6%8a%bd%e8%b1%a1%e7%b1%bb%e4%b8%8e%e6%8e%a5%e5%8f%a3">
                    抽象类与接口
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e5%a4%9a%e6%80%81">
                    多态
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e4%bc%98%e7%bc%ba%e7%82%b9">
                    优缺点
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e9%87%8d%e5%86%99%e4%b8%8e%e9%87%8d%e8%bd%bd">
                    重写与重载
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f">
                    设计模式
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e5%8d%95%e4%be%8b%e6%a8%a1%e5%bc%8f">
                    单例模式
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e9%a5%bf%e6%b1%89%e5%bc%8f">
                    饿汉式
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e7%ba%bf%e7%a8%8b%e4%b8%8d%e5%ae%89%e5%85%a8%e7%9a%84%e6%87%92%e6%b1%89%e5%bc%8f">
                    线程不安全的懒汉式
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e7%ba%bf%e7%a8%8b%e5%ae%89%e5%85%a8%e7%9a%84%e6%87%92%e6%b1%89%e5%bc%8f">
                    线程安全的懒汉式
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e5%8f%8c%e9%87%8d%e6%a0%a1%e9%aa%8c%e9%94%81">
                    双重校验锁
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e9%9d%99%e6%80%81%e5%86%85%e9%83%a8%e7%b1%bb%e5%bc%8f">
                    静态内部类式
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e6%9e%9a%e4%b8%be%e5%bc%8f">
                    枚举式
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e5%8d%95%e4%be%8b%e4%b8%8e%e5%ba%8f%e5%88%97%e5%8c%96">
                    单例与序列化
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e5%b7%a5%e5%8e%82%e6%a8%a1%e5%bc%8f">
                    工厂模式
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e7%ae%80%e5%8d%95%e5%b7%a5%e5%8e%82%e6%a8%a1%e5%bc%8f">
                    简单工厂模式
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e5%b7%a5%e5%8e%82%e6%96%b9%e6%b3%95%e6%a8%a1%e5%bc%8f">
                    工厂方法模式
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e6%8a%bd%e8%b1%a1%e5%b7%a5%e5%8e%82%e6%a8%a1%e5%bc%8f">
                    抽象工厂模式
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e5%8e%9f%e5%9e%8b%e6%a8%a1%e5%bc%8f">
                    原型模式
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e6%b5%85%e5%85%8b%e9%9a%86">
                    浅克隆
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e6%b7%b1%e5%85%8b%e9%9a%86">
                    深克隆
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e6%80%bb%e7%bb%93">
                    总结
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e5%bb%ba%e9%80%a0%e8%80%85%e6%a8%a1%e5%bc%8f">
                    建造者模式
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e9%80%82%e9%85%8d%e5%99%a8%e6%a8%a1%e5%bc%8f">
                    适配器模式
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e5%af%b9%e8%b1%a1%e9%80%82%e9%85%8d%e5%99%a8">
                    对象适配器
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e7%b1%bb%e9%80%82%e9%85%8d%e5%99%a8">
                    类适配器
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e6%80%bb%e7%bb%93-1">
                    总结
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e6%a1%a5%e6%8e%a5%e6%a8%a1%e5%bc%8f">
                    桥接模式
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e7%bb%84%e5%90%88%e6%a8%a1%e5%bc%8f">
                    组合模式
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e8%a3%85%e9%a5%b0%e6%a8%a1%e5%bc%8f">
                    装饰模式
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e5%a4%96%e8%a7%82%e6%a8%a1%e5%bc%8f">
                    外观模式
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e4%ba%ab%e5%85%83%e6%a8%a1%e5%bc%8f">
                    享元模式
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e4%bb%a3%e7%90%86%e6%a8%a1%e5%bc%8f">
                    代理模式
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e9%9d%99%e6%80%81%e4%bb%a3%e7%90%86">
                    静态代理
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e5%8a%a8%e6%80%81%e4%bb%a3%e7%90%86">
                    动态代理
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e6%80%bb%e7%bb%93-2">
                    总结
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e8%81%8c%e8%b4%a3%e9%93%be%e6%a8%a1%e5%bc%8f">
                    职责链模式
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e5%91%bd%e4%bb%a4%e6%a8%a1%e5%bc%8f">
                    命令模式
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e8%a7%a3%e9%87%8a%e5%99%a8%e6%a8%a1%e5%bc%8f">
                    解释器模式
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e8%bf%ad%e4%bb%a3%e5%99%a8%e6%a8%a1%e5%bc%8f">
                    迭代器模式
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e4%b8%ad%e4%bb%8b%e8%80%85%e6%a8%a1%e5%bc%8f">
                    中介者模式
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e5%a4%87%e5%bf%98%e5%bd%95%e6%a8%a1%e5%bc%8f">
                    备忘录模式
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e8%a7%82%e5%af%9f%e8%80%85%e6%a8%a1%e5%bc%8f">
                    观察者模式
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e7%8a%b6%e6%80%81%e6%a8%a1%e5%bc%8f">
                    状态模式
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e7%ad%96%e7%95%a5%e6%a8%a1%e5%bc%8f">
                    策略模式
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e6%a8%a1%e6%9d%bf%e6%96%b9%e6%b3%95%e6%a8%a1%e5%bc%8f">
                    模板方法模式
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e8%ae%bf%e9%97%ae%e8%80%85%e6%a8%a1%e5%bc%8f">
                    访问者模式
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        

    </div>

</div>



    

    
    <div class="main animate__animated animate__fadeInDown" id="main_content">
        <div class="nav_container animated fadeInDown">
    <div class="site_nav" id="site_nav">
        <ul><li class="">
                <a href="https://whiteppure.github.io/iblog/">首页</a>
            </li><li class="">
                <a href="https://whiteppure.github.io/iblog/posts/">归档</a>
            </li><li class="">
                <a href="https://whiteppure.github.io/iblog/tags/">标签</a>
            </li><li class="">
                <a href="https://whiteppure.github.io/iblog/about/">关于</a>
            </li>
        </ul>
    </div>
    <div class="menu_icon">
        <a id="menu_icon"><i class="ri-menu-line"></i></a>
    </div>
</div>
        <div id="post_header" class="header animated fadeInDown">
    <div class="site_title_container">
        <div class="site_title">
            <h1>
                <a href="https://whiteppure.github.io/iblog/">
                    <span>唯手熟尔</span>
                </a>
            </h1>
        </div>
        <div class="description">
            <p class="sub_title">
                无他,唯手熟尔
            </p>

            
            <div class="my_socials">
                
                    
                    <a href="https://github.com/whiteppure/" title="github" target="_blank">
                        <i class="ri-github-fill"></i>
                    </a>
                    
                
                <a href="https://whiteppure.github.io/iblog/index.xml" type="application/rss+xml" title="rss" target="_blank">
                    <i class="ri-rss-fill"></i>
                </a>
                
                
                <span id="sys_function" class="sys_function display_none">
                    <a id="export_pdf"  title="导出pdf" style="border: none; background-color: #ffffff; cursor: pointer; margin-left: 10px">
                        <svg t="1688701481347" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3517" width="16" height="16"><path d="M425.610455 85.814544H149.05897A42.303635 42.303635 0 0 0 106.6274 128.075535V896.492068c0 23.326702 18.976933 42.26099 42.43157 42.26099h682.743143a42.559504 42.559504 0 0 0 42.431569-42.559504v-384.016365a42.644793 42.644793 0 0 1 85.289587 0v384.016365A127.849091 127.849091 0 0 1 831.802113 1024H149.05897A127.635867 127.635867 0 0 1 21.337813 896.449423V128.03289A127.593222 127.593222 0 0 1 149.101614 0.524957h276.466196a42.644793 42.644793 0 0 1 0 85.289587z m564.062683 158.08425l-170.579174 170.579173a42.644793 42.644793 0 1 1-60.299738-60.299738L856.578738 256.393718H618.364922a42.644793 42.644793 0 1 1 0-85.289587h238.213816l-97.784512-97.784511A42.644793 42.644793 0 1 1 819.093964 13.019882l170.579174 170.579174a42.644793 42.644793 0 0 1 0 60.299738zM149.272194 597.552066a42.644793 42.644793 0 0 1 42.644793-42.644794h51.514911c59.190973 0 107.891327 23.284057 107.976617 97.102195 0 71.003581-49.46796 102.347504-106.185536 102.347504h-31.343923v66.781747a32.282109 32.282109 0 0 1-64.606862 0V597.552066z m92.709781 100.215264c31.429213 0 46.568114-16.46089 46.568114-45.757863 0-30.064579-17.313786-40.512554-48.359196-40.512554h-26.311837v86.270417h28.145563z m232.414124-142.860058c81.878003 0 136.036891 43.710913 136.036891 147.67892S556.231457 853.420826 477.935617 853.420826h-38.16709a42.644793 42.644793 0 0 1-42.644794-42.644793v-213.223967a42.644793 42.644793 0 0 1 42.644794-42.644794h34.542282z m-4.008611 240.729859c43.32711 0 73.988717-22.047358 73.988717-93.050939 0-71.046226-30.704251-90.705476-73.988717-90.705476h-8.699538v183.79906h8.699538zM692.481573 853.420826a32.282109 32.282109 0 0 1-32.282109-32.282108V597.552066a42.644793 42.644793 0 0 1 42.644793-42.644794h99.063855a29.680776 29.680776 0 1 1 0 59.404197h-77.144431v65.374469h61.749661a29.894 29.894 0 1 1 0 59.788h-61.749661v81.66478a32.282109 32.282109 0 0 1-32.282108 32.282108z" fill="#5f5f5f" p-id="3518"></path></svg>
                    </a>
                    <a id="export_pic" title="导出图片" style="border: none; background-color: #ffffff; cursor: pointer; margin-left: 10px">
                        <svg t="1689071509720" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4564" width="16" height="16"><path d="M909.132886 0.037506h-184.960611a33.909445 33.909445 0 0 0-32.368107 33.909445 33.909445 33.909445 0 0 0 33.909445 33.395666h158.244078l-200.373995 199.346437a33.395666 33.395666 0 0 0 0 47.781491 31.854327 31.854327 0 0 0 23.633856 9.76181 33.909445 33.909445 0 0 0 24.147635-9.76181l198.832657-199.346437V272.340628a33.909445 33.909445 0 0 0 69.874009 0V88.921355A88.37007 88.37007 0 0 0 909.132886 0.037506zM216.558153 347.866211a107.37991 107.37991 0 1 0 107.37991-107.379911 107.89369 107.89369 0 0 0-107.37991 107.379911z m154.133843 0a51.377948 51.377948 0 0 1-97.618101 0 51.377948 51.377948 0 1 1 97.618101 0z" p-id="4565" fill="#424242"></path><path d="M963.079731 437.777619a34.423225 34.423225 0 0 0-33.909446 33.909445v265.110209a1811.07265 1811.07265 0 0 0-137.692899-193.181082 106.352351 106.352351 0 0 0-78.60826-36.478343 123.820854 123.820854 0 0 0-82.204716 35.964563l-3.596456 3.082677-188.557068 176.74014c-11.816928-13.358266-47.781491-51.377948-82.204716-87.856291a83.232275 83.232275 0 0 0-85.801172-21.578738 105.324792 105.324792 0 0 0-38.019681 19.52362l-141.289356 121.765736V89.948914a22.092517 22.092517 0 0 1 22.606297-22.606297h417.702713a33.395666 33.395666 0 0 0 33.395666-33.909445 33.395666 33.395666 0 0 0-33.395666-33.395666H113.802258A89.911408 89.911408 0 0 0 23.89085 89.948914v844.139678a89.911408 89.911408 0 0 0 89.911408 89.911408h793.27551a89.911408 89.911408 0 0 0 89.397629-89.911408v-462.401528a33.909445 33.909445 0 0 0-33.395666-33.909445z m-33.909446 496.310973a22.606297 22.606297 0 0 1-22.092517 22.606297H113.802258a22.606297 22.606297 0 0 1-22.606297-22.606297v-88.37007l183.933052-160.812976a43.157476 43.157476 0 0 1 15.413385-7.192912 15.927164 15.927164 0 0 1 17.982281 5.137794c37.505902 36.478343 78.60826 83.232275 82.718496 87.856291a61.653537 61.653537 0 0 0 42.643696 22.092517 62.681096 62.681096 0 0 0 51.377948-20.037399c8.220472-8.220472 134.610223-125.875971 194.208641-181.877935a57.029522 57.029522 0 0 1 34.423225-16.440943 45.212594 45.212594 0 0 1 29.79921 15.927164 2954.231982 2954.231982 0 0 1 186.501949 256.889738z" p-id="4566" fill="#424242"></path></svg>
                    </a>
                    <a id="export_markdown" title="导出markdown" style="border: none; background-color: #ffffff; cursor: pointer; margin-left: 10px">
                        <svg t="1689071035200" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="13570" width="16" height="16"><path d="M178.073367 843.957262V461.158929h107.121045l107.121045 140.734874 107.125433-140.734874h107.116657v382.798333h-107.116657v-219.54307l-107.125433 140.730486-107.116657-140.730486v219.54307zM737.783131 892.148786l-131.221196-209.156132h87.479334V461.158929h87.479335v221.833725h87.483722z" p-id="13571" fill="#424242"></path><path d="M911.9958 217.142709c10.672172 10.663395 19.812851 25.144549 27.430816 43.430297 7.617965 18.285748 11.431335 35.044392 11.431336 50.28471V969.140255c0 15.235929-5.336086 28.18998-15.999481 38.853375-10.667783 10.667783-23.621834 16.003869-38.857763 16.003869H127.994904c-15.240317 0-28.18998-5.336086-38.857763-16.003869-10.663395-10.663395-15.999481-23.617446-15.999481-38.853375V54.852856c0-15.240317 5.331698-28.18998 15.999481-38.857763C99.804925 5.336086 112.758975 0 127.999292 0h512.000944c15.235929 0 31.998962 3.808982 50.28471 11.426947 18.285748 7.622353 32.762514 16.763033 43.430297 27.426428zM658.290372 77.715526v214.856442h214.856442c-3.808982-11.049559-7.99974-18.856218-12.572275-23.43314l-178.855415-178.851027c-4.572534-4.572534-12.383581-8.763292-23.43314-12.572275z m219.428976 873.143369V365.71496h-237.714724c-15.240317 0-28.18998-5.336086-38.857763-15.999481-10.663395-10.667783-15.999481-23.621834-15.999481-38.857763V73.142992H146.28504v877.715903z" p-id="13572" fill="#424242"></path></svg>
                    </a>
                    <a id="export_doc" title="导出文档" style="border: none; background-color: #ffffff; cursor: pointer; margin-left: 10px">
                        <svg t="1689246982401" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="6825" width="16" height="16"><path d="M270.76864 608.32h180.8a31.68 31.68 0 0 0 0-62.976H270.76864a31.68 31.68 0 0 0 0 62.976zM271.34464 458.56h457.92a33.472 33.472 0 0 0 31.552-34.752 33.28 33.28 0 0 0-31.552-34.624H271.34464a34.816 34.816 0 0 0 0 69.376zM271.34464 293.504h457.92a33.344 33.344 0 0 0 31.552-34.688 33.216 33.216 0 0 0-31.552-34.624H271.34464a33.28 33.28 0 0 0-31.616 34.624 33.28 33.28 0 0 0 31.616 34.688z" p-id="6826" fill="#424242"></path><path d="M869.87264 0H153.77664A70.4 70.4 0 0 0 84.65664 70.912V953.6A69.952 69.952 0 0 0 153.77664 1024h370.048a32 32 0 0 0 0-63.68H147.12064V64h729.6v468.672a31.296 31.296 0 1 0 62.528 0V70.912A70.4 70.4 0 0 0 869.87264 0z" p-id="6827" fill="#424242"></path><path d="M482.16064 730.624h337.664L715.82464 625.216a28.864 28.864 0 0 1-7.936-28.736 29.184 29.184 0 0 1 20.608-21.184 29.632 29.632 0 0 1 29.12 8.128l174.784 177.216-174.784 176.96a29.184 29.184 0 0 1-49.728-13.312 29.248 29.248 0 0 1 8-28.8l103.936-105.344H482.16064a29.696 29.696 0 0 1-29.504-29.76 29.632 29.632 0 0 1 29.504-29.76z" p-id="6828" fill="#424242"></path></svg>
                    </a>
                </span>
                <a  id="icon_more" title="更多" >
                    <svg t="1688715321313" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5356" width="16" height="16"><path d="M483.555556 199.111111m-85.333334 0a85.333333 85.333333 0 1 0 170.666667 0 85.333333 85.333333 0 1 0-170.666667 0Z" fill="#424242" p-id="5357"></path><path d="M483.555556 540.444444m-85.333334 0a85.333333 85.333333 0 1 0 170.666667 0 85.333333 85.333333 0 1 0-170.666667 0Z" fill="#424242" p-id="5358"></path><path d="M483.555556 881.777778m-85.333334 0a85.333333 85.333333 0 1 0 170.666667 0 85.333333 85.333333 0 1 0-170.666667 0Z" fill="#424242" p-id="5359"></path></svg>
                </a>
                <a  id="icon_less" class="display_none">
                    <svg t="1688723160472" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="15872" width="16" height="16"><path d="M300.105143 592.676571h423.789714a80.676571 80.676571 0 1 0 0-161.353142H300.105143a80.676571 80.676571 0 0 0 0 161.353142z" fill="#8a8a8a" p-id="15873"></path></svg>
                </a>
                
            </div>

            
            <div class="post">
                <div class="post_title post_detail_title">
                    <span class="date" id="busuanzi_container_site_pv">访问量 <span id="busuanzi_value_site_pv"></span>次</span>
                </div>
                <div class="post_title post_detail_title">
                    <span class="date" id="busuanzi_container_site_uv">访客数 <span id="busuanzi_value_site_uv"></span>人</span>
                </div>
            </div>
            
        </div>
    </div>
</div>
        <div class="content">
            <div class="post_page">
                <div class="post animate__animated animate__fadeInDown">
                    <div class="post_title post_detail_title">
                        <h2 id="post_single_title">面向对象</h2>
                        <span id="post_page_title_date" class="date">2021.02.15</span>
                    </div>
                    <div class="post_content markdown"><blockquote>
<p>面向对象是一种编程思想，包括三大特性和六大原则，其中，三大特性指的是封装、继承和多态；六大原则指的是<a href="#%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99">单一职责原则</a>、<a href="#%E5%BC%80%E6%94%BE%E5%B0%81%E9%97%AD%E5%8E%9F%E5%88%99">开放封闭原则</a>、<a href="#%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99">迪米特原则</a>、<a href="#%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99">里氏替换原则</a>、<a href="#%E4%BE%9D%E8%B5%96%E5%80%92%E7%BD%AE%E5%8E%9F%E5%88%99">依赖倒置原则</a>以及<a href="#%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99">接口隔离原则</a>，其中，单一职责原则是指一个类应该是一组相关性很高的函数和数据的封装，这是为了提高程序的内聚性，而其他五个原则是通过抽象来实现的，目的是为了降低程序的耦合性以及提高可扩展性。</p>
</blockquote>
<p>面向对象简称OO(object-oriented)是相对面向过程(procedure-oriented)来说的,是一种编程思想.Java就是一门面向对象的语言.</p>
<p>面向对象编程简称OOP(Object-oriented programming),是将事务高度抽象化的编程模式.
面向对象编程是以功能来划分问题的,将问题分解成一个一个步骤,对每个步骤进行相应的抽象,形成对应对象,通过不同对象之间的调用,组合成某个功能解决问题.</p>
<h2 id="对比面向过程">对比面向过程</h2>
<blockquote>
<p>PS: 面向过程编程简称POP(Procedural oriented programming),面向过程是以过程为中心的编程思想.是自顶而下的编程.</p>
</blockquote>
<p>举个栗子: 下五子棋</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">面向过程 {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  1.开始游戏
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  2.黑子先走
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  3.绘制画面
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  4.判断输赢
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  5.轮到白子
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  6.绘制画面
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  7.判断输赢
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  8.返回到 黑子先走
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">面向对象 {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    1.创建黑棋,白棋
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    2.创建棋盘
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    3.创建规则
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    4.赋予每个对象相关属性和指定行为
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    5.各个功能之间互相调用
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><p><strong>面向对象是模型化的,你只需抽象出几个类,进行封装成各个功能,通过不同对象之间的调用来解决问题.而面向过程需要把问题分解为几个步骤,每个步骤用对应的函数调用即可.面向过程是具体化的,流程化的,解决一个问题,需要你一步一步的分析,一步一步的实现.</strong></p>
<p>面向对象的底层其实还是面向过程,把面向过程抽象成类,然后进行封装,方便我们我们使用,就是面向对象了.</p>
<p>简而言之,用面向过程的方法写出来的程序是一份蛋炒饭,而用面向对象写出来的程序是一份盖浇饭(就是在一碗白米饭上面浇上一份盖菜，你喜欢什么菜,你就浇上什么菜).
通过例子可以看出面向对象更重视不重复造轮子,即创建一次,重复使用.</p>
<p>面向对象</p>
<blockquote>
<ul>
<li>
<p>优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统 更加灵活、更加易于维护。</p>
</li>
<li>
<p>缺点：性能比面向过程低</p>
</li>
</ul>
</blockquote>
<p>面向过程</p>
<blockquote>
<ul>
<li>优点：流程化使得编程任务明确，在开发之前基本考虑了实现方式和最终结果，具体步骤清楚，便于节点分析;    效率高，面向过程强调代码的短小精悍，善于结合数据结构来开发高效率的程序。</li>
<li>缺点：没有面向对象易维护、易复用、易扩展</li>
</ul>
</blockquote>
<p>抽象会使复杂的问题更加简单化,面向对象更符合人类的思维,而面向过程则是机器的思想.</p>
<h2 id="软件设计原则">软件设计原则</h2>
<p><strong>设计原则的目的是为了让程序达到高内聚、低耦合，提高可扩展性的目的，其实现手段是面向对象的三大特性：封装、继承以及多态。</strong></p>
<table>
<thead>
<tr>
<th>设计原则名称</th>
<th>核心思想</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99">单一职责原则</a></td>
<td>一个类只负责一个功能领域中的相应职责</td>
</tr>
<tr>
<td><a href="#%E5%BC%80%E6%94%BE%E5%B0%81%E9%97%AD%E5%8E%9F%E5%88%99">开放封闭原则</a></td>
<td>软件实体应对扩展开放，而对修改关闭</td>
</tr>
<tr>
<td><a href="#%E4%BE%9D%E8%B5%96%E5%80%92%E8%BD%AC%E5%8E%9F%E5%88%99">依赖倒转原则</a></td>
<td>抽象不应该依赖于细节，细节应该依赖于抽象</td>
</tr>
<tr>
<td><a href="#%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99">里氏替换原则</a></td>
<td>所有引用基类对象的地方能够透明地使用其子类的对象</td>
</tr>
<tr>
<td><a href="#%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99">接口隔离原则</a></td>
<td>使用多个专门的接口，而不使用单一的总接口</td>
</tr>
<tr>
<td><a href="#%E5%90%88%E6%88%90%E5%A4%8D%E7%94%A8%E5%8E%9F%E5%88%99">合成复用原则</a></td>
<td>尽量使用对象组合，而不是继承来达到复用的目的</td>
</tr>
<tr>
<td><a href="#%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99">迪米特法则</a></td>
<td>一个软件实体应当尽可能少地与其他实体发生相互作用</td>
</tr>
</tbody>
</table>
<h3 id="单一职责原则">单一职责原则</h3>
<blockquote>
<p><strong>其核心思想为：一个类，最好只做一件事，只有一个引起它的变化。单一职责原则可降低类的复杂度,提高代码可读性,可维护性,降低变更风险.</strong> 单一职责原则可以看做是低耦合、高内聚在面向对象原则上的引申，将职责定义为引起变化的原因，以提高内聚性来减少引起变化的原因。职责过多，可能引起它变化的原因就越多，这将导致职责依赖，相互之间就产生影响，从而大大损伤其内聚性和耦合度。通常意义下的单一职责，就是指只有一种单一功能，不要为类实现过多的功能点，以保证实体只有一个引起它变化的原因。 专注，是一个人优良的品质；同样的，单一也是一个类的优良设计。交杂不清的职责将使得代码看起来特别别扭牵一发而动全身，有失美感和必然导致丑陋的系统错误风险。</p>
</blockquote>
<p>代码实现</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public class MainTest {
</span></span><span class="line"><span class="cl">    public static void main(String[] args) {
</span></span><span class="line"><span class="cl">        Vehicle vehicle = new Vehicle();
</span></span><span class="line"><span class="cl">        vehicle.running(&#34;汽车&#34;);
</span></span><span class="line"><span class="cl">        // 飞机不是在路上行驶
</span></span><span class="line"><span class="cl">        vehicle.running(&#34;飞机&#34;);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">/**
</span></span><span class="line"><span class="cl"> * 在run方法中违反了单一职责原则
</span></span><span class="line"><span class="cl"> * 解决方法根据不同的交通工具,分解成不同的类即可
</span></span><span class="line"><span class="cl"> */
</span></span><span class="line"><span class="cl">class Vehicle{
</span></span><span class="line"><span class="cl">    public void running(String name) {
</span></span><span class="line"><span class="cl">        System.out.println(name + &#34;在路上行驶 ....&#34;);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">// 解决
</span></span><span class="line"><span class="cl">public class MainTest {
</span></span><span class="line"><span class="cl">    public static void main(String[] args) {
</span></span><span class="line"><span class="cl">        Driving driving = new Driving();
</span></span><span class="line"><span class="cl">        driving.running(&#34;汽车&#34;);
</span></span><span class="line"><span class="cl">        Flight flight = new Flight();
</span></span><span class="line"><span class="cl">        flight.running(&#34;飞机&#34;);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">class Driving {
</span></span><span class="line"><span class="cl">    public void running(String name) {
</span></span><span class="line"><span class="cl">        System.out.println(name + &#34;在路上行驶 ....&#34;);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">class Flight {
</span></span><span class="line"><span class="cl">    public void running(String name) {
</span></span><span class="line"><span class="cl">        System.out.println(name + &#34;在空中飞行 ....&#34;);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><p><strong>通常情况下,我们应当遵循单一职责原则,只要逻辑足够简单,才可以在代码里边违反单一职责原则;只要类中方法数量足够少,可以在方法级别保持单一职责原则.</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public class MainTest {
</span></span><span class="line"><span class="cl">    public static void main(String[] args) {
</span></span><span class="line"><span class="cl">        Vehicle2 vehicle2 = new Vehicle2();
</span></span><span class="line"><span class="cl">        vehicle2.driving(&#34;汽车&#34;);
</span></span><span class="line"><span class="cl">        vehicle2.flight(&#34;飞机&#34;);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">/*
</span></span><span class="line"><span class="cl"> * 改进
</span></span><span class="line"><span class="cl"> *↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓
</span></span><span class="line"><span class="cl"> */
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">class Vehicle2 {
</span></span><span class="line"><span class="cl">    public void driving(String name) {
</span></span><span class="line"><span class="cl">        System.out.println(name + &#34;在路上行驶 ....&#34;);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    public void flight(String name) {
</span></span><span class="line"><span class="cl">        System.out.println(name + &#34;在空中飞行 ....&#34;);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><h3 id="开放封闭原则">开放封闭原则</h3>
<blockquote>
<p><strong>软件实体应该是可扩展的，而不可修改的。也就是，对(提供方)扩展开放，对(使用方)修改封闭的。</strong> 开放封闭原则主要体现在两个方面</p>
<ul>
<li>对扩展开放，意味着有新的需求或变化时，可以对现有代码进行扩展，以适应新的情况。</li>
<li>对修改封闭，意味着类一旦设计完成，就可以独立完成其工作，而不要对其进行任何尝试的修改。</li>
</ul>
<p>实现开放封闭原则的核心思想就是对抽象编程，而不对具体编程，因为抽象相对稳定。让类依赖于固定的抽象，所以修改就是封闭的；而通过面向对象的继承和多态机制，又可以实现对抽象类的继承，通过覆写其方法来改变固有行为，实现新的拓展方法，所以就是开放的。 “需求总是变化”没有不变的软件，所以就需要用封闭开放原则来封闭变化满足需求，同时还能保持软件内部的封装体系稳定，不被需求的变化影响。<strong>编程中遵循其他原则,以及使用其他设计模式的目的就是为了遵循开闭原则.</strong></p>
</blockquote>
<p>当软件需要变化时,尽量使用扩展的软件实体的方式行为来实现变化,而不是通过修改已有的代码来实现变化.</p>
<p>代码实现</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">public class MainTest {
</span></span><span class="line"><span class="cl">    public static void main(String[] args) {
</span></span><span class="line"><span class="cl">        Mother mother = new Mother();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        Son son = new Son();
</span></span><span class="line"><span class="cl">        Daughter daughter = new Daughter();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        // 注入子类对象 如果扩展需要其他类 换成其他对象即可
</span></span><span class="line"><span class="cl">        mother.setAbstractFather(son);
</span></span><span class="line"><span class="cl">        mother.display();
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">abstract class AbstractFather {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    protected abstract void display();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">class Son  extends AbstractFather{
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    protected void display() {
</span></span><span class="line"><span class="cl">        System.out.println(&#34;son class ...&#34;);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">class Daughter  extends AbstractFather{
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    protected void display() {
</span></span><span class="line"><span class="cl">        System.out.println(&#34;daughter class ...&#34;);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">class Mother {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    private AbstractFather abstractFather;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public void setAbstractFather(AbstractFather abstractFather) {
</span></span><span class="line"><span class="cl">        this.abstractFather = abstractFather;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public void display() {
</span></span><span class="line"><span class="cl">        abstractFather.display();
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><h3 id="依赖倒置原则">依赖倒置原则</h3>
<blockquote>
<p><strong>该原则依赖于抽象。具体而言就是高层模块不依赖于底层模块，二者都同依赖于抽象；抽象不依赖于具体，具体依赖于抽象。</strong> 我们知道，依赖一定会存在于类与类、模块与模块之间。当两个模块之间存在紧密的耦合关系时，最好的方法就是分离接口和实现：在依赖之间定义一个抽象的接口使得高层模块调用接口，而底层模块实现接口的定义，以此来有效控制耦合关系，达到依赖于抽象的设计目标。 抽象的稳定性决定了系统的稳定性，因为抽象是不变的，依赖于抽象是面向对象设计的精髓，也是依赖倒置原则的核心。 依赖于抽象是一个通用的原则，而某些时候依赖于细节则是在所难免的，必须权衡在抽象和具体之间的取舍，方法不是一层不变的。<strong>依赖于抽象，就是对接口编程，不要对实现编程。</strong></p>
</blockquote>
<p>代码实现</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">public class MainTest {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public static void main(String[] args) {
</span></span><span class="line"><span class="cl">        Computer computer = new Computer();
</span></span><span class="line"><span class="cl">        // 对接口编程，不要对实现编程
</span></span><span class="line"><span class="cl">        // 如果没有接口 则代码很难实现扩展
</span></span><span class="line"><span class="cl">        Disk disk = new CustomDisk();
</span></span><span class="line"><span class="cl">        Memory memory = new CustomMemory();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        computer.setDisk(disk);
</span></span><span class="line"><span class="cl">        computer.setMemory(memory);
</span></span><span class="line"><span class="cl">        computer.run();
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">interface Disk{
</span></span><span class="line"><span class="cl">    void diskMethod();
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">interface Memory{
</span></span><span class="line"><span class="cl">    void memoryMethod();
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">class CustomDisk implements Disk{
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    public void diskMethod() {
</span></span><span class="line"><span class="cl">        System.out.println(&#34;i am disk ...&#34;);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">class  CustomMemory implements Memory{
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    public void memoryMethod() {
</span></span><span class="line"><span class="cl">        System.out.println(&#34;i am memory ...&#34;);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">class Computer {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    private Memory memory;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    private Disk disk;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public void setDisk(Disk disk) {
</span></span><span class="line"><span class="cl">        this.disk = disk;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public void setMemory(Memory memory) {
</span></span><span class="line"><span class="cl">        this.memory = memory;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public Disk getDisk() {
</span></span><span class="line"><span class="cl">        return disk;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public Memory getMemory() {
</span></span><span class="line"><span class="cl">        return memory;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    public void run() {
</span></span><span class="line"><span class="cl">        System.out.println(&#34; computer is running ...&#34;);
</span></span><span class="line"><span class="cl">        memory.memoryMethod();
</span></span><span class="line"><span class="cl">        disk.diskMethod();
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><h3 id="接口隔离原则">接口隔离原则</h3>
<blockquote>
<p><strong>使用多个小的专门的接口，而不要使用一个大的总接口。</strong> 具体而言，接口隔离原则体现在：接口应该是内聚的，应该避免“胖”接口。一个类对另外一个类的依赖应该建立在最小的接口上，不要强迫依赖不用的方法，这是一种接口污染。 接口有效地将细节和抽象隔离，体现了对抽象编程的一切好处，接口隔离强调接口的单一性。而胖接口存在明显的弊端，会导致实现的类型必须完全实现接口的所有方法、属性等；而某些时候，实现类型并非需要所有的接口定义，在设计上这是“浪费”，而且在实施上这会带来潜在的问题，对胖接口的修改将导致一连串的客户端程序需要修改，有时候这是一种灾难。在这种情况下，将胖接口分解为多个特点的定制化方法，使得客户端仅仅依赖于它们的实际调用的方法，从而解除了客户端不会依赖于它们不用的方法。</p>
<p>分离的手段主要有以下两种：</p>
<ul>
<li>委托分离，通过增加一个新的类型来委托客户的请求，隔离客户和接口的直接依赖，但是会增加系统的开销。</li>
<li>多重继承分离，通过接口多继承来实现客户的需求，这种方式是较好的。</li>
</ul>
</blockquote>
<p>代码实现</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public class MainTest {
</span></span><span class="line"><span class="cl">    public static void main(String[] args) {
</span></span><span class="line"><span class="cl">        FuncImpl func = new FuncImpl();
</span></span><span class="line"><span class="cl">        func.func1();
</span></span><span class="line"><span class="cl">        func.func2();
</span></span><span class="line"><span class="cl">        func.func3();
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">interface Function1{
</span></span><span class="line"><span class="cl">    void func1();
</span></span><span class="line"><span class="cl">    // 如果将接口中的方法都写在一个接口就会造成实现该接口就要重写该接口所有方法。
</span></span><span class="line"><span class="cl">    // 当然Java 8 接口可以有实现，降低了维护成本，解了决该问题；
</span></span><span class="line"><span class="cl">    // 但是我们还是应当遵循该原则，使得接口看起来更加清晰
</span></span><span class="line"><span class="cl">    // void func2();
</span></span><span class="line"><span class="cl">    // void func3();
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">interface Function2 {
</span></span><span class="line"><span class="cl">    void func2();
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">interface Function3 {
</span></span><span class="line"><span class="cl">    void func3();
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">class FuncImpl implements Function1,Function2,Function3{
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    public void func1() {
</span></span><span class="line"><span class="cl">        System.out.println(&#34;i am function1 impl&#34;);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    public void func2() {
</span></span><span class="line"><span class="cl">        System.out.println(&#34;i am function2 impl&#34;);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    public void func3() {
</span></span><span class="line"><span class="cl">        System.out.println(&#34;i am function3 impl&#34;);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><h3 id="里氏替换原则">里氏替换原则</h3>
<blockquote>
<p><strong>子类必须能够替换其基类。</strong> 这一思想体现为对继承机制的约束规范，只有子类能够替换基类时，才能保证系统在运行期内识别子类，这是保证继承复用的基础。在父类和子类的具体行为中，必须严格把握继承层次中的关系和特征，将基类替换为子类，程序的行为不会发生任何变化。同时，这一约束反过来则是不成立的，子类可以替换基类，但是基类不一定能替换子类。 里氏替换原则，主要着眼于对抽象和多态建立在继承的基础上，因此只有遵循了里氏替换原则，才能保证继承复用是可靠地。</p>
<p>实现的方法是面向接口编程：将公共部分抽象为基类接口或抽象类，通过<code>Extract Abstract Class</code>，在子类中通过覆写父类的方法实现新的方式支持同样的职责。 里氏替换原则是关于继承机制的设计原则，违反了里氏替换原则就必然导致违反开放封闭原则。 里氏替换原则能够保证系统具有良好的拓展性，同时实现基于多态的抽象机制，能够减少代码冗余，避免运行期的类型判别。</p>
</blockquote>
<p>简单来说就是子类可以扩展父类的功能,但是尽量不要重写父类的功能.如果通过重写父类方法来完成新的功能,这样写起来虽然简单,但整个体系的可复用性会非常差,特别是运用多态比较频繁时,程序运行出错的概率会非常大.</p>
<p>代码实现</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">public class MainTest {
</span></span><span class="line"><span class="cl">    public static void main(String[] args) {
</span></span><span class="line"><span class="cl">        Rectangle rectangle = new Rectangle();
</span></span><span class="line"><span class="cl">        rectangle.setWidth(20);
</span></span><span class="line"><span class="cl">        rectangle.setHeight(10);
</span></span><span class="line"><span class="cl">        resize(rectangle);
</span></span><span class="line"><span class="cl">        print(rectangle);
</span></span><span class="line"><span class="cl">        System.out.println(&#34;=======================&#34;);
</span></span><span class="line"><span class="cl">        // 因为 Square类 重写了父类set的方法导致调用时出错
</span></span><span class="line"><span class="cl">        Rectangle square = new Square();
</span></span><span class="line"><span class="cl">        square.setWidth(10);
</span></span><span class="line"><span class="cl">        resize(square);
</span></span><span class="line"><span class="cl">        print(square);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    public static void resize(Rectangle rectangle){
</span></span><span class="line"><span class="cl">        while (rectangle.getWidth() &gt;= rectangle.getHeight()){
</span></span><span class="line"><span class="cl">            rectangle.setHeight(rectangle.getHeight() + 1);
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public static void print(Rectangle rectangle){
</span></span><span class="line"><span class="cl">        System.out.println(rectangle.getWidth());
</span></span><span class="line"><span class="cl">        System.out.println(rectangle.getHeight());
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">class Square  extends Rectangle{
</span></span><span class="line"><span class="cl">    private Integer width;
</span></span><span class="line"><span class="cl">    private Integer height;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    public void setWidth(Integer width) {
</span></span><span class="line"><span class="cl">        super.setWidth(width);
</span></span><span class="line"><span class="cl">        super.setHeight(width);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    public void setHeight(Integer height) {
</span></span><span class="line"><span class="cl">        super.setWidth(height);
</span></span><span class="line"><span class="cl">        super.setHeight(height);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">class Rectangle {
</span></span><span class="line"><span class="cl">    private Integer width;
</span></span><span class="line"><span class="cl">    private Integer height;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public void setWidth(Integer width) {
</span></span><span class="line"><span class="cl">        this.width = width;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public void setHeight(Integer height) {
</span></span><span class="line"><span class="cl">        this.height = height;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public Integer getWidth() {
</span></span><span class="line"><span class="cl">        return width;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public Integer getHeight() {
</span></span><span class="line"><span class="cl">        return height;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><h3 id="合成复用原则">合成复用原则</h3>
<blockquote>
<p><strong>尽量使用对象组合，而不是继承来达到复用的目的。</strong> 在面向对象设计中，可以通过两种方法在不同的环境中复用已有的设计和实现，<strong>即通过组合/聚合关系或通过继承，但首先应该考虑使用组合/聚合</strong>，组合/聚合可以使系统更加灵活，降低类与类之间的耦合度，一个类的变化对其他类造成的影响相对较少；其次才考虑继承，在使用继承时，需要严格遵循里氏代换原则，有效使用继承会有助于对问题的理解，降低复杂度，而滥用继承反而会增加系统构建和维护的难度以及系统的复杂度，因此需要慎重使用继承复用。</p>
</blockquote>
<p>代码实现</p>
<p>详见<a href="#%E7%BB%A7%E6%89%BF%E4%B8%8E%E7%BB%84%E5%90%88">继承与组合</a></p>
<h3 id="迪米特法则">迪米特法则</h3>
<blockquote>
<p>迪米特法则又叫最少知识原则，就是说一个对象应当对其他对象有尽可能少的了解。
其核心思想是: <strong>降低类之间的耦合.如果类与类之间的关系越密切，耦合度越大，当一个类发生改变时，对另一个类的影响也越大.一个对象应该对其他对象有最少的了解。</strong> 通俗地讲，一个类应该对自己需要耦合或调用的类知道得最少，你（被耦合或调用的类）的内部是如何复杂都和我没关系，那是你的事情，我就知道你提供的<code>public</code>方法，我就调用这么多，其他的一概不关心.迪米特法则其根本思想，是强调了类之间的松耦合。类之间的耦合越弱，越有利于复用，一个处在弱耦合的类被修改，不会对有关系的类造成搏击，也就是说，信息的隐藏促进了软件的复用。</p>
</blockquote>
<p>迪米特法则还有个更简单的定义：只与直接的朋友通信</p>
<p>朋友定义：<strong>每个对象都会与其他对象有耦合关系，只要两个对象之间有耦合关系，我们就说这两个对象之间是朋友关系。</strong> 耦合的方式很多，依赖，关联，组合，聚合等。其中，我们称出现<strong>成员变量，方法参数，方法返回值中的类为直接的朋友</strong>，而出现在<strong>局部变量中的类不是直接的朋友</strong>。也就是说，<strong>陌生的类最好不要以局部变量的形式出现在类的内部。</strong></p>
<p>代码实现</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public class MainTest {
</span></span><span class="line"><span class="cl">    public static void main(String[] args) {
</span></span><span class="line"><span class="cl">        //创建了一个 SchoolManager 对象
</span></span><span class="line"><span class="cl">        SchoolManager schoolManager = new SchoolManager();
</span></span><span class="line"><span class="cl">        // SchoolManager直接朋友: CollegeManager (方法参数) Employee(返回值)
</span></span><span class="line"><span class="cl">        // CollegeEmployee以局部变量的形式出现在SchoolManager类中 所以违反了迪米特法则
</span></span><span class="line"><span class="cl">        schoolManager.printAllEmployee(new CollegeManager());
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">class Employee {
</span></span><span class="line"><span class="cl">    private String id;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public String getId() {
</span></span><span class="line"><span class="cl">        return id;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public void setId(String id) {
</span></span><span class="line"><span class="cl">        this.id = id;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">class CollegeEmployee {
</span></span><span class="line"><span class="cl">    private String id;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public String getId() {
</span></span><span class="line"><span class="cl">        return id;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public void setId(String id) {
</span></span><span class="line"><span class="cl">        this.id = id;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">class CollegeManager {
</span></span><span class="line"><span class="cl">    public List&lt;CollegeEmployee&gt; getAllEmployee() {
</span></span><span class="line"><span class="cl">        List&lt;CollegeEmployee&gt; list = new ArrayList&lt;&gt;();
</span></span><span class="line"><span class="cl">        for (int i = 0; i &lt; 10; i++) {
</span></span><span class="line"><span class="cl">            CollegeEmployee emp = new CollegeEmployee();
</span></span><span class="line"><span class="cl">            emp.setId(&#34;学院员工 id= &#34; + i);
</span></span><span class="line"><span class="cl">            list.add(emp);
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        return list;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">class SchoolManager {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public List&lt;Employee&gt; getAllEmployee() {
</span></span><span class="line"><span class="cl">        List&lt;Employee&gt; list = new ArrayList&lt;&gt;();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        for (int i = 0; i &lt; 5; i++) {
</span></span><span class="line"><span class="cl">            //这里我们增加了 5 个员工到
</span></span><span class="line"><span class="cl">            Employee emp = new Employee();
</span></span><span class="line"><span class="cl">            emp.setId(&#34;学校总部员工 id= &#34; + i);
</span></span><span class="line"><span class="cl">            list.add(emp);
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        return list;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    void printAllEmployee(CollegeManager sub) {
</span></span><span class="line"><span class="cl">        //获取到学院员工
</span></span><span class="line"><span class="cl">        List&lt;CollegeEmployee&gt; list1 = sub.getAllEmployee();
</span></span><span class="line"><span class="cl">        System.out.println(&#34;------------学院员工------------&#34;);
</span></span><span class="line"><span class="cl">        for (CollegeEmployee e : list1) {
</span></span><span class="line"><span class="cl">            System.out.println(e.getId());
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        //获取到学校总部员工
</span></span><span class="line"><span class="cl">        List&lt;Employee&gt; list2 = this.getAllEmployee();
</span></span><span class="line"><span class="cl">        System.out.println(&#34;------------学校总部员工------------&#34;);
</span></span><span class="line"><span class="cl">        for (Employee e : list2) {
</span></span><span class="line"><span class="cl">            System.out.println(e.getId());
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">class CollegeManager {
</span></span><span class="line"><span class="cl">    public List&lt;CollegeEmployee&gt; getAllEmployee() {
</span></span><span class="line"><span class="cl">        List&lt;CollegeEmployee&gt; list = new ArrayList&lt;&gt;();
</span></span><span class="line"><span class="cl">        for (int i = 0; i &lt; 10; i++) {
</span></span><span class="line"><span class="cl">            CollegeEmployee emp = new CollegeEmployee();
</span></span><span class="line"><span class="cl">            emp.setId(&#34;学院员工 id= &#34; + i);
</span></span><span class="line"><span class="cl">            list.add(emp);
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        return list;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    // 修改后
</span></span><span class="line"><span class="cl">    public void printAllEmployee() {
</span></span><span class="line"><span class="cl">        List&lt;CollegeEmployee&gt; list1 = this.getAllEmployee();
</span></span><span class="line"><span class="cl">        System.out.println(&#34;------------学院员工------------&#34;);
</span></span><span class="line"><span class="cl">        for (CollegeEmployee e : list1) {
</span></span><span class="line"><span class="cl">            System.out.println(e.getId());
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">class SchoolManager {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public List&lt;Employee&gt; getAllEmployee() {
</span></span><span class="line"><span class="cl">        List&lt;Employee&gt; list = new ArrayList&lt;&gt;();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        for (int i = 0; i &lt; 5; i++) {
</span></span><span class="line"><span class="cl">            //这里我们增加了 5 个员工到
</span></span><span class="line"><span class="cl">            Employee emp = new Employee();
</span></span><span class="line"><span class="cl">            emp.setId(&#34;学校总部员工 id= &#34; + i);
</span></span><span class="line"><span class="cl">            list.add(emp);
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        return list;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    void printAllEmployee(CollegeManager sub) {
</span></span><span class="line"><span class="cl">        //获取到学院员工
</span></span><span class="line"><span class="cl">        // 修改后
</span></span><span class="line"><span class="cl">        sub.printAllEmployee();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        //获取到学校总部员工
</span></span><span class="line"><span class="cl">        List&lt;Employee&gt; list2 = this.getAllEmployee();
</span></span><span class="line"><span class="cl">        System.out.println(&#34;------------学校总部员工------------&#34;);
</span></span><span class="line"><span class="cl">        for (Employee e : list2) {
</span></span><span class="line"><span class="cl">            System.out.println(e.getId());
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><h2 id="三大特性">三大特性</h2>
<h3 id="封装">封装</h3>
<p>封装是面向对象方法的重要原则，就是把对象的属性和操作（或服务）结合为一个独立的整体，并尽可能隐藏对象的内部实现细节.简单的说,一个类就是一个封装了数据以及操作这些数据的代码的逻辑实体。在一个对象内部，<strong>某些代码或某些数据可以是私有的</strong>，不能被外界访问。通过这种方式，对象对内部数据提供了不同级别的保护，以防止程序中无关的部分意外的改变或错误的使用了对象的私有部分。</p>
<p><strong>封装的目的是增强安全性和简化编程,使用者不必了解具体的实现细节,而只是要通过外部接口,以特定的访问权限来使用类的成员.</strong></p>
<h4 id="优点">优点</h4>
<ul>
<li>良好的封装能够减少耦合;提高了可维护性和灵活性以及可重用性;</li>
<li>类内部的结构可以自由修改;</li>
<li>可以对成员变量进行更精确的控制;</li>
<li>隐藏信息，实现细节;</li>
</ul>
<h4 id="访问权限">访问权限</h4>
<p>Java的封装可以通过修改属性的可见性限制对属性的访问来体现.</p>
<p><strong>Java 中有三个访问权限修饰符：private、protected 以及 public，如果不加访问修饰符，表示包级可见(default)。</strong></p>
<table>
<thead>
<tr>
<th>修饰符</th>
<th>当前类</th>
<th>同一包下</th>
<th>其他包的子类</th>
<th>不同包的子类</th>
<th>其他包</th>
</tr>
</thead>
<tbody>
<tr>
<td>public</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
</tr>
<tr>
<td>protected</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>Y/N</td>
<td>N</td>
</tr>
<tr>
<td>default</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>N</td>
<td>N</td>
</tr>
<tr>
<td>private</td>
<td>Y</td>
<td>N</td>
<td>N</td>
<td>N</td>
<td>N</td>
</tr>
</tbody>
</table>
<p>这四种访问权限的控制符能够控制类中成员的可见性.当然需要满足在不使用Java反射的情况下.</p>
<p><strong>注意</strong></p>
<ul>
<li><code>protected</code>用于修饰成员,表示在继承体系中成员对于子类可见.如果不存在继承关系则不能访问<code>protected</code>修饰的实例.</li>
<li>类可见表示其它类可以用这个类创建实例对象;</li>
<li>成员可见表示其它类可以用这个类的实例对象访问到该成员;</li>
</ul>
<p>设计良好的模块会隐藏所有的实现细节，把它的 API 与它的实现清晰地隔离开来。模块之间只通过它们的 API 进行通信，一个模块不需要知道其他模块的内部工作情况，这个概念被称为<strong>信息隐藏或封装</strong>。因此<strong>访问权限应当尽可能地使每个类或者成员不被外界访问</strong>。</p>
<p><strong>如果子类的方法重写了父类的方法，那么子类中该方法的访问级别不允许低于父类的访问级别</strong>。这是为了确保可以使用父类实例的地方都可以使用子类实例，也就是确保满足<strong>里氏替换原则</strong>。</p>
<p><strong>某个类的字段决不能是公有的，因为这么做的话就失去了对这个字段修改行为的控制，其他类可以对其随意修改。</strong>
例如下面的例子中，<code>AccessExample</code>拥有id公有字段，如果在某个时刻，我们想要使用<code>int</code>存储<code>id</code>字段，那么就需要修改所有类中的代码。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public class AccessExample {
</span></span><span class="line"><span class="cl">    public String id;
</span></span><span class="line"><span class="cl">    // public int id;
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><p>可以使用公有的 <code>getter</code> 和 <code>setter</code> 方法来替换公有字段，这样的话就可以控制对字段的修改行为。实现了封装</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public class AccessExample {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    private int id;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public String getId() {
</span></span><span class="line"><span class="cl">        return id + &#34;&#34;;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public void setId(String id) {
</span></span><span class="line"><span class="cl">        this.id = Integer.valueOf(id);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><p><strong>但是也有例外，如果是包级私有的类或者私有的嵌套类，那么直接暴露成员不会有特别大的影响。</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public class AccessWithInnerClassExample {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    private class InnerClass {
</span></span><span class="line"><span class="cl">        int x;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    private InnerClass innerClass;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public AccessWithInnerClassExample() {
</span></span><span class="line"><span class="cl">        innerClass = new InnerClass();
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public int getValue() {
</span></span><span class="line"><span class="cl">        return innerClass.x;  // 直接访问
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><h3 id="继承">继承</h3>
<p>继承可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。通过继承创建的新类称为“子类”或“派生类”，被继承的类称为“基类”、“父类”或“超类”。继承的过程，就是从一般到特殊的过程.<strong>要实现继承，可以通过“继承”（Inheritance）和“组合”（Composition）来实现.</strong> 继承概念的实现方式有两类：实现继承与接口继承。实现继承是指直接使用基类的属性和方法而无需额外编码的能力；接口继承是指仅使用属性和方法的名称、但是子类必须提供实现的能力.</p>
<blockquote>
<p>继承: 如果多个类的某个部分的功能相同,那么可以抽象出一个类来,把相同的部分放到父类中,让他们继承这个类</p>
<p>实现：如果多个类处理的目标是一样的，但是处理的方法方式不同，那么就定义一个接口，也就是一个<strong>标准</strong>，让他们的实现这个接口，各自实现自己具体的处理方法来处理那个目标</p>
</blockquote>
<p><strong>继承的根本原因是因为要复用，而实现的根本原因是需要定义一个标准.</strong></p>
<h4 id="继承与组合">继承与组合</h4>
<p>继承是实现复用代码的重要手段,但是继承会破坏封装.组合也是代码复用的重要方式,可以提供良好的封装性.</p>
<h5 id="实现继承">实现继承</h5>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">// 继承
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">public class MainTest {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public static void main(String[] args) {
</span></span><span class="line"><span class="cl">        B b = new B();
</span></span><span class="line"><span class="cl">        b.test();
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">class A {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    protected int i;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    protected void test() {
</span></span><span class="line"><span class="cl">        System.out.println(&#34;I am super class ... &#34;);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">class B  extends A{
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // 调用父类成员 
</span></span><span class="line"><span class="cl">    public void t() {
</span></span><span class="line"><span class="cl">        System.out.println(i);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><p>通过以上代码,可以发现,子类可以访问父类的成员变量方法,并且通过重写可以改变父类方法实现.从而破坏了封装性.</p>
<blockquote>
<p>在继承结构中，父类的内部细节对于子类是可见的。所以我们通常也可以说通过继承的代码复用是一种<strong>白盒式代码复用</strong>。（如果基类的实现发生改变，那么派生类的实现也将随之改变。这样就导致了子类行为的不可预知性；）</p>
</blockquote>
<p>为了保证父类有良好的封装性,不会对子类随意更改,设计父类时应遵循以下原则:</p>
<blockquote>
<ul>
<li>尽量隐藏父类的内部数据.尽量把所有父类的所有成员变量都用<code>private</code>修饰,不要让子类直接访问父类的成员.</li>
<li>不要让子类随意的修改访问父类的方法.父类中那些仅为辅助其他的工具方法,应该使用private修饰,让子类无法访问该方法;如果父类中的方法需要被外部类调用,则需以public修饰,但又不希望重写父类方法可以使用final来修饰方法;但如果希望父类某个方法被重写,但又不希望其他类访问自由,可以使用protected修饰.</li>
<li>尽量不要在父类构造器中调用将要被子类重写的方法.</li>
</ul>
</blockquote>
<p>继承是类与类或者接口与接口之间最常见的关系,继承是一种<code>is-a</code>关系。</p>
<h5 id="实现组合">实现组合</h5>
<p>组合是把旧类对象作为新类对象的成员变量组合进来,用以实现新类的功能.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">public class MainTest {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public static void main(String[] args) {
</span></span><span class="line"><span class="cl">        B b = new B(new A());
</span></span><span class="line"><span class="cl">        b.test();
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">class A {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    protected int i;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    protected void test() {
</span></span><span class="line"><span class="cl">        System.out.println(&#34;I am super class ... &#34;);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">class B {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    private final A a;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public B(A a) {
</span></span><span class="line"><span class="cl">        this.a = a;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    public void test() {
</span></span><span class="line"><span class="cl">        // 复用 A 类提供的 test 方法
</span></span><span class="line"><span class="cl">        a.test();
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><blockquote>
<p>组合是通过对现有的对象进行拼装（组合）产生新的、更复杂的功能。因为在对象之间，各自的内部细节是不可见的，所以我们也说这种方式的代码复用是<strong>黑盒式代码复用</strong>。（因为组合中一般都定义一个类型，所以在编译期根本不知道具体会调用哪个实现类的方法）</p>
</blockquote>
<p>组合强调的是整体与部分、拥有的关系，即<code>has-a</code>的关系.</p>
<h5 id="比较">比较</h5>
<blockquote>
<p>继承，在写代码的时候就要指名具体继承哪个类，所以，在编译期就确定了关系。（从基类继承来的实现是无法在运行期动态改变的，因此降低了应用的灵活性。）</p>
</blockquote>
<blockquote>
<p>组合，在写代码的时候可以采用面向接口编程。所以，类的组合关系一般在运行期确定。</p>
</blockquote>
<table>
<thead>
<tr>
<th>组合</th>
<th>继承</th>
</tr>
</thead>
<tbody>
<tr>
<td>优点：不破坏封装，整体类与局部类之间松耦合，彼此相对独立</td>
<td>缺点：破坏封装，子类与父类之间紧密耦合，子类依赖于父类的实现，子类缺乏独立性</td>
</tr>
<tr>
<td>优点：具有较好的可扩展性</td>
<td>缺点：支持扩展，但是往往以增加系统结构的复杂度为代价</td>
</tr>
<tr>
<td>优点：支持动态组合。在运行时，整体对象可以选择不同类型的局部对象</td>
<td>缺点：不支持动态继承。在运行时，子类无法选择不同的父类</td>
</tr>
<tr>
<td>优点：整体类可以对局部类进行包装，封装局部类的接口，提供新的接口</td>
<td>缺点：子类不能改变父类的接口</td>
</tr>
<tr>
<td>缺点：整体类不能自动获得和局部类同样的接口</td>
<td>优点：子类能自动继承父类的接口</td>
</tr>
<tr>
<td>缺点：创建整体类的对象时，需要创建所有局部类的对象</td>
<td>优点：创建子类的对象时，无须创建父类的对象</td>
</tr>
</tbody>
</table>
<h5 id="使用选择">使用选择</h5>
<p>经过以上比较,可以得出结论: 组合比继承更加灵活.所以在写代码如果这个功能组合和继承都能够完成,那么应该优先选择组合.
但是继承在一些场景还是要优先于组合的.</p>
<blockquote>
<ul>
<li>继承要慎用，其使用场合仅限于你确信使用该技术有效的情况。一个判断方法是，问一问自己是否需要从新类向基类进行向上转型。如果是必须的，则继承是必要的。反之则应该好好考虑是否需要继承。</li>
<li>只有当子类真正是超类的子类型时，才适合用继承。换句话说，对于两个类A和B，只有当两者之间确实存在is-a关系的时候，类B才应该继承类A。</li>
</ul>
</blockquote>
<h4 id="super">super</h4>
<ul>
<li>访问父类的构造函数：可以使用<code>super()</code>函数访问父类的构造函数，从而委托父类完成一些初始化的工作。<strong>应该注意到，子类一定会调用父类的构造函数来完成初始化工作，一般是调用父类的默认构造函数</strong>，<strong>如果子类需要调用父类其它构造函数，那么就可以使用super函数。</strong></li>
<li>访问父类的成员：如果子类重写了父类的某个方法，可以通过使用 <code>super </code>关键字来引用父类的方法实现。</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public class SuperExample {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    protected int x;
</span></span><span class="line"><span class="cl">    protected int y;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public SuperExample(int x, int y) {
</span></span><span class="line"><span class="cl">        this.x = x;
</span></span><span class="line"><span class="cl">        this.y = y;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public void func() {
</span></span><span class="line"><span class="cl">        System.out.println(&#34;SuperExample.func()&#34;);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">public class SuperExtendExample extends SuperExample {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    private int z;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public SuperExtendExample(int x, int y, int z) {
</span></span><span class="line"><span class="cl">        super(x, y);
</span></span><span class="line"><span class="cl">        this.z = z;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    public void func() {
</span></span><span class="line"><span class="cl">        super.func();
</span></span><span class="line"><span class="cl">        System.out.println(&#34;SuperExtendExample.func()&#34;);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">SuperExample e = new SuperExtendExample(1, 2, 3);
</span></span><span class="line"><span class="cl">e.func();
</span></span><span class="line"><span class="cl">SuperExample.func()
</span></span><span class="line"><span class="cl">SuperExtendExample.func()
</span></span></code></pre></div><h4 id="抽象类与接口">抽象类与接口</h4>
<p>抽象类和接口也是Java继承体系中的重要组成部分.抽象类是用来捕捉子类的通用特性的，而接口则是抽象方法的集合；抽象类不能被实例化，只能被用作子类的超类，是被用来创建继承层级里子类的模板，而接口只是一种形式，接口自身不能做任何事情。</p>
<h5 id="抽象类">抽象类</h5>
<p><strong>抽象类和抽象方法都使用<code>abstract</code>关键字进行声明。如果一个类中包含抽象方法，那么这个类必须声明为抽象类。</strong></p>
<p>抽象类和普通类最大的区别是，抽象类不能被实例化，需要继承抽象类才能实例化其子类。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public abstract class AbstractClassExample {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    protected int x;
</span></span><span class="line"><span class="cl">    private int y;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public abstract void func1();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public void func2() {
</span></span><span class="line"><span class="cl">        System.out.println(&#34;func2&#34;);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">public class AbstractExtendClassExample extends AbstractClassExample {
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    public void func1() {
</span></span><span class="line"><span class="cl">        System.out.println(&#34;func1&#34;);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">// 实例化抽象类
</span></span><span class="line"><span class="cl">// AbstractClassExample ac1 = new AbstractClassExample(); 
</span></span><span class="line"><span class="cl">// 实例化抽象类子类
</span></span><span class="line"><span class="cl">// AbstractClassExample ac2 = new AbstractExtendClassExample();
</span></span><span class="line"><span class="cl">// ac2.func1();
</span></span></code></pre></div><h5 id="接口">接口</h5>
<p><strong>接口是抽象类的延伸，在 Java 8 之前，它可以看成是一个完全抽象的类，也就是说它不能有任何的方法实现。</strong></p>
<p><strong>从 Java 8 开始</strong>，<strong>接口也可以拥有默认的方法实现</strong>，这是因为不支持默认方法的接口的维护成本太高了。在 Java 8 之前，如果一个接口想要添加新的方法，那么要修改所有实现了该接口的类,现在不用修改所有实现该接口的类.</p>
<p>接口的成员（字段 + 方法）默认都是<code>public</code>的，并且不允许定义为<code>private</code>或者 <code>protected</code>。</p>
<p>接口的字段默认都是用<code>static</code>和<code>final</code>修饰的.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public interface InterfaceExample {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    void func1();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    default void func2(){
</span></span><span class="line"><span class="cl">        System.out.println(&#34;func2&#34;);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    int x = 123;
</span></span><span class="line"><span class="cl">    // int y;               // Variable &#39;y&#39; might not have been initialized
</span></span><span class="line"><span class="cl">    public int z = 0;       // Modifier &#39;public&#39; is redundant for interface fields
</span></span><span class="line"><span class="cl">    // private int k = 0;   // Modifier &#39;private&#39; not allowed here
</span></span><span class="line"><span class="cl">    // protected int l = 0; // Modifier &#39;protected&#39; not allowed here
</span></span><span class="line"><span class="cl">    // private void fun3(); // Modifier &#39;private&#39; not allowed here
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">public class InterfaceImplementExample implements InterfaceExample {
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    public void func1() {
</span></span><span class="line"><span class="cl">        System.out.println(&#34;func1&#34;);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">// InterfaceExample ie1 = new InterfaceExample(); // &#39;InterfaceExample&#39; is abstract; cannot be instantiated
</span></span><span class="line"><span class="cl">InterfaceExample ie2 = new InterfaceImplementExample();
</span></span><span class="line"><span class="cl">ie2.func1();//func1
</span></span><span class="line"><span class="cl">System.out.println(InterfaceExample.x);//123
</span></span></code></pre></div><p>Java的接口可以多继承</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">interface Action extends Serializable,AutoCloseable {
</span></span><span class="line"><span class="cl">	// to do ...
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><h5 id="比较-1">比较</h5>
<p>从设计层面上看，抽象类提供了一种<code>is-a</code>关系，那么就必须满足里式替换原则，即子类对象必须能够替换掉所有父类对象。而接口更像是一种 <code>like-a</code> 关系，它只是提供一种方法实现契约，并不要求接口和实现接口的类具有 <code>is-a</code> 关系。
抽象类是一种自下而上的思想，而接口是一种自上而下的思想。抽象类是将多个类的公共特点聚合到同一个类中，然后实现父类的方法；接口更像是对类的一种约束，其他类调用实现某接口的类。</p>
<p>从语法角度来看，一个类可以实现多个接口，但是不能继承多个抽象类；接口的字段只能是<code>static</code>和<code>final</code>类型的，而抽象类的字段没有这种限制，接口的成员只能是<code>public</code>的，而抽象类的成员可以有多种访问权限。</p>
<h5 id="使用选择-1">使用选择</h5>
<p><strong>使用接口</strong></p>
<ul>
<li>需要让不相关的类都实现一个方法，例如:不相关的类都可以实现 <code>Compareable</code> 接口中的 <code>compareTo()</code> 方法；</li>
<li>需要使用多重继承。</li>
</ul>
<p><strong>使用抽象类</strong></p>
<ul>
<li>需要在几个相关的类中共享代码。</li>
<li>需要能控制继承来的成员的访问权限，而不是都为<code>public</code>。</li>
<li>需要继承非静态和非常量字段。</li>
</ul>
<p><strong>在很多情况下，接口优先于抽象类。因为接口没有抽象类严格的类层次结构要求，可以灵活地为一个类添加行为。并且从 Java 8 开始，接口也可以有默认的方法实现，使得修改接口的成本也变的很低。</strong></p>
<h3 id="多态">多态</h3>
<p>多态即多种表现形态;同一个行为具有多个不同表现形式或形态的能力.</p>
<p>多态存在的前提</p>
<ul>
<li>有类继承或者接口实现</li>
<li>子类要重写父类的方法</li>
<li>父类的引用指向子类的对象;例如：<code>Parent p = new Child();</code></li>
</ul>
<p>简单说来: 父类引用指向子类对象，调用方法时会调用子类的实现，而不是父类的实现，称为多态.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">class Parent {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    void contextLoads(){
</span></span><span class="line"><span class="cl">        System.out.println(&#34;i am Parent ... &#34;);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">class Child  extends Parent {
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    void contextLoads(){
</span></span><span class="line"><span class="cl">        System.out.println(&#34;i am Child ... &#34;);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">class mainTest{
</span></span><span class="line"><span class="cl">    public static void main(String[] args) {
</span></span><span class="line"><span class="cl">        Parent child = new Child();
</span></span><span class="line"><span class="cl">        // i am Child ... 
</span></span><span class="line"><span class="cl">        child.contextLoads();
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><h4 id="优缺点">优缺点</h4>
<p><strong>优点</strong></p>
<ul>
<li>消除类型之间的耦合关系</li>
<li>可替换性</li>
<li>可扩充性</li>
<li>接口性</li>
<li>灵活性</li>
<li>简化性</li>
</ul>
<p><strong>缺点</strong></p>
<p>不能使用子类特有的方法和属性.在编写代码期间使用多态调用方法或属性时，编译工具首先会检查父类中是否有该方法和属性，如果没有，则会编译报错。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">class Parent {
</span></span><span class="line"><span class="cl">    void contextLoads(){
</span></span><span class="line"><span class="cl">        System.out.println(&#34;i am Parent ... &#34;);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">class Child  extends Parent {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    String  c = &#34;child&#34;;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    void contextLoads(){
</span></span><span class="line"><span class="cl">        System.out.println(&#34;i am Child ... &#34;);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    void test() {
</span></span><span class="line"><span class="cl">        System.out.println(&#34;i am test method ...&#34;);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">class mainTest{
</span></span><span class="line"><span class="cl">    public static void main(String[] args) {
</span></span><span class="line"><span class="cl">        Parent child = new Child();
</span></span><span class="line"><span class="cl">        // 编译报错: 无法解析 &#39;Parent&#39; 中的方法 &#39;test&#39;
</span></span><span class="line"><span class="cl">        child.test();
</span></span><span class="line"><span class="cl">        // 编译报错: 不能解决符号 &#39;c&#39;
</span></span><span class="line"><span class="cl">        child.c;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><h4 id="重写与重载">重写与重载</h4>
<h5 id="重写">重写</h5>
<p><strong>重写(Override)存在于继承体系中，指子类实现了一个与父类在方法声明上完全相同的一个方法。</strong></p>
<blockquote>
<p>为了满足里式替换原则，重写有以下三个限制：</p>
<ul>
<li>子类方法的访问权限必须大于等于父类方法；</li>
<li>子类方法的返回类型必须是父类方法返回类型或为其子类型。</li>
<li>子类方法抛出的异常类型必须是父类抛出异常类型或为其子类型。</li>
</ul>
</blockquote>
<p>使用<code>@Override</code>注解，可以让编译器帮忙检查是否满足上面的三个限制条件。</p>
<p>下面的示例中，<code>SubClass </code>为 <code>SuperClass</code> 的子类，<code>SubClass</code> 重写了 <code>SuperClass</code> 的 <code>func()</code> 方法。其中：</p>
<ul>
<li><strong>子类方法访问权限为<code>public</code>，大于父类的<code>protected</code>。</strong></li>
<li><strong>子类的返回类型为<code>ArrayList</code>，是父类返回类型<code>List</code>的子类。</strong></li>
<li><strong>子类抛出的异常类型为 <code>Exception</code>，是父类抛出异常 <code>Throwable</code> 的子类。</strong></li>
<li><strong>子类重写方法使用<code>@Override</code>注解，从而让编译器自动检查是否满足限制条件。</strong></li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">class SuperClass {
</span></span><span class="line"><span class="cl">    protected List&lt;Integer&gt; func() throws Throwable {
</span></span><span class="line"><span class="cl">        return new ArrayList&lt;&gt;();
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">class SubClass extends SuperClass {
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    public ArrayList&lt;Integer&gt; func() throws Exception {
</span></span><span class="line"><span class="cl">        return new ArrayList&lt;&gt;();
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><p>在调用一个方法时，先从本类中查找看是否有对应的方法，如果没有查找到再到父类中查看，看是否有继承来的方法。否则就要对参数进行转型，转成父类之后看是否有对应的方法。总的来说，方法调用的优先级为：</p>
<ul>
<li><code>this.func(this)</code></li>
<li><code>super.func(this)</code></li>
<li><code>this.func(super)</code></li>
<li><code>super.func(super)</code></li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">/*继承关系
</span></span><span class="line"><span class="cl">    A
</span></span><span class="line"><span class="cl">    |
</span></span><span class="line"><span class="cl">    B
</span></span><span class="line"><span class="cl">    |
</span></span><span class="line"><span class="cl">    C
</span></span><span class="line"><span class="cl">    |
</span></span><span class="line"><span class="cl">    D
</span></span><span class="line"><span class="cl"> */
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">class A {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public void show(A obj) {
</span></span><span class="line"><span class="cl">        System.out.println(&#34;A.show(A)&#34;);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public void show(C obj) {
</span></span><span class="line"><span class="cl">        System.out.println(&#34;A.show(C)&#34;);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">class B extends A {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    public void show(A obj) {
</span></span><span class="line"><span class="cl">        System.out.println(&#34;B.show(A)&#34;);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">class C extends B {
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">class D extends C {
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">class  mainTest{
</span></span><span class="line"><span class="cl">    public static void main(String[] args) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        A a = new A();
</span></span><span class="line"><span class="cl">        B b = new B();
</span></span><span class="line"><span class="cl">        C c = new C();
</span></span><span class="line"><span class="cl">        D d = new D();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        // 在 A 中存在 show(A obj)，直接调用
</span></span><span class="line"><span class="cl">        a.show(a); // A.show(A)
</span></span><span class="line"><span class="cl">        // 在 A 中不存在 show(B obj)，将 B 转型成其父类 A
</span></span><span class="line"><span class="cl">        a.show(b); // A.show(A)
</span></span><span class="line"><span class="cl">        // 在 B 中存在从 A 继承来的 show(C obj)，直接调用
</span></span><span class="line"><span class="cl">        b.show(c); // A.show(C)
</span></span><span class="line"><span class="cl">        // 在 B 中不存在 show(D obj)，但是存在从 A 继承来的 show(C obj)，将 D 转型成其父类 C
</span></span><span class="line"><span class="cl">        b.show(d); // A.show(C)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        // 引用的还是 B 对象，所以 ba 和 b 的调用结果一样
</span></span><span class="line"><span class="cl">        A ba = new B();
</span></span><span class="line"><span class="cl">        ba.show(c); // A.show(C)
</span></span><span class="line"><span class="cl">        ba.show(d); // A.show(C)
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><h5 id="重载">重载</h5>
<p><strong>重载(overload)是在一个类里面，方法名字相同，但是参数类型、个数、顺序至少有一个不同。返回类型可以相同也可以不同。应该注意的是，返回值不同，其它都相同不算是重载。</strong></p>
<p><strong>每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。</strong> 最常用的地方就是构造器的重载。</p>
<blockquote>
<p><strong>重载规则:</strong></p>
<ul>
<li>被重载的方法必须改变参数列表(参数个数或类型不一样)；</li>
<li>被重载的方法可以改变返回类型；</li>
<li>被重载的方法可以改变访问修饰符；</li>
<li>被重载的方法可以声明新的或更广的检查异常；</li>
<li>方法能够在同一个类中或者在一个子类中被重载。</li>
<li>无法以返回值类型作为重载函数的区分标准。</li>
</ul>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public class Overloading {
</span></span><span class="line"><span class="cl">    public int test(){
</span></span><span class="line"><span class="cl">        System.out.println(&#34;test1&#34;);
</span></span><span class="line"><span class="cl">        return 1;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">    public void test(int a){
</span></span><span class="line"><span class="cl">        System.out.println(&#34;test2&#34;);
</span></span><span class="line"><span class="cl">    }   
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">    //以下两个参数类型顺序不同
</span></span><span class="line"><span class="cl">    public String test(int a,String s){
</span></span><span class="line"><span class="cl">        System.out.println(&#34;test3&#34;);
</span></span><span class="line"><span class="cl">        return &#34;returntest3&#34;;
</span></span><span class="line"><span class="cl">    }   
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">    public String test(String s,int a){
</span></span><span class="line"><span class="cl">        System.out.println(&#34;test4&#34;);
</span></span><span class="line"><span class="cl">        return &#34;returntest4&#34;;
</span></span><span class="line"><span class="cl">    }   
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">    public static void main(String[] args){
</span></span><span class="line"><span class="cl">        Overloading o = new Overloading();
</span></span><span class="line"><span class="cl">        System.out.println(o.test());
</span></span><span class="line"><span class="cl">        o.test(1);
</span></span><span class="line"><span class="cl">        System.out.println(o.test(1,&#34;test3&#34;));
</span></span><span class="line"><span class="cl">        System.out.println(o.test(&#34;test4&#34;,1));
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><p><strong>方法的重写(Override)和重载(Overload)是Java多态性的不同表现，重写是父类与子类之间多态性的一种表现，重载可以理解成多态的具体表现形式</strong></p>
<blockquote>
<ul>
<li>方法重载是一个类中定义了多个方法名相同,而他们的参数的数量不同或数量相同而类型和次序不同,则称为方法的重载(Overloading)。</li>
<li>方法重写是在子类存在方法与父类的方法的名字相同,而且参数的个数与类型一样,返回值也一样的方法,就称为重写(Overriding)。</li>
<li>方法重载是一个类的多态性表现,而方法重写是子类与父类的一种多态性表现。</li>
</ul>
</blockquote>
<h2 id="设计模式">设计模式</h2>
<blockquote>
<p>设计模式是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结，使用设计模式是为了可重用代码、让代码更容易被他人理解并且保证代码可靠性。</p>
<p>虽然<a href="https://baike.baidu.com/item/GoF/6406151?fr=aladdin">GoF</a>设计模式只有23个，但是它们各具特色，每个模式都为某一个可重复的设计问题提供了一套解决方案。<strong>根据它们的用途，设计模式可分为创建型，结构型和行为型三种</strong>，其中创建型模式主要用于描述如何创建对象，结构型模式主要用于描述如何实现类或对象的组合，行为型模式主要用于描述类或对象怎样交互以及怎样分配职责;在GoF23种设计模式中包含5种创建型设计模式、7种结构型设计模式和11种行为型设计模式。此外，根据某个模式主要是用于处理类之间的关系还是对象之间的关系，设计模式还可以分为类模式和对象模式。</p>
</blockquote>
<p>设计模式是一套被反复使用的、多数人知晓的、经过分类编目、代码设计经验的总结。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性、高内聚低耦合。</p>
<blockquote>
<p>设计模式练习网站: <a href="https://java-design-patterns.com/patterns">https://java-design-patterns.com/patterns</a></p>
</blockquote>
<table>
    <tr>
        <th rowspan="1">设计模式类型</th>
        <th colspan="1">设计模式名称</th>
        <th colspan="1">介绍</th>
        <th colspan="1">学习难度</th>
        <th colspan="1">使用频率</th>
    </tr>
    <tr>
        <td rowspan="6">创建型模式(6种)</td>
        <td><a href="#单例模式">单例模式</a></td>
        <td>保证一个类仅有一个对象，并提供一个访问它的全局访问点。</td>
        <td>★☆☆☆☆</td>
        <td>★★★★☆</td>
    </tr>
    <tr>
        <td><a href="#简单工厂模式">简单工厂模式</a></td>
        <td>定义一个工厂类，它可以根据参数的不同返回不同类的实例，被创建的实例通常都具有共同的父类。</td>
        <td>★★☆☆☆</td>
        <td>★★★★★</td>
    </tr>
    <tr>
        <td><a href="#工厂方法模式">工厂方法模式</a></td>
        <td>定义一个用于创建对象的接口，让子类决定将哪一个类实例化。</td>
        <td>★★☆☆☆</td>
        <td>★★★★★</td>
    </tr>
    <tr>
        <td><a href="#抽象工厂模式">抽象工厂模式</a></td>
        <td>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们的具体类。</td>
        <td>★★★★☆</td>
        <td>★★★★★</td>
    </tr>
    <tr>
        <td><a href="#原型模式">原型模式</a></td>
        <td>使用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。</td>
        <td>★★★☆☆</td>
        <td>★★★☆☆</td>
    </tr>
    <tr>
        <td><a href="#建造者模式">建造者模式</a></td>
        <td>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</td>
        <td>★★★★☆</td>
        <td>★★☆☆☆</td>
    </tr>
    <tr>
        <td rowspan="7">结构型模式(7种)</td>
        <td><a href="#适配器模式">适配器模式</a></td>
         <td>将一个类的接口转换成客户希望的另一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</td>
        <td>★★☆☆☆</td>
        <td>★★★★☆</td>
    </tr>
    <tr>
        <td><a href="#桥接模式">桥接模式</a></td>
        <td>将抽象部分与它的实现部分分离，使他们都可以独立地变化。</td>
        <td>★★★☆☆</td>
        <td>★★★☆☆</td>
    </tr>
    <tr>
        <td><a href="#组合模式">组合模式</a></td>
        <td>组合多个对象形成树形结构以表示具有“整体—部分”关系的层次结构。组合模式对单个对象和组合对象的使用具有一致性。</td>
        <td>★★★☆☆</td>
        <td>★★★★☆</td>
    </tr>
    <tr>
        <td><a href="#装饰模式">装饰模式</a></td>
        <td>动态地给一个对象增加一些额外的职责，就增加对象功能来说，装饰模式比生成子类实现更为灵活。</td>
        <td>★★★☆☆</td>
        <td>★★★☆☆</td>
    </tr>
    <tr>
        <td><a href="#外观模式">外观模式</a></td>
        <td>为子系统中的一组接口提供一个统一的入口。外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。</td>
        <td>★☆☆☆☆</td>
        <td>★★★★★</td>
    </tr>
    <tr>
        <td><a href="#享元模式">享元模式</a></td>
        <td>运用共享技术有效地支持大量细粒度的对象。</td>
        <td>★★★★☆</td>
        <td>★☆☆☆☆</td>
    </tr>
    <tr>
        <td><a href="#代理模式">代理模式</a></td>
        <td>为其他对象提供一个代理以控制对这个对象的访问。</td>
        <td>★★★☆☆</td>
        <td>★★★★☆</td>
    </tr>
    <tr>
        <td rowspan="11">行为模式(11种)</th>
        <td><a href="#职责链模式">职责链模式</a></td>
        <td>为解除请求的发送者和接收者之间的耦合，而使多个对象都有机会处理这个请求。将这些对象连成一条链，并沿着这条链传递该请求，直到有对象处理它。</td>
        <td>★★★☆☆</td>
        <td>★★☆☆☆</td>
    </tr>
    <tr>
        <td><a href="#命令模式">命令模式</a></td>
        <td>将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化，对请求排队或记录请求日志，以及支持可取消的操作。</td>
        <td>★★★☆☆</td>
        <td>★★★★☆</td>
    </tr>
    <tr>
        <td><a href="#解释器模式">解释器模式</a></td>
        <td>定义一个语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中的句子。</td>
        <td>★★★★★</td>
        <td>★☆☆☆☆</td>
    </tr>
    <tr>
        <td><a href="#迭代器模式">迭代器模式</a></td>
        <td>提供一种方法顺序访问一个聚合对象中各个元素，而又不需暴露该对象的内部表示。</td>
        <td>★★★☆☆</td>
        <td>★★★★★</td>
    </tr>
    <tr>
        <td><a href="#中介者模式">中介者模式</a></td>
        <td>用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显示地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。</td>
        <td>★★★☆☆</td>
        <td>★★☆☆☆</td>
    </tr>
    <tr>
        <td><a href="#备忘录模式">备忘录模式</a></td>
        <td>在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保持该状态，这样以后就可以将该对象恢复到保存的状态。</td>
        <td>★★☆☆☆</td>
        <td>★★☆☆☆</td>
    </tr>
    <tr>
        <td><a href="#观察者模式">观察者模式</a></td>
        <td>定义对象间的一种一对多的依赖关系，以便当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动刷新。</td>
        <td>★★★☆☆</td>
        <td>★★★★★</td>
    </tr>
    <tr>
        <td><a href="#状态模式">状态模式</a></td>
        <td>允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它所属的类。</td>
        <td>★★★☆☆</td>
        <td>★★★☆☆</td>
    </tr>
    <tr>
        <td><a href="#策略模式">策略模式</a></td>
        <td>定义一系列的算法，把它们一个个封装起来，并且使他们可相互替换。本模式使得算法的变化可以独立于使用它的客户。</td>
        <td>★☆☆☆☆</td>
        <td>★★★★☆</td>
    </tr>
    <tr>
        <td><a href="#模板方法模式">模板方法模式</a></td>
        <td>定义一个操作中的算法的骨架，而将一些步骤延迟到子类。</td>
        <td>★★☆☆☆</td>
        <td>★★★☆☆</td>
    </tr>
    <tr>
        <td><a href="#访问者模式">访问者模式</a></td>
        <td>表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素类别的前提下定义作用于这些元素的新操作。</td>
        <td>★★★★☆</td>
        <td>★☆☆☆☆</td>
    </tr>
</table>
<h3 id="单例模式">单例模式</h3>
<blockquote>
<p>单例模式：确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。单例模式是一种对象创建型模式。</p>
</blockquote>
<p>单例模式设计就是采用一定的方法保证在整个程序中,对某个类只能存在一个对象的实例,并且该类只提供一个取得其对象实例的方法.</p>
<blockquote>
<p>单例模式作用:<br></p>
<ul>
<li>在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如网站首页页面缓存）.</li>
<li>避免对资源的多重占用（比如写文件操作）.</li>
</ul>
</blockquote>
<p>单例模式使用的场景：需要频繁的进行创建和销毁的对象、创建对象时耗时过多或耗费资源过多(即：重量级对象)，但又经常用到的对象、工具类对象、频繁访问数据库或文件的对象(比如数据源、<code>session</code> 工厂等)</p>
<p>单例模式的6种写法.</p>
<table>
<thead>
<tr>
<th>写法名称</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#%E9%A5%BF%E6%B1%89%E5%BC%8F">饿汉式</a></td>
<td>线程安全,写法简单</td>
<td>不懒加载,可能造成浪费</td>
</tr>
<tr>
<td><a href="#%E6%87%92%E6%B1%89%E5%BC%8F(%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8)">懒汉式(线程不安全)</a></td>
<td>懒加载</td>
<td>线程不安全</td>
</tr>
<tr>
<td><a href="#%E6%87%92%E6%B1%89%E5%BC%8F(%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8)">懒汉式(线程安全)</a></td>
<td>线程安全,懒加载</td>
<td>效率很低,反序列化破坏单例</td>
</tr>
<tr>
<td><a href="#%E5%8F%8C%E9%87%8D%E6%A0%A1%E9%AA%8C%E9%94%81">双重校验锁</a></td>
<td>线程安全,懒加载</td>
<td>反序列化破坏单例</td>
</tr>
<tr>
<td><a href="#%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB%E5%BC%8F">静态内部类式</a></td>
<td>线程安全,懒加载</td>
<td>反序列化破坏单例</td>
</tr>
<tr>
<td><a href="#%E6%9E%9A%E4%B8%BE%E5%BC%8F">枚举式</a></td>
<td>防止反射攻击,反序列化创建对象,写法简单</td>
<td>不能传参,继承其他类</td>
</tr>
</tbody>
</table>
<h4 id="饿汉式">饿汉式</h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">class Singleton {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    private Singleton() {}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    private static final Singleton instance = new Singleton();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public static Singleton getInstance() {
</span></span><span class="line"><span class="cl">        return instance;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><p>这种写法比较简单，就是在类加载的时候就完成实例化。避免了线程同步问题。但是在类装载的时候就完成实例化，没有达到懒加载的效果。如果从始至终从未使用过这个实例，则会造成内存的浪费.</p>
<h4 id="线程不安全的懒汉式">线程不安全的懒汉式</h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">class Singleton {
</span></span><span class="line"><span class="cl">    private Singleton() {
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    private static Singleton instance;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public static Singleton getInstance() {
</span></span><span class="line"><span class="cl">        if (instance == null) {
</span></span><span class="line"><span class="cl">            instance = new Singleton();
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        return instance;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><p>起到了懒加载的效果，但是只能在单线程下使用。如果在多线程下，一个线程进入了<code>if (singleton == null)</code>判断语句块，还未来得及往下执行，另一个线程也通过了这个判断语句，这时便会产生多个实例。所以在多线程环境下不可使用这种方式.</p>
<h4 id="线程安全的懒汉式">线程安全的懒汉式</h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">class Singleton {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    private static Singleton instance;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    private Singleton() {
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public static synchronized Singleton getInstance() {
</span></span><span class="line"><span class="cl">        if (instance == null) {
</span></span><span class="line"><span class="cl">            instance = new Singleton();
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        return instance;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><p>虽然解决了线程安全问题但是效率太低了，每个线程在想获得类的实例时候，执行<code>getInstance()</code>方法都要进行同步。而其实这个方法只执行一次实例化代码就够了，后面的想获得该类实例，直接 <code>return</code>就行了。</p>
<h4 id="双重校验锁">双重校验锁</h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">class Singleton {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    /**
</span></span><span class="line"><span class="cl">     * volatile在这作用: 禁止JVM指令重排
</span></span><span class="line"><span class="cl">     */
</span></span><span class="line"><span class="cl">    private static volatile Singleton instance;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    private Singleton() {
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public static Singleton getInstance() {
</span></span><span class="line"><span class="cl">        if (instance == null) {
</span></span><span class="line"><span class="cl">            synchronized (Singleton.class) {
</span></span><span class="line"><span class="cl">                if (instance == null) {
</span></span><span class="line"><span class="cl">                    instance = new Singleton();
</span></span><span class="line"><span class="cl">                }
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        return instance;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><p><code>Double-Check</code>概念是多线程开发中常使用到的，如代码中所示，我们进行了两次<code>if (singleton == null)</code>检查，这样就可以保证线程安全了。这样，实例化代码只用执行一次，后面再次访问时，判断<code>if (singleton == null)</code>，直接<code>return</code>实例化对象，也避免的反复进行方法同步.</p>
<h4 id="静态内部类式">静态内部类式</h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">class Singleton {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    private Singleton() {}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    private static class InnerClass {
</span></span><span class="line"><span class="cl">        private static final Singleton instance = new Singleton();
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    public static Singleton getInstance() {
</span></span><span class="line"><span class="cl">        return InnerClass.instance;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><blockquote>
<p>这种方式同样利用了<code>classloder</code>的机制来保证初始化<code>instance</code>时只有一个线程，它跟饿汉式不同的是（很细微的差别）：饿汉式是只要<code>Singleton</code>类被装载了，那么<code>instance</code>就会被实例化（没有达到<code>lazy loading</code>效果），而这种方式是<code>Singleton</code>类被装载了，<code>instance</code>不一定被初始化。因为<code>SingletonHolder</code>类没有被主动使用，只有显示通过调用<code>getInstance</code>方法时，才会显示装载<code>SingletonHolder</code>类，从而实例化<code>instance</code>。想象一下，如果实例化<code>instance</code>很消耗资源，我想让他延迟加载，另外一方面，我不希望在<code>Singleton</code>类加载时就实例化，因为我不能确保<code>Singleton</code>类还可能在其他的地方被主动使用从而被加载，那么这个时候实例化<code>instance</code>显然是不合适的。这个时候，这种方式相比饿汉式更加合理。</p>
</blockquote>
<h4 id="枚举式">枚举式</h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">enum Singleton {
</span></span><span class="line"><span class="cl">    INSTAMCE;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    Singleton() {
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><p>这种方式是《Effective Java》作者<code>Josh Bloch</code>提倡的方式.借助 JDK1.5 中添加的枚举来实现单例模式。不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象。</p>
<h4 id="单例与序列化">单例与序列化</h4>
<p>上述单例模式6种写法除了,枚举式单例外其他5种写法都存在序列化问题.<strong>序列化可以破坏单例.原因是序列化会通过反射调用无参数的构造方法创建一个新的对象.</strong></p>
<p>要想防止序列化对单例的破坏，只要在单例类中定义<code>readResolve</code>方法就可以解决该问题.<strong>原因是反序列化时,会通过反射的方式调用要被反序列化的类的<code>readResolve</code>方法</strong>
主要在<code>Singleton</code>类中定义<code>readResolve</code>方法，并在该方法中指定要返回的对象的生成策略，就可以防止单例被破坏。</p>
<p>以<code>DCL</code>为例,在该单例类中插入<code>readResolve</code>方法。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public class Singleton implements Serializable{
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    private volatile static Singleton singleton;
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    private Singleton (){}
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    public static Singleton getSingleton() {
</span></span><span class="line"><span class="cl">        if (singleton == null) {
</span></span><span class="line"><span class="cl">            synchronized (Singleton.class) {
</span></span><span class="line"><span class="cl">                if (singleton == null) {
</span></span><span class="line"><span class="cl">                    singleton = new Singleton();
</span></span><span class="line"><span class="cl">                }
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        return singleton;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    private Object readResolve() {
</span></span><span class="line"><span class="cl">        return singleton;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><h3 id="工厂模式">工厂模式</h3>
<p>工厂模式是将实例化的对象代码提取出来,放到一个类中统一管理和维护,达到和主项目的依赖关系的解耦,从而提高项目的扩展和维护性.创建对象实例时,不要直接<code>new</code>类而是把这个<code>new</code>类的动作放在一个工厂的方法中,并返回.不要让类继承具体的类,而是继承抽象类或者实现接口.</p>
<p>详情查看以下三种工厂设计模式.</p>
<h4 id="简单工厂模式">简单工厂模式</h4>
<blockquote>
<p>简单工厂模式：定义一个工厂类，它可以根据参数的不同返回不同类的实例，被创建的实例通常都具有共同的父类。因为在简单工厂模式中用于创建实例的方法是静态方法，因此简单工厂模式又被称为静态工厂方法模式，它属于类创建型模式。</p>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public class SimpleFactoryDemo {
</span></span><span class="line"><span class="cl">    public static void main(String[] args) {
</span></span><span class="line"><span class="cl">        SimpleFactory.getTest(1);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">class SimpleFactoryImpl1 implements SimpleFactoryInterface {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    public void test() {
</span></span><span class="line"><span class="cl">        System.out.println(&#34;i am  simpleFactory 1 ...&#34;);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">class SimpleFactoryImpl2 implements SimpleFactoryInterface {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    public void test() {
</span></span><span class="line"><span class="cl">        System.out.println(&#34;i am  simpleFactory 2 ...&#34;);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">class SimpleFactory {
</span></span><span class="line"><span class="cl">    public static void getTest(int n) {
</span></span><span class="line"><span class="cl">        switch (n) {
</span></span><span class="line"><span class="cl">            case 1:
</span></span><span class="line"><span class="cl">                SimpleFactoryImpl1 simpleFactory = new SimpleFactoryImpl1();
</span></span><span class="line"><span class="cl">                simpleFactory.test();
</span></span><span class="line"><span class="cl">                break;
</span></span><span class="line"><span class="cl">            case 2:
</span></span><span class="line"><span class="cl">                SimpleFactoryImpl2 simpleFactoryImpl2 = new SimpleFactoryImpl2();
</span></span><span class="line"><span class="cl">                simpleFactoryImpl2.test();
</span></span><span class="line"><span class="cl">                break;
</span></span><span class="line"><span class="cl">            default:
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><p>简单工厂模式总结:</p>
<ul>
<li><strong>优点</strong> 实现了对象创建和使用的分离,代码解耦.符合面向接口(指对外暴露的接口或类)编程思想</li>
<li><strong>缺点</strong> 如果代码逻辑,职责过多,则简单工厂会变的十分臃肿.
系统代码扩展困难.一旦添加新产品就不得不修改工厂逻辑，在产品类型较多时,有可能造成工厂逻辑过于复杂,不利于系统的扩展和维护.</li>
</ul>
<p>简单工厂模式适用于创建的对象比较少,业务逻辑不太复杂的情景</p>
<h4 id="工厂方法模式">工厂方法模式</h4>
<blockquote>
<p>工厂方法模式：定义一个用于创建对象的接口，让子类决定将哪一个类实例化。工厂方法模式让一个类的实例化延迟到其子类。工厂方法模式又简称为工厂模式，又可称作虚拟构造器模式或多态工厂模式。工厂方法模式是一种类创建型模式。</p>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public class FactoryMethodDemo {
</span></span><span class="line"><span class="cl">    public static void main(String[] args) {
</span></span><span class="line"><span class="cl">        FoodFactory f = new ColdRiceNoodleFactory();
</span></span><span class="line"><span class="cl">        f.getFood().eat();
</span></span><span class="line"><span class="cl">        // 扩展需要增加产品及相应产品工厂并实现相关接口
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">interface Food {
</span></span><span class="line"><span class="cl">    void eat();
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">interface FoodFactory {
</span></span><span class="line"><span class="cl">    Food getFood();
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">class RiceNoodle implements Food{
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    public void eat() {
</span></span><span class="line"><span class="cl">        System.out.println(&#34;eat rice noodle ...&#34;);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">class RiceNoodleFactory implements FoodFactory{
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    public Food getFood() {
</span></span><span class="line"><span class="cl">        return new RiceNoodle();
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">class ColdRiceNoodle implements Food {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    public void eat() {
</span></span><span class="line"><span class="cl">        System.out.println(&#34;eat cold rice noodle ...&#34;);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">class ColdRiceNoodleFactory implements FoodFactory {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    public Food getFood() {
</span></span><span class="line"><span class="cl">        return new ColdRiceNoodle();
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><p>工厂方法模式是简单工厂模式的延伸,它<strong>继承了简单工厂模式的优点,同时还弥补了简单工厂模式的不足.</strong>
使用工厂方法模式扩展时,无须修改抽象工厂和抽象产品提供的接口,无须修改客户端,也无须修改其他的具体工厂和具体产品,而只<strong>要添加一个具体工厂和具体产品</strong>就可以了，这样，系统的可扩展性也就变得非常好，完全符合“开闭原则”。</p>
<p>但是在添加新产品时，需要编写新的具体产品类，而且还要提供与之对应的具体工厂类，<strong>系统中类的个数将成对增加</strong>，在一定程度上增加了系统的复杂度，有更多的类需要编译和运行，会给系统带来一些额外的开销。</p>
<h4 id="抽象工厂模式">抽象工厂模式</h4>
<blockquote>
<p>抽象工厂模式：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为Kit模式，它是一种对象创建型模式。</p>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">interface Food {
</span></span><span class="line"><span class="cl">    void eat();
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">interface FoodFactory {
</span></span><span class="line"><span class="cl">    ColdRiceNoodle getColdRiceNoodle();
</span></span><span class="line"><span class="cl">    RiceNoodle getRiceNoodle();
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">class RiceNoodle implements Food{
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    public void eat() {
</span></span><span class="line"><span class="cl">        System.out.println(&#34;eating rice noodle&#34;);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">class ColdRiceNoodle implements Food{
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    public void eat() {
</span></span><span class="line"><span class="cl">        System.out.println(&#34;eating cold rice noodle&#34;);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">class RiceNoodleFactory implements FoodFactory {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    public ColdRiceNoodle getColdRiceNoodle() {
</span></span><span class="line"><span class="cl">        return new ColdRiceNoodle();
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    public RiceNoodle getRiceNoodle() {
</span></span><span class="line"><span class="cl">        return new RiceNoodle();
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">class ColdRiceNoodleFactory implements FoodFactory {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    public ColdRiceNoodle getColdRiceNoodle() {
</span></span><span class="line"><span class="cl">        return new ColdRiceNoodle();
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    public RiceNoodle getRiceNoodle() {
</span></span><span class="line"><span class="cl">        return new RiceNoodle();
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><p>抽象工厂模式是工厂方法模式的进一步延伸,仍然具有工厂方法和简单工厂的<strong>优点</strong>.抽象工厂模式隔离了具体类的生成,使得客户并不需要知道什么被创建。由于这种隔离，更换一个具体工厂就变得相对容易，所有的具体工厂都实现了抽象工厂中定义的那些公共接口，因此只需改变具体工厂的实例，就可以在某种程度上改变整个软件系统的行为.</p>
<p>但是抽象工厂也存在一些<strong>缺点</strong>,增加新的产品等级结构麻烦，需要对原有系统进行较大的修改，甚至需要修改抽象层代码，这显然会带来较大的不便，违背了“开闭原则”。</p>
<h3 id="原型模式">原型模式</h3>
<p>在Java中通过<code>new</code>关键字创建的对象是非常繁琐的,在我们需要大量对象的情况下,原型模式就是我们可以考虑实现的方式.</p>
<blockquote>
<p>原型模式：使用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。原型模式是一种对象创建型模式</p>
</blockquote>
<p>原型模式我们也称为克隆模式，即一个某个对象为原型克隆出来一个一模一样的对象，该对象的属性和原型对象一模一样。而且对于原型对象没有任何影响。<strong>原型模式的克隆方式有两种：浅克隆和深度克隆;浅克隆和深克隆的主要区别在于是否支持引用类型的成员变量的复制.</strong></p>
<h4 id="浅克隆">浅克隆</h4>
<p>在浅克隆中,当对象被复制时只复制它本身和其中包含的值类型的成员变量,而引用类型的成员对象并没有复制.</p>
<p>代码实现</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public class ShallowClone {
</span></span><span class="line"><span class="cl">    public static void main(String[] args) {
</span></span><span class="line"><span class="cl">        CloneHuman cloneHuman = new CloneHuman(&#34;黑色&#34;,&#34;大眼睛&#34;,&#34;高鼻梁&#34;,&#34;大嘴巴&#34;,new Date(123231231231L));
</span></span><span class="line"><span class="cl">        for (int i = 0; i &lt; 20; i++) {
</span></span><span class="line"><span class="cl">            try {
</span></span><span class="line"><span class="cl">                CloneHuman clone = (CloneHuman)cloneHuman.clone();
</span></span><span class="line"><span class="cl">                System.out.printf(&#34;头发：%s,眼睛：%s,鼻子：%s,嘴巴：%s,生日：%s&#34;,clone.getHair(),clone.getEye(),clone.getNodes(),clone.getMouse(),clone.getBirth());
</span></span><span class="line"><span class="cl">                System.out.println();
</span></span><span class="line"><span class="cl">                System.out.println(&#34;浅克隆，引用类型地址比较：&#34; + (cloneHuman.getBirth() == clone.getBirth()));
</span></span><span class="line"><span class="cl">            } catch (CloneNotSupportedException e) {
</span></span><span class="line"><span class="cl">                System.out.println(e.getMessage());
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">class CloneHuman  implements Cloneable {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    private String hair;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    private String eye;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    private String nodes;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    private String mouse;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    private Date birth;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public String getHair() {
</span></span><span class="line"><span class="cl">        return hair;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public void setHair(String hair) {
</span></span><span class="line"><span class="cl">        this.hair = hair;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public String getEye() {
</span></span><span class="line"><span class="cl">        return eye;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public void setEye(String eye) {
</span></span><span class="line"><span class="cl">        this.eye = eye;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public String getNodes() {
</span></span><span class="line"><span class="cl">        return nodes;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public void setNodes(String nodes) {
</span></span><span class="line"><span class="cl">        this.nodes = nodes;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public String getMouse() {
</span></span><span class="line"><span class="cl">        return mouse;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public void setMouse(String mouse) {
</span></span><span class="line"><span class="cl">        this.mouse = mouse;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public CloneHuman(String hair, String eye, String nodes, String mouse,Date brith) {
</span></span><span class="line"><span class="cl">        this.hair = hair;
</span></span><span class="line"><span class="cl">        this.eye = eye;
</span></span><span class="line"><span class="cl">        this.nodes = nodes;
</span></span><span class="line"><span class="cl">        this.mouse = mouse;
</span></span><span class="line"><span class="cl">        this.birth = brith;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    protected Object clone() throws CloneNotSupportedException {
</span></span><span class="line"><span class="cl">        return super.clone();
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public Date getBirth() {
</span></span><span class="line"><span class="cl">        return birth;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public void setBirth(Date birth) {
</span></span><span class="line"><span class="cl">        this.birth = birth;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><blockquote>
<p>PS Java语言提供的<code>Cloneable</code>接口和<code>Serializable</code>接口的代码非常简单，它们都是空接口，这种空接口也称为标识接口，标识接口中没有任何方法的定义，其作用是告诉JRE这些接口的实现类是否具有某个功能，如是否支持克隆、是否支持序列化等。</p>
</blockquote>
<p>应该注意的是，<code>clone()</code>方法并不是<code>Cloneable</code>接口的方法，而是<code>Object</code>的一个<code>protected</code>方法。<code>Cloneable</code>接口只是规定，如果一个类没有实现<code>Cloneable</code>接口又调用了<code>clone()</code>方法，就会抛出 <code>CloneNotSupportedException</code>。</p>
<h4 id="深克隆">深克隆</h4>
<p>在深克隆中,除了对象本身被复制外,对象所包含的所有成员变量也将复制.
深克隆有两种实现方式,第一种是在浅克隆的基础上实现,第二种是通过序列化和反序列化实现</p>
<p><strong>在浅克隆的基础上实现</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public class DeepClone {
</span></span><span class="line"><span class="cl">    public static void main(String[] args) {
</span></span><span class="line"><span class="cl">        CloneHuman cloneHuman = new CloneHuman(&#34;黑色&#34;,&#34;大眼睛&#34;,&#34;高鼻梁&#34;,&#34;大嘴巴&#34;,new Date(123231231231L));
</span></span><span class="line"><span class="cl">        for (int i = 0; i &lt; 20; i++) {
</span></span><span class="line"><span class="cl">            try {
</span></span><span class="line"><span class="cl">                CloneHuman clone = (CloneHuman)cloneHuman.clone();
</span></span><span class="line"><span class="cl">                System.out.printf(&#34;头发：%s,眼睛：%s,鼻子：%s,嘴巴：%s,生日：%s&#34;,clone.getHair(),clone.getEye(),clone.getNodes(),clone.getMouse(),clone.getBirth());
</span></span><span class="line"><span class="cl">                System.out.println();
</span></span><span class="line"><span class="cl">                System.out.println(&#34;深克隆，引用类型地址比较：&#34; + (cloneHuman.getBirth() == clone.getBirth()));
</span></span><span class="line"><span class="cl">            } catch (CloneNotSupportedException e) {
</span></span><span class="line"><span class="cl">                System.out.println(e.getMessage());
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">class CloneHuman  implements Cloneable {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    private String hair;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    private String eye;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    private String nodes;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    private String mouse;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    private Date birth;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public String getHair() {
</span></span><span class="line"><span class="cl">        return hair;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public void setHair(String hair) {
</span></span><span class="line"><span class="cl">        this.hair = hair;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public String getEye() {
</span></span><span class="line"><span class="cl">        return eye;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public void setEye(String eye) {
</span></span><span class="line"><span class="cl">        this.eye = eye;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public String getNodes() {
</span></span><span class="line"><span class="cl">        return nodes;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public void setNodes(String nodes) {
</span></span><span class="line"><span class="cl">        this.nodes = nodes;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public String getMouse() {
</span></span><span class="line"><span class="cl">        return mouse;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public void setMouse(String mouse) {
</span></span><span class="line"><span class="cl">        this.mouse = mouse;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public CloneHuman(String hair, String eye, String nodes, String mouse,Date brith) {
</span></span><span class="line"><span class="cl">        this.hair = hair;
</span></span><span class="line"><span class="cl">        this.eye = eye;
</span></span><span class="line"><span class="cl">        this.nodes = nodes;
</span></span><span class="line"><span class="cl">        this.mouse = mouse;
</span></span><span class="line"><span class="cl">        this.birth = brith;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    protected Object clone() throws CloneNotSupportedException {
</span></span><span class="line"><span class="cl">        CloneHuman human = (CloneHuman)super.clone();
</span></span><span class="line"><span class="cl">        human.birth = (Date)this.birth.clone();
</span></span><span class="line"><span class="cl">        return human;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public Date getBirth() {
</span></span><span class="line"><span class="cl">        return birth;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public void setBirth(Date birth) {
</span></span><span class="line"><span class="cl">        this.birth = birth;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><p><strong>序列化反序列化实现深克隆</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public class DeepClone2 {
</span></span><span class="line"><span class="cl">    public static void main(String[] args) throws IOException, ClassNotFoundException {
</span></span><span class="line"><span class="cl">        CloneHuman2 cloneHuman1 = new CloneHuman2(&#34;黑色&#34;,&#34;大眼睛&#34;,&#34;高鼻梁&#34;,&#34;大嘴巴&#34;,new Date(123231231231L));
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        // 使用序列化和反序列化实现深克隆
</span></span><span class="line"><span class="cl">        ByteArrayOutputStream bos = new ByteArrayOutputStream();
</span></span><span class="line"><span class="cl">        ObjectOutputStream oos = new ObjectOutputStream(bos);
</span></span><span class="line"><span class="cl">        oos.writeObject(cloneHuman1);
</span></span><span class="line"><span class="cl">        byte[] bytes = bos.toByteArray();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        ByteArrayInputStream bis = new ByteArrayInputStream(bytes);
</span></span><span class="line"><span class="cl">        ObjectInputStream ois = new ObjectInputStream(bis);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        // 克隆好的对象
</span></span><span class="line"><span class="cl">        CloneHuman2 cloneHuman2 = (CloneHuman2) ois.readObject();
</span></span><span class="line"><span class="cl">        System.out.println(&#34;深克隆，引用类型地址比较：&#34; + (cloneHuman1.getBirth() == cloneHuman2.getBirth()));
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">class CloneHuman2  implements Cloneable, Serializable {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    private String hair;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    private String eye;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    private String nodes;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    private String mouse;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    private Date birth;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public String getHair() {
</span></span><span class="line"><span class="cl">        return hair;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public void setHair(String hair) {
</span></span><span class="line"><span class="cl">        this.hair = hair;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public String getEye() {
</span></span><span class="line"><span class="cl">        return eye;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public void setEye(String eye) {
</span></span><span class="line"><span class="cl">        this.eye = eye;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public String getNodes() {
</span></span><span class="line"><span class="cl">        return nodes;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public void setNodes(String nodes) {
</span></span><span class="line"><span class="cl">        this.nodes = nodes;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public String getMouse() {
</span></span><span class="line"><span class="cl">        return mouse;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public void setMouse(String mouse) {
</span></span><span class="line"><span class="cl">        this.mouse = mouse;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public CloneHuman2(String hair, String eye, String nodes, String mouse,Date brith) {
</span></span><span class="line"><span class="cl">        this.hair = hair;
</span></span><span class="line"><span class="cl">        this.eye = eye;
</span></span><span class="line"><span class="cl">        this.nodes = nodes;
</span></span><span class="line"><span class="cl">        this.mouse = mouse;
</span></span><span class="line"><span class="cl">        this.birth = brith;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    protected Object clone() throws CloneNotSupportedException {
</span></span><span class="line"><span class="cl">        CloneHuman2 human = (CloneHuman2)super.clone();
</span></span><span class="line"><span class="cl">        human.birth = (Date)this.birth.clone();
</span></span><span class="line"><span class="cl">        return human;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public Date getBirth() {
</span></span><span class="line"><span class="cl">        return birth;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public void setBirth(Date birth) {
</span></span><span class="line"><span class="cl">        this.birth = birth;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><h4 id="总结">总结</h4>
<p>原型模式作为一种快速创建大量相同或相似对象的方式，在软件开发中应用较为广泛，很多软件提供的复制和粘贴操作就是原型模式的典型应用.</p>
<p>通过<code>clone</code>的方式在获取大量对象的时候性能开销基本没有什么影响，而<code>new</code>的方式随着实例的对象越来越多，性能会急剧下降，所以原型模式是一种比较重要的获取实例的方式.</p>
<p><strong>优点</strong></p>
<ul>
<li>当创建新的对象实例较为复杂时，使用原型模式可以简化对象的创建过程，提高创建对象的效率。</li>
<li>可以使用深克隆的方式保存对象的状态，使用原型模式将对象复制一份并将其状态保存起来，可辅助实现撤销操作。</li>
<li>扩展性较好，由于在原型模式中提供了抽象原型类，在客户端可以针对抽象原型类进行编程，而将具体原型类写在配置文件中，增加或减少产品类对原有系统都没有任何影响。</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>需要为每一个类配备一个克隆方法，而且该克隆方法位于一个类的内部，当对已有的类进行改造时，需要修改源代码，违背了“开闭原则”。</li>
<li>在实现深克隆时需要编写较为复杂的代码，而且当对象之间存在多重的嵌套引用时，为了实现深克隆，每一层对象对应的类都必须支持深克隆，实现起来可能会比较麻烦。</li>
</ul>
<p><strong>使用场景</strong></p>
<p>原型模式很少单独出现，一般是和工厂方法模式一起出现，通过<code>clone</code>的方法创建一个对象，然后由工厂方法提供给调用者。
spring中bean的创建实际就是两种：单例模式和原型模式。</p>
<ul>
<li>创建新对象成本较大，新的对象可以通过原型模式对已有对象进行复制来获得。</li>
<li>系统要保存对象的状态，而对象的状态变化很小，或者对象本身占用内存较少时，可以使用原型模式配合备忘录模式来实现。</li>
</ul>
<h3 id="建造者模式">建造者模式</h3>
<blockquote>
<p>建造者模式：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。建造者模式是一种对象创建型模式。</p>
</blockquote>
<p>建造者模式是较为复杂的创建型模式，它将客户端与包含多个组成部分（或部件）的复杂对象的创建过程分离，客户端无须知道复杂对象的内部组成部分与装配方式，只需要知道所需建造者的类型即可。它关注如何一步一步创建一个的复杂对象，不同的具体建造者定义了不同的创建过程，且具体建造者相互独立，增加新的建造者非常方便，无须修改已有代码，系统具有较好的扩展性。</p>
<p>代码实现</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public class MainTest {
</span></span><span class="line"><span class="cl">    public static void main(String[] args) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        Director director = new Director();
</span></span><span class="line"><span class="cl">        Builder commonBuilder = new CommonRole();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        director.construct(commonBuilder);
</span></span><span class="line"><span class="cl">        Role commonRole = commonBuilder.getRole();
</span></span><span class="line"><span class="cl">        System.out.println(commonRole);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">class Role {
</span></span><span class="line"><span class="cl">    private String head;
</span></span><span class="line"><span class="cl">    private String body;
</span></span><span class="line"><span class="cl">    private String foot;
</span></span><span class="line"><span class="cl">    private String sp;
</span></span><span class="line"><span class="cl">    private String hp;
</span></span><span class="line"><span class="cl">    private String name;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public void setSp(String sp) {
</span></span><span class="line"><span class="cl">        this.sp = sp;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public String getSp() {
</span></span><span class="line"><span class="cl">        return sp;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public void setHp(String hp) {
</span></span><span class="line"><span class="cl">        this.hp = hp;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public String getHp() {
</span></span><span class="line"><span class="cl">        return hp;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public void setName(String name) {
</span></span><span class="line"><span class="cl">        this.name = name;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public String getName() {
</span></span><span class="line"><span class="cl">        return name;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    public String toString() {
</span></span><span class="line"><span class="cl">        return &#34;Role{&#34; +
</span></span><span class="line"><span class="cl">                &#34;head=&#39;&#34; + head + &#39;\&#39;&#39; +
</span></span><span class="line"><span class="cl">                &#34;, body=&#39;&#34; + body + &#39;\&#39;&#39; +
</span></span><span class="line"><span class="cl">                &#34;, foot=&#39;&#34; + foot + &#39;\&#39;&#39; +
</span></span><span class="line"><span class="cl">                &#34;, sp=&#39;&#34; + sp + &#39;\&#39;&#39; +
</span></span><span class="line"><span class="cl">                &#34;, hp=&#39;&#34; + hp + &#39;\&#39;&#39; +
</span></span><span class="line"><span class="cl">                &#34;, name=&#39;&#34; + name + &#39;\&#39;&#39; +
</span></span><span class="line"><span class="cl">                &#39;}&#39;;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">abstract class Builder {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public abstract void builderHead();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public abstract void builderBody();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public abstract void builderFoot();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public abstract void builderSp();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public abstract void builderHp();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public abstract void builderName();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public Role getRole() {
</span></span><span class="line"><span class="cl">        return new Role();
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">class CommonRole extends Builder {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    private Role role = new Role();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    public void builderHead() {
</span></span><span class="line"><span class="cl">        System.out.println(&#34;building head .....&#34;);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    public void builderBody() {
</span></span><span class="line"><span class="cl">        System.out.println(&#34;building body .....&#34;);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    public void builderFoot() {
</span></span><span class="line"><span class="cl">        System.out.println(&#34;building foot .....&#34;);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    public void builderSp() {
</span></span><span class="line"><span class="cl">        role.setSp(&#34;100&#34;);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    public void builderHp() {
</span></span><span class="line"><span class="cl">        role.setHp(&#34;100&#34;);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    public void builderName() {
</span></span><span class="line"><span class="cl">        role.setName(&#34;lucy&#34;);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    public Role getRole() {
</span></span><span class="line"><span class="cl">        return role;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">class Director {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public void construct(Builder builder) {
</span></span><span class="line"><span class="cl">        builder.builderHead();
</span></span><span class="line"><span class="cl">        builder.builderBody();
</span></span><span class="line"><span class="cl">        builder.builderFoot();
</span></span><span class="line"><span class="cl">        builder.builderHp();
</span></span><span class="line"><span class="cl">        builder.builderSp();
</span></span><span class="line"><span class="cl">        builder.builderName();
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><p><strong>优点</strong></p>
<ul>
<li>客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象。</li>
<li>建造者模式很容易进行扩展。如果有新的需求，通过实现一个新的建造者类就可以完成，基本上不用修改之前已经测试通过的代码，因此也就不会对原有功能引入风险。符合<a href="#%E5%BC%80%E6%94%BE%E5%B0%81%E9%97%AD%E5%8E%9F%E5%88%99">开放封闭原则</a>。</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>若产品内部发生变化，建造者都要修改，成本较大；若内部变化复杂，会有很多的建造类。</li>
<li>产品必须有共同点，使用范围有限。建造者模式创造出来的产品，其组成部分基本相同。如果产品之间的差异较大，则不适用这个模式。</li>
</ul>
<p><strong>使用场景</strong></p>
<ul>
<li>需要生成的产品对象有复杂的内部结构，这些产品对象通常包含多个成员属性。</li>
<li>需要生成的产品对象的属性相互依赖，需要指定其生成顺序。</li>
<li>对象的创建过程独立于创建该对象的类。在建造者模式中引入了指挥者类，将创建过程封装在指挥者类中，而不在建造者类中。</li>
<li>隔离复杂对象的创建和使用，并使得相同的创建过程可以创建不同的产品。</li>
</ul>
<h3 id="适配器模式">适配器模式</h3>
<blockquote>
<p>适配器模式：将一个接口转换成客户希望的另一个<strong>接口</strong>(指广义的接口，它可以表示一个方法或者方法的集合)，使接口不兼容的那些类可以一起工作，其别名为包装器。适配器模式既可以作为类结构型模式，也可以作为对象结构型模式。</p>
</blockquote>
<p>在适配器模式中，我们通过增加一个新的适配器类来解决接口不兼容的问题，使得原本没有任何关系的类可以协同工作。<strong>根据适配器类与适配者类的关系不同，适配器模式可分为对象适配器和类适配器两种，在对象适配器模式中，适配器与适配者之间是关联关系；在类适配器模式中，适配器与适配者之间是继承（或实现）关系。</strong></p>
<h4 id="对象适配器">对象适配器</h4>
<p>由于在Java中不支持多重继承，而且有破坏封装之嫌。所以提倡<a href="#%E7%BB%A7%E6%89%BF%E4%B8%8E%E7%BB%84%E5%90%88">多用组合少用继承</a>，在实际开发中推荐使用对象适配器模式。</p>
<p>代码实现</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public class MainTest {
</span></span><span class="line"><span class="cl">    public static void main(String[] args) {
</span></span><span class="line"><span class="cl">        new RedHat(new Linux()).useInputMethod();
</span></span><span class="line"><span class="cl">        System.out.println(&#34;==============&#34;);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        new Win10(new Windows()).useInputMethod();
</span></span><span class="line"><span class="cl">        System.out.println(&#34;==============&#34;);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        Adapter adapter = new Adapter(new Windows());
</span></span><span class="line"><span class="cl">        new RedHat(adapter).useInputMethod();
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">interface LinuxSoftware {
</span></span><span class="line"><span class="cl">    void inputMethod();
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">interface WindowsSoftware {
</span></span><span class="line"><span class="cl">    void inputMethod();
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">class Linux implements LinuxSoftware {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    public void inputMethod() {
</span></span><span class="line"><span class="cl">        System.out.println(&#34;linux 系统输入法 ...&#34;);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">class Windows implements WindowsSoftware {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    public void inputMethod() {
</span></span><span class="line"><span class="cl">        System.out.println(&#34;windows 系统输入法 ...&#34;);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">class RedHat {
</span></span><span class="line"><span class="cl">    private LinuxSoftware linuxSoftware;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public RedHat(LinuxSoftware linuxSoftware) {
</span></span><span class="line"><span class="cl">        this.linuxSoftware = linuxSoftware;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public void useInputMethod() {
</span></span><span class="line"><span class="cl">        System.out.println(&#34;开始使用 redHat 系统输入法 ...&#34;);
</span></span><span class="line"><span class="cl">        linuxSoftware.inputMethod();
</span></span><span class="line"><span class="cl">        System.out.println(&#34;结束使用 redHat 系统输入法 ...&#34;);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">class Win10 {
</span></span><span class="line"><span class="cl">    private WindowsSoftware windowsSoftware;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public Win10(WindowsSoftware windowsSoftware) {
</span></span><span class="line"><span class="cl">        this.windowsSoftware = windowsSoftware;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public void useInputMethod() {
</span></span><span class="line"><span class="cl">        System.out.println(&#34;开始使用 win10 系统输入法 ...&#34;);
</span></span><span class="line"><span class="cl">        windowsSoftware.inputMethod();
</span></span><span class="line"><span class="cl">        System.out.println(&#34;结束使用 win10 系统输入法 ...&#34;);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">// 在 Linux 系统上使用 windows 输入法
</span></span><span class="line"><span class="cl">class Adapter implements LinuxSoftware{
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    private WindowsSoftware windowsSoftware;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public Adapter(WindowsSoftware windowsSoftware) {
</span></span><span class="line"><span class="cl">        this.windowsSoftware = windowsSoftware;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    public void inputMethod() {
</span></span><span class="line"><span class="cl">        windowsSoftware.inputMethod();
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><h4 id="类适配器">类适配器</h4>
<p>类适配器模式和对象适配器模式最大的区别在于适配器和适配者之间的关系不同，对象适配器模式中适配器和适配者之间是关联关系，而类适配器模式中适配器和适配者是继承关系。</p>
<p>代码实现</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public class MainTest {
</span></span><span class="line"><span class="cl">    public static void main(String[] args) {
</span></span><span class="line"><span class="cl">        new RedHat(new Linux()).useInputMethod();
</span></span><span class="line"><span class="cl">        System.out.println(&#34;==============&#34;);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        new Win10(new Windows()).useInputMethod();
</span></span><span class="line"><span class="cl">        System.out.println(&#34;==============&#34;);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        Adapter adapter = new Adapter();
</span></span><span class="line"><span class="cl">        new RedHat(adapter).useInputMethod();
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">interface LinuxSoftware {
</span></span><span class="line"><span class="cl">    void inputMethod();
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">interface WindowsSoftware {
</span></span><span class="line"><span class="cl">    void inputMethod();
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">class Linux implements LinuxSoftware {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    public void inputMethod() {
</span></span><span class="line"><span class="cl">        System.out.println(&#34;linux 系统输入法 ...&#34;);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">class Windows implements WindowsSoftware {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    public void inputMethod() {
</span></span><span class="line"><span class="cl">        System.out.println(&#34;windows 系统输入法 ...&#34;);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">class RedHat {
</span></span><span class="line"><span class="cl">    private LinuxSoftware linuxSoftware;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public RedHat(LinuxSoftware linuxSoftware) {
</span></span><span class="line"><span class="cl">        this.linuxSoftware = linuxSoftware;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public void useInputMethod() {
</span></span><span class="line"><span class="cl">        System.out.println(&#34;开始使用 redHat 系统输入法 ...&#34;);
</span></span><span class="line"><span class="cl">        linuxSoftware.inputMethod();
</span></span><span class="line"><span class="cl">        System.out.println(&#34;结束使用 redHat 系统输入法 ...&#34;);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">class Win10 {
</span></span><span class="line"><span class="cl">    private WindowsSoftware windowsSoftware;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public Win10(WindowsSoftware windowsSoftware) {
</span></span><span class="line"><span class="cl">        this.windowsSoftware = windowsSoftware;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public void useInputMethod() {
</span></span><span class="line"><span class="cl">        System.out.println(&#34;开始使用 win10 系统输入法 ...&#34;);
</span></span><span class="line"><span class="cl">        windowsSoftware.inputMethod();
</span></span><span class="line"><span class="cl">        System.out.println(&#34;结束使用 win10 系统输入法 ...&#34;);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">// 在 Linux 系统上使用 windows 输入法
</span></span><span class="line"><span class="cl">class Adapter extends Windows implements LinuxSoftware{
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    public void inputMethod() {
</span></span><span class="line"><span class="cl">        super.inputMethod();
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><h4 id="总结-1">总结</h4>
<p>适配器模式将现有接口转化为客户类所期望的接口，实现了对现有类的复用，它是一种使用频率非常高的设计模式，在软件开发中得以广泛应用，在Spring等开源框架、驱动程序设计（如JDBC中的数据库驱动程序）中也使用了适配器模式。</p>
<p><strong>优点</strong></p>
<ul>
<li>将目标类和适配者类解耦，通过引入一个适配器类来重用现有的适配者类，无须修改原有结构。</li>
<li>增加了类的透明性和复用性，同时系统的灵活性和扩展性都非常好，更换适配器或者增加新的适配器都非常方便。可以在不修改原有代码的基础上增加新的适配器类，完全符合<a href="#%E5%BC%80%E6%94%BE%E5%B0%81%E9%97%AD%E5%8E%9F%E5%88%99">开放封闭原则</a>。</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>过多地使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是 A 接口，其实内部被适配成了 B 接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器。</li>
<li>对象适配器模式的缺点是很难置换适配者类的方法。</li>
<li>类适配器模式中的目标抽象类只能为接口，不能为类，其使用有一定的局限性。</li>
</ul>
<p><strong>使用场景</strong></p>
<p>系统需要使用现有的类，而这些类的接口不符合系统的需要；想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类一起工作。</p>
<ul>
<li>系统需要使用现有的类，而此类的接口不符合系统的需要。</li>
<li>想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作，这些源类不一定有一致的接口。</li>
<li>通过接口转换，将一个类插入另一个类系中。（比如老虎和飞禽，现在多了一个飞虎，在不增加实体的需求下，增加一个适配器，在里面包容一个虎对象，实现飞的接口。）</li>
</ul>
<h3 id="桥接模式">桥接模式</h3>
<blockquote>
<p>桥接模式：将实现与抽象放在两个不同的类层次中，使两个层次可以独立改变。它是一种对象结构型模式，又称为柄体模式或接口模式。</p>
</blockquote>
<p>桥接模式是一种很实用的结构型设计模式，如果软件系统中某个类存在两个独立变化的维度，通过该模式可以将这两个维度分离出来，使两者可以独立扩展，让系统更加符合“单一职责原则”。</p>
<p>例如像手机制造：内存是一个公司生产，芯片是另一个公司生产，而品牌又是另一个公司。我们需要什么样子的手机就把相应的芯片、内存组装起来。桥接模式就是把两个不同维度的东西桥接起来。</p>
<p>代码实现</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public class MainTest {
</span></span><span class="line"><span class="cl">    public static void main(String[] args) {
</span></span><span class="line"><span class="cl">        Phone_A phone_a = new Phone_A();
</span></span><span class="line"><span class="cl">        phone_a.setAbstractChip(new Chip_A());
</span></span><span class="line"><span class="cl">        phone_a.setAbstractMemory(new Memory_A());
</span></span><span class="line"><span class="cl">        phone_a.finished();
</span></span><span class="line"><span class="cl">        System.out.println(&#34;=================&#34;);
</span></span><span class="line"><span class="cl">        Phone_B phone_b = new Phone_B();
</span></span><span class="line"><span class="cl">        phone_b.setAbstractChip(new Chip_B());
</span></span><span class="line"><span class="cl">        phone_b.setAbstractMemory(new Memory_A());
</span></span><span class="line"><span class="cl">        phone_b.finished();
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">abstract class AbstractMemory {
</span></span><span class="line"><span class="cl">    protected abstract void size();
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">abstract class AbstractChip {
</span></span><span class="line"><span class="cl">    protected abstract void type();
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">abstract class  AbstractPhone {
</span></span><span class="line"><span class="cl">    protected AbstractMemory abstractMemory;
</span></span><span class="line"><span class="cl">    protected AbstractChip abstractChip;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public void setAbstractChip(AbstractChip abstractChip) {
</span></span><span class="line"><span class="cl">        this.abstractChip = abstractChip;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public void setAbstractMemory(AbstractMemory abstractMemory) {
</span></span><span class="line"><span class="cl">        this.abstractMemory = abstractMemory;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    protected abstract void finished();
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">class Memory_A  extends AbstractMemory{
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    protected void size() {
</span></span><span class="line"><span class="cl">        System.out.println(&#34;create 6G of memory ...&#34;);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">class Memory_B  extends AbstractMemory{
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    protected void size() {
</span></span><span class="line"><span class="cl">        System.out.println(&#34;create 8G of memory ...&#34;);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">class Chip_A extends AbstractChip {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    protected void type() {
</span></span><span class="line"><span class="cl">        System.out.println(&#34;snapdragon 888 chip ...&#34;);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">class Chip_B extends AbstractChip {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    protected void type() {
</span></span><span class="line"><span class="cl">        System.out.println(&#34;A14 chip ...&#34;);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">class Phone_A  extends AbstractPhone{
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    protected void finished() {
</span></span><span class="line"><span class="cl">        abstractMemory.size();
</span></span><span class="line"><span class="cl">        abstractChip.type();
</span></span><span class="line"><span class="cl">        System.out.println(&#34;phone_a assembly completed ...&#34;);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">class Phone_B  extends AbstractPhone{
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    protected void finished() {
</span></span><span class="line"><span class="cl">        abstractMemory.size();
</span></span><span class="line"><span class="cl">        abstractChip.type();
</span></span><span class="line"><span class="cl">        System.out.println(&#34;phone_b assembly completed ...&#34;);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><p>桥接模式是设计Java虚拟机和实现JDBC等驱动程序的核心模式之一，应用较为广泛。在软件开发中如果一个类或一个系统有多个变化维度时，都可以尝试使用桥接模式对其进行设计。桥接模式为多维度变化的系统提供了一套完整的解决方案，并且降低了系统的复杂度。</p>
<p><strong>优点</strong></p>
<ul>
<li>实现了抽象和实现部分的分离，从而极大的提供了系统的灵活性，让抽象部分和实现部分独立开来，这有助于系统进行分层设计，从而产生更好的结构化系统。</li>
<li>优秀的扩展能力。在两个变化维度中任意扩展一个维度，都不需要修改原有系统，符合<a href="#%E5%BC%80%E6%94%BE%E5%B0%81%E9%97%AD%E5%8E%9F%E5%88%99">开放封闭原则</a>。</li>
<li>桥接模式替代多层继承方案，可以减少子类的个数，降低系统的管理和维护成本。</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>桥接模式的引入会增加系统的理解与设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计与编程。</li>
<li>桥接模式要求正确识别出系统中两个独立变化的维度(抽象、和实现)，因此其使用范围有一定的局限性，即需要有这样的应用场景，如何正确识别两个独立维度也需要一定的经验积累。</li>
</ul>
<p><strong>使用场景</strong></p>
<ul>
<li>桥接模式主要解决在有多种可能会变化的情况下，用继承会造成类爆炸问题，扩展起来不灵活。对于两个独立变化的维度，使用桥接模式再适合不过了。</li>
<li>如果一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性，避免在两个层次之间建立静态的继承联系，通过桥接模式可以使它们在抽象层建立一个关联关系。</li>
</ul>
<h3 id="组合模式">组合模式</h3>
<blockquote>
<p>组合模式：组合多个对象形成树形结构以表示具有“整体—部分”关系的层次结构。组合模式对单个对象和组合对象的使用具有一致性，组合模式又可以称为“整体—部分”模式，它是一种对象结构型模式。</p>
</blockquote>
<p>组合模式，是用于把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次。</p>
<p>代码实现</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public class MainTest {
</span></span><span class="line"><span class="cl">    public static void main(String[] args) {
</span></span><span class="line"><span class="cl">        Tree tree = new Tree();
</span></span><span class="line"><span class="cl">        tree.add(new LeftNode());
</span></span><span class="line"><span class="cl">        tree.add(new RightNode());
</span></span><span class="line"><span class="cl">        tree.implmethod();
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">abstract class AbstractTree {
</span></span><span class="line"><span class="cl">    protected abstract void add(AbstractTree node);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    protected abstract void remove(AbstractTree node);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    protected abstract void implmethod();
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">class LeftNode extends AbstractTree {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    protected void add(AbstractTree node) {
</span></span><span class="line"><span class="cl">        System.out.println(&#34;Exception: the method is not supported. &#34;);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    protected void remove(AbstractTree node) {
</span></span><span class="line"><span class="cl">        System.out.println(&#34;Exception: the method is not supported. &#34;);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    protected void implmethod() {
</span></span><span class="line"><span class="cl">        System.out.println(&#34;left node method ...&#34;);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">class RightNode extends AbstractTree {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    protected void add(AbstractTree node) {
</span></span><span class="line"><span class="cl">        System.out.println(&#34;Exception: the method is not supported. &#34;);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    protected void remove(AbstractTree node) {
</span></span><span class="line"><span class="cl">        System.out.println(&#34;Exception: the method is not supported. &#34;);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    protected void implmethod() {
</span></span><span class="line"><span class="cl">        System.out.println(&#34;right node method ...&#34;);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">class Tree extends AbstractTree {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    private ArrayList&lt;AbstractTree&gt; treeList = new ArrayList&lt;&gt;();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    protected void add(AbstractTree node) {
</span></span><span class="line"><span class="cl">        treeList.add(node);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    protected void remove(AbstractTree node) {
</span></span><span class="line"><span class="cl">        treeList.remove(node);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    protected void implmethod() {
</span></span><span class="line"><span class="cl">        System.out.println(&#34;tree node&#34;);
</span></span><span class="line"><span class="cl">        for (AbstractTree node : treeList) {
</span></span><span class="line"><span class="cl">            node.implmethod();
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><p>组合模式使用面向对象的思想来实现树形结构的构建与处理，描述了如何将容器对象和叶子对象进行递归组合，实现简单，灵活性好。由于在软件开发中存在大量的树形结构，因此组合模式是一种使用频率较高的结构型设计模式。在XML解析、组织结构树处理、文件系统设计等领域，组合模式都得到了广泛应用。</p>
<p><strong>优点</strong></p>
<ul>
<li>高层模块调用简单。客户端可以一致地使用一个组合结构或其中单个对象，不必关心处理的是单个对象还是整个组合结构。</li>
<li>在组合模式中节点增加自由，无须对现有类库进行任何修改，符合<a href="#%E5%BC%80%E6%94%BE%E5%B0%81%E9%97%AD%E5%8E%9F%E5%88%99">开闭原则</a>。</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>在使用组合模式时，其叶子和树的声明都是实现类，而不是接口，违反了<a href="#%E4%BE%9D%E8%B5%96%E5%80%92%E7%BD%AE%E5%8E%9F%E5%88%99">依赖倒置原则</a>。</li>
</ul>
<p><strong>使用场景</strong></p>
<ul>
<li>部分、整体场景，如树形菜单，文件、文件夹的管理。</li>
<li>希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象。</li>
</ul>
<h3 id="装饰模式">装饰模式</h3>
<blockquote>
<p>装饰模式：动态地给一个对象增加一些额外的职责，就增加对象功能来说，装饰模式比生成子类实现更为灵活。装饰模式是一种对象结构型模式。</p>
</blockquote>
<p>代码实现</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public class MainTest {
</span></span><span class="line"><span class="cl">    public static void main(String[] args) {
</span></span><span class="line"><span class="cl">        Drink coffee = new ShortBlock();
</span></span><span class="line"><span class="cl">        System.out.println(&#34;订单价格：&#34;+ coffee.cost());
</span></span><span class="line"><span class="cl">        System.out.println(&#34;订单描述：&#34; + coffee.getDesc());
</span></span><span class="line"><span class="cl">        System.out.println(&#34;=====================&#34;);
</span></span><span class="line"><span class="cl">        coffee = new Chocolate(coffee);
</span></span><span class="line"><span class="cl">        System.out.println(&#34;订单价格：&#34;+ coffee.cost());
</span></span><span class="line"><span class="cl">        System.out.println(&#34;订单描述：&#34; + coffee.getDesc());
</span></span><span class="line"><span class="cl">        System.out.println(&#34;=====================&#34;);
</span></span><span class="line"><span class="cl">        coffee = new Milk(coffee);
</span></span><span class="line"><span class="cl">        System.out.println(&#34;订单价格：&#34;+ coffee.cost());
</span></span><span class="line"><span class="cl">        System.out.println(&#34;订单描述：&#34; + coffee.getDesc());
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">abstract class Drink {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public String desc;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    private double price = 0.0;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public void setDesc(String desc) {
</span></span><span class="line"><span class="cl">        this.desc = desc;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public String getDesc() {
</span></span><span class="line"><span class="cl">        return desc;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public void setPrice(double price) {
</span></span><span class="line"><span class="cl">        this.price = price;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public double getPrice() {
</span></span><span class="line"><span class="cl">        return price;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    protected abstract double cost();
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">class ShortBlock extends Drink{
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public ShortBlock() {
</span></span><span class="line"><span class="cl">        super.setPrice(3.0);
</span></span><span class="line"><span class="cl">        super.setDesc(&#34;ShortBlock&#34;);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    protected double cost() {
</span></span><span class="line"><span class="cl">        return super.getPrice();
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">class LongBlock extends Drink {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public LongBlock() {
</span></span><span class="line"><span class="cl">        super.setPrice(5.0);
</span></span><span class="line"><span class="cl">        super.setDesc(&#34;LongBlock&#34;);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    protected double cost() {
</span></span><span class="line"><span class="cl">        return super.getPrice();
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">class CoffeeShop extends Drink {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    private final Drink coffee;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    protected CoffeeShop(Drink coffee) {
</span></span><span class="line"><span class="cl">        this.coffee = coffee;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    protected double cost() {
</span></span><span class="line"><span class="cl">        return super.getPrice() + coffee.cost();
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    public String getDesc() {
</span></span><span class="line"><span class="cl">        return desc + &#34; &#34; + getPrice() +&#34; &amp;&amp; &#34;+  coffee.getDesc();
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">class Milk extends CoffeeShop {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public Milk(Drink seasoning) {
</span></span><span class="line"><span class="cl">        super(seasoning);
</span></span><span class="line"><span class="cl">        super.setDesc(&#34;Milk&#34;);
</span></span><span class="line"><span class="cl">        super.setPrice(6);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">class Chocolate extends CoffeeShop {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public Chocolate(Drink seasoning) {
</span></span><span class="line"><span class="cl">        super(seasoning);
</span></span><span class="line"><span class="cl">        super.setDesc(&#34;Chocolate&#34;);
</span></span><span class="line"><span class="cl">        super.setPrice(4);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><p>装饰模式降低了系统的耦合度，可以动态增加或删除对象的职责，并使得需要装饰的具体构件类和具体装饰类可以独立变化，以便增加新的具体构件类和具体装饰类。在软件开发中，装饰模式应用较为广泛，例如在JavaIO中的输入流和输出流的设计、javax.swing包中一些图形界面构件功能的增强等地方都运用了装饰模式。</p>
<p>**装饰者模式主要解决：**一般的，我们为了扩展一个类经常使用继承方式实现，由于继承为类引入静态特征，并且随着扩展功能的增多，子类会很膨胀。</p>
<p><strong>优点</strong></p>
<ul>
<li>对于扩展一个对象的功能，装饰模式比继承更加灵活性，不会导致类的个数急剧增加。</li>
<li>装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>多层装饰比较复杂。</li>
<li>使用装饰模式进行系统设计时将产生很多小对象，这些对象的区别在于它们之间相互连接的方式有所不同，而不是它们的类或者属性值有所不同，大量小对象的产生势必会占用更多的系统资源，在一定程序上影响程序的性能。</li>
</ul>
<p><strong>使用场景</strong></p>
<p>这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能。可代替继承。</p>
<ul>
<li>扩展一个类的功能。</li>
<li>动态增加功能，动态撤销。</li>
<li>当不能采用继承的方式对系统进行扩展或者采用继承不利于系统扩展和维护时可以使用装饰模式。不能采用继承的情况主要有两类：
<ul>
<li>第一类是系统中存在大量独立的扩展，为支持每一种扩展或者扩展之间的组合将产生大量的子类，使得子类数目呈爆炸性增长</li>
<li>第二类是因为类已定义为不能被继承</li>
</ul>
</li>
</ul>
<h3 id="外观模式">外观模式</h3>
<blockquote>
<p>外观模式：为子系统中的一组接口提供一个统一的入口。外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。</p>
</blockquote>
<p>外观模式又称为门面模式，它是一种对象结构型模式。外观模式是<a href="#%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99">迪米特法则</a>的一种具体实现，通过引入一个新的外观角色可以降低原有系统的复杂度，同时降低客户类与子系统的耦合度。</p>
<p>代码实现</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public class MainTest {
</span></span><span class="line"><span class="cl">    public static void main(String[] args) {
</span></span><span class="line"><span class="cl">        Facade facade = new Facade();
</span></span><span class="line"><span class="cl">        facade.aTest();
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">class Facade {
</span></span><span class="line"><span class="cl">    private final A a;
</span></span><span class="line"><span class="cl">    private final B b;
</span></span><span class="line"><span class="cl">    private final C c;
</span></span><span class="line"><span class="cl">    private final D d;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public Facade() {
</span></span><span class="line"><span class="cl">        this.a = A.getInstance();
</span></span><span class="line"><span class="cl">        this.b = B.getInstance();
</span></span><span class="line"><span class="cl">        this.c = C.getInstance();
</span></span><span class="line"><span class="cl">        this.d = D.getInstance();
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public void aTest() {
</span></span><span class="line"><span class="cl">        a.aTest();
</span></span><span class="line"><span class="cl">        b.aTest();
</span></span><span class="line"><span class="cl">        c.aTest();
</span></span><span class="line"><span class="cl">        d.aTest();
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">/**
</span></span><span class="line"><span class="cl"> * A调用B类，A调用C类，B调用C类，D调用B类，D调用C类
</span></span><span class="line"><span class="cl"> */
</span></span><span class="line"><span class="cl">class A {
</span></span><span class="line"><span class="cl">   private final static A instance = new A();
</span></span><span class="line"><span class="cl">   private A(){}
</span></span><span class="line"><span class="cl">   public static A getInstance() {
</span></span><span class="line"><span class="cl">       return instance;
</span></span><span class="line"><span class="cl">   }
</span></span><span class="line"><span class="cl">   public  void aTest() {
</span></span><span class="line"><span class="cl">       B.getInstance().aTest();
</span></span><span class="line"><span class="cl">       C.getInstance().aTest();
</span></span><span class="line"><span class="cl">       System.out.println(&#34;A class test method ...&#34;);
</span></span><span class="line"><span class="cl">   }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">class B {
</span></span><span class="line"><span class="cl">    private final static B instance = new B();
</span></span><span class="line"><span class="cl">    private B(){}
</span></span><span class="line"><span class="cl">    public static B getInstance() {
</span></span><span class="line"><span class="cl">        return instance;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    public  void aTest() {
</span></span><span class="line"><span class="cl">        C.getInstance().aTest();
</span></span><span class="line"><span class="cl">        System.out.println(&#34;B class test method ...&#34;);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">class C {
</span></span><span class="line"><span class="cl">    private final static C instance = new C();
</span></span><span class="line"><span class="cl">    private C(){}
</span></span><span class="line"><span class="cl">    public  static C getInstance() {
</span></span><span class="line"><span class="cl">        return instance;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    public  void aTest() {
</span></span><span class="line"><span class="cl">        System.out.println(&#34;C class test method ...&#34;);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">class D {
</span></span><span class="line"><span class="cl">    private final static D instance = new D();
</span></span><span class="line"><span class="cl">    private D(){}
</span></span><span class="line"><span class="cl">    public static D getInstance() {
</span></span><span class="line"><span class="cl">        return instance;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    public  void aTest() {
</span></span><span class="line"><span class="cl">        B.getInstance().aTest();
</span></span><span class="line"><span class="cl">        C.getInstance().aTest();
</span></span><span class="line"><span class="cl">        System.out.println(&#34;D class test method ...&#34;);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><p>外观模式的主要目的在于降低系统的复杂程度，在面向对象软件系统中，类与类之间的关系越多，不能表示系统设计得越好，反而表示系统中类之间的耦合度太大，这样的系统在维护和修改时都缺乏灵活性，因为一个类的改动会导致多个类发生变化，而外观模式的引入在很大程度上降低了类与类之间的耦合关系。引入外观模式之后，增加新的子系统或者移除子系统都非常方便，客户类无须进行修改（或者极少的修改），只需要在外观类中增加或移除对子系统的引用即可。从这一点来说，外观模式在一定程度上并不符合<a href="#%E5%BC%80%E6%94%BE%E5%B0%81%E9%97%AD%E5%8E%9F%E5%88%99">开放封闭原则</a>，增加新的子系统需要对原有系统进行一定的修改，虽然这个修改工作量不大。</p>
<p><strong>优点</strong></p>
<ul>
<li>减少关联关系；对客户端屏蔽了具体的实现，使得子系统使用起来更加容易；客户端代码将变得很简单，与之关联的对象也很少。</li>
<li>解耦合；具体实现有改变不会影响到调用的客户端，只需要调整外观类即可。</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>如果设计不当，扩展时增加新的实现可能需要修改外观类的源代码，违背了<a href="#%E5%BC%80%E6%94%BE%E5%B0%81%E9%97%AD%E5%8E%9F%E5%88%99">开放封闭原则</a>.</li>
<li>不能很好地限制客户端直接使用子系统类，如果对客户端访问子系统类做太多的限制则减少了可变性和灵活性。</li>
</ul>
<p><strong>使用场景</strong></p>
<ul>
<li>当要为访问一系列复杂的子系统提供一个简单入口时可以使用外观模式。</li>
<li>客户端程序与多个子系统之间存在很大的依赖性。引入外观类可以将子系统与客户端解耦，从而提高子系统的独立性和可移植性。</li>
<li>在层次化结构中，可以使用外观模式定义系统中每一层的入口，层与层之间不直接产生联系，而通过外观类建立联系，降低层之间的耦合度。</li>
</ul>
<h3 id="享元模式">享元模式</h3>
<blockquote>
<p>享元模式：运用共享技术有效地支持大量细粒度对象的复用。系统只使用少量的对象，而这些对象都很相似，状态变化很小，可以实现对象的多次复用。由于享元模式要求能够共享的对象必须是细粒度对象，因此它又称为轻量级模式，它是一种对象结构型模式。</p>
</blockquote>
<p>代码实现</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public class MainTest {
</span></span><span class="line"><span class="cl">    public static void main(String[] args) {
</span></span><span class="line"><span class="cl">        WebSiteFactory webSiteFactory = new WebSiteFactory();
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        webSiteFactory.getWebSite(&#34;新闻&#34;).use(new User(&#34;lucy&#34;));
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        webSiteFactory.getWebSite(&#34;新闻&#34;).use(new User(&#34;jane&#34;));
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        webSiteFactory.getWebSite(&#34;博客&#34;).use(new User(&#34;jack&#34;));
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        webSiteFactory.getWebSite(&#34;博客&#34;).use(new User(&#34;maik&#34;));
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        webSiteFactory.getWebSite(&#34;博客&#34;).use(new User(&#34;seven&#34;));
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        System.out.println(&#34;网站类型共：&#34; + webSiteFactory.countWebSiteType());
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">abstract class WebSite{
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    private String name;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public abstract void use(User user);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public void setName(String name) {
</span></span><span class="line"><span class="cl">        this.name = name;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public String getName() {
</span></span><span class="line"><span class="cl">        return name;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">class ConcreateWebSite extends WebSite {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public ConcreateWebSite(String name) {
</span></span><span class="line"><span class="cl">        super.setName(name);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    public void use(User user) {
</span></span><span class="line"><span class="cl">        System.out.println(&#34;网站类型名称：&#34; + super.getName() +&#34;\t 网站用户：&#34; + user.getUsername());
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">class User {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    private String username;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public User(String username) {
</span></span><span class="line"><span class="cl">        this.username = username;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public void setUsername(String username) {
</span></span><span class="line"><span class="cl">        this.username = username;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public String getUsername() {
</span></span><span class="line"><span class="cl">        return username;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">class WebSiteFactory{
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    private HashMap&lt;String, WebSite&gt; pool = new HashMap&lt;&gt;();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public WebSite getWebSite(String webSiteName){
</span></span><span class="line"><span class="cl">        if (!pool.containsKey(webSiteName)) {
</span></span><span class="line"><span class="cl">            pool.put(webSiteName, new ConcreateWebSite(webSiteName));
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        return pool.get(webSiteName);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public Integer countWebSiteType() {
</span></span><span class="line"><span class="cl">        return pool.size();
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><p>当系统中存在大量相同或者相似的对象时，享元模式是一种较好的解决方案，它通过共享技术实现相同或相似的细粒度对象的复用，从而节约了内存空间，提高了系统性能。相比其他结构型设计模式，享元模式的使用频率并不算太高，但是作为一种以“节约内存，提高性能”为出发点的设计模式，它在软件开发中还是得到了一定程度的应用。例如：String、Java的池技术等。</p>
<p>享元模式主要解决在有大量对象时，有可能会造成内存溢出，我们把其中共同的部分抽象出来，如果有相同的业务请求，直接返回在内存中已有的对象，避免重新创建。</p>
<p><strong>优点</strong></p>
<ul>
<li>大大减少对象的创建，降低系统的内存，使效率提高。</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>提高了系统的复杂度，需要分离出外部状态和内部状态，而且外部状态具有固有化的性质，不应该随着内部状态的变化而变化，否则会造成系统的混乱。</li>
</ul>
<p><strong>使用场景</strong></p>
<p>​	在使用享元模式时需要维护一个存储享元对象的享元池，而这需要耗费一定的系统资源，因此，应当在需要多次重复使用享元对象时才值得使用享元模式。</p>
<ul>
<li>系统有大量相似对象。</li>
<li>需要缓冲池的场景。</li>
</ul>
<h3 id="代理模式">代理模式</h3>
<blockquote>
<p>代理模式：给某一个对象提供一个代理或占位符，并由代理对象来控制对原对象的访问。</p>
</blockquote>
<p>代理模式是为一个对象提供一个替身，以控制对这个对象的访问。即通过代理对象访问目标对象.这样做的好处是:可以在目标对象实现的基础上,增强额外的功能操作,即扩展目标对象的功能。被代理的对象可以是远程对象、创建开销大的对象或需要安全控制的对象</p>
<p>代理模式有不同的形式, 主要有三种 静态代理、动态代理 (<code>JDK</code>代理、<code>Cglib</code>代理)。</p>
<h4 id="静态代理">静态代理</h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public class MainTest {
</span></span><span class="line"><span class="cl">    public static void main(String[] args) {
</span></span><span class="line"><span class="cl">        ProxyImpl proxy = new ProxyImpl();
</span></span><span class="line"><span class="cl">        StaticProxy staticProxy = new StaticProxy(proxy);
</span></span><span class="line"><span class="cl">        staticProxy.test();
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">interface ProxyInterface {
</span></span><span class="line"><span class="cl">    void test();
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">class ProxyImpl implements ProxyInterface{
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    public void test() {
</span></span><span class="line"><span class="cl">        System.out.println(&#34;helloWorld&#34;);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">class StaticProxy implements ProxyInterface{
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    private ProxyImpl target;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public StaticProxy (ProxyImpl target){
</span></span><span class="line"><span class="cl">        this.target=target;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    public void test() {
</span></span><span class="line"><span class="cl">        System.out.println(&#34;静态代理之前...&#34;);
</span></span><span class="line"><span class="cl">        target.test();
</span></span><span class="line"><span class="cl">        System.out.println(&#34;静态代理之后...&#34;);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><p>静态代理能在不修改目标对象的功能前提下，<strong>能通过代理对象对目标进行扩展。<strong>但是因为代理对象需要与目标对象实现相同的接口，所以会有很多代理类</strong>一旦接口增加方法后，目标对象与代理对象都需要维护</strong>。</p>
<h4 id="动态代理">动态代理</h4>
<p>动态代理，代理对象不需要实现接口，但是目标对象需要实现接口，否则不能实现动态代理。代理对象的生产是利用JDK的API，动态的在内存中构建代理对象。</p>
<h5 id="jdk动态代理">JDK动态代理</h5>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public class MainTest {
</span></span><span class="line"><span class="cl">    public static void main(String[] args) {
</span></span><span class="line"><span class="cl">        ProxyImpl proxy = new ProxyImpl();
</span></span><span class="line"><span class="cl">        ProxyInterface jdkProxyInterface = (ProxyInterface)new JDKProxy().bind(proxy);
</span></span><span class="line"><span class="cl">        jdkProxyInterface.test();
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">interface ProxyInterface {
</span></span><span class="line"><span class="cl">    void test();
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">class ProxyImpl implements ProxyInterface{
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    public void test() {
</span></span><span class="line"><span class="cl">        System.out.println(&#34;helloWorld&#34;);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">class JDKProxy {
</span></span><span class="line"><span class="cl">    //通用类型，表示被代理的真实对象
</span></span><span class="line"><span class="cl">    private Object target;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public Object bind(Object target){
</span></span><span class="line"><span class="cl">        this.target=target;
</span></span><span class="line"><span class="cl">        //生成代理类（与被代理对象实现相同接口的兄弟类）
</span></span><span class="line"><span class="cl">        return Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), (proxy, method, args) -&gt; {
</span></span><span class="line"><span class="cl">            Object res;
</span></span><span class="line"><span class="cl">            System.out.println(&#34;JDK动态代理前&#34;);
</span></span><span class="line"><span class="cl">            res=method.invoke(target, args);
</span></span><span class="line"><span class="cl">            System.out.println(&#34;JDK动态代理后&#34;);
</span></span><span class="line"><span class="cl">            return res;
</span></span><span class="line"><span class="cl">        });
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><h5 id="cglib动态代理">CGlib动态代理</h5>
<p><code>Cglib</code>代理也叫作子类代理,它是在内存中构建一个子类对象从而实现对目标对象功能扩展。
<code>Cglib</code>是一个强大的高性能的代码生成包,它可以在运行期扩展 java 类与实现 java 接口.它广泛的被许多 AOP 的框架使用,例如 Spring AOP，实现方法拦截。</p>
<p>以下测试代码需要导入Cglib和asm相关jar包。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">asm-3.3.1.jar
</span></span><span class="line"><span class="cl">cglib-2.2.jar
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-mysql" data-lang="mysql"><span class="line"><span class="cl"><span class="n">PS</span><span class="err">：使用</span><span class="o">`</span><span class="n">CGLib</span><span class="o">`</span><span class="err">实现动态代理时出现了下面这个异常</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">Exception</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">thread</span><span class="w"> </span><span class="s2">&#34;main&#34;</span><span class="w"> </span><span class="n">java</span><span class="p">.</span><span class="n">lang</span><span class="p">.</span><span class="n">IncompatibleClassChangeError</span><span class="p">:</span><span class="w"> 
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">class</span><span class="w"> </span><span class="n">net</span><span class="p">.</span><span class="n">sf</span><span class="p">.</span><span class="n">cglib</span><span class="p">.</span><span class="n">core</span><span class="p">.</span><span class="n">DebuggingClassWriter</span><span class="w"> </span><span class="n">has</span><span class="w"> </span><span class="n">interface</span><span class="w"> </span><span class="n">org</span><span class="p">.</span><span class="n">objectweb</span><span class="p">.</span><span class="n">asm</span><span class="p">.</span><span class="n">ClassVisitor</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">super</span><span class="w"> </span><span class="n">class</span><span class="w">
</span></span></span></code></pre></div><blockquote>
<ul>
<li>
<p>原因：
cglib.jar包含asm.jar包。报错内容是<code>ClassVisitor</code>的父类不相容。详细：<a href="https://my.oschina.net/itblog/blog/528613">原因分析</a><br></p>
</li>
<li>
<p>解决：
测试时用<code>cglib2.2.jar</code>和<code>asm3.3.1.jar</code>版本，解决jar包冲突问题。</p>
</li>
</ul>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public class MainTest {
</span></span><span class="line"><span class="cl">    public static void main(String[] args) {
</span></span><span class="line"><span class="cl">        Target target = new Target();
</span></span><span class="line"><span class="cl">        Target bind = (Target)new CGLibProxy().bind(target);
</span></span><span class="line"><span class="cl">        bind.test();
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">class Target{
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public void test() {
</span></span><span class="line"><span class="cl">        System.out.println(&#34;helloWorld&#34;);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">class CGLibProxy implements MethodInterceptor {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    private Object target;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public  Object bind(Object target) {
</span></span><span class="line"><span class="cl">        this.target = target;
</span></span><span class="line"><span class="cl">        Enhancer enhancer = new Enhancer();
</span></span><span class="line"><span class="cl">        enhancer.setSuperclass(target.getClass());
</span></span><span class="line"><span class="cl">        enhancer.setCallback(this);
</span></span><span class="line"><span class="cl">        return enhancer.create();
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    public Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {
</span></span><span class="line"><span class="cl">        Object res;
</span></span><span class="line"><span class="cl">        System.out.println(&#34;CGLib动态代理前&#34;);
</span></span><span class="line"><span class="cl">        res=method.invoke(target, args);
</span></span><span class="line"><span class="cl">        System.out.println(&#34;CGLib动态代理后&#34;);
</span></span><span class="line"><span class="cl">        return res;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><h4 id="总结-2">总结</h4>
<p>代理模式是常用的结构型设计模式之一，它为对象的间接访问提供了一个解决方案，可以对对象的访问进行控制。代理模式主要解决：在直接访问对象时带来的问题，比如说：要访问的对象在远程的机器上。在面向对象系统中，有些对象由于某些原因（比如对象创建开销很大，或者某些操作需要安全控制，或者需要进程外的访问），直接访问会给使用者或者系统结构带来很多麻烦，我们可以在访问此对象时加上一个对此对象的访问层。</p>
<p><strong>优点</strong></p>
<ul>
<li>职责清晰。能够协调调用者和被调用者，在一定程度上降低了系统的耦合度。</li>
<li>高扩展性。增加和更换代理类无须修改源代码，符合<a href="#%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99">开闭原则</a>，系统具有较好的灵活性和可扩展性。</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢。</li>
<li>实现代理模式需要额外的工作，有些代理模式的实现非常复杂</li>
</ul>
<p><strong>使用场景</strong></p>
<ul>
<li>想在访问一个类时做一些控制。</li>
</ul>
<h3 id="职责链模式">职责链模式</h3>
<blockquote>
<p>职责链模式：避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。职责链模式是一种对象行为型模式。</p>
</blockquote>
<p>代码实现</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public class MainTest {
</span></span><span class="line"><span class="cl">    public static void main(String[] args) {
</span></span><span class="line"><span class="cl">         // 产品
</span></span><span class="line"><span class="cl">        RequestEntity test = new RequestEntity(&#34;test&#34;, 2000);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        // 指定职责链
</span></span><span class="line"><span class="cl">        BeforeHandler before = new BeforeHandler(&#34;before&#34;);
</span></span><span class="line"><span class="cl">        AfterHandler after = new AfterHandler(&#34;after&#34;);
</span></span><span class="line"><span class="cl">        PostHandler post = new PostHandler(&#34;post&#34;);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        // 形成链状闭环 要确保会被责任链中的组件处理 否则会一直循环下去 ，当然也可以选择不闭环
</span></span><span class="line"><span class="cl">        before.setHandler(after);
</span></span><span class="line"><span class="cl">        after.setHandler(post);
</span></span><span class="line"><span class="cl">        post.setHandler(before);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        after.handleRequest(test);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">class RequestEntity {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public String name;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public Integer grade;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public RequestEntity(String name,Integer grade) {
</span></span><span class="line"><span class="cl">        this.name = name;
</span></span><span class="line"><span class="cl">        this.grade = grade;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public String getName() {
</span></span><span class="line"><span class="cl">        return name;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public float getGrade() {
</span></span><span class="line"><span class="cl">        return grade;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">abstract class Handler {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // 下一个引用
</span></span><span class="line"><span class="cl">    protected Handler handler;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    protected String name;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public Handler(String name) {
</span></span><span class="line"><span class="cl">        this.name = name;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public void setHandler(Handler handler) {
</span></span><span class="line"><span class="cl">        this.handler = handler;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public abstract void handleRequest(RequestEntity requestEntity);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">class BeforeHandler extends Handler {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public BeforeHandler(String name){
</span></span><span class="line"><span class="cl">        super(name);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    public void handleRequest(RequestEntity requestEntity) {
</span></span><span class="line"><span class="cl">        if (requestEntity.getGrade() &lt; 1000) {
</span></span><span class="line"><span class="cl">            System.out.println(&#34;分数为：&#34; + requestEntity.getGrade() + &#34;，被&#34; + this.name + &#34;处理 &#34;);
</span></span><span class="line"><span class="cl">        }else {
</span></span><span class="line"><span class="cl">            handler.handleRequest(requestEntity);
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">class AfterHandler extends Handler {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public AfterHandler(String name){
</span></span><span class="line"><span class="cl">        super(name);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    public void handleRequest(RequestEntity requestEntity) {
</span></span><span class="line"><span class="cl">        if (requestEntity.getGrade() &lt;= 2000) {
</span></span><span class="line"><span class="cl">            System.out.println(&#34;分数为：&#34; + requestEntity.getGrade() + &#34;，被&#34; + this.name + &#34;处理 &#34;);
</span></span><span class="line"><span class="cl">        }else {
</span></span><span class="line"><span class="cl">            handler.handleRequest(requestEntity);
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">class PostHandler extends Handler {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public PostHandler(String name){
</span></span><span class="line"><span class="cl">        super(name);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    public void handleRequest(RequestEntity requestEntity) {
</span></span><span class="line"><span class="cl">        if (requestEntity.getGrade() &gt; 3000) {
</span></span><span class="line"><span class="cl">            System.out.println(&#34;分数为：&#34; + requestEntity.getGrade() + &#34;，被&#34; + this.name + &#34;处理 &#34;);
</span></span><span class="line"><span class="cl">        }else {
</span></span><span class="line"><span class="cl">            handler.handleRequest(requestEntity);
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><p>职责链模式通过建立一条链来组织请求的处理者，请求将沿着链进行传递，请求发送者无须知道请求在何时、何处以及如何被处理，实现了请求发送者与处理者的解耦。在软件开发中，如果遇到有多个对象可以处理同一请求时可以应用职责链模式，例如在Web应用开发中创建一个过滤器(Filter)链来对请求数据进行过滤，在工作流系统中实现公文的分级审批等等，使用职责链模式可以较好地解决此类问题。</p>
<p><strong>优点</strong></p>
<ul>
<li>增加新的请求处理类很方便，只需要在客户端重新建链即可，从这一点来看是符合<a href="#%E5%BC%80%E6%94%BE%E5%B0%81%E9%97%AD%E5%8E%9F%E5%88%99">开闭原则</a>的。</li>
<li>为请求创建了一个接收者对象的链式结构。对请求的发送者和接收者进行解耦。</li>
<li>简化了对象。使得对象不需要知道链的结构。</li>
<li>增强给对象指派职责的灵活性。通过改变链内的成员或者调动它们的次序，允许动态地新增或者删除责任。</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>系统性能将受到一定影响，可能会造成循环调用。特别是在链比较长的时候，因此需控制链中最大节点数量，一般通过在 Handler 中设置一个最大节点数量，在<code> setNext()</code>方法中判断是否已经超过阀值，超过则不允许该链建立，避免出现超长链无意识地破坏系统性能。</li>
<li>调试不方便。采用了类似递归的方式，调试时逻辑可能比较复杂。可能不容易观察运行时的特征，有碍于除错。</li>
</ul>
<p><strong>使用场景</strong></p>
<ul>
<li>在处理消息的时候以过滤很多通道。</li>
<li>有多个对象可以处理同一个请求，具体哪个对象处理该请求由运行时刻自动确定。</li>
<li>在不明确指定接收者的情况下，向多个对象中的一个提交一个请求。</li>
<li>可动态指定一组对象处理请求。</li>
</ul>
<h3 id="命令模式">命令模式</h3>
<blockquote>
<p>命令模式：将一个请求封装为一个对象，从而让我们可用不同的请求对客户进行参数化；对请求排队或者记录请求日志，以及支持可撤销的操作。命令模式是一种对象行为型模式，其别名为动作模式或事务模式。</p>
</blockquote>
<p><strong>命令模式可以将请求发送者和接收者完全解耦，发送者与接收者之间没有直接引用关系，发送请求的对象只需要知道如何发送请求，而不必知道如何完成请求</strong>。</p>
<p>代码实现</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public class MainTest {
</span></span><span class="line"><span class="cl">    public static void main(String[] args) {
</span></span><span class="line"><span class="cl">        LightReceiver lightReceiver = new LightReceiver();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        LightOnCommand lightOnCommand = new LightOnCommand(lightReceiver);
</span></span><span class="line"><span class="cl">        LightOffCommand lightOffCommand = new LightOffCommand(lightReceiver);
</span></span><span class="line"><span class="cl">        RemoteCommand remoteCommand = new RemoteCommand();
</span></span><span class="line"><span class="cl">        // 测试
</span></span><span class="line"><span class="cl">        remoteCommand.setCommand(0,lightOnCommand,lightOffCommand);
</span></span><span class="line"><span class="cl">        // 按下开灯按钮
</span></span><span class="line"><span class="cl">        System.out.println(&#34;按下开灯按钮 -------&#34;);
</span></span><span class="line"><span class="cl">        remoteCommand.onButtonPushed(0);
</span></span><span class="line"><span class="cl">        // 按下关灯按钮
</span></span><span class="line"><span class="cl">        System.out.println(&#34;按下关灯按钮 -------&#34;);
</span></span><span class="line"><span class="cl">        remoteCommand.offButtonPushed(0);
</span></span><span class="line"><span class="cl">        // 按下撤销按钮
</span></span><span class="line"><span class="cl">        System.out.println(&#34;按下撤销按钮 ---------&#34;);
</span></span><span class="line"><span class="cl">        remoteCommand.undoButtonPushed(0);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">interface Command{
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    /**
</span></span><span class="line"><span class="cl">     * 执行命令
</span></span><span class="line"><span class="cl">     */
</span></span><span class="line"><span class="cl">    void exec();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    /**
</span></span><span class="line"><span class="cl">     * 撤销命令
</span></span><span class="line"><span class="cl">     */
</span></span><span class="line"><span class="cl">    void undo();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">class LightReceiver{
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public void on(){
</span></span><span class="line"><span class="cl">        System.out.println(&#34;开灯 ...&#34;);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public void off() {
</span></span><span class="line"><span class="cl">        System.out.println(&#34;关灯 ...&#34;);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">class LightOnCommand implements Command{
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    private LightReceiver lightReceiver;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public LightOnCommand(LightReceiver lightReceiver) {
</span></span><span class="line"><span class="cl">        super();
</span></span><span class="line"><span class="cl">        this.lightReceiver = lightReceiver;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    public void exec() {
</span></span><span class="line"><span class="cl">        lightReceiver.on();
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    public void undo() {
</span></span><span class="line"><span class="cl">        lightReceiver.off();
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">class LightOffCommand implements Command {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    private LightReceiver lightReceiver;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public LightOffCommand(LightReceiver lightReceiver) {
</span></span><span class="line"><span class="cl">        super();
</span></span><span class="line"><span class="cl">        this.lightReceiver = lightReceiver;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    public void exec() {
</span></span><span class="line"><span class="cl">        lightReceiver.off();
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    public void undo() {
</span></span><span class="line"><span class="cl">        lightReceiver.on();
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">/**
</span></span><span class="line"><span class="cl"> * 空执行 默认命令实现类
</span></span><span class="line"><span class="cl"> */
</span></span><span class="line"><span class="cl">class NoCommand implements Command {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    public void exec() {
</span></span><span class="line"><span class="cl">        System.out.println(&#34;默认命令执行&#34;);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    public void undo() {
</span></span><span class="line"><span class="cl">        System.out.println(&#34;默认撤销方法&#34;);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">class RemoteCommand {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // 存放开关命令
</span></span><span class="line"><span class="cl">    private Command onCommands[];
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    private Command offCommands[];
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // 存放撤销命令
</span></span><span class="line"><span class="cl">    private Command undoCommands[];
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public RemoteCommand() {
</span></span><span class="line"><span class="cl">        undoCommands = new Command[5];
</span></span><span class="line"><span class="cl">        onCommands = new Command[5];
</span></span><span class="line"><span class="cl">        offCommands = new Command[5];
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        // 默认空命令
</span></span><span class="line"><span class="cl">        for (int i = 0; i &lt; 5; i++) {
</span></span><span class="line"><span class="cl">            onCommands[i] = new NoCommand();
</span></span><span class="line"><span class="cl">            offCommands[i] = new NoCommand();
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // 设置命令
</span></span><span class="line"><span class="cl">    public  void  setCommand(int no, Command onCommand, Command offCommand) {
</span></span><span class="line"><span class="cl">        onCommands[no] = onCommand;
</span></span><span class="line"><span class="cl">        offCommands[no] = offCommand;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // 按下开的按钮
</span></span><span class="line"><span class="cl">    public void onButtonPushed(int no) {
</span></span><span class="line"><span class="cl">        onCommands[no].exec();
</span></span><span class="line"><span class="cl">        // 记录撤销操作
</span></span><span class="line"><span class="cl">        undoCommands[no] = onCommands[no];
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // 按下关闭的按钮
</span></span><span class="line"><span class="cl">    public void offButtonPushed(int no) {
</span></span><span class="line"><span class="cl">        offCommands[no].exec();
</span></span><span class="line"><span class="cl">        // 记录撤销操作
</span></span><span class="line"><span class="cl">        undoCommands[no] = offCommands[no];
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // 按下撤销按钮
</span></span><span class="line"><span class="cl">    public void undoButtonPushed(int no) {
</span></span><span class="line"><span class="cl">        undoCommands[no].undo();
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><p>命令模式是一种使用频率非常高的设计模式，它可以将请求发送者与接收者解耦，请求发送者通过命令对象来间接引用请求接收者，使得系统具有更好的灵活性和可扩展性。在基于GUI的软件开发，无论是在电脑桌面应用还是在移动应用中，命令模式都得到了广泛的应用。</p>
<p>在软件系统中，行为请求者与行为实现者通常是一种紧耦合的关系，但某些场合，比如需要对行为进行记录、撤销或重做、事务等处理时，这种无法抵御变化的紧耦合的设计就不太合适。</p>
<p><strong>优点</strong></p>
<ul>
<li>降低了系统耦合度。</li>
<li>新的命令可以很容易地加入到系统中。由于增加新的具体命令类不会影响到其他类，因此增加新的具体命令类很容易，无须修改原有系统源代码，甚至客户类代码，满足<a href="#%E5%BC%80%E6%94%BE%E5%B0%81%E9%97%AD%E5%8E%9F%E5%88%99">开闭原则</a>的要求。</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>使用命令模式可能会导致某些系统有过多的具体命令类。因为针对每一个对请求接收者的调用操作都需要设计一个具体命令类，因此在某些系统中可能需要提供大量的具体命令类，这将影响命令模式的使用。</li>
</ul>
<p><strong>使用场景</strong></p>
<ul>
<li>请求调用者需要与请求接收者解耦时，命令模式可以使调用者和接收者不直接交互。</li>
<li>当系统需要支持命令的撤销操作和恢复操作时。</li>
<li>系统需要在不同的时间指定请求、将请求排队和执行请求。一个命令对象和请求的初始调用者可以有不同的生命期，换言之，最初的请求发出者可能已经不在了，而命令对象本身仍然是活动的，可以通过该命令对象去调用请求接收者，而无须关心请求调用者的存在性，可以通过请求日志文件等机制来具体实现。</li>
</ul>
<h3 id="解释器模式">解释器模式</h3>
<blockquote>
<p>解释器模式：定义一个语言的文法，并且建立一个解释器来解释该语言中的句子，这里的“语言”是指使用规定格式和语法的代码。解释器模式是一种类行为型模式。</p>
</blockquote>
<p>代码实现</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public class MainTest {
</span></span><span class="line"><span class="cl">    public static void main(String[] args) throws IOException {
</span></span><span class="line"><span class="cl">        String expStr = getExpStr();
</span></span><span class="line"><span class="cl">        HashMap&lt;String, Integer&gt; var = getValue(expStr);
</span></span><span class="line"><span class="cl">        Calculator calculator = new Calculator(expStr);
</span></span><span class="line"><span class="cl">        System.out.println(&#34;运算结果：&#34; + expStr + &#34;=&#34; + calculator.run(var));
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // 获得表达式
</span></span><span class="line"><span class="cl">    public static String getExpStr() throws IOException {
</span></span><span class="line"><span class="cl">        System.out.print(&#34;请输入表达式：&#34;);
</span></span><span class="line"><span class="cl">        return (new BufferedReader(new InputStreamReader(System.in))).readLine();
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // 获得值映射
</span></span><span class="line"><span class="cl">    public static HashMap&lt;String, Integer&gt; getValue(String expStr) throws IOException {
</span></span><span class="line"><span class="cl">        HashMap&lt;String, Integer&gt; map = new HashMap&lt;&gt;();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        for (char ch : expStr.toCharArray()) {
</span></span><span class="line"><span class="cl">            if (ch != &#39;+&#39; &amp;&amp; ch != &#39;-&#39;) {
</span></span><span class="line"><span class="cl">                if (!map.containsKey(String.valueOf(ch))) {
</span></span><span class="line"><span class="cl">                    System.out.print(&#34;请输入&#34; + String.valueOf(ch) + &#34;的值：&#34;);
</span></span><span class="line"><span class="cl">                    String in = (new BufferedReader(new InputStreamReader(System.in))).readLine();
</span></span><span class="line"><span class="cl">                    map.put(String.valueOf(ch), Integer.valueOf(in));
</span></span><span class="line"><span class="cl">                }
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        return map;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">abstract class AbstractExpression {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    /**
</span></span><span class="line"><span class="cl">     * 表达式解释器
</span></span><span class="line"><span class="cl">     */
</span></span><span class="line"><span class="cl">    public abstract int interpreter(HashMap&lt;String, Integer&gt; var);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">/**
</span></span><span class="line"><span class="cl"> * 终结表达式
</span></span><span class="line"><span class="cl"> */
</span></span><span class="line"><span class="cl">class VarExpression extends AbstractExpression {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    private String key;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public VarExpression(String key) {
</span></span><span class="line"><span class="cl">        this.key = key;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    public int interpreter(HashMap&lt;String, Integer&gt; map) {
</span></span><span class="line"><span class="cl">        return map.get(key);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">/**
</span></span><span class="line"><span class="cl"> * 非终结表达式
</span></span><span class="line"><span class="cl"> */
</span></span><span class="line"><span class="cl">class SymbolExpression extends AbstractExpression {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    protected AbstractExpression left;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    protected AbstractExpression right;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    SymbolExpression(AbstractExpression left, AbstractExpression right) {
</span></span><span class="line"><span class="cl">        this.left = left;
</span></span><span class="line"><span class="cl">        this.right = right;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // 因为 SymbolExpression  是让其子类来实现，因此 interpreter 是一个默认实现
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    public int interpreter(HashMap&lt;String, Integer&gt; var) {
</span></span><span class="line"><span class="cl">        return 0;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">/**
</span></span><span class="line"><span class="cl"> * 减法
</span></span><span class="line"><span class="cl"> */
</span></span><span class="line"><span class="cl">class SubExpression extends SymbolExpression {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public SubExpression(AbstractExpression left, AbstractExpression right) {
</span></span><span class="line"><span class="cl">        super(left, right);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    public int interpreter(HashMap&lt;String, Integer&gt; var) {
</span></span><span class="line"><span class="cl">        return super.left.interpreter(var) - super.right.interpreter(var);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">/**
</span></span><span class="line"><span class="cl"> * 加法
</span></span><span class="line"><span class="cl"> */
</span></span><span class="line"><span class="cl">class AddExpression extends SymbolExpression {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public AddExpression(AbstractExpression left, AbstractExpression right) {
</span></span><span class="line"><span class="cl">        super(left, right);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    public int interpreter(HashMap&lt;String, Integer&gt; var) {
</span></span><span class="line"><span class="cl">        return super.left.interpreter(var) + super.right.interpreter(var);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">/**
</span></span><span class="line"><span class="cl"> * 计算器 调用加减法
</span></span><span class="line"><span class="cl"> */
</span></span><span class="line"><span class="cl">class Calculator {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    private AbstractExpression expression;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public  Calculator(AbstractExpression expression) {
</span></span><span class="line"><span class="cl">        this.expression = expression;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public Calculator(String expStr) {
</span></span><span class="line"><span class="cl">        // 安排运算先后顺序
</span></span><span class="line"><span class="cl">        Stack&lt;AbstractExpression&gt; stack = new Stack&lt;&gt;();
</span></span><span class="line"><span class="cl">        // 表达式拆分成字符数组
</span></span><span class="line"><span class="cl">        char[] charArray = expStr.toCharArray();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        AbstractExpression left = null;
</span></span><span class="line"><span class="cl">        AbstractExpression right = null;
</span></span><span class="line"><span class="cl">        //遍历我们的字符数组，  即遍历	[a, +, b]
</span></span><span class="line"><span class="cl">        //针对不同的情况，做处理
</span></span><span class="line"><span class="cl">        for (int i = 0; i &lt; charArray.length; i++) {
</span></span><span class="line"><span class="cl">            switch (charArray[i]) {
</span></span><span class="line"><span class="cl">                case &#39;+&#39;:
</span></span><span class="line"><span class="cl">                    // 从 stack 取 出 left =&gt; &#34;a&#34;
</span></span><span class="line"><span class="cl">                    left = stack.pop();
</span></span><span class="line"><span class="cl">                    // 取出右表达式 &#34;b&#34;
</span></span><span class="line"><span class="cl">                    right = new VarExpression(String.valueOf(charArray[++i]));
</span></span><span class="line"><span class="cl">                    stack.push(new AddExpression(left, right));
</span></span><span class="line"><span class="cl">                    // 然后根据得到 left 和 right 构建 AddExpresson 加入 stack
</span></span><span class="line"><span class="cl">                    break;
</span></span><span class="line"><span class="cl">                case &#39;-&#39;:
</span></span><span class="line"><span class="cl">                    left = stack.pop();
</span></span><span class="line"><span class="cl">                    right = new VarExpression(String.valueOf(charArray[++i]));
</span></span><span class="line"><span class="cl">                    stack.push(new SubExpression(left, right));
</span></span><span class="line"><span class="cl">                    break;
</span></span><span class="line"><span class="cl">                default:
</span></span><span class="line"><span class="cl">                    //如果是一个 Var 就创建要给 VarExpression 对象，并 push 到 stack
</span></span><span class="line"><span class="cl">                    stack.push(new VarExpression(String.valueOf(charArray[i])));
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                    break;
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        //当遍历完整个 charArray  数组后，stack 就得到最后
</span></span><span class="line"><span class="cl">        this.expression = stack.pop();
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public int run(HashMap&lt;String, Integer&gt; var) {
</span></span><span class="line"><span class="cl">        //最后将表达式 a+b 和 var = {a=10,b=20}
</span></span><span class="line"><span class="cl">        //然后传递给 expression 的 interpreter 进行解释执行
</span></span><span class="line"><span class="cl">        return this.expression.interpreter(var);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><p>解释器模式为自定义语言的设计和实现提供了一种解决方案，它用于定义一组文法规则并通过这组文法规则来解释语言中的句子。虽然解释器模式的使用频率不是特别高，但是它在正则表达式、XML文档解释等领域还是得到了广泛使用。与解释器模式类似，目前还诞生了很多基于抽象语法树的源代码处理工具，例如Eclipse中的Eclipse AST，它可以用于表示Java语言的语法结构，用户可以通过扩展其功能，创建自己的文法规则。</p>
<p><strong>优点</strong></p>
<ul>
<li>易于改变和扩展文法。增加新的解释表达式较为方便。如果用户需要增加新的解释表达式只需要对应增加一个新的终结符表达式或非终结符表达式类，原有表达式类代码无须修改，符合“<a href="#%E5%BC%80%E6%94%BE%E5%B0%81%E9%97%AD%E5%8E%9F%E5%88%99">开闭原则</a>”。</li>
<li>易于实现简单文法。</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>可利用场景比较少。</li>
<li>对于复杂的文法比较难维护。解释器模式会引起类膨胀。如果一个语言包含太多文法规则，类的个数将会急剧增加，导致系统难以管理和维护。</li>
<li>解释器模式采用递归调用方法。</li>
</ul>
<p><strong>使用场景</strong></p>
<ul>
<li>对于一些固定文法构建一个解释句子的解释器。</li>
<li>可以将一个需要解释执行的语言中的句子表示为一个抽象语法树</li>
<li>一些重复出现的问题可以用一种简单的语言来进行表达。</li>
<li>一个简单语法需要解释的场景。</li>
</ul>
<h3 id="迭代器模式">迭代器模式</h3>
<blockquote>
<p>迭代器模式：提供一种方法来访问聚合对象，而不用暴露这个对象的内部表示，其别名为游标。迭代器模式是一种对象行为型模式。</p>
</blockquote>
<p>迭代器模式的重要用途就是帮助我们遍历容器。迭代器模式，提供一种遍历集合元素的统一接口，用一致的方法遍历集合元素，不需要知道集合对象的底层表示，即：不暴露其内部的结构。在迭代器模式结构中包含聚合和迭代器两个层次结构，考虑到系统的灵活性和可扩展性，在迭代器模式中应用了<a href="#%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F">工厂方法模式</a>.</p>
<p>代码实现</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public class MainTest {
</span></span><span class="line"><span class="cl">    public static void main(String[] args) {
</span></span><span class="line"><span class="cl">        Bread bread = new Bread();
</span></span><span class="line"><span class="cl">        bread.add(&#34;面粉&#34;);
</span></span><span class="line"><span class="cl">        bread.add(&#34;黄油&#34;);
</span></span><span class="line"><span class="cl">        bread.add(&#34;白糖&#34;);
</span></span><span class="line"><span class="cl">        bread.add(&#34;鸡蛋&#34;);
</span></span><span class="line"><span class="cl">        Iterator iterator = bread.getIterator();
</span></span><span class="line"><span class="cl">        while (iterator.hasNext()) {
</span></span><span class="line"><span class="cl">            System.out.println(iterator.next());
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">class FoodIterator implements Iterator {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    String[] foods;
</span></span><span class="line"><span class="cl">    int      position = 0;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public FoodIterator(String[] foods) {
</span></span><span class="line"><span class="cl">        this.foods = foods;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    public boolean hasNext() {
</span></span><span class="line"><span class="cl">        return position != foods.length;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    public Object next() {
</span></span><span class="line"><span class="cl">        String food = foods[position];
</span></span><span class="line"><span class="cl">        position += 1;
</span></span><span class="line"><span class="cl">        return food;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">interface Food {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    void add(String name);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    Iterator getIterator();
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">class Bread implements Food{
</span></span><span class="line"><span class="cl">    private String[] foods    = new String[4];
</span></span><span class="line"><span class="cl">    private int      position = 0;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    public void add(String name) {
</span></span><span class="line"><span class="cl">        foods[position] = name;
</span></span><span class="line"><span class="cl">        position += 1;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    public Iterator getIterator() {
</span></span><span class="line"><span class="cl">        return new FoodIterator(this.foods);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><blockquote>
<p>迭代器模式是一种使用频率非常高的设计模式，通过引入迭代器可以将数据的遍历功能从聚合对象中分离出来，聚合对象只负责存储数据，而遍历数据由迭代器来完成。由于很多编程语言的类库都已经实现了迭代器模式，因此在实际开发中，我们只需要直接使用Java、C#等语言已定义好的迭代器即可，迭代器已经成为我们操作聚合对象的基本工具之一。</p>
</blockquote>
<p>迭代器的使用现在非常广泛，因为Java中提供了<code>java.util.Iterator</code>。而且Java中的很多容器（<code>Collection、Set</code>）也都提供了对迭代器的支持。</p>
<p><strong>优点</strong></p>
<ul>
<li>提供一个统一的方法遍历对象，客户不用再考虑聚合的类型，使用一种方法就可以遍历对象了。</li>
<li>隐藏了聚合的内部结构，客户端要遍历聚合的时候只能取到迭代器，而不会知道聚合的具体组成。</li>
<li>提供了一种设计思想，就是一个类应该只有一个引起变化的原因（<a href="#%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99">单一职责原则</a>）。在聚合类中，我们把迭代器分开，就是要把管理对象集合和遍历对象集合的责任分开，这样一来集合改变的话，只影响到聚合对象。而如果遍历方式改变的话，只影响到了迭代器。</li>
<li>当要展示一组相似对象，或者遍历一组相同对象时使用, 适合使用迭代器模式</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>由于迭代器模式将存储数据和遍历数据的职责分离，增加新的聚合类需要对应增加新的迭代器类，类的个数成对增加，这在一定程度上增加了系统的复杂性。</li>
</ul>
<p><strong>使用场景</strong></p>
<ul>
<li>需要为一个聚合对象提供多种遍历方式。</li>
<li>使用迭代器模式可以为遍历不同的聚合结构提供一个统一的接口，接口的实现类中为不同的聚合结构提供不同的遍历方式，而客户端可以一致性地操作该接口。</li>
</ul>
<h3 id="中介者模式">中介者模式</h3>
<blockquote>
<p>中介者模式：用一个中介对象（中介者）来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。中介者模式又称为调停者模式，它是一种对象行为型模式。</p>
</blockquote>
<p>如果在一个系统中对象之间存在多对多的相互关系，我们可以将对象之间的一些交互行为从各个对象中分离出来，并集中封装在一个中介者对象中，并由该中介者进行统一协调，这样对象之间多对多的复杂关系就转化为相对简单的一对多关系。通过引入中介者来简化对象之间的复杂交互，中介者模式是“<a href="#%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99">迪米特法则</a>”的一个典型应用。</p>
<p>代码实现</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public class MainTest {
</span></span><span class="line"><span class="cl">    public static void main(String[] args) {
</span></span><span class="line"><span class="cl">        //创建一个中介者对象
</span></span><span class="line"><span class="cl">        Mediator mediator = new ConcreteMediator();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        //创建 Alarm  并且加入到ConcreteMediator 对象的 HashMap
</span></span><span class="line"><span class="cl">        Alarm alarm = new Alarm(mediator, &#34;alarm&#34;);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        //创建了 CoffeeMachine 对象，并且加入到	ConcreteMediator 对象的 HashMap
</span></span><span class="line"><span class="cl">        CoffeeMachine coffeeMachine = new CoffeeMachine(mediator, &#34;coffeeMachine&#34;);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        //创建  tV , 并	且加入到	ConcreteMediator 对象的 HashMap
</span></span><span class="line"><span class="cl">        TV tV = new TV(mediator, &#34;TV&#34;);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        //让闹钟发出消息 依次调用
</span></span><span class="line"><span class="cl">        alarm.sendAlarm(0);
</span></span><span class="line"><span class="cl">        coffeeMachine.finishCoffee();
</span></span><span class="line"><span class="cl">        alarm.sendAlarm(1);
</span></span><span class="line"><span class="cl">        tV.startTv();
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">/**
</span></span><span class="line"><span class="cl"> * 中介者
</span></span><span class="line"><span class="cl"> */
</span></span><span class="line"><span class="cl">abstract class Mediator {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public abstract void register(String colleagueName, Colleague colleague);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public abstract void getMessage(int stateChange, String name);
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">class ConcreteMediator extends Mediator {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    /**
</span></span><span class="line"><span class="cl">     * 集合，放入所有的同事对象
</span></span><span class="line"><span class="cl">     */
</span></span><span class="line"><span class="cl">    private HashMap&lt;String, Colleague&gt; colleagueMap;
</span></span><span class="line"><span class="cl">    private HashMap&lt;String, String&gt; interMap;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public ConcreteMediator() {
</span></span><span class="line"><span class="cl">        colleagueMap = new HashMap&lt;&gt;();
</span></span><span class="line"><span class="cl">        interMap = new HashMap&lt;&gt;();
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    public void register(String colleagueName, Colleague colleague) {
</span></span><span class="line"><span class="cl">        if (colleague instanceof Alarm) {
</span></span><span class="line"><span class="cl">            interMap.put(&#34;Alarm&#34;, colleagueName);
</span></span><span class="line"><span class="cl">        } else if (colleague instanceof CoffeeMachine) {
</span></span><span class="line"><span class="cl">            interMap.put(&#34;CoffeeMachine&#34;, colleagueName);
</span></span><span class="line"><span class="cl">        } else {
</span></span><span class="line"><span class="cl">            System.out.println(&#34;........&#34;);
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    public void getMessage(int stateChange, String colleagueName) {
</span></span><span class="line"><span class="cl">        if (colleagueMap.get(colleagueName) instanceof Alarm) {
</span></span><span class="line"><span class="cl">            if (stateChange == 0) {
</span></span><span class="line"><span class="cl">                ((CoffeeMachine) (colleagueMap.get(interMap
</span></span><span class="line"><span class="cl">                        .get(&#34;CoffeeMachine&#34;)))).startCoffee();
</span></span><span class="line"><span class="cl">                ((TV) (colleagueMap.get(interMap.get(&#34;TV&#34;)))).startTv();
</span></span><span class="line"><span class="cl">            } else if (stateChange == 1) {
</span></span><span class="line"><span class="cl">                ((TV) (colleagueMap.get(interMap.get(&#34;TV&#34;)))).stopTv();
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        } else if (colleagueMap.get(colleagueName) instanceof TV) {
</span></span><span class="line"><span class="cl">            //如果 TV 发现消息
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">/**
</span></span><span class="line"><span class="cl"> * 抽象同事类
</span></span><span class="line"><span class="cl"> */
</span></span><span class="line"><span class="cl">abstract class Colleague {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    private final Mediator mediator;
</span></span><span class="line"><span class="cl">    public String name;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public Colleague(Mediator mediator, String name) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        this.mediator = mediator;
</span></span><span class="line"><span class="cl">        this.name = name;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public Mediator getMediator() {
</span></span><span class="line"><span class="cl">        return this.mediator;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public abstract void sendMessage(int stateChange);
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">class Alarm extends Colleague {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public Alarm(Mediator mediator, String name) {
</span></span><span class="line"><span class="cl">        super(mediator, name);
</span></span><span class="line"><span class="cl">        //在创建 Alarm 同事对象时，将自己放入到 ConcreteMediator 对象中[集合]
</span></span><span class="line"><span class="cl">        mediator.register(name, this);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public void sendAlarm(int stateChange) {
</span></span><span class="line"><span class="cl">        this.sendMessage(stateChange);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    public void sendMessage(int stateChange) {
</span></span><span class="line"><span class="cl">        // 调用的中介者对象的 getMessage 方法
</span></span><span class="line"><span class="cl">        this.getMediator().getMessage(stateChange, this.name);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">class TV extends Colleague {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public TV(Mediator mediator, String name) {
</span></span><span class="line"><span class="cl">        super(mediator, name);
</span></span><span class="line"><span class="cl">        mediator.register(name, this);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    public void sendMessage(int stateChange) {
</span></span><span class="line"><span class="cl">        this.getMediator().getMessage(stateChange, this.name);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public void startTv() {
</span></span><span class="line"><span class="cl">        System.out.println(&#34;It&#39;s time to StartTv!&#34;);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public void stopTv() {
</span></span><span class="line"><span class="cl">        System.out.println(&#34;StopTv!&#34;);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">class CoffeeMachine extends Colleague {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public CoffeeMachine(Mediator mediator, String name) {
</span></span><span class="line"><span class="cl">        super(mediator, name);
</span></span><span class="line"><span class="cl">        mediator.register(name, this);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    public void sendMessage(int stateChange) {
</span></span><span class="line"><span class="cl">        this.getMediator().getMessage(stateChange, this.name);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public void startCoffee() {
</span></span><span class="line"><span class="cl">        System.out.println(&#34;It&#39;s time to startcoffee!&#34;);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public void finishCoffee() {
</span></span><span class="line"><span class="cl">        System.out.println(&#34;After 5 minutes!&#34;);
</span></span><span class="line"><span class="cl">        System.out.println(&#34;Coffee is ok!&#34;);
</span></span><span class="line"><span class="cl">        sendMessage(0);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><p>中介者模式将一个网状的系统结构变成一个以中介者对象为中心的星形结构，在这个星型结构中，使用中介者对象与其他对象的一对多关系来取代原有对象之间的多对多关系。中介者模式在事件驱动类软件中应用较为广泛，特别是基于GUI（图形用户界面）的应用软件，此外，在类与类之间存在错综复杂的关联关系的系统中，中介者模式都能得到较好的应用。</p>
<p><strong>优点</strong></p>
<ul>
<li>减少类间依赖，降低了耦合，符合<a href="#%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99">迪米特法则</a>。</li>
<li>简化了对象之间的交互，它用中介者和同事的一对多交互代替了原来同事之间的多对多交互，一对多关系更容易理解、维护和扩展，将原本难以理解的网状结构转换成相对简单的星型结构。</li>
<li>降低了类的复杂度，将一对多转化成了一对一。</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>中介者承担了较多的责任，一旦中介者出现了问题，整个系统就会受到影响。</li>
<li>如果设计不当，可能会导致具体中介者类非常复杂，使得系统难以维护，在实际使用过程中要特别注意。</li>
</ul>
<p><strong>使用场景</strong></p>
<p>主要解决：对象与对象之间存在大量的关联关系，这样势必会导致系统的结构变得很复杂，同时若一个对象发生改变，我们也需要跟踪与之相关联的对象，同时做出相应的处理。</p>
<p>应当注意：不应当在职责混乱的时候使用。</p>
<ul>
<li>系统中对象之间存在比较复杂的引用关系，导致它们之间的依赖关系结构混乱而且难以复用该对象。</li>
<li>想通过一个中间类来封装多个类中的行为，而又不想生成太多的子类。</li>
</ul>
<h3 id="备忘录模式">备忘录模式</h3>
<blockquote>
<p>备忘录模式：在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样可以在以后将对象恢复到原先保存的状态。它是一种对象行为型模式，其别名为Token。</p>
</blockquote>
<p>在设计备忘录类时需要考虑其封装性，除了<code>Originator</code>类，不允许其他类来调用备忘录类<code>Memento</code>的构造函数与相关方法，如果不考虑封装性，允许其他类调用构造方法，将导致在备忘录中保存的历史状态发生改变，通过撤销操作所恢复的状态就不再是真实的历史状态，备忘录模式也就失去了本身的意义。</p>
<p>所谓备忘录模式就是在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样可以在以后将对象恢复到原先保存的状态。</p>
<p>代码实现</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public class MainTest {
</span></span><span class="line"><span class="cl">    public static void main(String[] args) {
</span></span><span class="line"><span class="cl">        Originator originator = new Originator();
</span></span><span class="line"><span class="cl">        CareTaker careTaker = new CareTaker();
</span></span><span class="line"><span class="cl">        // 保存状态
</span></span><span class="line"><span class="cl">        careTaker.saveMemento(originator.saveState(&#34; 状态#1 &#34;));
</span></span><span class="line"><span class="cl">        careTaker.saveMemento(originator.saveState(&#34; 状态#2 &#34;));
</span></span><span class="line"><span class="cl">        careTaker.saveMemento(originator.saveState(&#34; 状态#3 &#34;));
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        System.out.println(&#34;目前保存的状态为：&#34; + originator.getState());
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        System.out.println(&#34;开始恢复以前的状态 ....&#34;);
</span></span><span class="line"><span class="cl">        originator.recover(careTaker.recover(0));
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        System.out.println(&#34;恢复之后的状态为：&#34; + originator.getState());
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">class Originator{
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    private String state;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public String getState() {
</span></span><span class="line"><span class="cl">        return state;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public Memento saveState(String state) {
</span></span><span class="line"><span class="cl">        this.state = state;
</span></span><span class="line"><span class="cl">        return new Memento(state);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public void recover(Memento memento) {
</span></span><span class="line"><span class="cl">        this.state =  memento.getState();
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">/**
</span></span><span class="line"><span class="cl"> * 备忘录对象 保存对象信息
</span></span><span class="line"><span class="cl"> */
</span></span><span class="line"><span class="cl">class Memento{
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    /**
</span></span><span class="line"><span class="cl">     * 需要保存状态
</span></span><span class="line"><span class="cl">     */
</span></span><span class="line"><span class="cl">    private final String state;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public Memento(String state) {
</span></span><span class="line"><span class="cl">        this.state = state;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public String getState() {
</span></span><span class="line"><span class="cl">        return state;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">/**
</span></span><span class="line"><span class="cl"> * 管理备忘录对象
</span></span><span class="line"><span class="cl"> */
</span></span><span class="line"><span class="cl">class CareTaker {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public ArrayList&lt;Memento&gt; mementos = new ArrayList&lt;&gt;();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public Memento recover(int index) {
</span></span><span class="line"><span class="cl">       return mementos.get(index);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public void saveMemento(Memento memento) {
</span></span><span class="line"><span class="cl">        mementos.add(memento);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><p>备忘录模式在很多软件的使用过程中普遍存在，但是在应用软件开发中，它的使用频率并不太高，因为现在很多基于窗体和浏览器的应用软件并没有提供撤销操作。如果需要为软件提供撤销功能，备忘录模式无疑是一种很好的解决方案。在一些字处理软件、图像编辑软件、数据库管理系统等软件中备忘录模式都得到了很好的应用。</p>
<p>为了符合迪米特原则，还要增加一个管理备忘录的类(<code>CareTaker</code>);为了节约内存，可使用<a href="#%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F">原型模式</a>+<a href="#%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F">备忘录模式</a>。</p>
<p><strong>优点</strong></p>
<ul>
<li>给用户提供了一种可以恢复状态的机制，可以使用户能够比较方便地回到某个历史的状态。</li>
<li>实现了信息的封装，使得用户不需要关心状态的保存细节。</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>消耗资源。如果类的成员变量过多，势必会占用比较大的资源，而且每一次保存都会消耗一定的内存。每保存一次对象的状态都需要消耗一定的系统资源。</li>
</ul>
<p><strong>使用场景</strong></p>
<p>很多时候我们总是需要记录一个对象的内部状态，这样做的目的就是为了允许用户取消不确定或者错误的操作，能够恢复到他原先的状态，使得他有&quot;后悔药&quot;可吃。</p>
<ul>
<li>需要保存/恢复数据的相关状态场景。</li>
<li>提供一个可回滚的操作。</li>
</ul>
<h3 id="观察者模式">观察者模式</h3>
<blockquote>
<p>观察者模式：定义对象之间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。观察者模式的别名包括发布-订阅模式、模型-视图模式、源-监听器模式或从属者模式。观察者模式是一种对象行为型模式。</p>
</blockquote>
<p>观察者模式描述了如何建立对象与对象之间的依赖关系，以及如何构造满足这种需求的系统。观察者模式包含观察目标和观察者两类对象，一个目标可以有任意数目的与之相依赖的观察者，一旦观察目标的状态发生改变，所有的观察者都将得到通知。作为对这个通知的响应，每个观察者都将监视观察目标的状态以使其状态与目标状态同步，这种交互也称为发布-订阅(Publish-Subscribe)。观察目标是通知的发布者，它发出通知时并不需要知道谁是它的观察者，可以有任意数目的观察者订阅它并接收通知。</p>
<p>代码实现</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public class MainTest {
</span></span><span class="line"><span class="cl">    public static void main(String[] args) {
</span></span><span class="line"><span class="cl">        WeatherData weatherData = new WeatherData();
</span></span><span class="line"><span class="cl">        CurrentCondition currentCondition = new CurrentCondition();
</span></span><span class="line"><span class="cl">        BaiduSite baiduSite = new BaiduSite();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        // 注册观察者
</span></span><span class="line"><span class="cl">        weatherData.registerObserver(currentCondition);
</span></span><span class="line"><span class="cl">        weatherData.registerObserver(baiduSite);
</span></span><span class="line"><span class="cl">        // 设置数据 一旦数据变化 所有的观察者都会变化
</span></span><span class="line"><span class="cl">        weatherData.setWeatherData(10f, 20f);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        // 移除注册观察者
</span></span><span class="line"><span class="cl">        weatherData.removeObserver(baiduSite);
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        // 唤醒所有已经注册的观察者
</span></span><span class="line"><span class="cl">        weatherData.notifyObservers();
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">interface Subject {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    void registerObserver(Observer observer);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    void removeObserver(Observer observer);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    void notifyObservers();
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">/**
</span></span><span class="line"><span class="cl"> * 观察者
</span></span><span class="line"><span class="cl"> */
</span></span><span class="line"><span class="cl">interface Observer {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    void update(float  temperature, float humidity);
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">class WeatherData implements Subject{
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    private ArrayList&lt;Observer&gt; observers = new ArrayList&lt;&gt;();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    private float temperature;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    private float humidity;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public void setWeatherData(float humidity, float temperature) {
</span></span><span class="line"><span class="cl">        this.humidity = humidity;
</span></span><span class="line"><span class="cl">        this.temperature = temperature;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    public void registerObserver(Observer observer) {
</span></span><span class="line"><span class="cl">        observers.add(observer);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    public void removeObserver(Observer observer) {
</span></span><span class="line"><span class="cl">        if (observers.contains(observer)) {
</span></span><span class="line"><span class="cl">            observers.remove(observer);
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    public void notifyObservers() {
</span></span><span class="line"><span class="cl">        // 唤醒所有的观察者
</span></span><span class="line"><span class="cl">        for (Observer observer : observers) {
</span></span><span class="line"><span class="cl">            observer.update(temperature,humidity);
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">class CurrentCondition implements Observer{
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    private float temperature;
</span></span><span class="line"><span class="cl">    private float humidity;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    public void update(float temperature, float humidity) {
</span></span><span class="line"><span class="cl">        this.temperature = temperature;
</span></span><span class="line"><span class="cl">        this.humidity = humidity;
</span></span><span class="line"><span class="cl">        displayed();
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    void displayed() {
</span></span><span class="line"><span class="cl">        System.out.println(&#34;===当前天气情况===&#34;);
</span></span><span class="line"><span class="cl">        System.out.println(&#34;当前湿度：&#34; + this.temperature);
</span></span><span class="line"><span class="cl">        System.out.println(&#34;当前温度：&#34; + this.humidity);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">class BaiduSite implements Observer{
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    private float temperature;
</span></span><span class="line"><span class="cl">    private float humidity;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    public void update(float temperature, float humidity) {
</span></span><span class="line"><span class="cl">        this.temperature = temperature;
</span></span><span class="line"><span class="cl">        this.humidity = humidity;
</span></span><span class="line"><span class="cl">        displayed();
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    void displayed() {
</span></span><span class="line"><span class="cl">        System.out.println(&#34;===当前百度网站天气情况===&#34;);
</span></span><span class="line"><span class="cl">        System.out.println(&#34;当前湿度：&#34; + this.temperature);
</span></span><span class="line"><span class="cl">        System.out.println(&#34;当前温度：&#34; + this.humidity);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><p>观察者模式是一种使用频率非常高的设计模式，无论是移动应用、Web应用或者桌面应用，观察者模式几乎无处不在，它为实现对象之间的联动提供了一套完整的解决方案，凡是涉及到一对一或者一对多的对象交互场景都可以使用观察者模式。观察者模式广泛应用于各种编程语言的GUI事件处理的实现，在基于事件的XML解析技术（如SAX2）以及Web事件处理中也都使用了观察者模式。</p>
<p><strong>优点</strong></p>
<ul>
<li>观察者和被观察者是抽象耦合的。观察目标只需要维持一个抽象观察者的集合，无须了解其具体观察者。由于观察目标和观察者没有紧密地耦合在一起，因此它们可以属于不同的抽象化层次。</li>
<li>观察者模式满足“<a href="#%E5%BC%80%E6%94%BE%E5%B0%81%E9%97%AD%E5%8E%9F%E5%88%99">开闭原则</a>”的要求，增加新的具体观察者无须修改原有系统代码，在具体观察者与观察目标之间不存在关联关系的情况下，增加新的观察目标也很方便。</li>
<li>观察者模式可以实现表示层和数据逻辑层的分离，定义了稳定的消息更新传递机制，并抽象了更新接口，使得可以有各种各样不同的表示层充当具体观察者角色。</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。</li>
<li>如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。</li>
<li>观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。</li>
</ul>
<p><strong>使用场景</strong></p>
<p>一个对象状态改变给其他对象通知的问题，而且要考虑到易用和低耦合，保证高度的协作。一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知，进行广播通知。</p>
<ul>
<li>一个抽象模型有两个方面，其中一个方面依赖于另一个方面。将这些方面封装在独立的对象中使它们可以各自独立地改变和复用。</li>
<li>一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变，可以降低对象之间的耦合度。</li>
<li>一个对象必须通知其他对象，而并不知道这些对象是谁。</li>
<li>需要在系统中创建一个触发链，A对象的行为将影响B对象，B对象的行为将影响C对象……，可以使用观察者模式创建一种链式触发机制。</li>
</ul>
<p><strong>注意事项：</strong></p>
<ul>
<li>JAVA 中已经有了对观察者模式的支持类。</li>
<li>避免循环引用。</li>
<li>如果顺序执行，某一观察者错误会导致系统卡壳，一般采用异步方式。</li>
</ul>
<h3 id="状态模式">状态模式</h3>
<blockquote>
<p>状态模式：允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。其别名为状态对象，状态模式是一种对象行为型模式。</p>
</blockquote>
<p>状态模式用于解决系统中复杂对象的状态转换以及不同状态下行为的封装问题。当系统中某个对象存在多个状态，这些状态之间可以进行转换，而且对象在不同状态下行为不相同时可以使用状态模式。状态模式将一个对象的状态从该对象中分离出来，封装到专门的状态类中，使得对象状态可以灵活变化，对于客户端而言，无须关心对象状态的转换以及对象所处的当前状态，无论对于何种状态的对象，客户端都可以一致处理。</p>
<p>代码实现</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public class MainTest {
</span></span><span class="line"><span class="cl">    public static void main(String[] args) {
</span></span><span class="line"><span class="cl">        // 创建活动对象，奖品有 1 个奖品
</span></span><span class="line"><span class="cl">        RaffleActivity activity = new RaffleActivity(1);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        // 我们连续抽 300 次奖
</span></span><span class="line"><span class="cl">        for (int i = 0; i &lt; 30; i++) {
</span></span><span class="line"><span class="cl">            System.out.println(&#34;--------第&#34; + (i + 1) + &#34;次抽奖----------&#34;);
</span></span><span class="line"><span class="cl">            // 参加抽奖，第一步点击扣除积分
</span></span><span class="line"><span class="cl">            activity.debuctMoney();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            // 第二步抽奖
</span></span><span class="line"><span class="cl">            activity.raffle();
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">abstract class State {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // 扣除积分 - 50
</span></span><span class="line"><span class="cl">    public abstract void deductMoney();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // 是否抽中奖品
</span></span><span class="line"><span class="cl">    public abstract boolean raffle();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // 发放奖品
</span></span><span class="line"><span class="cl">    public abstract void dispensePrize();
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">class RaffleActivity {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // state 表示活动当前的状态，是变化
</span></span><span class="line"><span class="cl">    State state = null;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // 奖品数量
</span></span><span class="line"><span class="cl">    int count = 0;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // 四个属性，表示四种状态
</span></span><span class="line"><span class="cl">    State noRafflleState = new NoRaffleState(this);
</span></span><span class="line"><span class="cl">    State canRaffleState = new CanRaffleState(this);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    State dispenseState = new DispenseState(this);
</span></span><span class="line"><span class="cl">    State dispensOutState = new DispenseOutState(this);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    //构造器
</span></span><span class="line"><span class="cl">    //1. 初始化当前的状态为 noRafflleState（即不能抽奖的状态）
</span></span><span class="line"><span class="cl">    //2. 初始化奖品的数量
</span></span><span class="line"><span class="cl">    public RaffleActivity(int count) {
</span></span><span class="line"><span class="cl">        this.state = getNoRafflleState();
</span></span><span class="line"><span class="cl">        this.count = count;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    //扣分, 调用当前状态的 deductMoney
</span></span><span class="line"><span class="cl">    public void debuctMoney() {
</span></span><span class="line"><span class="cl">        state.deductMoney();
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    //抽奖
</span></span><span class="line"><span class="cl">    public void raffle() {
</span></span><span class="line"><span class="cl">        // 如果当前的状态是抽奖成功
</span></span><span class="line"><span class="cl">        if (state.raffle()) {
</span></span><span class="line"><span class="cl">            //领取奖品
</span></span><span class="line"><span class="cl">            state.dispensePrize();
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public State getState() {
</span></span><span class="line"><span class="cl">        return state;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public void setState(State state) {
</span></span><span class="line"><span class="cl">        this.state = state;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    //这里请大家注意，每领取一次奖品，count--
</span></span><span class="line"><span class="cl">    public int getCount() {
</span></span><span class="line"><span class="cl">        int curCount = count;
</span></span><span class="line"><span class="cl">        count--;
</span></span><span class="line"><span class="cl">        return curCount;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public void setCount(int count) {
</span></span><span class="line"><span class="cl">        this.count = count;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public State getNoRafflleState() {
</span></span><span class="line"><span class="cl">        return noRafflleState;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public void setNoRafflleState(State noRafflleState) {
</span></span><span class="line"><span class="cl">        this.noRafflleState = noRafflleState;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public State getCanRaffleState() {
</span></span><span class="line"><span class="cl">        return canRaffleState;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public void setCanRaffleState(State canRaffleState) {
</span></span><span class="line"><span class="cl">        this.canRaffleState = canRaffleState;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public State getDispenseState() {
</span></span><span class="line"><span class="cl">        return dispenseState;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public void setDispenseState(State dispenseState) {
</span></span><span class="line"><span class="cl">        this.dispenseState = dispenseState;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public State getDispensOutState() {
</span></span><span class="line"><span class="cl">        return dispensOutState;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public void setDispensOutState(State dispensOutState) {
</span></span><span class="line"><span class="cl">        this.dispensOutState = dispensOutState;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">class DispenseOutState extends State {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // 初始化时传入活动引用
</span></span><span class="line"><span class="cl">    RaffleActivity activity;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public DispenseOutState(RaffleActivity activity) {
</span></span><span class="line"><span class="cl">        this.activity = activity;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    public void deductMoney() {
</span></span><span class="line"><span class="cl">        System.out.println(&#34;奖品发送完了，请下次再参加&#34;);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    public boolean raffle() {
</span></span><span class="line"><span class="cl">        System.out.println(&#34;奖品发送完了，请下次再参加&#34;);
</span></span><span class="line"><span class="cl">        return false;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    public void dispensePrize() {
</span></span><span class="line"><span class="cl">        System.out.println(&#34;奖品发送完了，请下次再参加&#34;);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">class DispenseState extends State {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // 初始化时传入活动引用，发放奖品后改变其状态
</span></span><span class="line"><span class="cl">    RaffleActivity activity;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public DispenseState(RaffleActivity activity) {
</span></span><span class="line"><span class="cl">        this.activity = activity;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    public void deductMoney() {
</span></span><span class="line"><span class="cl">        System.out.println(&#34;不能扣除积分&#34;);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    public boolean raffle() {
</span></span><span class="line"><span class="cl">        System.out.println(&#34;不能抽奖&#34;);
</span></span><span class="line"><span class="cl">        return false;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    //发放奖品
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    public void dispensePrize() {
</span></span><span class="line"><span class="cl">        if (activity.getCount() &gt; 0) {
</span></span><span class="line"><span class="cl">            System.out.println(&#34;恭喜中奖了&#34;);
</span></span><span class="line"><span class="cl">            // 改变状态为不能抽奖
</span></span><span class="line"><span class="cl">            activity.setState(activity.getNoRafflleState());
</span></span><span class="line"><span class="cl">        } else {
</span></span><span class="line"><span class="cl">            System.out.println(&#34;很遗憾，奖品发送完了&#34;);
</span></span><span class="line"><span class="cl">            // 改变状态为奖品发送完毕, 后面我们就不可以抽奖
</span></span><span class="line"><span class="cl">            activity.setState(activity.getDispensOutState());
</span></span><span class="line"><span class="cl">            //System.out.println(&#34;抽奖活动结束&#34;);
</span></span><span class="line"><span class="cl">            //System.exit(0);
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">class NoRaffleState extends State {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // 初始化时传入活动引用，扣除积分后改变其状态
</span></span><span class="line"><span class="cl">    RaffleActivity activity;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public NoRaffleState(RaffleActivity activity) {
</span></span><span class="line"><span class="cl">        this.activity = activity;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // 当前状态可以扣积分 , 扣除后，将状态设置成可以抽奖状态
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    public void deductMoney() {
</span></span><span class="line"><span class="cl">        System.out.println(&#34;扣除 50 积分成功，您可以抽奖了&#34;);
</span></span><span class="line"><span class="cl">        activity.setState(activity.getCanRaffleState());
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // 当前状态不能抽奖
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    public boolean raffle() {
</span></span><span class="line"><span class="cl">        System.out.println(&#34;扣了积分才能抽奖喔！&#34;);
</span></span><span class="line"><span class="cl">        return false;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // 当前状态不能发奖品
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    public void dispensePrize() {
</span></span><span class="line"><span class="cl">        System.out.println(&#34;不能发放奖品&#34;);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">class CanRaffleState extends State {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    RaffleActivity activity;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public CanRaffleState(RaffleActivity activity) {
</span></span><span class="line"><span class="cl">        this.activity = activity;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    public void deductMoney() {
</span></span><span class="line"><span class="cl">        System.out.println(&#34;已经扣取过了积分&#34;);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    //可以抽奖, 抽完奖后，根据实际情况，改成新的状态
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    public boolean raffle() {
</span></span><span class="line"><span class="cl">        System.out.println(&#34;正在抽奖，请稍等！&#34;);
</span></span><span class="line"><span class="cl">        Random r = new Random();
</span></span><span class="line"><span class="cl">        int num = r.nextInt(10);
</span></span><span class="line"><span class="cl">        // 10%中奖机会
</span></span><span class="line"><span class="cl">        if (num == 0) {
</span></span><span class="line"><span class="cl">            // 改变活动状态为发放奖品
</span></span><span class="line"><span class="cl">            activity.setState(activity.getDispenseState());
</span></span><span class="line"><span class="cl">            return true;
</span></span><span class="line"><span class="cl">        } else {
</span></span><span class="line"><span class="cl">            System.out.println(&#34;很遗憾没有抽中奖品！&#34;);
</span></span><span class="line"><span class="cl">            // 改变状态为不能抽奖
</span></span><span class="line"><span class="cl">            activity.setState(activity.getNoRafflleState());
</span></span><span class="line"><span class="cl">            return false;
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // 不能发放奖品
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    public void dispensePrize() {
</span></span><span class="line"><span class="cl">        System.out.println(&#34;没中奖，不能发放奖品&#34;);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><p>状态模式将一个对象在不同状态下的不同行为封装在一个个状态类中，通过设置不同的状态对象可以让环境对象拥有不同的行为，而状态转换的细节对于客户端而言是透明的，方便了客户端的使用。在实际开发中，状态模式具有较高的使用频率，在工作流和游戏开发中状态模式都得到了广泛的应用，例如公文状态的转换、游戏中角色的升级等。</p>
<p><strong>优点</strong></p>
<ul>
<li>封装了状态的转换规则，在状态模式中可以将状态的转换代码封装在环境类或者具体状态类中，可以对状态转换代码进行集中管理，而不是分散在一个个业务方法中。</li>
<li>将所有与某个状态有关的行为放到一个类中，只需要注入一个不同的状态对象即可使环境对象拥有不同的行为。</li>
<li>可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数。</li>
<li>允许状态转换逻辑与状态对象合成一体，而不是提供一个巨大的条件语句块，状态模式可以让我们避免使用庞大的条件语句来将业务方法和状态转换代码交织在一起。</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>状态模式的使用必然会增加系统类和对象的个数。</li>
<li>状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱。</li>
<li>状态模式对“<a href="#%E5%BC%80%E6%94%BE%E5%B0%81%E9%97%AD%E5%8E%9F%E5%88%99">开闭原则</a>”的支持并不太好，增加新的状态类需要修改那些负责状态转换的源代码，否则无法转换到新增状态；而且修改某个状态类的行为也需修改对应类的源代码。</li>
</ul>
<p><strong>使用场景</strong></p>
<p>状态模式主要解决对象的行为依赖于它的状态（属性），并且可以根据它的状态改变而改变它的相关行为。在代码中包含大量与对象状态有关的条件语句时应该考虑使用状态模式。应当注意的是，在行为受状态约束的时候使用状态模式，状态应该不超过 5 个，太多则导致程序结构、代码混乱。</p>
<ul>
<li>行为随状态改变而改变的场景。</li>
<li>条件、分支语句的代替者。</li>
</ul>
<h3 id="策略模式">策略模式</h3>
<blockquote>
<p>策略模式：定义一系列算法类，将每一个算法封装起来，并让它们可以相互替换，策略模式让算法独立于使用它的客户而变化，也称为政策模式。策略模式是一种对象行为型模式。</p>
</blockquote>
<p>策略模式的主要目的是将算法的定义与使用分开，也就是将算法的行为和环境分开，将算法的定义放在专门的策略类中，每一个策略类封装了一种实现算法，使用算法的环境类针对抽象策略类进行编程，符合“依赖倒转原则”。在出现新的算法时，只需要增加一个新的实现了抽象策略类的具体策略类即可。</p>
<p>代码实现</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public class MainTest {
</span></span><span class="line"><span class="cl">    public static void main(String[] args) {
</span></span><span class="line"><span class="cl">        Bird bird = new Bird();
</span></span><span class="line"><span class="cl">        bird.fly();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        Duck duck = new Duck();
</span></span><span class="line"><span class="cl">        duck.fly();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        Dog dog = new Dog();
</span></span><span class="line"><span class="cl">        dog.fly();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        System.out.println(&#34;变为会飞 ：&#34;);
</span></span><span class="line"><span class="cl">        dog.setFlyStrategy(new GoodFlyStrategy());
</span></span><span class="line"><span class="cl">        dog.fly();
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">abstract class AbstractStrategy {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    protected FlyStrategy flyStrategy;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public void setFlyStrategy(FlyStrategy flyStrategy) {
</span></span><span class="line"><span class="cl">        this.flyStrategy = flyStrategy;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public abstract void fly();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">class Bird  extends AbstractStrategy{
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public Bird() {
</span></span><span class="line"><span class="cl">        System.out.print(&#34;小鸟&#34;);
</span></span><span class="line"><span class="cl">        flyStrategy = new GoodFlyStrategy();
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    public void fly() {
</span></span><span class="line"><span class="cl">        flyStrategy.fly();
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">class Duck extends AbstractStrategy {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public Duck() {
</span></span><span class="line"><span class="cl">        System.out.print(&#34;鸭子&#34;);
</span></span><span class="line"><span class="cl">        flyStrategy = new BadFlyStrategy();
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    public void fly() {
</span></span><span class="line"><span class="cl">        flyStrategy.fly();
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">class Dog extends AbstractStrategy {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public Dog() {
</span></span><span class="line"><span class="cl">        System.out.print(&#34;狗&#34;);
</span></span><span class="line"><span class="cl">        flyStrategy = new NoFlyStrategy();
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    public void fly() {
</span></span><span class="line"><span class="cl">        flyStrategy.fly();
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">interface FlyStrategy {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    void fly();
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">class GoodFlyStrategy implements FlyStrategy {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    public void fly() {
</span></span><span class="line"><span class="cl">        System.out.println(&#34;擅长飞翔 ...&#34;);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">class BadFlyStrategy implements FlyStrategy {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    public void fly() {
</span></span><span class="line"><span class="cl">        System.out.println(&#34;不擅长飞翔 ...&#34;);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">class NoFlyStrategy implements FlyStrategy {
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    public void fly() {
</span></span><span class="line"><span class="cl">        System.out.println(&#34;不会飞 ...&#34;);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><p>策略模式用于算法的自由切换和扩展，它是应用较为广泛的设计模式之一。策略模式对应于解决某一问题的一个算法族，允许用户从该算法族中任选一个算法来解决某一问题，同时可以方便地更换算法或者增加新的算法。只要涉及到算法的封装、复用和切换都可以考虑使用策略模式。</p>
<p><strong>优点</strong></p>
<ul>
<li>策略模式提供了对“<a href="#%E5%BC%80%E6%94%BE%E5%B0%81%E9%97%AD%E5%8E%9F%E5%88%99">开闭原则</a>”的完美支持，用户可以在不修改原有系统的基础上选择算法或行为，也可以灵活地增加新的算法或行为。</li>
<li>策略模式提供了管理相关的算法族的办法。策略类的等级结构定义了一个算法或行为族，恰当使用继承可以把公共的代码移到抽象策略类中，从而避免重复的代码。</li>
<li>策略模式提供了一种算法的复用机制，由于将算法单独提取出来封装在策略类中，因此不同的环境类可以方便地复用这些策略类。</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>客户端必须知道所有的策略类，并自行决定使用哪一个策略类。这就意味着客户端必须理解这些算法的区别，以便适时选择恰当的算法。换言之，策略模式只适用于客户端知道所有的算法或行为的情况。</li>
<li>所有策略类都需要对外暴露。</li>
</ul>
<p>如果一个系统的策略多于四个，就需要考虑使用混合模式，解决策略类膨胀的问题。</p>
<p><strong>使用场景</strong></p>
<ul>
<li>
<p>一个系统有许多许多类，而区分它们的只是他们直接的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。</p>
</li>
<li>
<p>如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现。</p>
</li>
</ul>
<h3 id="模板方法模式">模板方法模式</h3>
<blockquote>
<p>模板方法模式：定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。模板方法模式是一种基于继承的代码复用技术，它是一种类行为型模式。</p>
</blockquote>
<p>代码实现</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public class MainTest {
</span></span><span class="line"><span class="cl">    public static void main(String[] args) {
</span></span><span class="line"><span class="cl">        System.out.println(&#34;=====红豆豆浆=====&#34;);
</span></span><span class="line"><span class="cl">        RedBean redBean = new RedBean();
</span></span><span class="line"><span class="cl">        redBean.template();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        System.out.println(&#34;=====花生豆浆=====&#34;);
</span></span><span class="line"><span class="cl">        Peanut peanut = new Peanut();
</span></span><span class="line"><span class="cl">        peanut.template();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        System.out.println(&#34;=====豆浆=====&#34;);
</span></span><span class="line"><span class="cl">        None none = new None();
</span></span><span class="line"><span class="cl">        none.template();
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">abstract class SoyaMilk {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    final void template(){
</span></span><span class="line"><span class="cl">        filterMaterial();
</span></span><span class="line"><span class="cl">        soak();
</span></span><span class="line"><span class="cl">        if (isAppended()) {
</span></span><span class="line"><span class="cl">            add();
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        over();
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    void filterMaterial() {
</span></span><span class="line"><span class="cl">        System.out.println(&#34;第一步：筛选材料&#34;);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    void soak() {
</span></span><span class="line"><span class="cl">        System.out.println(&#34;第二步：浸泡&#34;);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    abstract void add();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    void over(){
</span></span><span class="line"><span class="cl">        System.out.println(&#34;第四步：打豆浆&#34;);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    /**
</span></span><span class="line"><span class="cl">     * 钩子方法
</span></span><span class="line"><span class="cl">     * @return
</span></span><span class="line"><span class="cl">     */
</span></span><span class="line"><span class="cl">    boolean isAppended(){
</span></span><span class="line"><span class="cl">        return true;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">class Peanut extends SoyaMilk{
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    void add() {
</span></span><span class="line"><span class="cl">        System.out.println(&#34;第三步：加入花生&#34;);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">class RedBean extends SoyaMilk {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    void add() {
</span></span><span class="line"><span class="cl">        System.out.println(&#34;第三步：加入红豆&#34;);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">class None extends SoyaMilk {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    void add() {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    boolean isAppended() {
</span></span><span class="line"><span class="cl">        return false;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><p>模板方法模式是基于继承的代码复用技术，它体现了面向对象的诸多重要思想，是一种使用较为频繁的模式。模板方法模式广泛应用于框架设计中，以确保通过父类来控制处理流程的逻辑顺序（如框架的初始化，测试流程的设置等）。</p>
<p><strong>优点</strong></p>
<ul>
<li>它封装了不变部分，扩展可变部分。它把认为是不变部分的算法封装到父类中实现，而把可变部分算法由子类继承实现，便于子类继续扩展。</li>
<li>它在父类中提取了公共的部分代码，便于代码复用。</li>
<li>部分方法是由子类实现的，因此子类可以通过扩展方式增加相应的功能，符合<a href="#%E5%BC%80%E6%94%BE%E5%B0%81%E9%97%AD%E5%8E%9F%E5%88%99">开闭原则</a>。</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>需要为每一个基本方法的不同实现提供一个子类，如果父类中可变的基本方法太多，将会导致类的个数增加，系统更加庞大，设计也更加抽象，间接地增加了系统实现的复杂度。此时，可结合<a href="#%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F">桥接模式</a>来进行设计。</li>
<li>由于继承关系自身的缺点，如果父类添加新的抽象方法，则所有子类都要改一遍。</li>
</ul>
<p><strong>使用场景</strong></p>
<ul>
<li>算法的整体步骤很固定，但其中个别部分易变时，这时候可以使用模板方法模式，将容易变的部分抽象出来，供子类实现。</li>
<li>当多个子类存在公共的行为时，可以将其提取出来并集中到一个公共父类中以避免代码重复。首先，要识别现有代码中的不同之处，并且将不同之处分离为新的操作。最后，用一个调用这些新的操作的模板方法来替换这些不同的代码。</li>
<li>当需要控制子类的扩展时，模板方法只在特定点调用钩子操作，这样就只允许在这些点进行扩展。</li>
</ul>
<h3 id="访问者模式">访问者模式</h3>
<blockquote>
<p>访问者模式：提供一个作用于某对象结构中的各元素的操作表示，它使我们可以在不改变各元素的类的前提下定义作用于这些元素的新操作。访问者模式是一种对象行为型模式。</p>
</blockquote>
<p>代码实现</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public class MainTest {
</span></span><span class="line"><span class="cl">    public static void main(String[] args) {
</span></span><span class="line"><span class="cl">        ObjectStructure objectStructure = new ObjectStructure();
</span></span><span class="line"><span class="cl">        objectStructure.attach(new Man());
</span></span><span class="line"><span class="cl">        objectStructure.attach(new WoMan());
</span></span><span class="line"><span class="cl">        objectStructure.attach(new Man());
</span></span><span class="line"><span class="cl">        objectStructure.attach(new WoMan());
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        // 显示成功的评价
</span></span><span class="line"><span class="cl">        Success success = new Success();
</span></span><span class="line"><span class="cl">        objectStructure.display(success);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        System.out.println(&#34;==================&#34;);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        // 显示失败的评价
</span></span><span class="line"><span class="cl">        Fail fail = new Fail();
</span></span><span class="line"><span class="cl">        objectStructure.display(fail);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">abstract class Action {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    protected abstract void getManResult(Man man);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    protected abstract void getWomanResult(WoMan woman );
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">class Success  extends Action{
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    protected void getManResult(Man man) {
</span></span><span class="line"><span class="cl">        System.out.println(&#34;男人觉得很赞～&#34;);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    protected void getWomanResult(WoMan woman) {
</span></span><span class="line"><span class="cl">        System.out.println(&#34;女人觉得很赞～&#34;);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">class Fail  extends Action{
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    protected void getManResult(Man man) {
</span></span><span class="line"><span class="cl">        System.out.println(&#34;男人觉得很失败～&#34;);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    protected void getWomanResult(WoMan woman) {
</span></span><span class="line"><span class="cl">        System.out.println(&#34;女人觉得很失败～&#34;);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">abstract class  Person {
</span></span><span class="line"><span class="cl">    abstract void accpet(Action action);
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">class WoMan extends Person{
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    void accpet(Action action) {
</span></span><span class="line"><span class="cl">         action.getWomanResult(this);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">class Man  extends Person{
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    void accpet(Action action) {
</span></span><span class="line"><span class="cl">        action.getManResult(this);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">class ObjectStructure {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    ArrayList&lt;Person&gt; people =  new ArrayList&lt;&gt;();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public void attach(Person person) {
</span></span><span class="line"><span class="cl">        people.add(person);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public void detach(Person person) {
</span></span><span class="line"><span class="cl">        people.remove(person);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public void display(Action acion) {
</span></span><span class="line"><span class="cl">        people.forEach(item -&gt; {
</span></span><span class="line"><span class="cl">            item.accpet(acion);
</span></span><span class="line"><span class="cl">        });
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><p>由于访问者模式的使用条件较为苛刻，本身结构也较为复杂，因此在实际应用中使用频率不是特别高。当系统中存在一个较为复杂的对象结构，且不同访问者对其所采取的操作也不相同时，可以考虑使用访问者模式进行设计。在XML文档解析、编译器的设计、复杂集合对象的处理等领域访问者模式得到了一定的应用。</p>
<p><strong>优点</strong></p>
<ul>
<li>扩展性好。增加新的访问操作很方便。使用访问者模式，增加新的访问操作就意味着增加一个新的具体访问者类，实现简单，无须修改源代码，符合“<a href="#%E5%BC%80%E6%94%BE%E5%B0%81%E9%97%AD%E5%8E%9F%E5%88%99">开闭原则</a>”。</li>
<li>复用性好。可以通过访问者来定义整个对象结构通用的功能，从而提高系统的复用程度。</li>
<li>灵活性好。访问者模式将数据结构与作用于结构上的操作解耦，使得操作集合可相对自由地演化而不影响系统的数据结构。</li>
<li>符合<a href="#%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99">单一职责原则</a>。访问者模式把相关的行为封装在一起，构成一个访问者，使每一个访问者的功能都比较单一。</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>破坏封装。访问者模式中具体元素对访问者公布细节，这破坏了对象的封装性。具体元素对访问者公布细节，违反了<a href="#%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99">迪米特法则</a></li>
<li>违反了<a href="#%E4%BE%9D%E8%B5%96%E5%80%92%E7%BD%AE%E5%8E%9F%E5%88%99">依赖倒置原则</a>。访问者模式依赖了具体类，而没有依赖抽象类。</li>
</ul>
<p><strong>使用场景</strong></p>
<p>需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作&quot;污染&quot;这些对象的类，使用访问者模式将这些封装到类中。访问者可以对功能进行统一，可以做报表、UI、拦截器与过滤器。</p>
<ul>
<li>对象结构中对象对应的类很少改变，但经常需要在此对象结构上定义新的操作。</li>
<li>需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作&quot;污染&quot;这些对象的类，也不希望在增加新操作时修改这些类。</li>
</ul>
</div>
                    <div id="post_footer" class="post_footer">
                        <div class="meta">
                            <div id="post_footer_info" class="info">
                                <span class="field tags">
                                    <i class="ri-stack-line"></i>
                                    
                                        
                                        <a href="https://whiteppure.github.io/iblog/tags/java/">Java</a>
                                        
                                        <a href="https://whiteppure.github.io/iblog/tags/java%E5%9F%BA%E7%A1%80/">Java基础</a>
                                        
                                    
                                    
                                      <span id="busuanzi_container_page_pv">
                                          阅读量<span id="busuanzi_value_page_pv"></span>次
                                      </span>
                                    
                                </span>
                            </div>
                        </div>
                    </div>
                </div>
                
                
                
<div id="doc_comments" class="doc_comments">
    <div class="comments_block_title">发表评论</div>
    <div id="vcomments"></div>
</div>

<link rel="stylesheet" href="https://whiteppure.github.io/iblog/css/comments.css" />

<script src='//unpkg.com/valine/dist/Valine.min.js'></script>

<script type="text/javascript">
    new Valine({
        el: '#vcomments',
        appId: 'pRSrjsfbN6L1DUxgfqJWOMYP-gzGzoHsz',
        appKey: 'VPWpnDPGDM8Xhdlh5OvHOpak',
        placeholder: '说点什么吧...',
        visitor: 'true',
        
        emojiCDN: '//i0.hdslb.com/bfs/emote/',
        
        emojiMaps: {
            "tv_doge": "6ea59c827c414b4a2955fe79e0f6fd3dcd515e24.png",
            "tv_亲亲": "a8111ad55953ef5e3be3327ef94eb4a39d535d06.png",
            "tv_偷笑": "bb690d4107620f1c15cff29509db529a73aee261.png",
            "tv_再见": "180129b8ea851044ce71caf55cc8ce44bd4a4fc8.png",
            "tv_冷漠": "b9cbc755c2b3ee43be07ca13de84e5b699a3f101.png",
            "tv_发怒": "34ba3cd204d5b05fec70ce08fa9fa0dd612409ff.png",
            "tv_发财": "34db290afd2963723c6eb3c4560667db7253a21a.png",
            "tv_可爱": "9e55fd9b500ac4b96613539f1ce2f9499e314ed9.png",
            "tv_吐血": "09dd16a7aa59b77baa1155d47484409624470c77.png",
            "tv_呆": "fe1179ebaa191569b0d31cecafe7a2cd1c951c9d.png",
            "tv_呕吐": "9f996894a39e282ccf5e66856af49483f81870f3.png",
            "tv_困": "241ee304e44c0af029adceb294399391e4737ef2.png",
            "tv_坏笑": "1f0b87f731a671079842116e0991c91c2c88645a.png",
            "tv_大佬": "093c1e2c490161aca397afc45573c877cdead616.png",
            "tv_大哭": "23269aeb35f99daee28dda129676f6e9ea87934f.png",
            "tv_委屈": "d04dba7b5465779e9755d2ab6f0a897b9b33bb77.png",
            "tv_害羞": "a37683fb5642fa3ddfc7f4e5525fd13e42a2bdb1.png",
            "tv_尴尬": "7cfa62dafc59798a3d3fb262d421eeeff166cfa4.png",
            "tv_微笑": "70dc5c7b56f93eb61bddba11e28fb1d18fddcd4c.png",
            "tv_思考": "90cf159733e558137ed20aa04d09964436f618a1.png",
            "tv_惊吓": "0d15c7e2ee58e935adc6a7193ee042388adc22af.png",
            "tv_打脸": "56ab10b624063e966bfcb76ea5dc4794d87dfd47.png",
            "tv_抓狂": "fe31c08edad661d63762b04e17b8d5ae3c71a757.png",
            "tv_抠鼻": "c666f55e88d471e51bbd9fab9bb308110824a6eb.png",
            "tv_斜眼笑": "911f987aa8bc1bee12d52aafe62bc41ef4474e6c.png",
            "tv_无奈": "ea8ed89ee9878f2fece2dda0ea8a5dbfe21b5751.png",
            "tv_晕": "5443c22b4d07fb1907ccc610c8e6db254f2461b7.png",
            "tv_流汗": "cead1c351ab8d79e9f369605beb90148db0fbed3.png",
            "tv_流泪": "7e71cde7858f0cd50d74b0264aa26db612a8a167.png",
            "tv_流鼻血": "c32d39db2737f89b904ca32700d140a9241b0767.png",
            "tv_点赞": "f85c354995bd99e28fc76c869bfe42ba6438eff4.png",
            "tv_生气": "26702dcafdab5e8225b43ffd23c94ac1ff932654.png",
            "tv_生病": "8b0ec90e6b86771092a498c54f09fc94621c1900.png",
            "tv_疑问": "0793d949b18d7be716078349c202c15ff166f314.png",
            "tv_白眼": "c1d59f439e379ee50eef488bcb5e5378e5044ea4.png",
            "tv_皱眉": "72ccad6679fea0d14cce648b4d818e09b8ffea2d.png",
            "tv_目瞪口呆": "0b8cb81a68de5d5365212c99375e7ace3e7891b7.png",
            "tv_睡着": "8b196675b53af58264f383c50ad0945048290b33.png",
            "tv_笑哭": "1abc628f6d4f4caf9d0e7800878f4697abbc8273.png",
            "tv_腼腆": "89712c0d4af73e67f89e35cbc518420380a7f6f4.png",
            "tv_色": "61822c7e9aae5da76475e7892534545336b23a6f.png",
            "tv_调侃": "4bc022533ef31544ca0d72c12c808cf4a1cce3e3.png",
            "tv_调皮": "b9c41de8e82dd7a8515ae5e3cb63e898bf245186.png",
            "tv_鄙视": "6e72339f346a692a495b123174b49e4e8e781303.png",
            "tv_闭嘴": "c9e990da7f6e93975e25fd8b70e2e290aa4086ef.png",
            "tv_难过": "87f46748d3f142ebc6586ff58860d0e2fc8263ba.png",
            "tv_馋": "fc7e829b845c43c623c8b490ee3602b7f0e76a31.png",
            "tv_鬼脸": "0ffbbddf8a94d124ca2f54b360bbc04feb6bbfea.png",
            "tv_黑人问号": "45821a01f51bc867da9edbaa2e070410819a95b2.png",
            "tv_鼓掌": "1d21793f96ef4e6f48b23e53e3b9e42da833a0f6.png"
        }
    })
</script>

                
            </div>
        </div>
    </div>
    <div class="side_nav">
    
    <a id="top_to_back" href="#" class="top_to_back">
        <svg t="1688614744062" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2152" width="16" height="16"><path d="M966.4 323.2c-9.6-9.6-25.6-9.6-35.2 0l-416 416-425.6-416c-9.6-9.6-25.6-9.6-35.2 0-9.6 9.6-9.6 25.6 0 35.2l441.6 432c9.6 9.6 25.6 9.6 35.2 0l435.2-432C976 345.6 976 332.8 966.4 323.2z" p-id="2153" fill="#424242"></path></svg>    </a>
    
    <div>
        <a id="content_display" class="content_display">
            <svg t="1688606941910" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="57753" width="18" height="18"><path d="M192 448c10.9 0 21.8-4.2 30.2-12.5L497 160.8c5.4-5.4 11.8-6.2 15.1-6.2 3.3 0 9.6 0.8 15.1 6.2l274.7 274.7c16.7 16.7 43.7 16.7 60.3 0 16.7-16.7 16.7-43.7 0-60.3L587.4 100.4c-41.6-41.6-109.3-41.6-150.9 0L161.8 375.2c-16.7 16.7-16.7 43.7 0 60.3 8.4 8.3 19.3 12.5 30.2 12.5zM801.8 588.5L527.1 863.2c-5.4 5.4-11.8 6.2-15.1 6.2-3.3 0-9.7-0.8-15.1-6.2L222.2 588.5c-16.7-16.7-43.7-16.7-60.3 0-16.7 16.7-16.7 43.7 0 60.3l274.8 274.8c20.8 20.8 48.1 31.2 75.4 31.2 27.3 0 54.6-10.4 75.4-31.2l274.7-274.8c16.7-16.7 16.7-43.7 0-60.3-16.7-16.7-43.7-16.7-60.4 0z" fill="#424242" p-id="57754"></path></svg>
        </a>
        <a id="content_hidden" class="content_hidden">
            <svg t="1688603143752" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="15592" width="18" height="18"><path d="M479.004101 645.938677L165.25229 958.480465a37.510709 37.510709 0 0 0 0 54.059551 36.47863 36.47863 0 0 0 53.063061 0l293.679668-292.576411 293.715256 292.576411a36.443042 36.443042 0 0 0 53.063061 0 37.510709 37.510709 0 0 0 0-54.059551l-313.751811-312.541788c-21.210989-22.349834-36.514219-24.698702-66.017424 0z m66.053013-267.877709l312.577377-312.541789a37.510709 37.510709 0 0 0 0-54.059551 36.443042 36.443042 0 0 0-53.063061 0l-292.505234 292.576411L219.560963 11.459628a36.47863 36.47863 0 0 0-53.063061 0 37.510709 37.510709 0 0 0 0 54.059551l312.577377 312.541789a46.58588 46.58588 0 0 0 65.981835-0.035589z" p-id="15593" fill="#424242"></path></svg>
        </a>
    </div>
    
    <a id="back_to_top" href="#" class="back_to_top">
        <svg t="1688628374733" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3166" width="16" height="16"><path d="M966.4 668.8l-435.2-432c-9.6-9.6-25.6-9.6-35.2 0l-441.6 432c-9.6 9.6-9.6 25.6 0 35.2 9.6 9.6 25.6 9.6 35.2 0l425.6-416 416 416c9.6 9.6 25.6 9.6 35.2 0S976 678.4 966.4 668.8z" p-id="3167" fill="#424242"></path></svg>
    </a>
</div>
    <footer class="footer">
    <div id="footer_powered_by" class="powered_by">
        <a href="https://varkai.com">Designed by VarKai,</a>
        <a href="http://www.gohugo.io/">Proudly published with Hugo</a>
    </div>

    <div id="footer_slogan" class="footer_slogan">
        <span>whitepure@2020</span>
    </div>
</footer>
    <script src="https://whiteppure.github.io/iblog/js/jquery-3.5.1.min.js"></script>
<link href="https://whiteppure.github.io/iblog/css/fancybox.min.css" rel="stylesheet">
<script src="https://whiteppure.github.io/iblog/js/fancybox.min.js"></script>
<script src="https://whiteppure.github.io/iblog/js/darkmode.js"></script>
<script src="https://whiteppure.github.io/iblog/js/zozo.js"></script>
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="https://whiteppure.github.io/iblog/js/busuanzi_2.3_busuanzi.pure.mini.js"></script>
<script src="https://whiteppure.github.io/iblog/js/html2canvas.js"></script>
<script src="https://whiteppure.github.io/iblog/js/utils.js"></script>
<script src="https://whiteppure.github.io/iblog/js/html2md.js"></script>
<script src="https://whiteppure.github.io/iblog/js/htmlexport.js"></script>
<script src="https://whiteppure.github.io/iblog/js/autodarkmode.js"></script>










</body>

</html>