<!DOCTYPE html>
<html lang="zh" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="whitepure" />
	
	
	
	<title>Java数据类型 ｜ 脚踏实地</title>
	
    
    
    <meta name="description" content="基本类型 Java语言提供了八种基本类型。六种数值类型（四个整数型，两个浮点型），一种字符类型，还有一种布尔型. 俗称4类8种 这里只介绍称4类8种.实际上，JAVA" />
    

    
    
    <meta name="keywords" content="whitepure博客, whiteppure, whitepure, 李济芝, Java, 博客, 技术博客" />
    

	

    <link rel="shortcut icon" href="https://whiteppure.github.io/iblog/images/favicon.ico" />

    <link rel="stylesheet" type="text/css" media="screen" href="https://whiteppure.github.io/iblog/css/normalize.css" />

    <link rel="stylesheet" type="text/css" media="screen" href="https://whiteppure.github.io/iblog/css/animate.min.css" />
    <link rel="stylesheet" type="text/css" media="screen" href="https://whiteppure.github.io/iblog/css/zozo.css" />
	<link rel="stylesheet" type="text/css" media="screen" href="https://cdn.jsdelivr.net/npm/remixicon@2.5.0/fonts/remixicon.css" />
    <link rel="stylesheet" type="text/css" media="screen" href="https://whiteppure.github.io/iblog/css/highlight.css" />

    <link rel="stylesheet" type="text/css" media="screen" href="https://whiteppure.github.io/iblog/css/toc.css" />
    <link rel="stylesheet" type="text/css" media="screen" href="https://whiteppure.github.io/iblog/css/search.css" />

    
    
</head>

<body>
    <div class="post-password">
        
    </div>

    
    
    









<div id="post_content_toc" class="toc">
    <div class="page-header"><strong></strong></div>
    <div id="page-scrollspy" class="toc-nav">

        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e5%9f%ba%e6%9c%ac%e7%b1%bb%e5%9e%8b">
                    基本类型
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e6%95%b0%e5%80%bc%e7%b1%bb%e5%9e%8b">
                    数值类型
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e6%95%b4%e5%9e%8b">
                    整型
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e6%b5%ae%e7%82%b9%e5%9e%8b">
                    浮点型
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e5%ad%97%e7%ac%a6%e7%b1%bb%e5%9e%8b">
                    字符类型
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e5%b8%83%e5%b0%94%e7%b1%bb%e5%9e%8b">
                    布尔类型
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e7%b1%bb%e5%9e%8b%e8%bd%ac%e6%8d%a2">
                    类型转换
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e8%87%aa%e5%8a%a8%e7%b1%bb%e5%9e%8b%e8%bd%ac%e6%8d%a2">
                    自动类型转换
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e9%9a%90%e5%bc%8f%e7%b1%bb%e5%9e%8b%e8%bd%ac%e6%8d%a2">
                    隐式类型转换
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e5%8c%85%e8%a3%85%e7%b1%bb%e5%9e%8b">
                    包装类型
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e6%8b%86%e7%ae%b1%e4%b8%8e%e8%a3%85%e7%ae%b1">
                    拆箱与装箱
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e8%87%aa%e5%8a%a8%e6%8b%86%e8%a3%85%e7%ae%b1">
                    自动拆装箱
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e8%87%aa%e5%8a%a8%e6%8b%86%e8%a3%85%e7%ae%b1%e5%b8%a6%e6%9d%a5%e7%9a%84%e9%97%ae%e9%a2%98">
                    自动拆装箱带来的问题
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e7%bc%93%e5%ad%98%e6%b1%a0">
                    缓存池
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e5%bc%95%e7%94%a8%e7%b1%bb%e5%9e%8b">
                    引用类型
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e4%b8%8e%e5%9f%ba%e6%9c%ac%e7%b1%bb%e5%9e%8b%e5%8c%ba%e5%88%ab">
                    与基本类型区别
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e6%b3%a8%e6%84%8f%e4%ba%8b%e9%a1%b9">
                    注意事项
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e5%b8%b8%e9%87%8f">
                    常量
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e5%ae%9a%e4%b9%89%e5%b8%b8%e9%87%8f">
                    定义常量
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e5%b8%b8%e9%87%8f%e6%b1%a0">
                    常量池
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#class%e5%b8%b8%e9%87%8f%e6%b1%a0">
                    Class常量池
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e8%bf%90%e8%a1%8c%e6%97%b6%e5%b8%b8%e9%87%8f%e6%b1%a0">
                    运行时常量池
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e5%ad%97%e7%ac%a6%e4%b8%b2%e5%b8%b8%e9%87%8f%e6%b1%a0">
                    字符串常量池
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e9%9c%80%e8%a6%81%e5%b8%b8%e9%87%8f%e6%b1%a0">
                    为什么需要常量池
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#string-%e7%b1%bb">
                    String 类
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e4%b8%ba%e4%bb%80%e4%b9%88jdk9%e6%94%b9%e5%8f%98%e4%ba%86%e5%ad%98%e5%82%a8%e7%bb%93%e6%9e%84">
                    为什么JDK9改变了存储结构
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e4%b8%8d%e5%8f%af%e5%8f%98%e6%80%a7">
                    不可变性
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e4%bd%bf%e7%94%a8">
                    使用
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e5%88%9b%e5%bb%ba%e5%ad%97%e7%ac%a6%e4%b8%b2">
                    创建字符串
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e8%bf%9e%e6%8e%a5%e5%ad%97%e7%ac%a6%e4%b8%b2">
                    连接字符串
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e5%b8%b8%e7%94%a8%e6%96%b9%e6%b3%95">
                    常用方法
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e9%95%bf%e5%ba%a6%e9%99%90%e5%88%b6">
                    长度限制
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e7%bc%96%e7%a0%81%e9%97%ae%e9%a2%98">
                    编码问题
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#unicode">
                    Unicode
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e4%b9%b1%e7%a0%81%e5%8e%9f%e5%9b%a0">
                    乱码原因
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e7%9b%b8%e5%85%b3%e6%96%b9%e6%b3%95">
                    相关方法
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        

    </div>

</div>



    

    
    <div class="main animate__animated animate__fadeInDown" id="main_content">
        <div class="nav_container animated fadeInDown">
    <div class="site_nav" id="site_nav">
        <ul><li class="">
                <a href="https://whiteppure.github.io/iblog/">首页</a>
            </li><li class="">
                <a href="https://whiteppure.github.io/iblog/posts/">归档</a>
            </li><li class="">
                <a href="https://whiteppure.github.io/iblog/tags/">标签</a>
            </li><li class="">
                <a href="https://whiteppure.github.io/iblog/about/">关于</a>
            </li>
        </ul>
    </div>
    <div class="menu_icon">
        <a id="menu_icon"><i class="ri-menu-line"></i></a>
    </div>
</div>
        <div id="post_header" class="header animated fadeInDown">
    <div class="site_title_container">
        <div class="site_title">
            <h1>
                <a href="https://whiteppure.github.io/iblog/">
                    <span>脚踏实地</span>
                </a>
            </h1>
        </div>
        <div class="description">
            <p class="sub_title">
                
            </p>

            
            <div class="my_socials">
                
                    
                    <a href="https://github.com/whiteppure/" title="github" target="_blank">
                        <i class="ri-github-fill"></i>
                    </a>
                    
                
                <a href="https://whiteppure.github.io/iblog/index.xml" type="application/rss+xml" title="rss" target="_blank">
                    <i class="ri-rss-fill"></i>
                </a>
                
                
                <span id="sys_function" class="sys_function display_none">
                    <a id="export_pdf"  title="导出pdf" style="border: none; background-color: #ffffff; cursor: pointer; margin-left: 10px">
                        <svg t="1688701481347" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3517" width="16" height="16"><path d="M425.610455 85.814544H149.05897A42.303635 42.303635 0 0 0 106.6274 128.075535V896.492068c0 23.326702 18.976933 42.26099 42.43157 42.26099h682.743143a42.559504 42.559504 0 0 0 42.431569-42.559504v-384.016365a42.644793 42.644793 0 0 1 85.289587 0v384.016365A127.849091 127.849091 0 0 1 831.802113 1024H149.05897A127.635867 127.635867 0 0 1 21.337813 896.449423V128.03289A127.593222 127.593222 0 0 1 149.101614 0.524957h276.466196a42.644793 42.644793 0 0 1 0 85.289587z m564.062683 158.08425l-170.579174 170.579173a42.644793 42.644793 0 1 1-60.299738-60.299738L856.578738 256.393718H618.364922a42.644793 42.644793 0 1 1 0-85.289587h238.213816l-97.784512-97.784511A42.644793 42.644793 0 1 1 819.093964 13.019882l170.579174 170.579174a42.644793 42.644793 0 0 1 0 60.299738zM149.272194 597.552066a42.644793 42.644793 0 0 1 42.644793-42.644794h51.514911c59.190973 0 107.891327 23.284057 107.976617 97.102195 0 71.003581-49.46796 102.347504-106.185536 102.347504h-31.343923v66.781747a32.282109 32.282109 0 0 1-64.606862 0V597.552066z m92.709781 100.215264c31.429213 0 46.568114-16.46089 46.568114-45.757863 0-30.064579-17.313786-40.512554-48.359196-40.512554h-26.311837v86.270417h28.145563z m232.414124-142.860058c81.878003 0 136.036891 43.710913 136.036891 147.67892S556.231457 853.420826 477.935617 853.420826h-38.16709a42.644793 42.644793 0 0 1-42.644794-42.644793v-213.223967a42.644793 42.644793 0 0 1 42.644794-42.644794h34.542282z m-4.008611 240.729859c43.32711 0 73.988717-22.047358 73.988717-93.050939 0-71.046226-30.704251-90.705476-73.988717-90.705476h-8.699538v183.79906h8.699538zM692.481573 853.420826a32.282109 32.282109 0 0 1-32.282109-32.282108V597.552066a42.644793 42.644793 0 0 1 42.644793-42.644794h99.063855a29.680776 29.680776 0 1 1 0 59.404197h-77.144431v65.374469h61.749661a29.894 29.894 0 1 1 0 59.788h-61.749661v81.66478a32.282109 32.282109 0 0 1-32.282108 32.282108z" fill="#5f5f5f" p-id="3518"></path></svg>
                    </a>
                    <a id="export_pic" title="导出图片" style="border: none; background-color: #ffffff; cursor: pointer; margin-left: 10px">
                        <svg t="1689071509720" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4564" width="16" height="16"><path d="M909.132886 0.037506h-184.960611a33.909445 33.909445 0 0 0-32.368107 33.909445 33.909445 33.909445 0 0 0 33.909445 33.395666h158.244078l-200.373995 199.346437a33.395666 33.395666 0 0 0 0 47.781491 31.854327 31.854327 0 0 0 23.633856 9.76181 33.909445 33.909445 0 0 0 24.147635-9.76181l198.832657-199.346437V272.340628a33.909445 33.909445 0 0 0 69.874009 0V88.921355A88.37007 88.37007 0 0 0 909.132886 0.037506zM216.558153 347.866211a107.37991 107.37991 0 1 0 107.37991-107.379911 107.89369 107.89369 0 0 0-107.37991 107.379911z m154.133843 0a51.377948 51.377948 0 0 1-97.618101 0 51.377948 51.377948 0 1 1 97.618101 0z" p-id="4565" fill="#424242"></path><path d="M963.079731 437.777619a34.423225 34.423225 0 0 0-33.909446 33.909445v265.110209a1811.07265 1811.07265 0 0 0-137.692899-193.181082 106.352351 106.352351 0 0 0-78.60826-36.478343 123.820854 123.820854 0 0 0-82.204716 35.964563l-3.596456 3.082677-188.557068 176.74014c-11.816928-13.358266-47.781491-51.377948-82.204716-87.856291a83.232275 83.232275 0 0 0-85.801172-21.578738 105.324792 105.324792 0 0 0-38.019681 19.52362l-141.289356 121.765736V89.948914a22.092517 22.092517 0 0 1 22.606297-22.606297h417.702713a33.395666 33.395666 0 0 0 33.395666-33.909445 33.395666 33.395666 0 0 0-33.395666-33.395666H113.802258A89.911408 89.911408 0 0 0 23.89085 89.948914v844.139678a89.911408 89.911408 0 0 0 89.911408 89.911408h793.27551a89.911408 89.911408 0 0 0 89.397629-89.911408v-462.401528a33.909445 33.909445 0 0 0-33.395666-33.909445z m-33.909446 496.310973a22.606297 22.606297 0 0 1-22.092517 22.606297H113.802258a22.606297 22.606297 0 0 1-22.606297-22.606297v-88.37007l183.933052-160.812976a43.157476 43.157476 0 0 1 15.413385-7.192912 15.927164 15.927164 0 0 1 17.982281 5.137794c37.505902 36.478343 78.60826 83.232275 82.718496 87.856291a61.653537 61.653537 0 0 0 42.643696 22.092517 62.681096 62.681096 0 0 0 51.377948-20.037399c8.220472-8.220472 134.610223-125.875971 194.208641-181.877935a57.029522 57.029522 0 0 1 34.423225-16.440943 45.212594 45.212594 0 0 1 29.79921 15.927164 2954.231982 2954.231982 0 0 1 186.501949 256.889738z" p-id="4566" fill="#424242"></path></svg>
                    </a>
                    <a id="export_markdown" title="导出markdown" style="border: none; background-color: #ffffff; cursor: pointer; margin-left: 10px">
                        <svg t="1689071035200" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="13570" width="16" height="16"><path d="M178.073367 843.957262V461.158929h107.121045l107.121045 140.734874 107.125433-140.734874h107.116657v382.798333h-107.116657v-219.54307l-107.125433 140.730486-107.116657-140.730486v219.54307zM737.783131 892.148786l-131.221196-209.156132h87.479334V461.158929h87.479335v221.833725h87.483722z" p-id="13571" fill="#424242"></path><path d="M911.9958 217.142709c10.672172 10.663395 19.812851 25.144549 27.430816 43.430297 7.617965 18.285748 11.431335 35.044392 11.431336 50.28471V969.140255c0 15.235929-5.336086 28.18998-15.999481 38.853375-10.667783 10.667783-23.621834 16.003869-38.857763 16.003869H127.994904c-15.240317 0-28.18998-5.336086-38.857763-16.003869-10.663395-10.663395-15.999481-23.617446-15.999481-38.853375V54.852856c0-15.240317 5.331698-28.18998 15.999481-38.857763C99.804925 5.336086 112.758975 0 127.999292 0h512.000944c15.235929 0 31.998962 3.808982 50.28471 11.426947 18.285748 7.622353 32.762514 16.763033 43.430297 27.426428zM658.290372 77.715526v214.856442h214.856442c-3.808982-11.049559-7.99974-18.856218-12.572275-23.43314l-178.855415-178.851027c-4.572534-4.572534-12.383581-8.763292-23.43314-12.572275z m219.428976 873.143369V365.71496h-237.714724c-15.240317 0-28.18998-5.336086-38.857763-15.999481-10.663395-10.667783-15.999481-23.621834-15.999481-38.857763V73.142992H146.28504v877.715903z" p-id="13572" fill="#424242"></path></svg>
                    </a>
                    <a id="export_doc" title="导出文档" style="border: none; background-color: #ffffff; cursor: pointer; margin-left: 10px">
                        <svg t="1689246982401" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="6825" width="16" height="16"><path d="M270.76864 608.32h180.8a31.68 31.68 0 0 0 0-62.976H270.76864a31.68 31.68 0 0 0 0 62.976zM271.34464 458.56h457.92a33.472 33.472 0 0 0 31.552-34.752 33.28 33.28 0 0 0-31.552-34.624H271.34464a34.816 34.816 0 0 0 0 69.376zM271.34464 293.504h457.92a33.344 33.344 0 0 0 31.552-34.688 33.216 33.216 0 0 0-31.552-34.624H271.34464a33.28 33.28 0 0 0-31.616 34.624 33.28 33.28 0 0 0 31.616 34.688z" p-id="6826" fill="#424242"></path><path d="M869.87264 0H153.77664A70.4 70.4 0 0 0 84.65664 70.912V953.6A69.952 69.952 0 0 0 153.77664 1024h370.048a32 32 0 0 0 0-63.68H147.12064V64h729.6v468.672a31.296 31.296 0 1 0 62.528 0V70.912A70.4 70.4 0 0 0 869.87264 0z" p-id="6827" fill="#424242"></path><path d="M482.16064 730.624h337.664L715.82464 625.216a28.864 28.864 0 0 1-7.936-28.736 29.184 29.184 0 0 1 20.608-21.184 29.632 29.632 0 0 1 29.12 8.128l174.784 177.216-174.784 176.96a29.184 29.184 0 0 1-49.728-13.312 29.248 29.248 0 0 1 8-28.8l103.936-105.344H482.16064a29.696 29.696 0 0 1-29.504-29.76 29.632 29.632 0 0 1 29.504-29.76z" p-id="6828" fill="#424242"></path></svg>
                    </a>
                </span>
                <a  id="icon_more" title="更多" >
                    <svg t="1688715321313" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5356" width="16" height="16"><path d="M483.555556 199.111111m-85.333334 0a85.333333 85.333333 0 1 0 170.666667 0 85.333333 85.333333 0 1 0-170.666667 0Z" fill="#424242" p-id="5357"></path><path d="M483.555556 540.444444m-85.333334 0a85.333333 85.333333 0 1 0 170.666667 0 85.333333 85.333333 0 1 0-170.666667 0Z" fill="#424242" p-id="5358"></path><path d="M483.555556 881.777778m-85.333334 0a85.333333 85.333333 0 1 0 170.666667 0 85.333333 85.333333 0 1 0-170.666667 0Z" fill="#424242" p-id="5359"></path></svg>
                </a>
                <a  id="icon_less" class="display_none">
                    <svg t="1688723160472" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="15872" width="16" height="16"><path d="M300.105143 592.676571h423.789714a80.676571 80.676571 0 1 0 0-161.353142H300.105143a80.676571 80.676571 0 0 0 0 161.353142z" fill="#8a8a8a" p-id="15873"></path></svg>
                </a>
                
            </div>

            
            <div class="post">
                <div class="post_title post_detail_title">
                    <span class="date" id="busuanzi_container_site_pv">访问量 <span id="busuanzi_value_site_pv"></span>次</span>
                </div>
                <div class="post_title post_detail_title">
                    <span class="date" id="busuanzi_container_site_uv">访客数 <span id="busuanzi_value_site_uv"></span>人</span>
                </div>
            </div>
            
        </div>
    </div>
</div>
        <div class="content">
            <div class="post_page">
                <div class="post animate__animated animate__fadeInDown">
                    <div class="post_title post_detail_title">
                        <h2 id="post_single_title">Java数据类型</h2>
                        <span id="post_page_title_date" class="date">2021.01.20</span>
                    </div>
                    <div class="post_content markdown"><h2 id="基本类型">基本类型</h2>
<p>Java语言提供了八种基本类型。六种数值类型（四个整数型，两个浮点型），一种字符类型，还有一种布尔型.  <strong>俗称4类8种</strong></p>
<p>这里只介绍称4类8种.实际上，JAVA中还存在另外一种基本类型 void，它也有对应的包装类<code>java.lang.Void</code>，不过我们无法直接对它们进行操作.</p>
<blockquote>
<p>一个Byte(字节)等于8个bit(位),bit是最小的单位,1B(字节)=8bit(位). <br>
一般情况下，一个汉字是两个字节，英文与数字是一个字节</p>
</blockquote>
<h3 id="数值类型">数值类型</h3>
<h4 id="整型">整型</h4>
<ul>
<li>
<p>byte/8</p>
<ul>
<li>byte 数据类型是8位、有符号的，以二进制补码表示的整数;</li>
<li>最小值是 <code>-128（-2^7)</code></li>
<li>最大值是 <code>127（2^7-1）</code></li>
<li>默认值是 0</li>
<li>byte 类型用在大型数组中节约空间，主要代替整数，因为byte变量占用的空间只有int类型的四分之一</li>
<li>例子：<code>byte a = 100，byte b = -50</code></li>
</ul>
</li>
<li>
<p>short/16</p>
<ul>
<li>short 数据类型是16位、有符号的以二进制补码表示的整数</li>
<li>最小值是 <code>-32768（-2^15）</code></li>
<li>最大值是 <code>32767（2^15 - 1）</code></li>
<li>Short 数据类型也可以像byte那样节省空间.一个short变量是int型变量所占空间的二分之一</li>
<li>默认值是 0</li>
<li>例子：<code>short s = 1000，short r = -20000</code></li>
</ul>
</li>
<li>
<p>int/32</p>
<ul>
<li>int 数据类型是32位、有符号的以二进制补码表示的整数</li>
<li>最小值是 <code>-2,147,483,648（-2^31）</code></li>
<li>最大值是 <code>2,147,483,647（2^31 - 1）</code></li>
<li>一般地整型变量默认为 int 类型</li>
<li>默认值是 0</li>
<li>例子：<code>int a = 100000, int b = -200000</code></li>
</ul>
</li>
<li>
<p>long/64</p>
<ul>
<li>long 数据类型是 64 位、有符号的以二进制补码表示的整数</li>
<li>最小值是 <code>-9,223,372,036,854,775,808（-2^63）</code></li>
<li>最大值是 <code>9,223,372,036,854,775,807（2^63 -1）</code></li>
<li>这种类型主要使用在需要比较大整数的系统上</li>
<li>默认值是 <code>0L</code></li>
<li>例子： <code>long a = 100000L，Long b = -200000L</code></li>
</ul>
</li>
</ul>
<h4 id="浮点型">浮点型</h4>
<ul>
<li>
<p>float/32</p>
<ul>
<li>float 数据类型是单精度32位.符合IEEE 754标准的浮点数</li>
<li>float 在储存大型浮点数组的时候可节省内存空间</li>
<li>最小值<code>1.4E-45</code>,最大值<code>3.4028235E38</code></li>
<li>默认值是<code> 0.0f</code></li>
<li>浮点数不能用来表示精确的值，如货币</li>
<li>例子：<code>float f = 234.5f</code></li>
</ul>
</li>
<li>
<p>double/64</p>
<ul>
<li>double 数据类型是双精度、64位、符合IEEE754标准的浮点数</li>
<li>浮点数的默认类型为double类型</li>
<li>double类型同样不能表示精确的值，如货币</li>
<li>最小值<code>4.9E-324</code>,最大值<code>1.7976931348623157E308</code></li>
<li>默认值是 <code>0.0d</code></li>
<li>例子：<code>double d = 123.4</code></li>
</ul>
</li>
</ul>
<p><code>Float</code>和<code>Double</code>的最小值和最大值都是以科学记数法的形式输出的，结尾的&quot;E+数字&quot;表示E之前的数字要乘以10的多少次方.比如<code>3.14E3</code>就是<code>3.14 × 10^3 =3140</code>，<code>3.14E-3</code> 就是 <code>3.14 x 10^-3 =0.00314</code>.</p>
<h3 id="字符类型">字符类型</h3>
<ul>
<li>char/16
<ul>
<li>char类型是一个单一的 16 位 Unicode 字符</li>
<li>最小值是 <code>\u0000</code>（即为 0）</li>
<li>最大值是 <code>\uffff</code>（即为65、535）</li>
<li>默认值是 <code>\u0000</code></li>
<li>char 数据类型可以储存任何字符</li>
<li>例子：<code>char letter = 'A'</code></li>
</ul>
</li>
</ul>
<h3 id="布尔类型">布尔类型</h3>
<ul>
<li>boolean/~
<ul>
<li>boolean数据类型表示一位的信息</li>
<li>只有两个取值：true 和 false</li>
<li>这种类型只作为一种标志来记录 true/false 情况</li>
<li>默认值是 <code>false</code></li>
<li>例子：<code>boolean one = true</code></li>
</ul>
</li>
</ul>
<p>boolean 只有两个值：<code>true、false</code>，可以使用 1 bit 来存储，但是具体大小没有明确规定。<strong>JVM 会在编译时期将 boolean 类型的数据转换为 int，使用 1 来表示 true，0 表示 false。JVM 支持 boolean 数组，但是是通过读写 byte 数组来实现的。</strong></p>
<h2 id="类型转换">类型转换</h2>
<p><strong>整型、实型（常量）、字符型数据可以混合运算。运算中，不同类型的数据先转化为同一类型，然后进行运算。</strong></p>
<p>转换从低级到高级。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">byte,short,char,int,long,float,double
</span></span></code></pre></div><p>数据类型转换必须满足如下规则：</p>
<ul>
<li>
<p>不能对boolean类型进行类型转换。</p>
</li>
<li>
<p>不能把对象类型转换成不相关类的对象。</p>
</li>
<li>
<p>在把容量大的类型转换为容量小的类型时必须使用强制类型转换。</p>
</li>
<li>
<p>浮点数到整数的转换是通过舍弃小数得到，而不是四舍五入</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">(int)23.7 == 23;        
</span></span><span class="line"><span class="cl">(int)-45.89f == -45
</span></span></code></pre></div></li>
<li>
<p>转换过程中可能导致溢出或损失精度,在运算时要避免该问题.例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">// 因为 byte 类型是 8 位，最大值为127，所以当 int 强制转换为 byte 类型时，值 128 时候就会导致溢出
</span></span><span class="line"><span class="cl">int i =128;   
</span></span><span class="line"><span class="cl">byte b = (byte)i;
</span></span></code></pre></div></li>
</ul>
<h3 id="自动类型转换">自动类型转换</h3>
<p>自动类型转换必须满足<strong>转换前的数据类型的位数要低于转换后的数据类型</strong>. 即可以 <code>long l = 100;</code>而不可以<code>int l = 100L;</code></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public class Test{
</span></span><span class="line"><span class="cl">        public static void main(String[] args){
</span></span><span class="line"><span class="cl">            char c1=&#39;a&#39;;//定义一个char类型
</span></span><span class="line"><span class="cl">            int i1 = c1;//char自动类型转换为int
</span></span><span class="line"><span class="cl">            System.out.println(&#34;char自动类型转换为int后的值等于&#34;+i1);
</span></span><span class="line"><span class="cl">            char c2 = &#39;A&#39;;//定义一个char类型
</span></span><span class="line"><span class="cl">            int i2 = c2+1;//char 类型和 int 类型计算
</span></span><span class="line"><span class="cl">            System.out.println(&#34;char类型和int计算后的值等于&#34;+i2);
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">// 结果:
</span></span><span class="line"><span class="cl">// char自动类型转换为int后的值等于97
</span></span><span class="line"><span class="cl">// char类型和int计算后的值等于66
</span></span></code></pre></div><h3 id="隐式类型转换">隐式类型转换</h3>
<p><strong>Java 不能隐式执行向下转型，因为这会使得精度降低。</strong></p>
<p><code>1.1 </code>字面量属于 <code>double</code> 类型，不能直接将 <code>1.1 </code>直接赋值给 <code>float </code>变量，因为这是向下转型。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">float f = 1.1;
</span></span></code></pre></div><p><code>1.1f</code> 字面量才是 float 类型。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">float f = 1.1f;
</span></span></code></pre></div><p>因为字面量 1 是 int 类型，它比 short 类型精度要高，因此不能隐式地将 int 类型下转型为 short 类型。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">short s1 = 1;
</span></span><span class="line"><span class="cl">s1 = s1 + 1;
</span></span></code></pre></div><p>但是使用 += 或者 ++ 运算符可以执行隐式类型转换。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">s1 += 1;
</span></span><span class="line"><span class="cl">s1++;
</span></span></code></pre></div><p>上面的语句相当于将 <code>s1 + 1</code> 的计算结果进行了向下转型：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">//强制类型转换
</span></span><span class="line"><span class="cl">s1 = (short) (s1 + 1);
</span></span></code></pre></div><p>简而言之,不能够直接的将精度高的类型 直接的赋值给精度低的类型.如: <code>float f = 1.1; short s = 1;</code> 如果想要赋值可用Java的隐式类型转换 如:<code>float f+=1.1; s += 1;</code></p>
<p><strong>由大到小需要强制转换,由小到大不需要强转.  顺序:<code>byte , short , char , int ,long,float,double</code></strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">byte b=1; int a = b;//由小到大
</span></span><span class="line"><span class="cl">int c = 1;
</span></span><span class="line"><span class="cl">byte d = (byte) c;//由大到小
</span></span></code></pre></div><h2 id="包装类型">包装类型</h2>
<table>
<thead>
<tr>
<th>基本数据类型</th>
<th>包装类</th>
</tr>
</thead>
<tbody>
<tr>
<td>byte</td>
<td>Byte</td>
</tr>
<tr>
<td>boolean</td>
<td>Boolean</td>
</tr>
<tr>
<td>short</td>
<td>Short</td>
</tr>
<tr>
<td>char</td>
<td>Character</td>
</tr>
<tr>
<td>int</td>
<td>Integer</td>
</tr>
<tr>
<td>long</td>
<td>Long</td>
</tr>
<tr>
<td>float</td>
<td>Float</td>
</tr>
<tr>
<td>double</td>
<td>Double</td>
</tr>
</tbody>
</table>
<p>在这八个类名中，除了 <code>Integer</code> 和 <code>Character</code> 类以后，其它六个类的类名和基本数据类型一致，只是类名的第一个字母大写即可.</p>
<p><code>Integer、Long、Byte、Double、Float、Short</code>都是抽象类<code>Number</code>的子类.</p>
<p>因为 Java 是一种面向对象语言，很多地方都需要使用对象而不是基本数据类型。比如，在集合类中，我们是无法将<code> int 、double</code> 等类型放进去的。因为集合的容器要求元素是 <code>Object</code> 类型.所以才有了对应基本类型分包装类型.</p>
<h3 id="拆箱与装箱">拆箱与装箱</h3>
<p>基本类型都有对应的包装类型，基本类型与其对应的包装类型之间的赋值使用自动装箱与拆箱完成。</p>
<p>以<code>Integer int</code> 为例</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">Integer x = 2;     // 装箱 调用了 Integer.valueOf(2)
</span></span><span class="line"><span class="cl">int y = x;         // 拆箱 调用了 X.intValue()
</span></span></code></pre></div><h4 id="自动拆装箱">自动拆装箱</h4>
<p>自动装箱: 就是将基本数据类型自动转换成对应的包装类.</p>
<p>自动拆箱：就是将包装类自动转换成对应的基本数据类型.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">    Integer i = 10;  //自动装箱
</span></span><span class="line"><span class="cl">    int b = i;     //自动拆箱
</span></span></code></pre></div><p>反编译得</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">    public static  void main(String[]args){
</span></span><span class="line"><span class="cl">        Integer integer=Integer.valueOf(1);
</span></span><span class="line"><span class="cl">        int i=integer.intValue();
</span></span><span class="line"><span class="cl">    }
</span></span></code></pre></div><p><code>int</code>的自动装箱都是通过<code> Integer.valueOf()</code> 方法来实现的，Integer 的自动拆箱都是通过 <code>integer.intValue</code> 来实现的</p>
<blockquote>
<p>自动装箱都是通过包装类的 <code>valueOf()</code> 方法来实现的.自动拆箱都是通过包装类对象的 <code>xxxValue() </code>来实现的。</p>
</blockquote>
<h4 id="自动拆装箱带来的问题">自动拆装箱带来的问题</h4>
<ul>
<li>
<p><strong>比较</strong>
包装对象的数值比较,不能简单的使用<code>==</code>,虽然 -128 到 127 之间的数字可以,但是这个范围之外还是需要使用 <code>equals</code>方法进行比较.</p>
</li>
<li>
<p><strong>NPE</strong>
因为有自动拆箱的机制，如果初始的包装类型对象为<code>null</code>，那么在自动拆箱的时候的就会报<code>NullPointerException</code>，在使用时需要格外注意.</p>
</li>
<li>
<p><strong>内存浪费</strong>
如果一个 for 循环中有大量拆装箱操作，会浪费很多资源</p>
</li>
</ul>
<h3 id="缓存池">缓存池</h3>
<p>案例: <strong><code>new Integer(123) </code>与 <code>Integer.valueOf(123)</code> 的区别在于：</strong></p>
<ul>
<li><code>new Integer(123)</code> 每次都会新建一个对象；</li>
<li><code>Integer.valueOf(123)</code> 会使用缓存池中的对象，多次调用会取得同一个对象的引用</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">Integer x = new Integer(123);
</span></span><span class="line"><span class="cl">Integer y = new Integer(123);
</span></span><span class="line"><span class="cl">System.out.println(x == y);    // false
</span></span><span class="line"><span class="cl">Integer z = Integer.valueOf(123);
</span></span><span class="line"><span class="cl">Integer k = Integer.valueOf(123);
</span></span><span class="line"><span class="cl">System.out.println(z == k);   // true
</span></span></code></pre></div><p><code>valueOf()</code> 方法的实现比较简单，就是先判断值是否在缓存池中，如果在的话就直接返回缓存池的内容</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public static Integer valueOf(int i) {
</span></span><span class="line"><span class="cl">    if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)
</span></span><span class="line"><span class="cl">        return IntegerCache.cache[i + (-IntegerCache.low)];
</span></span><span class="line"><span class="cl">    return new Integer(i);
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><p><strong>在 Java 8 中，Integer 缓存池的大小默认为 -128~127</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">static final int low = -128;
</span></span><span class="line"><span class="cl">static final int high;
</span></span><span class="line"><span class="cl">static final Integer cache[];
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">static {
</span></span><span class="line"><span class="cl">    // high value may be configured by property
</span></span><span class="line"><span class="cl">    int h = 127;
</span></span><span class="line"><span class="cl">    String integerCacheHighPropValue =
</span></span><span class="line"><span class="cl">        sun.misc.VM.getSavedProperty(&#34;java.lang.Integer.IntegerCache.high&#34;);
</span></span><span class="line"><span class="cl">    if (integerCacheHighPropValue != null) {
</span></span><span class="line"><span class="cl">        try {
</span></span><span class="line"><span class="cl">            int i = parseInt(integerCacheHighPropValue);
</span></span><span class="line"><span class="cl">            i = Math.max(i, 127);
</span></span><span class="line"><span class="cl">            // Maximum array size is Integer.MAX_VALUE
</span></span><span class="line"><span class="cl">            h = Math.min(i, Integer.MAX_VALUE - (-low) -1);
</span></span><span class="line"><span class="cl">        } catch( NumberFormatException nfe) {
</span></span><span class="line"><span class="cl">            // If the property cannot be parsed into an int, ignore it.
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    high = h;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    cache = new Integer[(high - low) + 1];
</span></span><span class="line"><span class="cl">    int j = low;
</span></span><span class="line"><span class="cl">    for(int k = 0; k &lt; cache.length; k++)
</span></span><span class="line"><span class="cl">        cache[k] = new Integer(j++);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // range [-128, 127] must be interned (JLS7 5.1.7)
</span></span><span class="line"><span class="cl">    assert IntegerCache.high &gt;= 127;
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><p><strong>编译器会在自动装箱过程调用 <code>valueOf()</code> 方法，因此多个值相同且值在缓存池范围内的 Integer 实例使用自动装箱来创建，那么就会引用相同的对象。</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">Integer m = 123;
</span></span><span class="line"><span class="cl">Integer n = 123;
</span></span><span class="line"><span class="cl">System.out.println(m == n); // true
</span></span></code></pre></div><p><code>Integer,int </code>在 <code>-127~128</code>之前是不会创建新的对象的,即</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl"> Integer a = new Integer(12);
</span></span><span class="line"><span class="cl"> int b = 12;
</span></span><span class="line"><span class="cl"> System.out.println(a==b);//true
</span></span></code></pre></div><p><code>Integer</code>和<code>int</code>自动装箱拆箱会通过<code>valueOf()</code>方法实现,当这个数在-127~128之间直接从缓存里边取,不会重新new对象</p>
<p><strong>基本类型对应的缓冲池如下：</strong></p>
<ul>
<li><code>boolean values true and false</code></li>
<li><code>all byte values</code></li>
<li><code>short values between -128 and 127</code></li>
<li><code>int values between -128 and 127</code></li>
<li><code>char in the range \u0000 to \u007F</code></li>
</ul>
<p>在使用这些基本类型对应的包装类型时，如果该数值范围在缓冲池范围内，就可以直接使用缓冲池中的对象。==两种浮点数类型的包装类Float,Double并没有实现常量池技术。==</p>
<blockquote>
<p>在 JDK 1.8 所有的数值类缓冲池中，Integer 的缓冲池<code> IntegerCache</code> 很特殊，这个缓冲池的下界是 - 128，上界默认是 127,但是这个上界是可调的:<br>在启动JVM的时候，通过<code>-XX:AutoBoxCacheMax=&lt;size&gt;</code>来指定这个缓冲池的大小,该选项在 JVM 初始化的时候会设定一个名为 <code>java.lang.IntegerCache.high</code> 系统属性,然后 <code>IntegerCache</code>初始化的时候就会读取该系统属性来决定上界。</p>
</blockquote>
<h2 id="引用类型">引用类型</h2>
<ul>
<li>类</li>
<li>数组类型</li>
<li>接口类型</li>
<li>注解类型</li>
<li>枚举类型</li>
</ul>
<p>引用类型指向一个对象(类似于C的指针),指向对象的变量是引用变量</p>
<p>所有引用类型的默认值都是<code>null</code></p>
<h3 id="与基本类型区别">与基本类型区别</h3>
<ol>
<li>
<p>基本数据类型在被创建时,在栈中直接划分一块内存,将数值直接存入栈中,引用数据类型再被创建时,先在堆中开辟内存创建存放值,然后引用到栈中的是在堆中的地址值</p>
</li>
<li>
<p>传递参数的时候不同.基本数据类型是值传递,引用数据类型是引用传递.</p>
</li>
</ol>
<h3 id="注意事项">注意事项</h3>
<ul>
<li><code>String</code>类是引用类型,不是基本类型</li>
<li>默认<code>double</code>类型，如果<code>float</code>加后缀F(不区分大小写).如果<code>long</code>类型加后缀L(不区分大小写)</li>
<li>浮点数可能是个近似值,不是精确值.如果想要表示精确用<code>BigDecimal</code>类型</li>
</ul>
<h2 id="常量">常量</h2>
<p>案例: 常量,变量和字面量</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">int a = 10; //a为变量，10为字面量
</span></span><span class="line"><span class="cl">final int b = 10;  //b为常量，10为字面量
</span></span><span class="line"><span class="cl">static c = &#34;Hello World&#34;;  //c为变量,HelloWorld为字面量
</span></span></code></pre></div><ul>
<li>常量：程序运行中，固定不变的量.</li>
<li>变量：值可以修改的数据类型。</li>
<li>字面量：字面量就是数据，是由字母、数字等构成的字符串或者数值，如30（整型）、3.15（浮点型）、“我是字符串”（字符串型）、‘中’（字符型）、true（布尔型）、false（布尔型）等,只能作为右值出现如<code>int a = 10</code>;这里的a是左值,10为右值.</li>
</ul>
<p>字面量</p>
<blockquote>
<p>在计算机科学中，字面量（literal）是用于表达源代码中一个固定值的表示法（notation）。几乎所有计算机编程语言都具有对基本值的字面量表示，诸如：整数、浮点数以及字符串；而有很多也对布尔类型和字符类型的值也支持字面量表示；还有一些甚至对枚举类型的元素以及像数组、记录和对象等复合类型的值也支持字面量表示法。</p>
</blockquote>
<p>Java常量</p>
<blockquote>
<p>JAVA常量就是在程序运行过程中一直不会改变的量的量称为常量.常量在整个程序中只能被赋值一次.</p>
</blockquote>
<p>Java常量简单理解为<code>final</code>修饰的变量</p>
<h3 id="定义常量">定义常量</h3>
<p>在 Java 中使用<code>final</code>关键字来修饰常量，声明方式和变量类似</p>
<p>要声明一个常量，第一需要制定数据类型，第二需要通过<code>final</code>关键字进行限定格式：
<code>final 数据类型 常量名称[=值]</code></p>
<p><strong>常量在程序运行时是不能被修改的(final作用).所以在定义常量时就需要对该常量进行初始化.为了与变量区别，常量取名一般都用大写字符</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">final double PI = 3.1415927;
</span></span></code></pre></div><p><code>final</code> 关键字表示最终的，它可以修改很多元素，修饰变量就变成了常量.之后会详细说明<code>final</code>关键字</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public class HelloWorld {
</span></span><span class="line"><span class="cl">    // 静态常量
</span></span><span class="line"><span class="cl">    public static final double PI = 3.14;
</span></span><span class="line"><span class="cl">    // 声明成员常量
</span></span><span class="line"><span class="cl">    final int y = 10;
</span></span><span class="line"><span class="cl">    public static void main(String[] args) {
</span></span><span class="line"><span class="cl">        // 声明局部常量
</span></span><span class="line"><span class="cl">        final double x = 3.3;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><h3 id="常量池">常量池</h3>
<p>一个有效的字节码文件中除了包含类的版本信息、字段、方法以及接口等描述符信息外，
还包含一项信息就是常量池表（Constant Pool Table），包括各种字面量和对类型、域和方法的符号引用。</p>
<p><strong>常量池中有什么？</strong></p>
<ul>
<li>数量值</li>
<li>字符串值</li>
<li>类引用</li>
<li>字段引用</li>
<li>方法引用</li>
</ul>
<p>常量池、可以看做是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等类型。</p>
<p>在Java中，大致上可以分为三种常量池.分别是字符串常量池、Class常量池(静态常量池)和运行时常量池.</p>
<p><strong>我们常说的常量池，就是指方法区中的运行时常量池。</strong></p>
<h4 id="class常量池">Class常量池</h4>
<h5 id="class文件">Class文件</h5>
<blockquote>
<p>class文件全名称为Java class文件，主要在平台无关性和网络移动性方面使Java更适合网络。它在平台无关性方面的任务是：为Java程序提供独立于底层主机平台的二进制形式的服务。(会产生字节码)</p>
</blockquote>
<blockquote>
<p>有了字节码，无论是哪种平台（如Windows、Linux等），只要安装了虚拟机，都可以直接运行字节码。目前Java虚拟机已经可以支持很多除Java语言以外的语言了，如Groovy、JRuby、Jython、Scala等。之所以可以支持，就是因为这些语言也可以被编译成字节码。而虚拟机并不关心字节码是有哪种语言编译而来的。</p>
</blockquote>
<p>将下面代码通过<code>javac</code>命令编译</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public class HelloWorld {
</span></span><span class="line"><span class="cl">    public static void main(String[] args) {
</span></span><span class="line"><span class="cl">        String s = &#34;123&#34;;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><p>生成<code>.class</code>文件.<code>vi</code>命令查看</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">Êþº¾^@^@^@4^@^Q
</span></span><span class="line"><span class="cl">^@^D^@^M^H^@^N^G^@^O^G^@^P^A^@^F&lt;init&gt;^A^@^C()V^A^@^DCode^A^@^OLineNumberTable^A^@^Dmain^A^@^V([Ljava/lang/String;)V^A^@
</span></span><span class="line"><span class="cl">SourceFile^A^@^OHelloWorld.java^L^@^E^@^F^A^@^C123^A^@7com/example/springboot/example/security/util/HelloWorld^A^@^Pjava/lang/Object^@!^@^C^@^D^@^@^@^@^@^B^@^A^@^E^@^F^@^A^@^G^@^@^@^]^@^A^@^A^@^@^@^E*·^@^A±^@^@^@^A^@^H^@^@^@^F^@^A^@^@^@^C^@        ^@      ^@
</span></span><span class="line"><span class="cl">^@^A^@^G^@^@^@ ^@^A^@^B^@^@^@^D^R^BL±^@^@^@^A^@^H^@^@^@
</span></span><span class="line"><span class="cl">^@^B^@^@^@^E^@^C^@^F^@^A^@^K^@^@^@^B^@^L
</span></span></code></pre></div><blockquote>
<p>使用16进制打开class文件：使用 vim xxx.class ，然后在交互模式下，输入:%!xxd 即可。</p>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">00000000: cafe babe 0000 0034 0011 0a00 0400 0d08  .......4........
</span></span><span class="line"><span class="cl">00000010: 000e 0700 0f07 0010 0100 063c 696e 6974  ...........&lt;init
</span></span><span class="line"><span class="cl">00000020: 3e01 0003 2829 5601 0004 436f 6465 0100  &gt;...()V...Code..
</span></span><span class="line"><span class="cl">00000030: 0f4c 696e 654e 756d 6265 7254 6162 6c65  .LineNumberTable
</span></span><span class="line"><span class="cl">00000040: 0100 046d 6169 6e01 0016 285b 4c6a 6176  ...main...([Ljav
</span></span><span class="line"><span class="cl">00000050: 612f 6c61 6e67 2f53 7472 696e 673b 2956  a/lang/String;)V
</span></span><span class="line"><span class="cl">00000060: 0100 0a53 6f75 7263 6546 696c 6501 000f  ...SourceFile...
</span></span><span class="line"><span class="cl">00000070: 4865 6c6c 6f57 6f72 6c64 2e6a 6176 610c  HelloWorld.java.
</span></span><span class="line"><span class="cl">00000080: 0005 0006 0100 0331 3233 0100 3763 6f6d  .......123..7com
</span></span><span class="line"><span class="cl">00000090: 2f65 7861 6d70 6c65 2f73 7072 696e 6762  /example/springb
</span></span><span class="line"><span class="cl">000000a0: 6f6f 742f 6578 616d 706c 652f 7365 6375  oot/example/secu
</span></span><span class="line"><span class="cl">000000b0: 7269 7479 2f75 7469 6c2f 4865 6c6c 6f57  rity/util/HelloW
</span></span><span class="line"><span class="cl">000000c0: 6f72 6c64 0100 106a 6176 612f 6c61 6e67  orld...java/lang
</span></span></code></pre></div><blockquote>
<p>HelloWorld.class文件中的前八个字母是cafe babe，这就是Class文件的魔数（Java中的”魔数”）</p>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">cafe babe   0000      0034        0011      0a00 0400 0d08
</span></span><span class="line"><span class="cl">   魔数    此版本号   主版本号    常量池计数器      常量池计数区
</span></span></code></pre></div><blockquote>
<p>我们需要知道的是,在Class文件的4个字节的魔数后面的分别是4个字节的Class文件的版本号（第5、6个字节是次版本号，第7、8个字节是主版本号，我生成的Class文件的版本号是52，这时Java 8对应的版本。也就是说，这个版本的字节码，在JDK 1.8以下的版本中无法运行）在版本号后面的，就是Class常量池入口了.</p>
</blockquote>
<h5 id="存放内容">存放内容</h5>
<p><strong>Class常量池中主要存放两大类常量：字面量和符号引用。</strong></p>
<blockquote>
<p>PS 字面量前面已经记录过了,这里来记录下符号引用的概念.</p>
</blockquote>
<p><strong>符号引用</strong></p>
<p>符号引用是编译原理中的概念，是相对于直接引用来说的。主要包括了以下三类常量： <strong>类和接口的全限定名  字段的名称和描述符 方法的名称和描述符.</strong></p>
<blockquote>
<p>符号引用 ：符号引用以一组符号来描述所引用的目标。符号引用可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可，符号引用和虚拟机的布局无关。</p>
</blockquote>
<p>在编译的时候每个java类都会被编译成一个class文件，但在编译的时候虚拟机并不知道所引用类的地址，所以就用符号引用来代替，
而在这个解析阶段就是为了把这个符号引用转化成为真正的地址的阶段。</p>
<blockquote>
<p>解析阶段:
Java类从加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括，加载 ,验证 , 准备 , 解析 , 初始化 , 卸载 ，总共七个阶段。其中验证 ,准备 , 解析 统称为连接。
而在解析阶段会有一步将常量池当中二进制数据当中的符号引用转化为直接引用的过程。</p>
</blockquote>
<p>在Java编译阶段,由<code>.java</code>文件会生成<code>.class</code>文件.Class文件中除了包含类的版本、字段、方法、接口等描述信息外，还有一项信息就是常量池，用于存放编译器生成的各种字面量和符号引用。</p>
<p>由于不同的Class文件中包含的常量的个数是不固定的，所以在Class文件的常量池入口处会设置两个字节的常量池容量计数器，记录了常量池中常量的个数。</p>
<p>Class常量池可以理解为是Class文件中的资源仓库。</p>
<p>class常量池中保存了各种常量。而这些常量都是开发者定义出来，需要在程序的运行期使用的。</p>
<blockquote>
<p>Java代码在进行Javac编译的时候,在Class文件中不会保存各个方法、字段的最终内存布局信息，因此这些字段、方法的符号引用不经过运行期转换的话无法得到真正的内存入口地址，也就无法直接被虚拟机使用。当虚拟机运行时，需要从常量池获得对应的符号引用，再在类创建时或运行时解析、翻译到具体的内存地址之中。</p>
</blockquote>
<p>Class是用来保存常量的一个媒介场所，并且是一个中间场所。在JVM真的运行时，需要把常量池中的常量加载到内存中.</p>
<h4 id="运行时常量池">运行时常量池</h4>
<blockquote>
<p>运行时常量池是每一个类或接口的常量池的运行时表示形式.</p>
<p>它包括了若干种不同的常量：从编译期可知的数值字面量到必须运行期解析后才能获得的方法或字段引用。运行时常量池扮演了类似传统语言中符号表的角色，不过它存储数据范围比通常意义上的符号表要更为广泛。</p>
<p>每一个运行时常量池都分配在 Java 虚拟机的方法区之中，在类和接口被加载到虚拟机后，对应的运行时常量池就被创建出来。</p>
</blockquote>
<ul>
<li>保存在方法区中的叫运行时常量池。</li>
<li>在 class/字节码 文件中的叫class常量池（静态常量池）。</li>
</ul>
<p>简单说来就是JVM在完成类装载操作后，将class文件中的常量池载入到内存中，并保存在方法区中。
我们常说的常量池，就是指方法区中的运行时常量池。</p>
<p>运行时常量池类似于传统编程语言中的符号表，但是它所包含的数据却比符号表要更加丰富一些。</p>
<p>当创建类或接口的运行时常量池时，如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大值，则JVM会抛outOfMemoryError异常。</p>
<h5 id="存放位置及存放来源">存放位置及存放来源</h5>
<p>在不同版本的JDK中，运行时常量池所处的位置也不一样.以<code>HotSpot</code>为例:
JDK1.7之前方法区位于永久代.由于一些原因在JDK1.8时彻底祛除了永久代,用元空间代替.</p>
<blockquote>
<p>根据JVM规范,JVM内存共分为虚拟机栈，堆，方法区，程序计数器，本地方法栈五个部分.</p>
</blockquote>
<p>运行时常量池存放在JVM内存模型中的方法区中。</p>
<blockquote>
<p>PS 方法区：</p>
<ul>
<li>被所有方法线程共享的一块内存区域.</li>
<li>用于存储已经被虚拟机加载的类信息，常量，静态变量等.</li>
<li>这个区域的内存回收目标主要针对常量池的回收和堆类型的卸载.</li>
</ul>
</blockquote>
<p><strong>运行时常量池是方法区的一部分</strong><code>.class</code>文件中除了有类的版本、字段、方法、接口等描述信息外,还有一项信息是常量池，
用于存放<strong>编译期</strong>生成的<strong>各种字面量和符号引用</strong>,这部分内容将在类加载后进入方法区的运行时常量池中存放.</p>
<p>运行时常量池中包含多种不同的常量，包括编译期就已经明确的数值字面量，也包括到运行期解析后才能够获得的方法或者字段引用。
此时不再是常量池中的符号地址了，这里换为真实地址。</p>
<p>运行时常量池内容包含了Class常量池中的常量和字符串常量池中的内容.
运行时常量池，相对于Class文件常量池的另一重要特征是：具备动态性。</p>
<h4 id="字符串常量池">字符串常量池</h4>
<p>在JVM中，为了减少相同的字符串的重复创建，为了达到节省内存的目的。会单独开辟一块内存，用于保存字符串常量，这个内存区域被叫做字符串常量池.</p>
<p>字符串常量池保存着所有字符串字面量,这些字面量在编译时期就确定.</p>
<h5 id="内存分配">内存分配</h5>
<p>不同版本JDK内存分配情况：</p>
<ul>
<li>Java 6及以前，字符串常量池存放在永久代</li>
<li>Java 7将字符串常量池的位置调整到Java堆内</li>
</ul>
<p><strong>字符串常量池为什么要调整位置？</strong></p>
<p>JDK7中将字符串常量池放到了堆空间中。因为对永久代的回收效率很低，只有在Full GC的时候才会触发。</p>
<p>Full GC 是老年代的空间不足、永久代不足时才会触发。
这就导致字符串常量池回收效率不高。而我们开发中会有大量的字符串被创建，回收效率低，导致永久代内存不足。
所以JDK7之后将字符串常量池放到堆里，能及时回收内存，避免出现<code>OOM</code>错误。</p>
<p>简单说来：</p>
<ul>
<li>永久代垃圾回收频率低；而字符串使用频率比较高，不能及时回收字符串，会导致导致永久代内存不足。</li>
<li>永久代的默认比较小；因字符串大量使用，所以会导致<code>OOM</code>(<code>OutOfMemoryError </code>)错误。</li>
</ul>
<p><strong>如何证明Java8中的字符串常量池方到了堆中？</strong></p>
<p>代码演示：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public class MainTest {
</span></span><span class="line"><span class="cl">    // 虚拟机参数： -Xmx6m -Xms6m -XX:MetaspaceSize=10m -XX:MaxMetaspaceSize=10m
</span></span><span class="line"><span class="cl">    public static void main(String[] args) {
</span></span><span class="line"><span class="cl">        HashSet&lt;String&gt; hashSet = new HashSet&lt;&gt;();
</span></span><span class="line"><span class="cl">        short i = 0;
</span></span><span class="line"><span class="cl">        while (true) {
</span></span><span class="line"><span class="cl">            hashSet.add(String.valueOf(i++).intern());
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><p>抛出异常证明Java8中的字符串常量池方到了堆中</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">Exception in thread &#34;main&#34; java.lang.OutOfMemoryError: Java heap space
</span></span></code></pre></div><h5 id="intern方法">intern方法</h5>
<p>intern是一个native方法，调用的是底层C的方法</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl">    <span class="o">/**</span>
</span></span><span class="line"><span class="cl">     <span class="o">*</span> <span class="n">Returns</span> <span class="n">a</span> <span class="n">canonical</span> <span class="n">representation</span> <span class="k">for</span> <span class="n">the</span> <span class="n">string</span> <span class="n">object</span><span class="o">.</span>
</span></span><span class="line"><span class="cl">     <span class="o">*</span> <span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">     <span class="o">*</span> <span class="n">A</span> <span class="n">pool</span> <span class="n">of</span> <span class="n">strings</span><span class="p">,</span> <span class="n">initially</span> <span class="n">empty</span><span class="p">,</span> <span class="n">is</span> <span class="n">maintained</span> <span class="n">privately</span> <span class="n">by</span> <span class="n">the</span>
</span></span><span class="line"><span class="cl">     <span class="o">*</span> <span class="k">class</span> <span class="p">{</span><span class="err">@</span><span class="n">code</span> <span class="ne">String</span><span class="p">}</span><span class="o">.</span>
</span></span><span class="line"><span class="cl">     <span class="o">*</span> <span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">     <span class="o">*</span> <span class="n">When</span> <span class="n">the</span> <span class="n">intern</span> <span class="n">method</span> <span class="n">is</span> <span class="n">invoked</span><span class="p">,</span> <span class="k">if</span> <span class="n">the</span> <span class="n">pool</span> <span class="n">already</span> <span class="n">contains</span> <span class="n">a</span>
</span></span><span class="line"><span class="cl">     <span class="o">*</span> <span class="n">string</span> <span class="n">equal</span> <span class="n">to</span> <span class="n">this</span> <span class="p">{</span><span class="err">@</span><span class="n">code</span> <span class="ne">String</span><span class="p">}</span> <span class="n">object</span> <span class="n">as</span> <span class="n">determined</span> <span class="n">by</span>
</span></span><span class="line"><span class="cl">     <span class="o">*</span> <span class="n">the</span> <span class="p">{</span><span class="err">@</span><span class="n">link</span> <span class="c1">#equals(Object)} method, then the string from the pool is</span>
</span></span><span class="line"><span class="cl">     <span class="o">*</span> <span class="n">returned</span><span class="o">.</span> <span class="n">Otherwise</span><span class="p">,</span> <span class="n">this</span> <span class="p">{</span><span class="err">@</span><span class="n">code</span> <span class="ne">String</span><span class="p">}</span> <span class="n">object</span> <span class="n">is</span> <span class="n">added</span> <span class="n">to</span> <span class="n">the</span>
</span></span><span class="line"><span class="cl">     <span class="o">*</span> <span class="n">pool</span> <span class="ow">and</span> <span class="n">a</span> <span class="n">reference</span> <span class="n">to</span> <span class="n">this</span> <span class="p">{</span><span class="err">@</span><span class="n">code</span> <span class="ne">String</span><span class="p">}</span> <span class="n">object</span> <span class="n">is</span> <span class="n">returned</span><span class="o">.</span>
</span></span><span class="line"><span class="cl">     <span class="o">*</span> <span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">     <span class="o">*</span> <span class="n">It</span> <span class="n">follows</span> <span class="n">that</span> <span class="k">for</span> <span class="n">any</span> <span class="n">two</span> <span class="n">strings</span> <span class="p">{</span><span class="err">@</span><span class="n">code</span> <span class="n">s</span><span class="p">}</span> <span class="ow">and</span> <span class="p">{</span><span class="err">@</span><span class="n">code</span> <span class="n">t</span><span class="p">},</span>
</span></span><span class="line"><span class="cl">     <span class="o">*</span> <span class="p">{</span><span class="err">@</span><span class="n">code</span> <span class="n">s</span><span class="o">.</span><span class="n">intern</span><span class="p">()</span> <span class="o">==</span> <span class="n">t</span><span class="o">.</span><span class="n">intern</span><span class="p">()}</span> <span class="n">is</span> <span class="p">{</span><span class="err">@</span><span class="n">code</span> <span class="bp">true</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">     <span class="o">*</span> <span class="k">if</span> <span class="ow">and</span> <span class="n">only</span> <span class="k">if</span> <span class="p">{</span><span class="err">@</span><span class="n">code</span> <span class="n">s</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">t</span><span class="p">)}</span> <span class="n">is</span> <span class="p">{</span><span class="err">@</span><span class="n">code</span> <span class="bp">true</span><span class="p">}</span><span class="o">.</span>
</span></span><span class="line"><span class="cl">     <span class="o">*</span> <span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">     <span class="o">*</span> <span class="n">All</span> <span class="n">literal</span> <span class="n">strings</span> <span class="ow">and</span> <span class="n">string</span><span class="o">-</span><span class="n">valued</span> <span class="n">constant</span> <span class="n">expressions</span> <span class="n">are</span>
</span></span><span class="line"><span class="cl">     <span class="o">*</span> <span class="n">interned</span><span class="o">.</span> <span class="ne">String</span> <span class="n">literals</span> <span class="n">are</span> <span class="n">defined</span> <span class="ow">in</span> <span class="n">section</span> <span class="mf">3.10</span><span class="o">.</span><span class="mi">5</span> <span class="n">of</span> <span class="n">the</span>
</span></span><span class="line"><span class="cl">     <span class="o">*</span> <span class="o">&lt;</span><span class="n">cite</span><span class="o">&gt;</span><span class="n">The</span> <span class="n">Java</span><span class="o">&amp;</span><span class="n">trade</span><span class="p">;</span> <span class="n">Language</span> <span class="n">Specification</span><span class="o">&lt;/</span><span class="n">cite</span><span class="o">&gt;.</span>
</span></span><span class="line"><span class="cl">     <span class="o">*/</span>
</span></span><span class="line"><span class="cl">    <span class="n">public</span> <span class="n">native</span> <span class="ne">String</span> <span class="n">intern</span><span class="p">();</span>
</span></span></code></pre></div><p><code>intern</code>方法文档注释大意是：字符串池最初是空的，由String类私有地维护。在调用intern方法时，如果池中已经包含了由equals(object)方法确定的与该字符串对象相等的字符串，则返回池中的字符串。
否则，该字符串对象将被添加到池中，并返回对该字符串对象的引用。</p>
<p><strong>当一个字符串调用 <code>intern()</code> 方法时，如果 String Pool 中已经存在一个字符串和该字符串值相等（使用 <code>equals()</code>方法进行确定），那么就会返回 String Pool 中字符串的引用；否则，就会在 String Pool 中添加一个新的字符串，并返回这个新字符串的引用.</strong></p>
<p>下面示例中，s1 和 s2 采用<code> new String()</code> 的方式新建了两个不同字符串，而 s3 和 s4 是通过 <code>s1.intern()</code> 方法取得一个字符串引用。<code>intern()</code> 首先把 s1 引用的字符串放到 String Pool 中，然后返回这个字符串引用。因此 s3 和 s4 引用的是同一个字符串。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public class MainTest {
</span></span><span class="line"><span class="cl">    public static void main(String[] args) {
</span></span><span class="line"><span class="cl">        String s1 = new String(&#34;aaa&#34;);
</span></span><span class="line"><span class="cl">        String s2 = new String(&#34;aaa&#34;);
</span></span><span class="line"><span class="cl">        System.out.println(s1 == s2);           // false
</span></span><span class="line"><span class="cl">        String s3 = s1.intern();
</span></span><span class="line"><span class="cl">        String s4 = s1.intern();
</span></span><span class="line"><span class="cl">        System.out.println(s3 == s4);           // true
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><p>上面的示例说明了可以使用 String的<code>intern()</code>方法在程序运行过程中将字符串添加到字符串常量池中。</p>
<p><strong>空间效率测试</strong></p>
<p>对于程序中大量使用存在的字符串时，尤其存在很多已经重复的字符串时，使用<code>intern()</code>方法能够节省内存空间。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public class MainTest {
</span></span><span class="line"><span class="cl">    static final int MAX_COUNT = 1000 * 10000;
</span></span><span class="line"><span class="cl">    static final String[] arr = new String[MAX_COUNT];
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public static void main(String[] args) {
</span></span><span class="line"><span class="cl">        Integer [] data = new Integer[]{1,2,3,4,5,6,7,8,9,10};
</span></span><span class="line"><span class="cl">        long start = System.currentTimeMillis();
</span></span><span class="line"><span class="cl">        for (int i = 0; i &lt; MAX_COUNT; i++) {
</span></span><span class="line"><span class="cl">//            arr[i] = new String(String.valueOf(data[i%data.length])); // 花费的时间为：3074
</span></span><span class="line"><span class="cl">            arr[i] = new String(String.valueOf(data[i%data.length])).intern(); // 花费的时间为：1196
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        long end = System.currentTimeMillis();
</span></span><span class="line"><span class="cl">        System.out.println(&#34;花费的时间为：&#34; + (end - start));
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        try {
</span></span><span class="line"><span class="cl">            Thread.sleep(1000000);
</span></span><span class="line"><span class="cl">        } catch (Exception e) {
</span></span><span class="line"><span class="cl">            e.getStackTrace();
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        System.gc();
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><p>不使用<code>intern</code>方法
<img alt="不用intern方法测试" src="/iblog/posts/annex/images/essays/%E4%B8%8D%E7%94%A8intern%E6%96%B9%E6%B3%95%E6%B5%8B%E8%AF%95.png"></p>
<p>使用<code>intern</code>方法后
<img alt="使用intern方法测试" src="/iblog/posts/annex/images/essays/%E4%BD%BF%E7%94%A8intern%E6%96%B9%E6%B3%95%E6%B5%8B%E8%AF%95.png"></p>
<h5 id="经典案例">经典案例</h5>
<p><strong>String常量池常考的一个问题就是<code>new String(&quot;abc&quot;)</code>会创建几个对象?</strong></p>
<p>答案: 两个字符串对象(前提是 String常量池中还没有 &ldquo;abc&rdquo; 字符串对象).</p>
<ul>
<li>&ldquo;abc&rdquo; 属于字符串字面量，因此编译时期会在 String 常量池 中创建一个字符串对象，指向这个 &ldquo;abc&rdquo; 字符串字面量;</li>
<li>而使用 new 的方式会在堆中创建一个字符串对象。</li>
</ul>
<p>以下是 JDK8 中 String 构造函数的源码，文档注释大意是：</p>
<blockquote>
<p>初始化新创建的String对象，使其表示与实参相同的字符序列;换句话说，新创建的字符串是实参字符串的副本。
除非需要显式复制形参的值，否则没有必要使用这个构造函数，因为字符串是不可变的。</p>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="o">/**</span>
</span></span><span class="line"><span class="cl"> <span class="o">*</span> <span class="n">Initializes</span> <span class="n">a</span> <span class="n">newly</span> <span class="n">created</span> <span class="p">{</span><span class="err">@</span><span class="n">code</span> <span class="ne">String</span><span class="p">}</span> <span class="n">object</span> <span class="n">so</span> <span class="n">that</span> <span class="n">it</span> <span class="n">represents</span>
</span></span><span class="line"><span class="cl"> <span class="o">*</span> <span class="n">the</span> <span class="n">same</span> <span class="n">sequence</span> <span class="n">of</span> <span class="n">characters</span> <span class="n">as</span> <span class="n">the</span> <span class="n">argument</span><span class="p">;</span> <span class="ow">in</span> <span class="n">other</span> <span class="n">words</span><span class="p">,</span> <span class="n">the</span>
</span></span><span class="line"><span class="cl"> <span class="o">*</span> <span class="n">newly</span> <span class="n">created</span> <span class="n">string</span> <span class="n">is</span> <span class="n">a</span> <span class="n">copy</span> <span class="n">of</span> <span class="n">the</span> <span class="n">argument</span> <span class="n">string</span><span class="o">.</span> <span class="n">Unless</span> <span class="n">an</span>
</span></span><span class="line"><span class="cl"> <span class="o">*</span> <span class="n">explicit</span> <span class="n">copy</span> <span class="n">of</span> <span class="p">{</span><span class="err">@</span><span class="n">code</span> <span class="n">original</span><span class="p">}</span> <span class="n">is</span> <span class="n">needed</span><span class="p">,</span> <span class="n">use</span> <span class="n">of</span> <span class="n">this</span> <span class="n">constructor</span> <span class="n">is</span>
</span></span><span class="line"><span class="cl"> <span class="o">*</span> <span class="n">unnecessary</span> <span class="n">since</span> <span class="n">Strings</span> <span class="n">are</span> <span class="n">immutable</span><span class="o">.</span>
</span></span><span class="line"><span class="cl"> <span class="o">*</span>
</span></span><span class="line"><span class="cl"> <span class="o">*/</span>
</span></span><span class="line"><span class="cl"><span class="n">public</span> <span class="ne">String</span><span class="p">(</span><span class="ne">String</span> <span class="n">original</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">this</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">original</span><span class="o">.</span><span class="n">value</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">this</span><span class="o">.</span><span class="n">hash</span> <span class="o">=</span> <span class="n">original</span><span class="o">.</span><span class="n">hash</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>字节码分析：</p>
<p>创建一个测试类，其 main 方法中使用这种方式来创建字符串对象。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public class MainTest {
</span></span><span class="line"><span class="cl">    public static void main(String[] args) {
</span></span><span class="line"><span class="cl">        String s = new String(&#34;abc&#34;);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><p>使用 <code>javap -verbose</code> 进行反编译，得到以下内容：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">// ...
</span></span><span class="line"><span class="cl">Constant pool:
</span></span><span class="line"><span class="cl">// ...
</span></span><span class="line"><span class="cl">   #2 = Class              #18            // java/lang/String
</span></span><span class="line"><span class="cl">   #3 = String             #19            // abc
</span></span><span class="line"><span class="cl">// ...
</span></span><span class="line"><span class="cl">  #18 = Utf8               java/lang/String
</span></span><span class="line"><span class="cl">  #19 = Utf8               abc
</span></span><span class="line"><span class="cl">// ...
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  public static void main(java.lang.String[]);
</span></span><span class="line"><span class="cl">    descriptor: ([Ljava/lang/String;)V
</span></span><span class="line"><span class="cl">    flags: ACC_PUBLIC, ACC_STATIC
</span></span><span class="line"><span class="cl">    Code:
</span></span><span class="line"><span class="cl">      stack=3, locals=2, args_size=1
</span></span><span class="line"><span class="cl">         0: new           #2                  // class java/lang/String
</span></span><span class="line"><span class="cl">         3: dup
</span></span><span class="line"><span class="cl">         4: ldc           #3                  // String abc
</span></span><span class="line"><span class="cl">         6: invokespecial #4                  // Method java/lang/String.&#34;&lt;init&gt;&#34;:(Ljava/lang/String;)V
</span></span><span class="line"><span class="cl">         9: astore_1
</span></span><span class="line"><span class="cl">// ...
</span></span></code></pre></div><p>在 <code>Constant Pool</code> 中，#19 存储这字符串字面量 <code>&quot;abc&quot;</code>，#3 是 String Pool 的字符串对象，它指向 <code>#19</code> 这个字符串字面量。
在 <code>main</code> 方法中，<code>0:</code> 行使用 <code>new #2</code> 在堆中创建一个字符串对象，并且使用 <code>ldc #3</code> 将 String Pool 中的字符串对象作为 String 构造函数的参数。
所以能看到使用<code>new String()</code> 的方式创建字符串是创建两个对象。</p>
<p><strong>使用<code>new String(&quot;a&quot;) + new String(&quot;b&quot;)</code> 会创建几个对象？</strong></p>
<p>答案：会创建6个对象：</p>
<ul>
<li>对象1：因为存在用&quot;+&ldquo;连接，所以从字节码角度分析会产生<code>new StringBuilder()</code>对象；</li>
<li>对象2：<code>new String(&quot;a&quot;)</code>会从堆空间创建一个对象；</li>
<li>对象3：常量池的 a ；</li>
<li>对象4：<code>new String(&quot;b&quot;)</code> 会从堆空间创建一个对象；</li>
<li>对象5：常量池的 b；</li>
<li>对象6：从字节码角度分析，通过<code>new StringBuilder().append()</code>添加完字符串后，会通过<code>StringBuilder.toString()</code>中会创建一个 <code>new String(&quot;ab&quot;)</code>；
但是调用<code>toString()</code>方法，不会在常量池中生成ab字符串；</li>
</ul>
<p>也可跟上面的代码一样从字节码角度进行分析，这里不做过多分析。</p>
<p><strong>扩展：在JDK1.6/JDK1.7中下列代码执行结果不同</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public class MainTest {
</span></span><span class="line"><span class="cl">    public static void main(String[] args) {
</span></span><span class="line"><span class="cl">        String s3 = new String(&#34;1&#34;) + new String(&#34;1&#34;); // ==&gt; new String(&#34;11&#34;); 并不会在字符串常量池创建 &#34;11&#34;
</span></span><span class="line"><span class="cl">        // 在Jdk7及之后，JVM为了节省空间进行优化，在字符串常量池中的对象只保存了堆中对象的地址，而并不是创建了一个真正的对象；
</span></span><span class="line"><span class="cl">        // &#34;11&#34;不在字符串常量池中 ，把&#34;11&#34;放入字符串常量池中 因为堆中已经存在对象，JDK6在字符串池中保存的是一个真正的对象 JDK7保存的是一个引用地址
</span></span><span class="line"><span class="cl">        s3.intern(); 
</span></span><span class="line"><span class="cl">        // 获取字符串常量池的引用
</span></span><span class="line"><span class="cl">        String s4 = &#34;11&#34;; 
</span></span><span class="line"><span class="cl">        System.out.println(s3 == s4); // JDK1.6: false   JDK1.7: true
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><p>原因是因为字符串常量池在JDK1.7的时候被放在了堆中，而JDK1.6被放在了永久区中；</p>
<p>JDK1.6创建对象被放在了永久区中的字符串常量池，并非堆中，JVM无法对其进行优化；
在JDK1.7及之后，<code>new String(&quot;1&quot;)</code> 会在堆中创建一个对象并且会在字符串常量池中创建一个对象；
因为在堆中已经创建了对象，JVM为了节省空间，在字符串常量池中的对象只保留了引用堆中对象的地址，而并不是创建了一个真正的对象；</p>
<p>JDK1.6中，将这个字符串对象尝试放入串池。</p>
<ul>
<li>如果串池中有，则并不会放入。返回已有的串池中的对象的地址</li>
<li>如果没有，会把此<strong>对象复制一份，放入串池</strong>，并返回串池中的对象地址</li>
</ul>
<p><img alt="JDK6字符串常量池案例解析" src="/iblog/posts/annex/images/essays/JDK6%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0%E6%A1%88%E4%BE%8B%E8%A7%A3%E6%9E%90.png"></p>
<p>JDK1.7起，将这个字符串对象尝试放入串池。</p>
<ul>
<li>如果串池中有，则并不会放入。返回已有的串池中的对象的地址</li>
<li>如果没有，则会把<strong>对象的引用地址复制一份，放入串池</strong>，并返回串池中的引用地址</li>
</ul>
<p><img alt="JDK78字符串常量池案例解析" src="/iblog/posts/annex/images/essays/JDK78%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0%E6%A1%88%E4%BE%8B%E8%A7%A3%E6%9E%90.png"></p>
<h5 id="注意">注意</h5>
<p>字符串常量池是不会存储相同内容的字符串的。</p>
<p>字符串常量池其实是一个固定大小的<code>Hashtable</code>;
如果放进字符串常量池的string非常多，就会造成Hash冲突严重，从而导致链表会很长，而链表长了后直接会造成的影响就是当调用string.intern时性能会大幅下降。</p>
<p>使用VM参数<code>-XX:StringTablesize</code>可设置字符串常量池的的长度；</p>
<p>不同JDK版本字符串常量池的的长度：</p>
<ul>
<li>在JDK6中stringTable是固定的，为1009的长度，所以如果常量池中的字符串过多就会导致效率下降很快。<code>-XX:StringTablesize</code>设置没有要求，可随意设置；</li>
<li>在JDK中，stringTable的长度默认值是60013；<code>-XX:StringTablesize</code>设置没有要求，可随意设置；</li>
<li>在JDK8中，StringTable可以设置的最小值为1009;stringTable的长度默认值是60013；</li>
</ul>
<p>可以配置不同版本的JRE，运行下列代码，然后使用 <code>jsp(获取程序进程ID) -&gt; jinfo -flag StringTableSize 进程ID</code>命令进行查看stringTableSize</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public class MainTest {
</span></span><span class="line"><span class="cl">    public static void main(String[] args) {
</span></span><span class="line"><span class="cl">        try {
</span></span><span class="line"><span class="cl">            Thread.sleep(1000000);
</span></span><span class="line"><span class="cl">        } catch (InterruptedException e) {
</span></span><span class="line"><span class="cl">            e.printStackTrace();
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><h4 id="为什么需要常量池">为什么需要常量池</h4>
<p>一个Java源文件中的类、接口，编译后产生一个字节码文件。
而Java中的字节码需要数据支持，通常这种数据会很大以至于不能直接存到字节码里，换另一种方式，可以存到常量池，这个字节码包含了指向常量池的引用。
在动态链接的时候会用到运行时常量池。</p>
<p>比如：如下的代码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public class SimpleClass {
</span></span><span class="line"><span class="cl">    public void sayHello() {
</span></span><span class="line"><span class="cl">        System.out.println(&#34;hello&#34;);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><p>虽然上述代码生成的class文件只有194字节，但是里面却使用了String、System、PrintStream及Object等结构。
这里的代码量其实很少了，如果代码多的话，引用的结构将会更多，这样就需要用到常量池了。</p>
<p>常量池是为了避免频繁的创建和销毁对象而影响系统性能，其实现了对象的共享.
避免了相同内容的字符串的创建，节省了内存，省去了创建相同字符串的时间，同时提升了性能.</p>
<h2 id="string-类">String 类</h2>
<p>String是Java中一个比较基础的类.广泛应用 在 Java 编程中，在Java中字符串属于对象，Java 提供了 String 类来创建和操作字符串.</p>
<p>String被声明为<code>final</code>,因此它不可被继承(当然Integer等包装类也不能被继承)；</p>
<p>String实现了Serializable接口：表示字符串是支持序列化的。实现了Comparable接口：表示string可以比较大小；</p>
<h3 id="为什么jdk9改变了存储结构">为什么JDK9改变了存储结构</h3>
<p><strong>在 Java 8 中，String 内部使用 char 数组存储数据。</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public final class String
</span></span><span class="line"><span class="cl">    implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence {
</span></span><span class="line"><span class="cl">    /** The value is used for character storage. */
</span></span><span class="line"><span class="cl">    private final char value[];
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><p><strong>在 Java 9 之后，String 类的实现改用 byte 数组存储字符串，同时使用 coder 来标识使用了哪种编码。</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public final class String
</span></span><span class="line"><span class="cl">    implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence {
</span></span><span class="line"><span class="cl">    /** The value is used for character storage. */
</span></span><span class="line"><span class="cl">    private final byte[] value;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    /** The identifier of the encoding used to encode the bytes in {@code value}. */
</span></span><span class="line"><span class="cl">    private final byte coder;
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><p><a href="http://openjdk.java.net/jeps/254">那么为什么要改变内存存储结构呢？</a>
官方的解释：</p>
<blockquote>
<p>The current implementation of the String class stores characters in a char array, using two bytes (sixteen bits) for each character.
Data gathered from many different applications indicates that strings are a major component of heap usage and,
moreover, that most String objects contain only Latin-1 characters. Such characters require only one byte of storage,
hence half of the space in the internal char arrays of such String objects is going unused.</p>
<p>We propose to change the internal representation of the String class from a UTF-16 char array to a byte array plus an encoding-flag field.
The new String class will store characters encoded either as ISO-8859-1/Latin-1 (one byte per character),
or as UTF-16 (two bytes per character), based upon the contents of the string.
The encoding flag will indicate which encoding is used.</p>
</blockquote>
<p>大意：String类的当前实现将字符存储在char数组中，每个字符使用两个字节(16位)。
从许多不同的应用程序收集的数据表明，字符串是堆使用的主要组成部分，而且，大多数字符串对象只包含拉丁字符。
这些字符只需要一个字节的存储空间，因此这些字符串对象的内部char数组中有一半的空间将不会使用。</p>
<p>我们建议将String类的内部表示从UTF-16字符数组更改为一个字节数组加上一个编码标志字段。
新的String类将根据字符串的内容存储编码为ISO-8859-1/Latin-1(每个字符一个字节)或UTF-16(每个字符两个字节)的字符。
编码标志将指示所使用的编码。</p>
<p>简单说来就是用char数组存，有些数据占不了两个字节，所以为了节约资源改成byte数组存放；
如果存放的不是拉丁文则需要占两个字节，所以还需要加上编码标记。</p>
<p>基于String的数据结构，<code>StringBuffer</code>和<code>StringBuilder</code>也同样做了修改</p>
<h3 id="不可变性">不可变性</h3>
<p>value数组被声明为<code>final</code>，这意味着value数组初始化之后就不能再引用其它数组。
并且 String 内部没有改变 value 数组的方法，因此可以保证<code>String</code>不可变；
String是Java中一个不可变的类，所以他一旦一个string对象在内存(堆)中被创建出来，他就无法被修改。</p>
<p>下面代码说明String是不可变的：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public class MainTest {
</span></span><span class="line"><span class="cl">    String str = new String(&#34;good&#34;);
</span></span><span class="line"><span class="cl">    char [] ch = {&#39;t&#39;,&#39;e&#39;,&#39;s&#39;,&#39;t&#39;};
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public void change(String str, char ch []) {
</span></span><span class="line"><span class="cl">        str = &#34;test ok&#34;;
</span></span><span class="line"><span class="cl">        System.out.println( &#34;chanage方法里str=&#34; + str); // chanage方法里str=test ok
</span></span><span class="line"><span class="cl">        ch[0] = &#39;b&#39;;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public static void main(String[] args) {
</span></span><span class="line"><span class="cl">        MainTest ex = new MainTest();
</span></span><span class="line"><span class="cl">        ex.change(ex.str, ex.ch);
</span></span><span class="line"><span class="cl">        System.out.println(ex.str); // good
</span></span><span class="line"><span class="cl">        System.out.println(ex.ch);// best
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><p><strong>特别要注意的是，String类的所有方法都没有改变字符串本身的值，都是返回了一个新的对象。字符串不可变的根本原因应是处于安全性考虑。</strong></p>
<p>不可变性优点：</p>
<ol>
<li>可以缓存 hash 值</li>
</ol>
<p>因为<code>String</code>的<code>hash</code>值经常被使用,像<code>Set、Map</code>结构中的 key 值也需要用到<code>HashCode</code>来保证唯一性和一致性，因此不可变的 <code>HashCode</code> 才是安全可靠的</p>
<ol start="2">
<li>String常量池的需要</li>
</ol>
<p>字符串常量池的基础就是字符串的不可变性，如果字符串是可变的，那想一想，常量池就没必要存在了。
如果一个 <code>String</code> 对象已经被创建过了，那么就会从<code>String常量池中取得引用。只有</code>String`是不可变的，才可能使用 String常量池。</p>
<ol start="3">
<li>安全性</li>
</ol>
<p><code>String</code>经常作为参数,<code>String</code>不可变性可以保证参数不可变。例如在作为网络连接参数的情况下如果<code>String</code>是可变的，那么在网络连接过程中，<code>String</code>被改变，改变<code>String</code>对象的那一方以为现在连接的是其它主机,而实际情况却不一定是.
实际项目中会用到,比如数据库连接串、账号、密码等字符串，只有不可变的连接串、用户名和密码才能保证安全性.</p>
<ol start="4">
<li>线程安全</li>
</ol>
<p>字符串在 Java 中的使用频率可谓高之又高，那在高并发的情况下不可变性也使得对字符串的读写操作不用考虑多线程竞争的情况.
String不可变性天生具备线程安全,可以在多个线程中安全地使用.</p>
<h3 id="使用">使用</h3>
<h4 id="创建字符串">创建字符串</h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">// String 直接创建
</span></span><span class="line"><span class="cl">String str1 = &#34;123&#34;;
</span></span><span class="line"><span class="cl">// String 对象创建
</span></span><span class="line"><span class="cl">String str2 = new String(&#34;123&#34;);
</span></span><span class="line"><span class="cl">// 引用创建
</span></span><span class="line"><span class="cl">String str3 = str1;
</span></span></code></pre></div><p>格式化创建字符串</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">String str = String.format(&#34;浮点型变量: &#34; +
</span></span><span class="line"><span class="cl">                   &#34;%f, 整型变量: &#34; +
</span></span><span class="line"><span class="cl">                   &#34; %d, 字符串变量: &#34; +
</span></span><span class="line"><span class="cl">                   &#34; %s&#34;, 1.0f, 1, &#34;1&#34;);
</span></span><span class="line"><span class="cl">System.out.println(str);
</span></span></code></pre></div><p><strong>通过字面量的方式（区别于new）给一个字符串赋值,存储在String常量池中，而 new 创建的字符串对象在堆上.</strong></p>
<h4 id="连接字符串">连接字符串</h4>
<p><strong>因为String类是不可变的.所以所谓字符串拼接，都是重新生成了一个新的字符串.</strong></p>
<p>以下是字符串的几种拼接的方式</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">// 原字符串
</span></span><span class="line"><span class="cl">String str1 = &#34;123&#34;;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">//1. concat 方法连接字符串
</span></span><span class="line"><span class="cl">String str2 = &#34;123&#34;.concat(&#34;456&#34;);
</span></span><span class="line"><span class="cl">System.out.println(str2);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">//2. 用 &#34;+&#34; 连接字符串
</span></span><span class="line"><span class="cl">// 在编译时会编译成 String str4 = &#34;123456&#34;;
</span></span><span class="line"><span class="cl">String str3 = &#34;123&#34; + &#34;456&#34;;
</span></span><span class="line"><span class="cl">// 会调用StringBuilder.append方法
</span></span><span class="line"><span class="cl">String str4 = str3 + &#34;789&#34;;
</span></span><span class="line"><span class="cl">System.out.println(str3);
</span></span><span class="line"><span class="cl">System.out.println(str4);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">//3. 用JDK内置处理字符串类 Stringbuilder, StringBuffer
</span></span><span class="line"><span class="cl">StringBuilder builder = new StringBuilder();
</span></span><span class="line"><span class="cl">StringBuffer buffer = new StringBuffer();
</span></span><span class="line"><span class="cl">String str5 = builder.append(str).append(&#34;456&#34;).toString();
</span></span><span class="line"><span class="cl">String str6 = buffer.append(str).append(&#34;456&#34;).toString();
</span></span><span class="line"><span class="cl">System.out.println(str5);
</span></span><span class="line"><span class="cl">System.out.println(str6);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">//4. Java8新增String.join方法连接字符串
</span></span><span class="line"><span class="cl">List&lt;String&gt; list = new ArrayList&lt;&gt;();
</span></span><span class="line"><span class="cl">list.add(&#34;1&#34;);
</span></span><span class="line"><span class="cl">list.add(&#34;2&#34;);
</span></span><span class="line"><span class="cl">list.add(&#34;3&#34;);
</span></span><span class="line"><span class="cl">String str7 = String.join(&#34;-&#34;, list);
</span></span><span class="line"><span class="cl">String str8 = String.join(&#34;~&#34;, new String[]{&#34;1&#34;,&#34;2&#34;,&#34;3&#34;}r);
</span></span><span class="line"><span class="cl">System.out.println(str7);
</span></span><span class="line"><span class="cl">System.out.println(str8);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">//5. 用第三方处理字符串工具类. 例如: apache.commons.
</span></span><span class="line"><span class="cl">String str9 = StringUtils.join(new String[]{str, &#34;456&#34;, &#34;789&#34;});
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">// Java8提供的String.join方法和`apache.commons`方法相似.
</span></span><span class="line"><span class="cl">// 主要作用是将数组或集合以某拼接符拼接到一起形成新的字符串
</span></span></code></pre></div><h5 id="拼接字符串">拼接字符串</h5>
<p>拼接字符串最简单的方式就是直接使用符号+来拼接. + 是Java提供的一个语法糖.</p>
<blockquote>
<p>语法糖：语法糖（Syntactic sugar），也译为糖衣语法，是由英国计算机科学家彼得·兰丁发明的一个术语，指计算机语言中添加的某种语法，这种语法对语言的功能没有影响，但是更方便程序员使用。语法糖让程序更加简洁，有更高的可读性。</p>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">    public static void main(String[] args) {
</span></span><span class="line"><span class="cl">        String str = &#34;12&#34; + &#34;3&#34;;
</span></span><span class="line"><span class="cl">    }
</span></span></code></pre></div><p>两个都为编译期常量,编译器会进行常量折叠变为<code>String str = &quot;123&quot;;</code></p>
<p>如果拼接符号的前后出现了变量，则相当于在堆空间中<code>new String()</code>（这里的堆指的是除了字符串常量池外的区域），具体的内容为拼接的结果.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">    public static void main(String[] args) {
</span></span><span class="line"><span class="cl">        String str1 = &#34;123&#34;;
</span></span><span class="line"><span class="cl">        String str2 = &#34;456&#34;;
</span></span><span class="line"><span class="cl">        String str3 = str1 + str2;
</span></span><span class="line"><span class="cl">        System.out.println(str3);
</span></span><span class="line"><span class="cl">    }
</span></span></code></pre></div><p>打开文件所在位置,用<code>javap -verbose</code>命令进行反编译.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="o">//</span> <span class="o">...</span>
</span></span><span class="line"><span class="cl">  <span class="n">public</span> <span class="k">static</span> <span class="n">void</span> <span class="n">main</span><span class="p">(</span><span class="n">java</span><span class="o">.</span><span class="n">lang</span><span class="o">.</span><span class="n">String</span><span class="p">[]);</span>
</span></span><span class="line"><span class="cl">    <span class="n">descriptor</span><span class="p">:</span> <span class="p">([</span><span class="n">Ljava</span><span class="o">/</span><span class="n">lang</span><span class="o">/</span><span class="ne">String</span><span class="p">;)</span><span class="n">V</span>
</span></span><span class="line"><span class="cl">    <span class="n">flags</span><span class="p">:</span> <span class="n">ACC_PUBLIC</span><span class="p">,</span> <span class="n">ACC_STATIC</span>
</span></span><span class="line"><span class="cl">    <span class="n">Code</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">      <span class="n">stack</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">locals</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">args_size</span><span class="o">=</span><span class="mi">1</span>
</span></span><span class="line"><span class="cl">         <span class="mi">0</span><span class="p">:</span> <span class="n">ldc</span>           <span class="c1">#2                  // String 123</span>
</span></span><span class="line"><span class="cl">         <span class="mi">2</span><span class="p">:</span> <span class="n">astore_1</span>
</span></span><span class="line"><span class="cl">         <span class="mi">3</span><span class="p">:</span> <span class="n">ldc</span>           <span class="c1">#3                  // String 456</span>
</span></span><span class="line"><span class="cl">         <span class="mi">5</span><span class="p">:</span> <span class="n">astore_2</span>
</span></span><span class="line"><span class="cl">         <span class="mi">6</span><span class="p">:</span> <span class="n">new</span>           <span class="c1">#4                  // class java/lang/StringBuilder</span>
</span></span><span class="line"><span class="cl">         <span class="mi">9</span><span class="p">:</span> <span class="n">dup</span>
</span></span><span class="line"><span class="cl">        <span class="mi">10</span><span class="p">:</span> <span class="n">invokespecial</span> <span class="c1">#5                  // Method java/lang/StringBuilder.&#34;&lt;init&gt;&#34;:()V</span>
</span></span><span class="line"><span class="cl">        <span class="mi">13</span><span class="p">:</span> <span class="n">aload_1</span>
</span></span><span class="line"><span class="cl">        <span class="mi">14</span><span class="p">:</span> <span class="n">invokevirtual</span> <span class="c1">#6                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span>
</span></span><span class="line"><span class="cl">        <span class="mi">17</span><span class="p">:</span> <span class="n">aload_2</span>
</span></span><span class="line"><span class="cl">        <span class="mi">18</span><span class="p">:</span> <span class="n">invokevirtual</span> <span class="c1">#6                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span>
</span></span><span class="line"><span class="cl">        <span class="mi">21</span><span class="p">:</span> <span class="n">invokevirtual</span> <span class="c1">#7                  // Method java/lang/StringBuilder.toString:()Ljava/lang/String;</span>
</span></span><span class="line"><span class="cl">        <span class="mi">24</span><span class="p">:</span> <span class="n">astore_3</span>
</span></span><span class="line"><span class="cl">        <span class="mi">25</span><span class="p">:</span> <span class="n">getstatic</span>     <span class="c1">#8                  // Field java/lang/System.out:Ljava/io/PrintStream;</span>
</span></span><span class="line"><span class="cl">        <span class="mi">28</span><span class="p">:</span> <span class="n">aload_3</span>
</span></span><span class="line"><span class="cl">        <span class="mi">29</span><span class="p">:</span> <span class="n">invokevirtual</span> <span class="c1">#9                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span>
</span></span><span class="line"><span class="cl">        <span class="mi">32</span><span class="p">:</span> <span class="k">return</span>
</span></span><span class="line"><span class="cl">      <span class="o">//</span> <span class="o">...</span>
</span></span></code></pre></div><p>可以看到<strong>在字符串拼接过程中,是将String转成了<code>StringBuilder</code>后，使用其<code>append</code>方法进行拼接字符串处理的.最后在去调用<code>StringBuilder</code>的<code>toString</code>方法进行返回</strong></p>
<blockquote>
<p>在JDK5之后，使用的是StringBuilder，在JDK5之前使用的是StringBuffer</p>
</blockquote>
<p>但是如果使用final修饰String变量时，在VM编译过程中，仍然被编译器优化；</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public class MainTest {
</span></span><span class="line"><span class="cl">    public static void main(String[] args) {
</span></span><span class="line"><span class="cl">        final String a = &#34;1&#34;;
</span></span><span class="line"><span class="cl">        final String b = &#34;2&#34;;
</span></span><span class="line"><span class="cl">        String ab = a + b; // 在class文件中会优化为: String ab = 12;
</span></span><span class="line"><span class="cl">        String ab0 = &#34;12&#34;;
</span></span><span class="line"><span class="cl">        System.out.println(ab == ab0);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><p>在开发中，能够使用final的时候，建议使用上。</p>
<h5 id="concat方法">concat方法</h5>
<p>源码</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">    public String concat(String str) {
</span></span><span class="line"><span class="cl">        // 获取字符串长度 
</span></span><span class="line"><span class="cl">        int otherLen = str.length();
</span></span><span class="line"><span class="cl">        // 判空
</span></span><span class="line"><span class="cl">        if (otherLen == 0) {
</span></span><span class="line"><span class="cl">            return this;
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        // 获取已有字符串长度
</span></span><span class="line"><span class="cl">        int len = value.length;
</span></span><span class="line"><span class="cl">        // 创建新的字符数组.
</span></span><span class="line"><span class="cl">        // 长度为:已有字符串+待拼接字符长度.
</span></span><span class="line"><span class="cl">        // 将两个字符串的值复制到新的字符数组
</span></span><span class="line"><span class="cl">        char buf[] = Arrays.copyOf(value, len + otherLen);
</span></span><span class="line"><span class="cl">        str.getChars(buf, len);
</span></span><span class="line"><span class="cl">        // 创建新的字符串对象
</span></span><span class="line"><span class="cl">        return new String(buf, true);
</span></span><span class="line"><span class="cl">    }
</span></span></code></pre></div><h5 id="stringbuffer和stringbuilder">StringBuffer和StringBuilder</h5>
<p><code>Stringbuilder</code>和<code>StringBuffer</code>共同的父类：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">abstract class AbstractStringBuilder implements Appendable, CharSequence {
</span></span><span class="line"><span class="cl">    /**
</span></span><span class="line"><span class="cl">     * The value is used for character storage.
</span></span><span class="line"><span class="cl">     */
</span></span><span class="line"><span class="cl">    char[] value;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    /**
</span></span><span class="line"><span class="cl">     * The count is the number of characters used.
</span></span><span class="line"><span class="cl">     */
</span></span><span class="line"><span class="cl">    int count;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    // ...
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><p>用于存贮的<code>value</code>并没有用<code>final</code>修饰,说明是可以修改的.还有一个属性字段<code>count</code>,用来保存数组中已经使用的字符个数.</p>
<p><strong>append方法</strong></p>
<p><code>StringBuilder.append</code>方法</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    public StringBuilder append(String str) {
</span></span><span class="line"><span class="cl">        super.append(str);
</span></span><span class="line"><span class="cl">        return this;
</span></span><span class="line"><span class="cl">    }
</span></span></code></pre></div><p><code>StringBuffer.append</code>方法</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    public synchronized StringBuffer append(String str) {
</span></span><span class="line"><span class="cl">        toStringCache = null;
</span></span><span class="line"><span class="cl">        super.append(str);
</span></span><span class="line"><span class="cl">        return this;
</span></span><span class="line"><span class="cl">    }
</span></span></code></pre></div><p>由此可以看出<code>StringBuilder</code>和<code>StringBuffer</code>原理是相似的,最大的区别就是<code>StringBuffer</code>是线程安全的.原因是用了<code>synchronized</code>修饰.</p>
<p><code>append</code>方法原理的在父类中.需要注意的是,如果<code>append</code>方法<code>append(null)</code>会直接拼接字符串&quot;null&rdquo;</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">    public AbstractStringBuilder append(String str) {
</span></span><span class="line"><span class="cl">        // 判空
</span></span><span class="line"><span class="cl">        if (str == null)
</span></span><span class="line"><span class="cl">            /**
</span></span><span class="line"><span class="cl">             * final char[] value = this.value;
</span></span><span class="line"><span class="cl">             * value[c++] = &#39;n&#39;;
</span></span><span class="line"><span class="cl">             * value[c++] = &#39;u&#39;;
</span></span><span class="line"><span class="cl">             * value[c++] = &#39;l&#39;;
</span></span><span class="line"><span class="cl">             * value[c++] = &#39;l&#39;;
</span></span><span class="line"><span class="cl">             */
</span></span><span class="line"><span class="cl">           // 如果是&#39;null&#39; 则返回 字符串 &#34;null&#34;
</span></span><span class="line"><span class="cl">            return appendNull();
</span></span><span class="line"><span class="cl">        // 获取字符长度
</span></span><span class="line"><span class="cl">        int len = str.length();
</span></span><span class="line"><span class="cl">        /**  if (count + len - value.length &gt; 0) {
</span></span><span class="line"><span class="cl">                // 拷贝字符到内部的字符数组中.如果字符数组长度不够，会进行扩展
</span></span><span class="line"><span class="cl">                value = Arrays.copyOf(value,newCapacity(count+len));
</span></span><span class="line"><span class="cl">             }
</span></span><span class="line"><span class="cl">        **/
</span></span><span class="line"><span class="cl">        ensureCapacityInternal(count + len);
</span></span><span class="line"><span class="cl">        // 复制数组
</span></span><span class="line"><span class="cl">        // System.arraycopy(value, srcBegin, dst, dstBegin, srcEnd - srcBegin);
</span></span><span class="line"><span class="cl">        str.getChars(0, len, value, count);
</span></span><span class="line"><span class="cl">        // 拼接字符长度
</span></span><span class="line"><span class="cl">        count += len;
</span></span><span class="line"><span class="cl">        return this;
</span></span><span class="line"><span class="cl">    }
</span></span></code></pre></div><p>与 String 类不同的是，<code>StringBuffer</code> 和 <code>StringBuilder</code> 类的对象能够被多次的修改，并且不产生新的未使用对象。</p>
<p>如果你需要一个可修改的字符串，应该使用<code>StringBuffer</code> 或者 <code>StringBuilder</code>。但是会有大量时间浪费在垃圾回收上，因为每次试图修改都有新的<code>String</code>对象被创建出来.</p>
<h5 id="比较和使用">比较和使用</h5>
<p>时间比较(短-&gt;长):</p>
<p><code>StringBuilder</code>&lt;<code>StringBuffer</code>&lt;<code>concat</code>&lt;<code>+</code>&lt;<code>StringUtils.join</code></p>
<p>使用注意:</p>
<ul>
<li>
<p>如果在并发场景中进行字符串拼接的话,要使用<code>StringBuffer</code>来代替<code>StringBuilder</code>.</p>
</li>
<li>
<p>如果不是在循环体中进行字符串拼接的话,直接使用+就好了,如果在循环体内使用&quot;+&ldquo;拼接字符串对象会在每一次循环都会创建<code>StringBuilder</code>对象,导致程序效率降低.
如下代码：</p>
</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">    public static void method1(int highLevel) {
</span></span><span class="line"><span class="cl">        String src = &#34;&#34;;
</span></span><span class="line"><span class="cl">        for (int i = 0; i &lt; highLevel; i++) {
</span></span><span class="line"><span class="cl">            src += &#34;a&#34;; // 每次循环都会创建一个StringBuilder对象
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public static void method2(int highLevel) {
</span></span><span class="line"><span class="cl">        StringBuilder sb = new StringBuilder();
</span></span><span class="line"><span class="cl">        for (int i = 0; i &lt; highLevel; i++) {
</span></span><span class="line"><span class="cl">            sb.append(&#34;a&#34;);
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    }
</span></span></code></pre></div><p>通过<code>StringBuilder</code>的<code>append()</code>方式添加字符串的效率，要远远高于<code>String</code>的字符串拼接方法.</p>
<p>在实际开发中还可以进行优化，<code>StringBuilder</code> 的空参构造器，默认的字符串容量是16,如果需要存放的数据过多，容量就会进行扩容，我们可以设置默认初始化更大的长度，来减少扩容的次数。</p>
<p>如果我们能够确定，前前后后需要添加的字符串不高于某个限定值，那么建议使用构造器创建一个阈值的长度。</p>
<h4 id="常用方法">常用方法</h4>
<p>基于Java8整理.如果查看其他方法请参照<a href="https://docs.oracle.com/javase/8/docs/api/index.html">Java8API官方文档</a> <code>java.lang.String</code></p>
<h5 id="substring">substring</h5>
<p>对字符串进行截取.返回一个新的字符串,它是此字符串的一个子字符串.</p>
<p>源码</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">    public String substring(int beginIndex) {
</span></span><span class="line"><span class="cl">        // 判空
</span></span><span class="line"><span class="cl">        if (beginIndex &lt; 0) {
</span></span><span class="line"><span class="cl">            throw new StringIndexOutOfBoundsException(beginIndex);
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        // 需要截取的长度不能超过源字符的长度
</span></span><span class="line"><span class="cl">        int subLen = value.length - beginIndex;
</span></span><span class="line"><span class="cl">        if (subLen &lt; 0) {
</span></span><span class="line"><span class="cl">            throw new StringIndexOutOfBoundsException(subLen);
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        // 如果传入的长度不等于被截字符串的长度 则创建新的字符串
</span></span><span class="line"><span class="cl">        return (beginIndex == 0) ? this : new String(value, beginIndex, subLen);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    public String substring(int beginIndex, int endIndex) {
</span></span><span class="line"><span class="cl">        if (beginIndex &lt; 0) {
</span></span><span class="line"><span class="cl">            throw new StringIndexOutOfBoundsException(beginIndex);
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        if (endIndex &gt; value.length) {
</span></span><span class="line"><span class="cl">            throw new StringIndexOutOfBoundsException(endIndex);
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        int subLen = endIndex - beginIndex;
</span></span><span class="line"><span class="cl">        if (subLen &lt; 0) {
</span></span><span class="line"><span class="cl">            throw new StringIndexOutOfBoundsException(subLen);
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        return ((beginIndex == 0) &amp;&amp; (endIndex == value.length)) ? this
</span></span><span class="line"><span class="cl">                : new String(value, beginIndex, subLen);
</span></span><span class="line"><span class="cl">    }
</span></span></code></pre></div><p>使用</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">    public static void main(String[] args) {
</span></span><span class="line"><span class="cl">        String str = &#34;123456&#34;;
</span></span><span class="line"><span class="cl">        String substring = str.substring(2);
</span></span><span class="line"><span class="cl">        // 3456
</span></span><span class="line"><span class="cl">        System.out.println(substring);
</span></span><span class="line"><span class="cl">        // 索引从1开始截取字符串
</span></span><span class="line"><span class="cl">        String substring2 = str.substring(2,4);
</span></span><span class="line"><span class="cl">        // 34
</span></span><span class="line"><span class="cl">        System.out.println(substring2);
</span></span><span class="line"><span class="cl">    }
</span></span></code></pre></div><h5 id="replace">replace</h5>
<p>替换字符串.返回一个新的字符串,它是通过用 <code>newChar</code> 替换此字符串中出现的所有 <code>oldChar</code> 得到的.</p>
<p>源码</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl"> public String replace(char oldChar, char newChar) {
</span></span><span class="line"><span class="cl">        // 校验: 需要进行替换新旧字符不能相同
</span></span><span class="line"><span class="cl">        if (oldChar != newChar) {
</span></span><span class="line"><span class="cl">            // 获取源字符串中的长度
</span></span><span class="line"><span class="cl">            int len = value.length;
</span></span><span class="line"><span class="cl">            int i = -1;
</span></span><span class="line"><span class="cl">            // 获取源字符串
</span></span><span class="line"><span class="cl">            char[] val = value; /* avoid getfield opcode */
</span></span><span class="line"><span class="cl">            // 判断源字符串是否存在 需要替换的旧字符
</span></span><span class="line"><span class="cl">            while (++i &lt; len) {
</span></span><span class="line"><span class="cl">                if (val[i] == oldChar) {
</span></span><span class="line"><span class="cl">                    break;
</span></span><span class="line"><span class="cl">                }
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">            if (i &lt; len) {
</span></span><span class="line"><span class="cl">                // 创建新的字符数组 用于替换后保存新字符串 
</span></span><span class="line"><span class="cl">                char buf[] = new char[len];
</span></span><span class="line"><span class="cl">                for (int j = 0; j &lt; i; j++) {
</span></span><span class="line"><span class="cl">                    // 将旧字符存入到新字符数组
</span></span><span class="line"><span class="cl">                    buf[j] = val[j];
</span></span><span class="line"><span class="cl">                }
</span></span><span class="line"><span class="cl">                while (i &lt; len) {
</span></span><span class="line"><span class="cl">                    char c = val[i];
</span></span><span class="line"><span class="cl">                    // 替换字符
</span></span><span class="line"><span class="cl">                    buf[i] = (c == oldChar) ? newChar : c;
</span></span><span class="line"><span class="cl">                    i++;
</span></span><span class="line"><span class="cl">                }
</span></span><span class="line"><span class="cl">                // 创建新字符串对象
</span></span><span class="line"><span class="cl">                return new String(buf, true);
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        return this;
</span></span><span class="line"><span class="cl">    }
</span></span></code></pre></div><p>使用</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">    public static void main(String[] args) {
</span></span><span class="line"><span class="cl">        String str = &#34;123456&#34;;
</span></span><span class="line"><span class="cl">        // 223456
</span></span><span class="line"><span class="cl">        System.out.println(str.replace(&#39;1&#39;, &#39;2&#39;));
</span></span><span class="line"><span class="cl">    }
</span></span></code></pre></div><h5 id="replaceall">replaceAll</h5>
<p>使用给定的 <code>replacement</code> 替换此字符串所有匹配给定的正则表达式的子字符串.</p>
<p>源码</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">    public String replaceAll(String regex, String replacement) {
</span></span><span class="line"><span class="cl">        return Pattern.compile(regex).matcher(this).replaceAll(replacement);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">    // complile 解析正则表达式 获得 Pattern对象
</span></span><span class="line"><span class="cl">    public static Pattern compile(String regex) {
</span></span><span class="line"><span class="cl">        return new Pattern(regex, 0);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    //matcher 获取匹配器对象
</span></span><span class="line"><span class="cl">    public Matcher matcher(CharSequence input) {
</span></span><span class="line"><span class="cl">        if (!compiled) {
</span></span><span class="line"><span class="cl">            synchronized(this) {
</span></span><span class="line"><span class="cl">                if (!compiled)
</span></span><span class="line"><span class="cl">                    compile();
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        Matcher m = new Matcher(this, input);
</span></span><span class="line"><span class="cl">        return m;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    // replaceAll 进行字符串替换
</span></span><span class="line"><span class="cl">    public String replaceAll(String replacement) {
</span></span><span class="line"><span class="cl">    // 对当前Matcher类进行重置，即对其中记录匹配结果的开始和结束位置索引，以及分组信息重置
</span></span><span class="line"><span class="cl">        reset();
</span></span><span class="line"><span class="cl">        // 执行第一次搜索
</span></span><span class="line"><span class="cl">        boolean result = find();
</span></span><span class="line"><span class="cl">         // 第一次搜索匹配成功
</span></span><span class="line"><span class="cl">        if (result) {
</span></span><span class="line"><span class="cl">            // 用于记录最终的替换结果字符串
</span></span><span class="line"><span class="cl">            StringBuffer sb = new StringBuffer();
</span></span><span class="line"><span class="cl">            do {
</span></span><span class="line"><span class="cl">            // 重点：用于将从上一次匹配子字符串的下一个索引位置开始，到当前匹配的子字符串的结束索引位置的所有字符 append到字符串sb中
</span></span><span class="line"><span class="cl">                appendReplacement(sb, replacement);
</span></span><span class="line"><span class="cl">                result = find();
</span></span><span class="line"><span class="cl">            } while (result);
</span></span><span class="line"><span class="cl">            // 将从最后一次匹配子字符串的下一个索引位置，到字符串的结尾的所有字符append到字符串sb中
</span></span><span class="line"><span class="cl">            appendTail(sb);
</span></span><span class="line"><span class="cl">            return sb.toString();
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        return text.toString();
</span></span><span class="line"><span class="cl">    }
</span></span></code></pre></div><p>重点看一下<code>replaceAll</code>中调用的<code>appendReplacement</code>方法</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">    public Matcher appendReplacement(StringBuffer sb, String replacement) {
</span></span><span class="line"><span class="cl">            
</span></span><span class="line"><span class="cl">            // ...
</span></span><span class="line"><span class="cl">            
</span></span><span class="line"><span class="cl">            // 用于跟踪 replacement 字符串的索引
</span></span><span class="line"><span class="cl">            int cursor = 0;
</span></span><span class="line"><span class="cl">            
</span></span><span class="line"><span class="cl">            // 对当前匹配到子字符串替换后的结果字符串
</span></span><span class="line"><span class="cl">            StringBuffer result = new StringBuffer();
</span></span><span class="line"><span class="cl">            
</span></span><span class="line"><span class="cl">            // 遍历 replacement字符串
</span></span><span class="line"><span class="cl">            while (cursor &lt; replacement.length()) {
</span></span><span class="line"><span class="cl">                
</span></span><span class="line"><span class="cl">                char nextChar = replacement.charAt(cursor);
</span></span><span class="line"><span class="cl">                
</span></span><span class="line"><span class="cl">                if (nextChar == &#39;\\&#39;) {
</span></span><span class="line"><span class="cl">                    // 重点1：当字符为&#39;\&#39;时，跳过，并获取其后面的字符，追加到result
</span></span><span class="line"><span class="cl">                    cursor++;
</span></span><span class="line"><span class="cl">                    nextChar = replacement.charAt(cursor);
</span></span><span class="line"><span class="cl">                    result.append(nextChar);
</span></span><span class="line"><span class="cl">                    cursor++;
</span></span><span class="line"><span class="cl">                } else if (nextChar == &#39;$&#39;) {
</span></span><span class="line"><span class="cl">                    
</span></span><span class="line"><span class="cl">                    // 重点2：当字符为$时，跳过，并获取其后面的数值，并以此如果$后面第一个不为数字则抛异常，
</span></span><span class="line"><span class="cl">                    // Skip past $
</span></span><span class="line"><span class="cl">                    cursor++;
</span></span><span class="line"><span class="cl">                    
</span></span><span class="line"><span class="cl">                    // The first number is always a group
</span></span><span class="line"><span class="cl">                    int refNum = (int)replacement.charAt(cursor) - &#39;0&#39;;
</span></span><span class="line"><span class="cl">                    
</span></span><span class="line"><span class="cl">                    // 此处代码用于计算$符号后的数值，数值结果赋予 refNum
</span></span><span class="line"><span class="cl">                    // ...
</span></span><span class="line"><span class="cl">                    
</span></span><span class="line"><span class="cl">                    // group(refNum) 用于获取正则表达式第refNum个分组表示的字符串，不详说了
</span></span><span class="line"><span class="cl">                    if (group(refNum) != null)
</span></span><span class="line"><span class="cl">                         // 追加到result
</span></span><span class="line"><span class="cl">                        result.append(group(refNum));
</span></span><span class="line"><span class="cl">                } else {
</span></span><span class="line"><span class="cl">                    
</span></span><span class="line"><span class="cl">                    // 当前字符不为\ 或 $ 则直接追加到result
</span></span><span class="line"><span class="cl">                    result.append(nextChar);
</span></span><span class="line"><span class="cl">                    cursor++;
</span></span><span class="line"><span class="cl">                }
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">            
</span></span><span class="line"><span class="cl">            // 将从上一次匹配的子字符串的结尾索引，到当前匹配的第一个字符串索引的字符串追加到sb
</span></span><span class="line"><span class="cl">            // lastAppendPosition参数为上一次执行appendReplacement方法最后追加的字符在原始字符串中的索引位置。
</span></span><span class="line"><span class="cl">            // first 参数为当前待替换的子字符串的首个字符在原始字符串中的索引位置
</span></span><span class="line"><span class="cl">            sb.append(getSubSequence(lastAppendPosition, first));
</span></span><span class="line"><span class="cl">            
</span></span><span class="line"><span class="cl">            // 将当前配置子字符串替换后的结果字符串追加到sb
</span></span><span class="line"><span class="cl">            sb.append(result.toString());
</span></span><span class="line"><span class="cl">            
</span></span><span class="line"><span class="cl">            // 更新lastAppendPosition，供下一个匹配执行appendReplacement方法使用
</span></span><span class="line"><span class="cl">            lastAppendPosition = last;
</span></span><span class="line"><span class="cl">            
</span></span><span class="line"><span class="cl">            /* sb中追加了当前匹配的子字符串与前一次匹配子字符串中间的字符，以及当前匹配子字符串被替换后的字符串
</span></span><span class="line"><span class="cl">             */
</span></span><span class="line"><span class="cl">            return this;
</span></span><span class="line"><span class="cl">        }
</span></span></code></pre></div><p><code>replaceAll</code>中第二个参数<code>replacement</code>中，\ 有转义的作用, $ 用于获取分组匹配的当前子字符串 因为引入了 $ 符的分组功能,所以为了解决能输出 $ 字符，故引入 \ 转义功能.</p>
<p>使用</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">    public static void main(String[] args) {
</span></span><span class="line"><span class="cl">        String str = &#34;111111&#34;;
</span></span><span class="line"><span class="cl">        // 222222
</span></span><span class="line"><span class="cl">        System.out.println(str.replaceAll(&#34;1&#34;, &#34;2&#34;));
</span></span><span class="line"><span class="cl">    }
</span></span></code></pre></div><h5 id="valueof">valueOf</h5>
<p>该方法作用是将对象转成String类型.</p>
<p>源码</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">    public static String valueOf(Object obj) {
</span></span><span class="line"><span class="cl">        return (obj == null) ? &#34;null&#34; : obj.toString();
</span></span><span class="line"><span class="cl">    }
</span></span></code></pre></div><p>使用</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">    public static void main(String[] args) {
</span></span><span class="line"><span class="cl">        Integer integer = 11111;
</span></span><span class="line"><span class="cl">        String str = String.valueOf(integer);
</span></span><span class="line"><span class="cl">        // 11111
</span></span><span class="line"><span class="cl">        System.out.println(str);
</span></span><span class="line"><span class="cl">    }
</span></span></code></pre></div><h3 id="长度限制">长度限制</h3>
<p>翻阅String源码在String源码中发现有定义字符串长度的构造函数</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">    // count 就是 字符串定义长度 
</span></span><span class="line"><span class="cl">    public String(char value[], int offset, int count) {
</span></span><span class="line"><span class="cl">        if (offset &lt; 0) {
</span></span><span class="line"><span class="cl">            throw new StringIndexOutOfBoundsException(offset);
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        if (count &lt;= 0) {
</span></span><span class="line"><span class="cl">            if (count &lt; 0) {
</span></span><span class="line"><span class="cl">                throw new StringIndexOutOfBoundsException(count);
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">            if (offset &lt;= value.length) {
</span></span><span class="line"><span class="cl">                this.value = &#34;&#34;.value;
</span></span><span class="line"><span class="cl">                return;
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        // Note: offset or count might be near -1&gt;&gt;&gt;1.
</span></span><span class="line"><span class="cl">        if (offset &gt; value.length - count) {
</span></span><span class="line"><span class="cl">            throw new StringIndexOutOfBoundsException(offset + count);
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        this.value = Arrays.copyOfRange(value, offset, offset+count);
</span></span><span class="line"><span class="cl">    }
</span></span></code></pre></div><p>通过源码可以看到<code>int</code>的最大长度就是<code>String</code>的支持的最大长度.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">    public static void main(String[] args) {
</span></span><span class="line"><span class="cl">        // 2,147,483,648 = 2^31 - 1 
</span></span><span class="line"><span class="cl">        System.out.println(Integer.MAX_VALUE);
</span></span><span class="line"><span class="cl">    }
</span></span></code></pre></div><p><strong>注意<code>new String(char value[], int offset, int count)</code>是运行时<code>String</code>支持的最大长度.</strong></p>
<p>在<code>String</code>编译声明期间,用<code>javac</code>编译 长度为<code>2^31 -1</code>的字符串.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">    public static void main(String[] args) {
</span></span><span class="line"><span class="cl">        // 长度: 2^31 -1
</span></span><span class="line"><span class="cl">        String str = &#34;1111 ... &#34;;
</span></span><span class="line"><span class="cl">        System.out.println(str);
</span></span><span class="line"><span class="cl">    }
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">java: 常量字符串过长
</span></span></code></pre></div><p>在<code>Gen</code>类中相关报错信息源码</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="n">private</span> <span class="n">void</span> <span class="n">checkStringConstant</span><span class="p">(</span><span class="n">DiagnosticPosition</span> <span class="n">var1</span><span class="p">,</span> <span class="ne">Object</span> <span class="n">var2</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">this</span><span class="o">.</span><span class="n">nerrs</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">var2</span> <span class="o">!=</span> <span class="n">null</span> <span class="o">&amp;&amp;</span> <span class="n">var2</span> <span class="n">instanceof</span> <span class="ne">String</span> <span class="o">&amp;&amp;</span> <span class="p">((</span><span class="ne">String</span><span class="p">)</span><span class="n">var2</span><span class="p">)</span><span class="o">.</span><span class="n">length</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="mi">65535</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">this</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">var1</span><span class="p">,</span> <span class="s2">&#34;limit.string&#34;</span><span class="p">,</span> <span class="n">new</span> <span class="ne">Object</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">        <span class="o">++</span><span class="n">this</span><span class="o">.</span><span class="n">nerrs</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>可以看到源码中如果<code>String</code>长度大于等于65535会导致编译失败</p>
<p>在编译期的时候,字面量要进字符串常量池.所以要遵守<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4.3">《Java®虚拟机规范》(Java8)中对String常量池的描述.</a></p>
<p><code>CONSTANT_String_info</code> 用于表示 <code>java.lang.String</code> 类型的常量对象结构体</p>
<p><code>CONSTANT_String_info</code>格式如下:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">CONSTANT_String_info {
</span></span><span class="line"><span class="cl">    u1 tag;
</span></span><span class="line"><span class="cl">    u2 string_index;
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><blockquote>
<p><strong>tag</strong><br>
结构<code>CONSTANT_String_info</code>的标签项的值为<code>CONSTANT_String(8)</code></p>
</blockquote>
<blockquote>
<p><strong>string_index</strong><br>
<code>string_index</code> 项的值必须是对常量池的有效索引，常量池在该索引处的项必须是 <code>CONSTANT_Utf8_info</code> 结构，表示一组 <code>Unicode</code> 码点序列，这组 Unicode 码点序列最终会被初始化为一个 下 <code>Unicode</code> 对象</p>
</blockquote>
<p><code>CONSTANT_Utf8_info</code>是一个<code>CONSTANT_Utf8</code>类型的常量池数据项，它存储的是一个常量字符串。常量池中的所有字面量几乎都是通过<code>CONSTANT_Utf8_info</code>描述的。<code>CONSTANT_Utf8_info</code>的定义如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">ONSTANT_Utf8_info {
</span></span><span class="line"><span class="cl">    u1 tag;
</span></span><span class="line"><span class="cl">    u2 length;
</span></span><span class="line"><span class="cl">    u1 bytes[length];
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><p><code>length</code>则指明了 <code>bytes</code>数组的长度，其类型为<code>u2</code></p>
<p>通过查阅《JVM规范》发现<code>u2</code>表示两个字节的无符号数，那么1个字节有8位，2个字节就有16位。16位无符号数可表示的最大值位<code>2^16 - 1 = 65535</code>。也就是说，<code>Class</code>文件中常量池的格式规定了，其字符串常量的长度不能超过65535。</p>
<p><strong>关于编译器字符串最大长度65534的问题</strong></p>
<blockquote>
<p>如果一个方法的Java虚拟机代码长度正好是65535字节，并且以一个1字节长的指令结束，那么该指令不能被异常处理程序保护。编译器作者可以通过将任何方法、实例初始化方法或静态初始化器(任何代码数组的大小)生成的Java虚拟机代码的最大大小限制为65534字节来解决这个问题</p>
</blockquote>
<p><strong>简单来说</strong></p>
<ul>
<li>在程序运行时String最大长度为int最大长度为<code>2^31 -1</code></li>
<li>在程序编译期根据<code>String</code>JVM常量池规范String字符串在声明时最大为 65535,但是为了修复<code>Java</code>的遗留问题改为65534</li>
</ul>
<p>在程序开发中,需要注意如果你用<code>String</code>变量接收Base64图片或音频视频需要注意不要超过在程序运行时字符串的最大阈值.</p>
<h3 id="编码问题">编码问题</h3>
<p>因为全世界有很多编程人员，有很多语言，不同的国家使用不同的语言，如果说没有一套统一的编码规则，这么多语言混在一起，很容易出现乱码现象，本着既方便又节约内存的理念大家基本都是用<code>utf-8</code>码来编写程序.</p>
<h4 id="unicode">Unicode</h4>
<blockquote>
<p>Unicode（中文：万国码、国际码、统一码、单一码）是计算机科学领域里的一项业界标准。它对世界上大部分的文字系统进行了整理、编码，使得计算机可以用更为简单的方式来呈现和处理文字.</p>
</blockquote>
<blockquote>
<p>Unicode伴随着通用字符集的标准而发展，同时也以书本的形式对外发表。Unicode至今仍在不断增修，每个新版本都加入更多新的字符。目前最新的版本为2018年6月5日公布的11.0.0，已经收录超过13万个字符（第十万个字符在2005年获采纳）。Unicode涵盖的数据除了视觉上的字形、编码方法、标准的字符编码外，还包含了字符特性，如大小写字母。</p>
</blockquote>
<p><code>Unicode</code>是一种编码规范，是为解决全球字符通用编码而设计的，而<code>UTF-8 UTF-16</code>等是这种规范的一种实现.<code>Unicode</code>是字符集而<code>UTF-8</code>是编码规则。</p>
<p>Java内部采用<code>Unicode</code>编码规范，也就是支持多语言的，具体采用的<code>UTF-16</code>编码方式.</p>
<p><strong>不管程序过程中用到了<code>GBK</code>还是<code>ISO8859-1</code>等格式，在存储与传递的过程中实际传递的都是<code>Unicode</code>编码的数据，要想接收到的值不出现乱码，就要保证传过去的时候用的是X编码，接收的时候也用X编码来转换接收</strong></p>
<h4 id="乱码原因">乱码原因</h4>
<p><strong>编码时格式和解码时格式不一致.</strong></p>
<p><code>string</code>在文件里面底层保存形式是二进制,底层用<code>byte[]</code>数组存储(Java9. Java8是用<code>char</code>数组储存).<code>byte[]</code>数组里面的内容可以按照不同的编码格式存放.在读取字符串的时候,也可以按照不同的解码格式存放.这样就造成了<strong>乱码</strong>.</p>
<p>简单理解为</p>
<p>在编码(字符串到字节)的时候是用一种编码;而在解码(从字节到字符串)的时候用另一种编码;所以导致乱码问题.<strong>所以想要避免乱码问题最简单的办法就是从始至终,都用同一种字符格式</strong></p>
<h4 id="相关方法">相关方法</h4>
<p><code>String</code>类有两种比较常用的操作编码方式</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">    // 注意处理异常
</span></span><span class="line"><span class="cl">    public static void main(String[] args) throws UnsupportedEncodingException {
</span></span><span class="line"><span class="cl">        // 本地使用的是 utf-8 的编码
</span></span><span class="line"><span class="cl">        String str = &#34;你好&#34;;
</span></span><span class="line"><span class="cl">        byte[] bytes = str.getBytes(&#34;utf-8&#34;);
</span></span><span class="line"><span class="cl">        // 你好
</span></span><span class="line"><span class="cl">        System.out.println(new String(bytes));
</span></span><span class="line"><span class="cl">        String string = new String(str.getBytes(), &#34;utf-8&#34;);
</span></span><span class="line"><span class="cl">        // 你好
</span></span><span class="line"><span class="cl">        System.out.println(string);
</span></span><span class="line"><span class="cl">    }
</span></span></code></pre></div><h5 id="getbytesstring-charsetname">getBytes(String charsetName)</h5>
<p>该方法会根据指定的<code>decode</code>编码返回某字符串在该编码下的<code>byte</code>数组表示</p>
<p>源码</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">    public byte[] getBytes(String charsetName)
</span></span><span class="line"><span class="cl">            throws UnsupportedEncodingException {
</span></span><span class="line"><span class="cl">        if (charsetName == null) throw new NullPointerException();
</span></span><span class="line"><span class="cl">        return StringCoding.encode(charsetName, value, 0, value.length);
</span></span><span class="line"><span class="cl">    }
</span></span></code></pre></div><p><code>StringCoding.encode</code>方法</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">// len: 当前字符串长度
</span></span><span class="line"><span class="cl">static byte[] encode(String charsetName, char[] ca, int off, int len)
</span></span><span class="line"><span class="cl">        throws UnsupportedEncodingException
</span></span><span class="line"><span class="cl">    {
</span></span><span class="line"><span class="cl">        StringEncoder se = deref(encoder);
</span></span><span class="line"><span class="cl">        // 如果为空 默认ISO-8859-1
</span></span><span class="line"><span class="cl">        String csn = (charsetName == null) ? &#34;ISO-8859-1&#34; : charsetName;
</span></span><span class="line"><span class="cl">        // 
</span></span><span class="line"><span class="cl">        if ((se == null) || !(csn.equals(se.requestedCharsetName())
</span></span><span class="line"><span class="cl">                              || csn.equals(se.charsetName()))) {
</span></span><span class="line"><span class="cl">            se = null;
</span></span><span class="line"><span class="cl">            try {
</span></span><span class="line"><span class="cl">                // 根据编码获取 Charset对象
</span></span><span class="line"><span class="cl">                Charset cs = lookupCharset(csn);
</span></span><span class="line"><span class="cl">                if (cs != null)
</span></span><span class="line"><span class="cl">                    se = new StringEncoder(cs, csn);
</span></span><span class="line"><span class="cl">            } catch (IllegalCharsetNameException x) {}
</span></span><span class="line"><span class="cl">            if (se == null)
</span></span><span class="line"><span class="cl">                throw new UnsupportedEncodingException (csn);
</span></span><span class="line"><span class="cl">            set(encoder, se);
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        return se.encode(ca, off, len);
</span></span><span class="line"><span class="cl">    }
</span></span></code></pre></div><h5 id="new-stringbyte-bytes-string-charsetname">new String(byte bytes[], String charsetName)</h5>
<p>该方法为字节数组构造</p>
<p><code>char[]</code>数组是以<code>unicode</code>码来存储的,<code>String</code>和<code>char</code>为内存形式.<code>byte</code>是网络传输或存储的序列化形式.可以通过<code>charset</code>来解码指定的<code>byte</code>数组，将其解码成<code>unicode</code>的<code>char[]</code>数组，构造<code>String</code>.</p>
<p>源码</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">    public String(byte bytes[], String charsetName)
</span></span><span class="line"><span class="cl">            throws UnsupportedEncodingException {
</span></span><span class="line"><span class="cl">        this(bytes, 0, bytes.length, charsetName);
</span></span><span class="line"><span class="cl">    }
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">    public String(byte bytes[], int offset, int length, String charsetName)
</span></span><span class="line"><span class="cl">            throws UnsupportedEncodingException {
</span></span><span class="line"><span class="cl">        if (charsetName == null)
</span></span><span class="line"><span class="cl">            throw new NullPointerException(&#34;charsetName&#34;);
</span></span><span class="line"><span class="cl">        checkBounds(bytes, offset, length);
</span></span><span class="line"><span class="cl">        this.value = StringCoding.decode(charsetName, bytes, offset, length);
</span></span><span class="line"><span class="cl">    }
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">    static char[] decode(String charsetName, byte[] ba, int off, int len)
</span></span><span class="line"><span class="cl">        throws UnsupportedEncodingException
</span></span><span class="line"><span class="cl">    {
</span></span><span class="line"><span class="cl">        StringDecoder sd = deref(decoder);
</span></span><span class="line"><span class="cl">        String csn = (charsetName == null) ? &#34;ISO-8859-1&#34; : charsetName;
</span></span><span class="line"><span class="cl">        if ((sd == null) || !(csn.equals(sd.requestedCharsetName())
</span></span><span class="line"><span class="cl">                              || csn.equals(sd.charsetName()))) {
</span></span><span class="line"><span class="cl">            sd = null;
</span></span><span class="line"><span class="cl">            try {
</span></span><span class="line"><span class="cl">                Charset cs = lookupCharset(csn);
</span></span><span class="line"><span class="cl">                if (cs != null)
</span></span><span class="line"><span class="cl">                    sd = new StringDecoder(cs, csn);
</span></span><span class="line"><span class="cl">            } catch (IllegalCharsetNameException x) {}
</span></span><span class="line"><span class="cl">            if (sd == null)
</span></span><span class="line"><span class="cl">                throw new UnsupportedEncodingException(csn);
</span></span><span class="line"><span class="cl">            set(decoder, sd);
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        return sd.decode(ba, off, len);
</span></span><span class="line"><span class="cl">    }
</span></span></code></pre></div></div>
                    <div id="post_footer" class="post_footer">
                        <div class="meta">
                            <div id="post_footer_info" class="info">
                                <span class="field tags">
                                    <i class="ri-stack-line"></i>
                                    
                                        
                                        <a href="https://whiteppure.github.io/iblog/tags/java/">Java</a>
                                        
                                        <a href="https://whiteppure.github.io/iblog/tags/java%E5%9F%BA%E7%A1%80/">Java基础</a>
                                        
                                    
                                    
                                      <span id="busuanzi_container_page_pv">
                                          阅读量<span id="busuanzi_value_page_pv"></span>次
                                      </span>
                                    
                                </span>
                            </div>
                        </div>
                    </div>
                </div>
                
                
                
<div id="doc_comments" class="doc_comments">
    <div class="comments_block_title">发表评论</div>
    <div id="vcomments"></div>
</div>

<link rel="stylesheet" href="https://whiteppure.github.io/iblog/css/comments.css" />

<script src='//unpkg.com/valine/dist/Valine.min.js'></script>

<script type="text/javascript">
    new Valine({
        el: '#vcomments',
        appId: 'pRSrjsfbN6L1DUxgfqJWOMYP-gzGzoHsz',
        appKey: 'VPWpnDPGDM8Xhdlh5OvHOpak',
        placeholder: '说点什么吧...',
        visitor: 'true',
        
        emojiCDN: '//i0.hdslb.com/bfs/emote/',
        
        emojiMaps: {
            "tv_doge": "6ea59c827c414b4a2955fe79e0f6fd3dcd515e24.png",
            "tv_亲亲": "a8111ad55953ef5e3be3327ef94eb4a39d535d06.png",
            "tv_偷笑": "bb690d4107620f1c15cff29509db529a73aee261.png",
            "tv_再见": "180129b8ea851044ce71caf55cc8ce44bd4a4fc8.png",
            "tv_冷漠": "b9cbc755c2b3ee43be07ca13de84e5b699a3f101.png",
            "tv_发怒": "34ba3cd204d5b05fec70ce08fa9fa0dd612409ff.png",
            "tv_发财": "34db290afd2963723c6eb3c4560667db7253a21a.png",
            "tv_可爱": "9e55fd9b500ac4b96613539f1ce2f9499e314ed9.png",
            "tv_吐血": "09dd16a7aa59b77baa1155d47484409624470c77.png",
            "tv_呆": "fe1179ebaa191569b0d31cecafe7a2cd1c951c9d.png",
            "tv_呕吐": "9f996894a39e282ccf5e66856af49483f81870f3.png",
            "tv_困": "241ee304e44c0af029adceb294399391e4737ef2.png",
            "tv_坏笑": "1f0b87f731a671079842116e0991c91c2c88645a.png",
            "tv_大佬": "093c1e2c490161aca397afc45573c877cdead616.png",
            "tv_大哭": "23269aeb35f99daee28dda129676f6e9ea87934f.png",
            "tv_委屈": "d04dba7b5465779e9755d2ab6f0a897b9b33bb77.png",
            "tv_害羞": "a37683fb5642fa3ddfc7f4e5525fd13e42a2bdb1.png",
            "tv_尴尬": "7cfa62dafc59798a3d3fb262d421eeeff166cfa4.png",
            "tv_微笑": "70dc5c7b56f93eb61bddba11e28fb1d18fddcd4c.png",
            "tv_思考": "90cf159733e558137ed20aa04d09964436f618a1.png",
            "tv_惊吓": "0d15c7e2ee58e935adc6a7193ee042388adc22af.png",
            "tv_打脸": "56ab10b624063e966bfcb76ea5dc4794d87dfd47.png",
            "tv_抓狂": "fe31c08edad661d63762b04e17b8d5ae3c71a757.png",
            "tv_抠鼻": "c666f55e88d471e51bbd9fab9bb308110824a6eb.png",
            "tv_斜眼笑": "911f987aa8bc1bee12d52aafe62bc41ef4474e6c.png",
            "tv_无奈": "ea8ed89ee9878f2fece2dda0ea8a5dbfe21b5751.png",
            "tv_晕": "5443c22b4d07fb1907ccc610c8e6db254f2461b7.png",
            "tv_流汗": "cead1c351ab8d79e9f369605beb90148db0fbed3.png",
            "tv_流泪": "7e71cde7858f0cd50d74b0264aa26db612a8a167.png",
            "tv_流鼻血": "c32d39db2737f89b904ca32700d140a9241b0767.png",
            "tv_点赞": "f85c354995bd99e28fc76c869bfe42ba6438eff4.png",
            "tv_生气": "26702dcafdab5e8225b43ffd23c94ac1ff932654.png",
            "tv_生病": "8b0ec90e6b86771092a498c54f09fc94621c1900.png",
            "tv_疑问": "0793d949b18d7be716078349c202c15ff166f314.png",
            "tv_白眼": "c1d59f439e379ee50eef488bcb5e5378e5044ea4.png",
            "tv_皱眉": "72ccad6679fea0d14cce648b4d818e09b8ffea2d.png",
            "tv_目瞪口呆": "0b8cb81a68de5d5365212c99375e7ace3e7891b7.png",
            "tv_睡着": "8b196675b53af58264f383c50ad0945048290b33.png",
            "tv_笑哭": "1abc628f6d4f4caf9d0e7800878f4697abbc8273.png",
            "tv_腼腆": "89712c0d4af73e67f89e35cbc518420380a7f6f4.png",
            "tv_色": "61822c7e9aae5da76475e7892534545336b23a6f.png",
            "tv_调侃": "4bc022533ef31544ca0d72c12c808cf4a1cce3e3.png",
            "tv_调皮": "b9c41de8e82dd7a8515ae5e3cb63e898bf245186.png",
            "tv_鄙视": "6e72339f346a692a495b123174b49e4e8e781303.png",
            "tv_闭嘴": "c9e990da7f6e93975e25fd8b70e2e290aa4086ef.png",
            "tv_难过": "87f46748d3f142ebc6586ff58860d0e2fc8263ba.png",
            "tv_馋": "fc7e829b845c43c623c8b490ee3602b7f0e76a31.png",
            "tv_鬼脸": "0ffbbddf8a94d124ca2f54b360bbc04feb6bbfea.png",
            "tv_黑人问号": "45821a01f51bc867da9edbaa2e070410819a95b2.png",
            "tv_鼓掌": "1d21793f96ef4e6f48b23e53e3b9e42da833a0f6.png"
        }
    })
</script>

                
            </div>
        </div>
    </div>
    
<a id="search-btn" style="display: inline-block;" href="javascript:void(0);">
    <span class="ri-search-line"></span>
</a>
<div id="fastSearch">
    <input id="searchInput" tabindex="0" autocomplete="off">
    <ul id="searchResults"></ul>
</div>
<div class="side_nav">
    
    <a id="top_to_back" href="#" class="top_to_back">
        <svg t="1688614744062" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2152" width="16" height="16"><path d="M966.4 323.2c-9.6-9.6-25.6-9.6-35.2 0l-416 416-425.6-416c-9.6-9.6-25.6-9.6-35.2 0-9.6 9.6-9.6 25.6 0 35.2l441.6 432c9.6 9.6 25.6 9.6 35.2 0l435.2-432C976 345.6 976 332.8 966.4 323.2z" p-id="2153" fill="#424242"></path></svg>    </a>
    
    <div>
        <a id="content_display" class="content_display">
            <svg t="1688606941910" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="57753" width="18" height="18"><path d="M192 448c10.9 0 21.8-4.2 30.2-12.5L497 160.8c5.4-5.4 11.8-6.2 15.1-6.2 3.3 0 9.6 0.8 15.1 6.2l274.7 274.7c16.7 16.7 43.7 16.7 60.3 0 16.7-16.7 16.7-43.7 0-60.3L587.4 100.4c-41.6-41.6-109.3-41.6-150.9 0L161.8 375.2c-16.7 16.7-16.7 43.7 0 60.3 8.4 8.3 19.3 12.5 30.2 12.5zM801.8 588.5L527.1 863.2c-5.4 5.4-11.8 6.2-15.1 6.2-3.3 0-9.7-0.8-15.1-6.2L222.2 588.5c-16.7-16.7-43.7-16.7-60.3 0-16.7 16.7-16.7 43.7 0 60.3l274.8 274.8c20.8 20.8 48.1 31.2 75.4 31.2 27.3 0 54.6-10.4 75.4-31.2l274.7-274.8c16.7-16.7 16.7-43.7 0-60.3-16.7-16.7-43.7-16.7-60.4 0z" fill="#424242" p-id="57754"></path></svg>
        </a>
        <a id="content_hidden" class="content_hidden">
            <svg t="1688603143752" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="15592" width="18" height="18"><path d="M479.004101 645.938677L165.25229 958.480465a37.510709 37.510709 0 0 0 0 54.059551 36.47863 36.47863 0 0 0 53.063061 0l293.679668-292.576411 293.715256 292.576411a36.443042 36.443042 0 0 0 53.063061 0 37.510709 37.510709 0 0 0 0-54.059551l-313.751811-312.541788c-21.210989-22.349834-36.514219-24.698702-66.017424 0z m66.053013-267.877709l312.577377-312.541789a37.510709 37.510709 0 0 0 0-54.059551 36.443042 36.443042 0 0 0-53.063061 0l-292.505234 292.576411L219.560963 11.459628a36.47863 36.47863 0 0 0-53.063061 0 37.510709 37.510709 0 0 0 0 54.059551l312.577377 312.541789a46.58588 46.58588 0 0 0 65.981835-0.035589z" p-id="15593" fill="#424242"></path></svg>
        </a>
    </div>
    
    <a id="back_to_top" href="#" class="back_to_top">
        <svg t="1688628374733" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3166" width="16" height="16"><path d="M966.4 668.8l-435.2-432c-9.6-9.6-25.6-9.6-35.2 0l-441.6 432c-9.6 9.6-9.6 25.6 0 35.2 9.6 9.6 25.6 9.6 35.2 0l425.6-416 416 416c9.6 9.6 25.6 9.6 35.2 0S976 678.4 966.4 668.8z" p-id="3167" fill="#424242"></path></svg>
    </a>
</div>
    <footer class="footer">
    <div id="footer_powered_by" class="powered_by">
        <a href="https://varkai.com">Designed by VarKai,</a>
        <a href="http://www.gohugo.io/">Proudly published with Hugo</a>
    </div>

    <div id="footer_slogan" class="footer_slogan">
        <span>from 2021</span>
    </div>
</footer>
    <script src="https://whiteppure.github.io/iblog/js/jquery-3.5.1.min.js"></script>
<link href="https://whiteppure.github.io/iblog/css/fancybox.min.css" rel="stylesheet">
<script src="https://whiteppure.github.io/iblog/js/fancybox.min.js"></script>
<script src="https://whiteppure.github.io/iblog/js/darkmode.js"></script>
<script src="https://whiteppure.github.io/iblog/js/zozo.js"></script>
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="https://whiteppure.github.io/iblog/js/busuanzi_2.3_busuanzi.pure.mini.js"></script>
<script src="https://whiteppure.github.io/iblog/js/html2canvas.js"></script>
<script src="https://whiteppure.github.io/iblog/js/utils.js"></script>
<script src="https://whiteppure.github.io/iblog/js/html2md.js"></script>
<script src="https://whiteppure.github.io/iblog/js/htmlexport.js"></script>

<script src="https://whiteppure.github.io/iblog/js/fastsearch.js"></script>
<script src="https://whiteppure.github.io/iblog/js/fuse.js"></script>
































</body>

</html>