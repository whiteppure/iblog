<!DOCTYPE html>
<html lang="zh" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="whitepure" />
	
	
	
	<title>数据结构与算法 ｜ 泊客</title>
	
    
    
    <meta name="description" content="数据结构 数据结构是一门研究组织数据方式的学科，有了编程语言也就有了数据结构，学好数据结构可以编写出更有效率的代码。数据结构是算法的基础，想要学好算法，就必须把数" />
    

    
    
    <meta name="keywords" content="whitepure博客, whiteppure, whitepure" />
    

	
    
    <link rel="shortcut icon" href="https://whiteppure.github.io/iblog/images/favicon.ico" />

    <link rel="stylesheet" type="text/css" media="screen" href="https://whiteppure.github.io/iblog/css/normalize.css" />
    <link rel="stylesheet" type="text/css" media="screen" href="https://cdn.jsdelivr.net/npm/animate.css@4.1.0/animate.min.css" />
    <link rel="stylesheet" type="text/css" media="screen" href="https://whiteppure.github.io/iblog/css/zozo.css" />
	<link rel="stylesheet" type="text/css" media="screen" href="https://cdn.jsdelivr.net/npm/remixicon@2.5.0/fonts/remixicon.css" />
    <link rel="stylesheet" type="text/css" media="screen" href="https://whiteppure.github.io/iblog/css/highlight.css" />

    <link rel="stylesheet" type="text/css" media="screen" href="https://whiteppure.github.io/iblog/css/toc.css" />

    
    
</head>

<body>
    
    
    









<div class="toc">

    <div class="page-header"><strong>- CATALOG -</strong></div>

    <div id="page-scrollspy" class="toc-nav">

        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84">
                    数据结构
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e7%a8%80%e7%96%8f%e6%95%b0%e7%bb%84">
                    稀疏数组
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e9%98%9f%e5%88%97">
                    队列
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e9%93%be%e8%a1%a8">
                    链表
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e5%8d%95%e5%90%91%e9%93%be%e8%a1%a8">
                    单向链表
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e5%8f%8c%e5%90%91%e9%93%be%e8%a1%a8">
                    双向链表
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e7%ba%a6%e7%91%9f%e5%a4%ab%e9%97%ae%e9%a2%98">
                    约瑟夫问题
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e6%a0%88">
                    栈
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e6%a0%88%e5%ae%9e%e7%8e%b0%e4%b8%ad%e7%bc%80%e8%a1%a8%e8%be%be%e5%bc%8f">
                    栈实现中缀表达式
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e6%a0%88%e5%ae%9e%e7%8e%b0%e5%90%8e%e7%bc%80%e8%a1%a8%e8%be%be%e5%bc%8f">
                    栈实现后缀表达式
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e4%b8%ad%e7%bc%80%e8%a1%a8%e8%be%be%e5%bc%8f%e8%bd%ac%e5%90%8e%e7%bc%80%e8%a1%a8%e8%be%be%e5%bc%8f">
                    中缀表达式转后缀表达式
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e5%93%88%e5%b8%8c%e8%a1%a8">
                    哈希表
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e4%ba%8c%e5%8f%89%e6%a0%91">
                    二叉树
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e4%ba%8c%e5%8f%89%e6%a0%91%e7%9a%84%e9%81%8d%e5%8e%86%e5%8f%8a%e6%9f%a5%e6%89%be">
                    二叉树的遍历及查找
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e4%ba%8c%e5%8f%89%e6%a0%91%e7%9a%84%e5%88%a0%e9%99%a4">
                    二叉树的删除
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e9%a1%ba%e5%ba%8f%e5%ad%98%e5%82%a8%e4%ba%8c%e5%8f%89%e6%a0%91">
                    顺序存储二叉树
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e7%ba%bf%e7%b4%a2%e5%8c%96%e4%ba%8c%e5%8f%89%e6%a0%91">
                    线索化二叉树
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e5%93%88%e5%a4%ab%e6%9b%bc%e6%a0%91">
                    哈夫曼树
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e4%ba%8c%e5%8f%89%e6%8e%92%e5%ba%8f%e6%a0%91">
                    二叉排序树
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e5%b9%b3%e8%a1%a1%e4%ba%8c%e5%8f%89%e6%a0%91">
                    平衡二叉树
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e5%a4%9a%e8%b7%af%e6%9f%a5%e6%89%be%e6%a0%91">
                    多路查找树
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#2-3%e6%a0%91">
                    2-3树
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#b%e6%a0%91">
                    B树
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#b%e6%a0%91-1">
                    B&#43;树
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#b%e6%a0%91-2">
                    B*树
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e5%9b%be">
                    图
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e7%ae%97%e6%b3%95">
                    算法
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e7%ae%97%e6%b3%95%e5%a4%8d%e6%9d%82%e5%ba%a6">
                    算法复杂度
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e6%97%b6%e9%97%b4%e5%a4%8d%e6%9d%82%e5%ba%a6">
                    时间复杂度
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e7%a9%ba%e9%97%b4%e5%a4%8d%e6%9d%82%e5%ba%a6">
                    空间复杂度
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e9%80%92%e5%bd%92">
                    递归
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e8%bf%b7%e5%ae%ab%e5%9b%9e%e6%ba%af">
                    迷宫回溯
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e5%85%ab%e7%9a%87%e5%90%8e%e9%97%ae%e9%a2%98">
                    八皇后问题
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e6%8e%92%e5%ba%8f%e7%ae%97%e6%b3%95">
                    排序算法
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e5%86%92%e6%b3%a1%e6%8e%92%e5%ba%8f">
                    冒泡排序
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e9%80%89%e6%8b%a9%e6%8e%92%e5%ba%8f">
                    选择排序
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e6%8f%92%e5%85%a5%e6%8e%92%e5%ba%8f">
                    插入排序
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e5%b8%8c%e5%b0%94%e6%8e%92%e5%ba%8f">
                    希尔排序
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e5%bf%ab%e9%80%9f%e6%8e%92%e5%ba%8f">
                    快速排序
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e5%bd%92%e5%b9%b6%e6%8e%92%e5%ba%8f">
                    归并排序
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e5%9f%ba%e6%95%b0%e6%8e%92%e5%ba%8f">
                    基数排序
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e5%a0%86%e6%8e%92%e5%ba%8f">
                    堆排序
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e6%9f%a5%e6%89%be%e7%ae%97%e6%b3%95">
                    查找算法
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e7%ba%bf%e6%80%a7%e6%9f%a5%e6%89%be">
                    线性查找
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e4%ba%8c%e5%88%86%e6%9f%a5%e6%89%be">
                    二分查找
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e6%8f%92%e5%80%bc%e6%9f%a5%e6%89%be">
                    插值查找
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e6%96%90%e6%b3%a2%e9%82%a3%e5%a5%91%e6%9f%a5%e6%89%be">
                    斐波那契查找
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e5%93%88%e5%a4%ab%e6%9b%bc%e7%bc%96%e7%a0%81">
                    哈夫曼编码
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e5%88%86%e6%b2%bb%e7%ae%97%e6%b3%95">
                    分治算法
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92%e7%ae%97%e6%b3%95">
                    动态规划算法
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#kmp%e7%ae%97%e6%b3%95">
                    KMP算法
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e8%b4%aa%e5%bf%83%e7%ae%97%e6%b3%95">
                    贪心算法
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e6%99%ae%e9%87%8c%e5%a7%86%e7%ae%97%e6%b3%95">
                    普里姆算法
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e5%85%8b%e9%b2%81%e6%96%af%e5%8d%a1%e5%b0%94%e7%ae%97%e6%b3%95">
                    克鲁斯卡尔算法
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e8%bf%aa%e6%9d%b0%e6%96%af%e7%89%b9%e6%8b%89%e7%ae%97%e6%b3%95">
                    迪杰斯特拉算法
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e5%bc%97%e6%b4%9b%e4%bc%8a%e5%be%b7%e7%ae%97%e6%b3%95">
                    弗洛伊德算法
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e9%a9%ac%e8%b8%8f%e6%a3%8b%e7%9b%98%e7%ae%97%e6%b3%95">
                    马踏棋盘算法
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        

    </div>

</div>



    
    <div class="main animate__animated animate__fadeInDown" id="pdf_content">
        <div class="nav_container animated fadeInDown">
    <div class="site_nav" id="site_nav">
        <ul><li class="">
                <a href="https://whiteppure.github.io/iblog/">首页</a>
            </li><li class="">
                <a href="https://whiteppure.github.io/iblog/posts/">归档</a>
            </li><li class="">
                <a href="https://whiteppure.github.io/iblog/tags/">标签</a>
            </li><li class="">
                <a href="https://whiteppure.github.io/iblog/about/">关于</a>
            </li>
        </ul>
    </div>
    <div class="menu_icon">
        <a id="menu_icon"><i class="ri-menu-line"></i></a>
    </div>
</div>
        <div class="header animated fadeInDown">
    <div class="site_title_container">
        <div class="site_title">
            <h1>
                <a href="https://whiteppure.github.io/iblog/">
                    <span>泊客</span>
                </a>
            </h1>
        </div>
        <div class="description">
            <p class="sub_title">
                大道至简
            </p>
            <div class="my_socials">
                
                
                <a href="https://github.com/whiteppure/" title="github" target="_blank">
                    <i class="ri-github-fill"></i>
                </a>
                
                
                <a href="https://whiteppure.github.io/iblog/index.xml" type="application/rss+xml" title="rss" target="_blank">
                    <i class="ri-rss-fill"></i>
                </a>
                



            </div>
            
            <div class="post">
                <div class="post_title post_detail_title">
                    <span class="date" id="busuanzi_container_site_pv">访问量 <span id="busuanzi_value_site_pv"></span>次</span>
                </div>
                <div class="post_title post_detail_title">
                    <span class="date" id="busuanzi_container_site_uv">访客数 <span id="busuanzi_value_site_uv"></span>人</span>
                </div>
            </div>
            
        </div>
    </div>
</div>
        <div class="content">
            <div class="post_page">
                <div class="post animate__animated animate__fadeInDown">
                    <div class="post_title post_detail_title">
                        <h2><a href='/iblog/posts/essays/data-structures-algorithms/'>数据结构与算法</a></h2>
                        <span class="date">2021.12.10</span>
                    </div>
                    <div class="post_content markdown"><h2 id="数据结构">数据结构</h2>
<p>数据结构是一门研究组织数据方式的学科，有了编程语言也就有了数据结构，学好数据结构可以编写出更有效率的代码。数据结构是算法的基础，想要学好算法，就必须把数据结构学到位。</p>
<p>数据结构包括：线性结构、非线性结构。</p>
<p>线性结构作为最常用的数据结构，其特点是数据元素之间存在一对一的线性存储关系。线性结构有两种不同的存储结构，即顺序存储和链式存储。顺序存储的线性表被称为顺序表，顺序表中存储元素的地址是连续的；链式存储的线性表被称为链表，链表中存储元素的地址不一定是连续的，元素结点中存放数据元素以及相邻元素地址信息。</p>
<p>常见的线性结构有：数组、链表、队列、栈；常见非线性结构有：多维数组、广义表、树结构、图结构。</p>
<h3 id="稀疏数组">稀疏数组</h3>
<p>使用稀疏数组可以用来压缩数据。稀疏数组的第一行依次记录原数组一共有几行几列，有多少个不为零的值，之后的每行记录原数组中不为零的值所在的行数、列数以及数组中元素该值。如图所示：</p>
<p><img src="/iblog/posts/annex/images/essays/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-001.png" alt="数据结构与算法-001"></p>
<p>二维数组转稀疏数组</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">TwoDimensionArrayDemo</span> <span class="o">{</span>
  <span class="c1">// 将二维数组转换为稀疏数组
</span><span class="c1"></span>  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span><span class="o">[][]</span> <span class="nf">twoDimensionArrayToSparseArray</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">array</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 记录棋盘中有效值的数量
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">row</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">column</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">ints</span> <span class="o">:</span> <span class="n">array</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">column</span> <span class="o">=</span> <span class="n">ints</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
      <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">item</span> <span class="o">:</span> <span class="n">ints</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">item</span> <span class="o">!=</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span>
          <span class="n">sum</span><span class="o">++;</span>
        <span class="o">}</span>
      <span class="o">}</span>
    <span class="o">}</span>

    <span class="c1">// 创建稀疏数组
</span><span class="c1"></span>    <span class="kt">int</span><span class="o">[][]</span> <span class="n">sparseArray</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">sum</span> <span class="o">+</span> <span class="n">1</span><span class="o">][</span><span class="n">3</span><span class="o">];</span>
    <span class="n">sparseArray</span><span class="o">[</span><span class="n">0</span><span class="o">][</span><span class="n">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">row</span><span class="o">;</span>
    <span class="n">sparseArray</span><span class="o">[</span><span class="n">0</span><span class="o">][</span><span class="n">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">column</span><span class="o">;</span>
    <span class="n">sparseArray</span><span class="o">[</span><span class="n">0</span><span class="o">][</span><span class="n">2</span><span class="o">]</span> <span class="o">=</span> <span class="n">sum</span><span class="o">;</span>

    <span class="c1">// 给稀疏数组赋值
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">array</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
      <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">array</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">length</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">array</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">!=</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span>
          <span class="n">count</span><span class="o">++;</span>
          <span class="n">sparseArray</span><span class="o">[</span><span class="n">count</span><span class="o">][</span><span class="n">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
          <span class="n">sparseArray</span><span class="o">[</span><span class="n">count</span><span class="o">][</span><span class="n">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">j</span><span class="o">;</span>
          <span class="n">sparseArray</span><span class="o">[</span><span class="n">count</span><span class="o">][</span><span class="n">2</span><span class="o">]</span> <span class="o">=</span> <span class="n">array</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">];</span>
        <span class="o">}</span>
      <span class="o">}</span>
    <span class="o">}</span>

    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;稀疏数组====》&#34;</span><span class="o">);</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">sparseArray</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
      <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">printf</span><span class="o">(</span><span class="s">&#34;%d\t%d\t%d\t\n&#34;</span><span class="o">,</span> <span class="n">sparseArray</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">0</span><span class="o">],</span> <span class="n">sparseArray</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">1</span><span class="o">],</span> <span class="n">sparseArray</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">2</span><span class="o">]);</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">sparseArray</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>稀疏数组转二维数组</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">TwoDimensionArrayDemo</span> <span class="o">{</span>
  <span class="c1">// 稀疏数组转二维数组
</span><span class="c1"></span>  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span><span class="o">[][]</span> <span class="nf">sparseArrayToTwoDimensionArray</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">sparseArray</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span><span class="o">[][]</span> <span class="n">toTwoDimensionArray</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">sparseArray</span><span class="o">[</span><span class="n">0</span><span class="o">][</span><span class="n">0</span><span class="o">]][</span><span class="n">sparseArray</span><span class="o">[</span><span class="n">0</span><span class="o">][</span><span class="n">1</span><span class="o">]];</span>
    <span class="c1">// 给二维数组赋值
</span><span class="c1"></span>    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">sparseArray</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
      <span class="n">toTwoDimensionArray</span><span class="o">[</span><span class="n">sparseArray</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">0</span><span class="o">]][</span><span class="n">sparseArray</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">1</span><span class="o">]]</span> <span class="o">=</span> <span class="n">sparseArray</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">2</span><span class="o">];</span>
    <span class="o">}</span>

    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;二维数组====》&#34;</span><span class="o">);</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">row</span> <span class="o">:</span> <span class="n">toTwoDimensionArray</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">data</span> <span class="o">:</span> <span class="n">row</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">printf</span><span class="o">(</span><span class="s">&#34;%d\t&#34;</span><span class="o">,</span> <span class="n">data</span><span class="o">);</span>
      <span class="o">}</span>
      <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">toTwoDimensionArray</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><h3 id="队列">队列</h3>
<p>队列是一个有序列表，可以使用数组或链表来实现。队列遵循先入先出的原则。即，先存入队列的数据，要先取出。后存入的要后取出。</p>
<p>使用数组模拟队列示意图：</p>
<p><img src="/iblog/posts/annex/images/essays/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-002.png" alt="数据结构与算法-002"></p>
<p>数组模拟单向队列</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java">    <span class="kd">public</span> <span class="kd">class</span> <span class="nc">ArrayQueue</span><span class="o">{</span>

        <span class="c1">// 队列容量
</span><span class="c1"></span>        <span class="kd">private</span> <span class="kt">int</span> <span class="n">capacity</span><span class="o">;</span>

        <span class="c1">// 保存队列中的数据
</span><span class="c1"></span>        <span class="kd">private</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span><span class="o">;</span>

        <span class="c1">// 头部指针
</span><span class="c1"></span>        <span class="kd">private</span> <span class="kt">int</span> <span class="n">front</span><span class="o">;</span>

        <span class="c1">// 尾部指针
</span><span class="c1"></span>        <span class="kd">private</span> <span class="kt">int</span> <span class="n">rear</span><span class="o">;</span>

        <span class="kd">public</span> <span class="nf">ArrayQueue</span><span class="o">(</span><span class="kt">int</span> <span class="n">capacity</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">this</span><span class="o">.</span><span class="na">capacity</span> <span class="o">=</span> <span class="n">capacity</span><span class="o">;</span>
            <span class="n">arr</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">capacity</span><span class="o">];</span>
            <span class="n">front</span> <span class="o">=</span> <span class="o">-</span><span class="n">1</span><span class="o">;</span>
            <span class="n">rear</span> <span class="o">=</span> <span class="o">-</span><span class="n">1</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isEmpty</span><span class="o">()</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">front</span> <span class="o">==</span> <span class="n">rear</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isFull</span><span class="o">()</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">capacity</span> <span class="o">-</span> <span class="n">1</span> <span class="o">==</span> <span class="n">rear</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">add</span><span class="o">(</span><span class="kt">int</span> <span class="n">data</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">isFull</span><span class="o">())</span> <span class="o">{</span>
                <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;队列已经满了，不能在继续添加&#34;</span><span class="o">);</span>
                <span class="k">return</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="n">arr</span><span class="o">[++</span><span class="n">rear</span><span class="o">]</span> <span class="o">=</span> <span class="n">data</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="kd">public</span> <span class="kt">int</span> <span class="nf">get</span><span class="o">()</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">isEmpty</span><span class="o">())</span> <span class="o">{</span>
                <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;队列为空，不能获取元素&#34;</span><span class="o">);</span>
                <span class="k">return</span> <span class="o">-</span><span class="n">1</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="k">return</span> <span class="n">arr</span><span class="o">[++</span><span class="n">front</span><span class="o">];</span>
        <span class="o">}</span>

        <span class="c1">// 显示队列的所有数据
</span><span class="c1"></span>        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">show</span><span class="o">()</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">isEmpty</span><span class="o">())</span> <span class="o">{</span>
                <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;队列空的，没有数据~~&#34;</span><span class="o">);</span>
                <span class="k">return</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;开始遍历队列：&#34;</span><span class="o">);</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">front</span> <span class="o">+</span> <span class="n">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">rear</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">printf</span><span class="o">(</span><span class="s">&#34;arr[%d]=%d\n&#34;</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span> <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
            <span class="o">}</span>
        <span class="o">}</span>


        <span class="c1">// 显示队列的头数据， 注意不是取出数据
</span><span class="c1"></span>        <span class="kd">public</span> <span class="kt">int</span> <span class="nf">peek</span><span class="o">()</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">isEmpty</span><span class="o">())</span> <span class="o">{</span>
                <span class="k">throw</span> <span class="k">new</span> <span class="n">RuntimeException</span><span class="o">(</span><span class="s">&#34;队列空的，没有数据~~&#34;</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="k">return</span> <span class="n">arr</span><span class="o">[</span><span class="n">front</span> <span class="o">+</span> <span class="n">1</span><span class="o">];</span>
        <span class="o">}</span>

    <span class="o">}</span>
</code></pre></div><p>数组模拟环形队列</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java">    <span class="kd">public</span>  <span class="kd">class</span> <span class="nc">CircleArrayQueue</span><span class="o">{</span>

        <span class="c1">// 队列容量
</span><span class="c1"></span>        <span class="kd">private</span> <span class="kt">int</span> <span class="n">capacity</span><span class="o">;</span>

        <span class="c1">// 保存队列中的数据
</span><span class="c1"></span>        <span class="kd">private</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span><span class="o">;</span>

        <span class="c1">// 头部指针
</span><span class="c1"></span>        <span class="kd">private</span> <span class="kt">int</span> <span class="n">front</span><span class="o">;</span>

        <span class="c1">// 尾部指针
</span><span class="c1"></span>        <span class="kd">private</span> <span class="kt">int</span> <span class="n">rear</span><span class="o">;</span>

        <span class="kd">public</span> <span class="nf">CircleArrayQueue</span><span class="o">(</span><span class="kt">int</span> <span class="n">capacity</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">this</span><span class="o">.</span><span class="na">capacity</span> <span class="o">=</span> <span class="n">capacity</span><span class="o">;</span>
            <span class="n">arr</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">capacity</span><span class="o">];</span>
        <span class="o">}</span>

        <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isEmpty</span><span class="o">()</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">front</span> <span class="o">==</span> <span class="n">rear</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isFull</span><span class="o">()</span> <span class="o">{</span>
            <span class="c1">// 此处+1 是因为存储元素从0算起
</span><span class="c1"></span>            <span class="k">return</span> <span class="o">(</span><span class="n">rear</span> <span class="o">+</span> <span class="n">1</span><span class="o">)</span> <span class="o">%</span> <span class="n">capacity</span>  <span class="o">==</span> <span class="n">front</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">add</span><span class="o">(</span><span class="kt">int</span> <span class="n">data</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">isFull</span><span class="o">())</span> <span class="o">{</span>
                <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;队列已经满了，不能在继续添加&#34;</span><span class="o">);</span>
                <span class="k">return</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="n">arr</span><span class="o">[</span><span class="n">rear</span><span class="o">]</span> <span class="o">=</span> <span class="n">data</span><span class="o">;</span>
            <span class="n">rear</span> <span class="o">=</span> <span class="o">(</span><span class="n">rear</span> <span class="o">+</span> <span class="n">1</span><span class="o">)</span> <span class="o">%</span> <span class="n">capacity</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="kd">public</span> <span class="kt">int</span> <span class="nf">get</span><span class="o">()</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">isEmpty</span><span class="o">())</span> <span class="o">{</span>
                <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;队列为空，不能获取元素&#34;</span><span class="o">);</span>
                <span class="k">return</span> <span class="o">-</span><span class="n">1</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="kt">int</span> <span class="n">value</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="n">front</span><span class="o">];</span>
            <span class="n">front</span> <span class="o">=</span> <span class="o">(</span><span class="n">front</span> <span class="o">+</span> <span class="n">1</span><span class="o">)</span> <span class="o">%</span> <span class="n">capacity</span><span class="o">;</span>
            <span class="k">return</span> <span class="n">value</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// 显示队列的所有数据
</span><span class="c1"></span>        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">show</span><span class="o">()</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">isEmpty</span><span class="o">())</span> <span class="o">{</span>
                <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;队列空的，没有数据~~&#34;</span><span class="o">);</span>
                <span class="k">return</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;开始遍历队列：&#34;</span><span class="o">);</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">front</span> <span class="o">%</span> <span class="n">capacity</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">front</span> <span class="o">+</span> <span class="o">((</span><span class="n">rear</span> <span class="o">+</span> <span class="n">capacity</span> <span class="o">-</span> <span class="n">front</span><span class="o">)</span> <span class="o">%</span> <span class="n">capacity</span><span class="o">);</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">printf</span><span class="o">(</span><span class="s">&#34;arr[%d]=%d\n&#34;</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span> <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// 显示队列的头数据， 注意不是取出数据
</span><span class="c1"></span>        <span class="kd">public</span> <span class="kt">int</span> <span class="nf">peek</span><span class="o">()</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">isEmpty</span><span class="o">())</span> <span class="o">{</span>
                <span class="k">throw</span> <span class="k">new</span> <span class="n">RuntimeException</span><span class="o">(</span><span class="s">&#34;队列空的，没有数据~~&#34;</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="k">return</span> <span class="n">arr</span><span class="o">[</span><span class="n">front</span><span class="o">];</span>
        <span class="o">}</span>

    <span class="o">}</span>
</code></pre></div><h3 id="链表">链表</h3>
<p>链表属于线性结构，存储空间不连续。</p>
<p>链表特点：</p>
<ul>
<li>链表是以节点的方式来存储，是链式存储；data 域存放数据，next 域指向下一个节点；</li>
<li>链表分带头节点的链表和没有头节点的链表，根据实际的需求来确定；</li>
</ul>
<p><img src="/iblog/posts/annex/images/essays/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-003.png" alt="数据结构与算法-003"></p>
<h4 id="单向链表">单向链表</h4>
<p>操作单向链表：对于插入、删除操作，只能定位至待操作节点的前一个节点，如果定位至当前节点，那么其上一个节点的信息便会丢失。</p>
<p>单向链表，链表的增、删、查、改</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">SingleLinkedList</span><span class="o">{</span>

    <span class="c1">// 头结点
</span><span class="c1"></span>    <span class="kd">private</span> <span class="n">Node</span> <span class="n">headNode</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="o">(</span><span class="n">0</span><span class="o">,</span><span class="s">&#34;&#34;</span><span class="o">);</span>

    <span class="c1">// 添加方法
</span><span class="c1"></span>    <span class="kd">public</span>  <span class="kt">void</span> <span class="nf">add</span><span class="o">(</span><span class="n">Node</span> <span class="n">node</span><span class="o">){</span>
        <span class="n">Node</span> <span class="n">tmpNode</span> <span class="o">=</span> <span class="n">headNode</span><span class="o">;</span>

        <span class="k">while</span> <span class="o">(</span><span class="n">tmpNode</span><span class="o">.</span><span class="na">next</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
            <span class="c1">// 指向下一个结点
</span><span class="c1"></span>            <span class="n">tmpNode</span> <span class="o">=</span> <span class="n">tmpNode</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">// 退出循环意味着tmpNode.next == null 即找到最后一个结点了
</span><span class="c1"></span>        <span class="n">tmpNode</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">node</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// 顺序添加
</span><span class="c1"></span>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">addByOrder</span><span class="o">(</span><span class="n">Node</span> <span class="n">node</span><span class="o">){</span>
        <span class="kt">boolean</span> <span class="n">flag</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
        <span class="n">Node</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">headNode</span><span class="o">;</span>
        <span class="k">while</span> <span class="o">(</span><span class="kc">true</span><span class="o">){</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">tmp</span><span class="o">.</span><span class="na">next</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="c1">// 将新插入的结点num跟链表中已经存在的num进行比较，如果 &lt; 链表中的结点 则说明找到了该位置
</span><span class="c1"></span>            <span class="k">if</span> <span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">num</span> <span class="o">&lt;</span> <span class="n">tmp</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">num</span><span class="o">){</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="c1">// 如果num相同则不能添加
</span><span class="c1"></span>            <span class="k">if</span> <span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">num</span> <span class="o">==</span> <span class="n">tmp</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">num</span><span class="o">){</span>
                <span class="n">flag</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="k">if</span> <span class="o">(!</span><span class="n">flag</span><span class="o">){</span>
            <span class="n">node</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="n">tmp</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">node</span><span class="o">;</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">printf</span><span class="o">(</span><span class="s">&#34;需要添加的结点编号：%d已经存在了&#34;</span><span class="o">,</span><span class="n">node</span><span class="o">.</span><span class="na">num</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="c1">// 遍历链表
</span><span class="c1"></span>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">list</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">// 遍历除了头结点外的所有结点
</span><span class="c1"></span>        <span class="n">Node</span> <span class="n">tmpNode</span> <span class="o">=</span> <span class="n">headNode</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">tmpNode</span> <span class="o">==</span> <span class="kc">null</span><span class="o">){</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;链表为空！&#34;</span><span class="o">);</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="k">while</span> <span class="o">(</span><span class="n">tmpNode</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">tmpNode</span><span class="o">);</span>
            <span class="c1">// 指向下一个结点
</span><span class="c1"></span>            <span class="n">tmpNode</span> <span class="o">=</span> <span class="n">tmpNode</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>


<span class="o">}</span>


<span class="kd">class</span> <span class="nc">Node</span> <span class="o">{</span>

    <span class="kt">int</span> <span class="n">num</span><span class="o">;</span>
    <span class="n">String</span> <span class="n">name</span><span class="o">;</span>
    <span class="n">Node</span> <span class="n">next</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">Node</span><span class="o">(</span><span class="kt">int</span> <span class="n">num</span><span class="o">,</span><span class="n">String</span> <span class="n">name</span><span class="o">){</span>
        <span class="k">this</span><span class="o">.</span><span class="na">num</span> <span class="o">=</span> <span class="n">num</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="n">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="s">&#34;Node{&#34;</span> <span class="o">+</span>
                <span class="s">&#34;num=&#34;</span> <span class="o">+</span> <span class="n">num</span> <span class="o">+</span>
                <span class="s">&#34;, name=&#39;&#34;</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="sc">&#39;\&#39;&#39;</span> <span class="o">+</span>
                <span class="sc">&#39;}&#39;</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>反转单向链表</p>
<p><img src="/iblog/posts/annex/images/essays/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-004.png" alt="数据结构与算法-004"></p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">LinkedListDemo</span><span class="o">{</span>
    <span class="c1">// 反转链表
</span><span class="c1"></span>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">reserve</span><span class="o">(</span><span class="n">Node</span> <span class="n">head</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">head</span><span class="o">.</span><span class="na">next</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">head</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">next</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span><span class="o">;</span>
      <span class="o">}</span>

      <span class="n">Node</span> <span class="n">reserve</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="o">(</span><span class="n">0</span><span class="o">,</span> <span class="s">&#34;&#34;</span><span class="o">);</span>
      <span class="n">Node</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">head</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
      <span class="n">Node</span> <span class="n">next</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
      <span class="c1">// 遍历链表
</span><span class="c1"></span>      <span class="c1">// 遍历原来的链表，每遍历一个节点，就将其取出，并放在新的链表reverseHead 的最前端
</span><span class="c1"></span>      <span class="k">while</span> <span class="o">(</span><span class="n">cur</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>

        <span class="c1">// 保存当前结点的下一个结点
</span><span class="c1"></span>        <span class="n">next</span> <span class="o">=</span> <span class="n">cur</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>

        <span class="c1">// 将cur的下一个节点指向新的链表的最前端（覆盖掉）保证将最新的结点放到reseve的最前面
</span><span class="c1"></span>        <span class="n">cur</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">reserve</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>

        <span class="c1">// 将cur 连接到新的链表上
</span><span class="c1"></span>        <span class="n">reserve</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">cur</span><span class="o">;</span>

        <span class="c1">// 将之前保存好的结点赋值给当前结点
</span><span class="c1"></span>        <span class="n">cur</span> <span class="o">=</span> <span class="n">next</span><span class="o">;</span>
      <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>利用栈逆序打印单向链表</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">LinkedListDemo</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">reservePrint</span><span class="o">(</span><span class="n">Node</span> <span class="n">head</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">head</span><span class="o">.</span><span class="na">next</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">head</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">next</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">return</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="n">Stack</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span> <span class="n">nodes</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Stack</span><span class="o">&lt;&gt;();</span>
    <span class="n">Node</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">head</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">tmp</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">nodes</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">tmp</span><span class="o">);</span>
      <span class="n">tmp</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// 从stack中取出结点
</span><span class="c1"></span>    <span class="k">while</span> <span class="o">(</span><span class="n">nodes</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">&gt;</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">nodes</span><span class="o">.</span><span class="na">pop</span><span class="o">());</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><h4 id="双向链表">双向链表</h4>
<p>对比单向链表：</p>
<ul>
<li>单向链表，查找的方向只能是一个方向，而双向链表可以向前或者向后查找；</li>
<li>单向链表不能自我删除，需要靠辅助节点，而双向链表，则可以自我删除；</li>
</ul>
<p><img src="/iblog/posts/annex/images/essays/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-005.png" alt="数据结构与算法-005"></p>
<p>双向链表，增、删、改、查</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">DoubleLinkedList</span><span class="o">{</span>

    <span class="c1">// 头结点
</span><span class="c1"></span>    <span class="kd">private</span> <span class="n">Node</span> <span class="n">headNode</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="o">(</span><span class="n">0</span><span class="o">,</span><span class="s">&#34;&#34;</span><span class="o">);</span>


    <span class="kd">public</span> <span class="n">Node</span> <span class="nf">getHeadNode</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">headNode</span><span class="o">;</span>
    <span class="o">}</span>


    <span class="c1">// 添加方法
</span><span class="c1"></span>    <span class="kd">public</span>  <span class="kt">void</span> <span class="nf">add</span><span class="o">(</span><span class="n">Node</span> <span class="n">node</span><span class="o">){</span>
        <span class="n">Node</span> <span class="n">tmpNode</span> <span class="o">=</span> <span class="n">headNode</span><span class="o">;</span>

        <span class="k">while</span> <span class="o">(</span><span class="n">tmpNode</span><span class="o">.</span><span class="na">next</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
            <span class="c1">// 指向下一个结点
</span><span class="c1"></span>            <span class="n">tmpNode</span> <span class="o">=</span> <span class="n">tmpNode</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">// 退出循环意味着tmpNode.next == null 即找到最后一个结点了
</span><span class="c1"></span>        <span class="n">tmpNode</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">node</span><span class="o">;</span>
        <span class="n">node</span><span class="o">.</span><span class="na">prev</span> <span class="o">=</span> <span class="n">tmpNode</span><span class="o">;</span>
    <span class="o">}</span>


    <span class="c1">// 双向链表修改
</span><span class="c1"></span>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">update</span><span class="o">(</span><span class="n">Node</span> <span class="n">node</span><span class="o">){</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">headNode</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="n">Node</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">headNode</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="k">while</span> <span class="o">(</span><span class="kc">true</span><span class="o">){</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">tmp</span> <span class="o">==</span> <span class="kc">null</span><span class="o">){</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">num</span> <span class="o">==</span> <span class="n">tmp</span><span class="o">.</span><span class="na">num</span><span class="o">){</span>
                <span class="n">tmp</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">name</span><span class="o">;</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="c1">// 双向链表删除
</span><span class="c1"></span>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">remove</span><span class="o">(</span><span class="kt">int</span> <span class="n">num</span><span class="o">){</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">headNode</span><span class="o">.</span><span class="na">next</span> <span class="o">==</span> <span class="kc">null</span><span class="o">){</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;链表为空，无法删除！&#34;</span><span class="o">);</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="n">Node</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">headNode</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">tmp</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">num</span> <span class="o">==</span> <span class="n">tmp</span><span class="o">.</span><span class="na">num</span><span class="o">){</span>
                <span class="n">tmp</span><span class="o">.</span><span class="na">prev</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>

                <span class="c1">// 最后一个结点的next 为null null.pre会出现空指针异常
</span><span class="c1"></span>                <span class="k">if</span><span class="o">(</span><span class="n">tmp</span><span class="o">.</span><span class="na">next</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">tmp</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">prev</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">.</span><span class="na">prev</span><span class="o">;</span>
                <span class="o">}</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="c1">// 遍历链表
</span><span class="c1"></span>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">list</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">// 遍历除了头结点外的所有结点
</span><span class="c1"></span>        <span class="n">Node</span> <span class="n">tmpNode</span> <span class="o">=</span> <span class="n">headNode</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">tmpNode</span> <span class="o">==</span> <span class="kc">null</span><span class="o">){</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;链表为空！&#34;</span><span class="o">);</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="k">while</span> <span class="o">(</span><span class="n">tmpNode</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">tmpNode</span><span class="o">);</span>
            <span class="c1">// 指向下一个结点
</span><span class="c1"></span>            <span class="n">tmpNode</span> <span class="o">=</span> <span class="n">tmpNode</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>


<span class="o">}</span>


<span class="kd">class</span> <span class="nc">Node</span> <span class="o">{</span>

    <span class="kt">int</span> <span class="n">num</span><span class="o">;</span>
    <span class="n">String</span> <span class="n">name</span><span class="o">;</span>
    <span class="n">Node</span> <span class="n">next</span><span class="o">;</span>
    <span class="n">Node</span> <span class="n">prev</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">Node</span><span class="o">(</span><span class="kt">int</span> <span class="n">num</span><span class="o">,</span><span class="n">String</span> <span class="n">name</span><span class="o">){</span>
        <span class="k">this</span><span class="o">.</span><span class="na">num</span> <span class="o">=</span> <span class="n">num</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="n">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="s">&#34;Node{&#34;</span> <span class="o">+</span>
                <span class="s">&#34;num=&#34;</span> <span class="o">+</span> <span class="n">num</span> <span class="o">+</span>
                <span class="s">&#34;, name=&#39;&#34;</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="sc">&#39;\&#39;&#39;</span> <span class="o">+</span>
                <span class="sc">&#39;}&#39;</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><h4 id="约瑟夫问题">约瑟夫问题</h4>
<blockquote>
<p>约瑟夫问题为：设编号为 1，2，…n的n个人围坐一圈，约定编号为 k（1&lt;=k&lt;=n） 的人从 1 开始报数,数到 m 的那个人出列，它的下一位又从 1 开始报数，数到 m 的那个人又出列， 依次类推，直到所有人出列为止，由此产生一个出队编号的序列。</p>
</blockquote>
<p>用一个不带头结点的循环链表来处理约瑟夫问题：先构成一个有 n 个结点的单循环链表，然后由 k 结点起从 1 开始计数，计到 m 时，对应结点从链表中删除，然后再从被删除结点的下一个结点又从 1 开始计数，直到最后一个结点从链表中删除算法结束。</p>
<p><img src="/iblog/posts/annex/images/essays/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-006.png" alt="数据结构与算法-006"></p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">JoesphSingletonLinkedList</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="n">Node</span> <span class="n">first</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>


    <span class="c1">// 向单向链表添加数据
</span><span class="c1"></span>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">add</span><span class="o">(</span><span class="kt">int</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">nums</span> <span class="o">&lt;</span> <span class="n">1</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;nums的值不正确&#34;</span><span class="o">);</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="n">Node</span> <span class="n">cur</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">nums</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">Node</span> <span class="n">node</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">1</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">first</span> <span class="o">=</span> <span class="n">node</span><span class="o">;</span>
                <span class="n">first</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">first</span><span class="o">;</span>
                <span class="n">cur</span> <span class="o">=</span> <span class="n">first</span><span class="o">;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="n">cur</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">node</span><span class="o">;</span>
                <span class="n">node</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">first</span><span class="o">;</span>
                <span class="n">cur</span> <span class="o">=</span> <span class="n">node</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>


    <span class="c1">// 遍历单向循环链表
</span><span class="c1"></span>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">list</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">Node</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">first</span><span class="o">;</span>
        <span class="k">while</span> <span class="o">(</span><span class="kc">true</span><span class="o">){</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">printf</span><span class="o">(</span><span class="s">&#34;当前结点为：%d\n&#34;</span><span class="o">,</span><span class="n">tmp</span><span class="o">.</span><span class="na">num</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">tmp</span><span class="o">.</span><span class="na">next</span> <span class="o">==</span> <span class="n">first</span><span class="o">){</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>


    <span class="c1">// 约瑟夫问题
</span><span class="c1"></span>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">joseph</span><span class="o">(</span><span class="kt">int</span> <span class="n">startNum</span><span class="o">,</span><span class="kt">int</span> <span class="n">countNum</span><span class="o">,</span><span class="kt">int</span> <span class="n">sum</span><span class="o">){</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">startNum</span> <span class="o">&gt;</span> <span class="n">sum</span> <span class="o">||</span> <span class="n">startNum</span> <span class="o">&lt;</span> <span class="n">0</span> <span class="o">||</span> <span class="n">countNum</span> <span class="o">&lt;</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;输入的参数不正确！&#34;</span><span class="o">);</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">// 创建辅助指针，将该指针指向 first 的前一个
</span><span class="c1"></span>        <span class="n">Node</span> <span class="n">helper</span> <span class="o">=</span> <span class="n">first</span><span class="o">;</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">helper</span><span class="o">.</span><span class="na">next</span> <span class="o">!=</span> <span class="n">first</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">helper</span> <span class="o">=</span> <span class="n">helper</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// 将first 和 help指针循环 （startNum - 1）次；因为从startNum开始，需要减一
</span><span class="c1"></span>        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">startNum</span> <span class="o">-</span> <span class="n">1</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">first</span> <span class="o">=</span> <span class="n">first</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="n">helper</span> <span class="o">=</span> <span class="n">helper</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="k">while</span> <span class="o">(</span><span class="kc">true</span><span class="o">){</span>
            <span class="c1">// 当环形链表中只存在一个结点
</span><span class="c1"></span>            <span class="k">if</span> <span class="o">(</span><span class="n">first</span> <span class="o">==</span> <span class="n">helper</span><span class="o">){</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="c1">// 因为是环形链表，所以需要循环挨个出链表
</span><span class="c1"></span>            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">countNum</span> <span class="o">-</span> <span class="n">1</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                <span class="n">first</span> <span class="o">=</span> <span class="n">first</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
                <span class="n">helper</span> <span class="o">=</span> <span class="n">helper</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="c1">// 当前 first 就是出圈的结点
</span><span class="c1"></span>            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">printf</span><span class="o">(</span><span class="s">&#34;当前出队列的结点编号为：%d\n&#34;</span><span class="o">,</span><span class="n">first</span><span class="o">.</span><span class="na">num</span><span class="o">);</span>
            <span class="n">first</span> <span class="o">=</span> <span class="n">first</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="n">helper</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">first</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">printf</span><span class="o">(</span><span class="s">&#34;最后的结点为：%d\n&#34;</span><span class="o">,</span><span class="n">first</span><span class="o">.</span><span class="na">num</span><span class="o">);</span>
    <span class="o">}</span>

<span class="o">}</span>


<span class="kd">class</span> <span class="nc">Node</span> <span class="o">{</span>

    <span class="kt">int</span> <span class="n">num</span><span class="o">;</span>
    <span class="n">Node</span> <span class="n">next</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">Node</span><span class="o">(</span><span class="kt">int</span> <span class="n">num</span><span class="o">){</span>
        <span class="k">this</span><span class="o">.</span><span class="na">num</span> <span class="o">=</span> <span class="n">num</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="n">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="s">&#34;Node{&#34;</span> <span class="o">+</span>
                <span class="s">&#34;num=&#34;</span> <span class="o">+</span> <span class="n">num</span> <span class="o">+</span>
                <span class="sc">&#39;}&#39;</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><h3 id="栈">栈</h3>
<p>栈的英文为stack，是一个先入后出(FILO-First In Last Out)的有序列表，最先放入栈中元素在栈底，最后放入的元素在栈顶，而删除元素刚好相反，最后放入的元素最先删除，最先放入的元素最后删除。</p>
<p>栈是限制线性表中元素的插入和删除只能在线性表的同一端进行的一种特殊线性表。允许插入和删除的一端，为变化的一端，称为栈顶(Top)，另一端为固定的一端，称为栈底(Bottom)。</p>
<p>下图是出栈和入栈</p>
<p><img src="/iblog/posts/annex/images/essays/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-007.png" alt="数据结构与算法-007"></p>
<p>栈的应用场景：</p>
<ul>
<li>子程序的调用： 在跳往子程序前， 会先将下个指令的地址存到堆栈中， 直到子程序执行完后再将地址取出， 以回到原来的程序中；</li>
<li>处理递归调用： 和子程序的调用类似， 只是除了储存下一个指令的地址外， 也将参数、 区域变量等数据存入栈中；</li>
<li>表达式的转换：中缀表达式转后缀表达式与求值；</li>
<li>二叉树的遍历；</li>
<li>图形的深度优先(depth 一 first)搜索法；</li>
</ul>
<p>数组模拟栈</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">ArrayStack</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;{</span>

    <span class="kd">private</span> <span class="kt">int</span> <span class="n">size</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">top</span><span class="o">;</span>
    <span class="kd">private</span> <span class="n">Object</span><span class="o">[]</span> <span class="n">stack</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">ArrayStack</span><span class="o">(</span><span class="kt">int</span> <span class="n">size</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">size</span> <span class="o">=</span> <span class="n">size</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">stack</span> <span class="o">=</span> <span class="k">new</span> <span class="n">String</span><span class="o">[</span><span class="n">size</span><span class="o">];</span>
        <span class="n">top</span> <span class="o">=</span> <span class="o">-</span><span class="n">1</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isFull</span><span class="o">(){</span>
        <span class="k">return</span> <span class="n">top</span> <span class="o">==</span> <span class="n">size</span> <span class="o">-</span><span class="n">1</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isEmpty</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">top</span> <span class="o">==</span> <span class="o">-</span><span class="n">1</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// 入栈
</span><span class="c1"></span>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">push</span><span class="o">(</span><span class="n">T</span> <span class="n">item</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">isFull</span><span class="o">())</span> <span class="o">{</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;栈已经满了，不能继续添加！&#34;</span><span class="o">);</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="n">top</span><span class="o">++;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">stack</span><span class="o">[</span><span class="n">top</span><span class="o">]</span> <span class="o">=</span> <span class="n">item</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// 出栈操作
</span><span class="c1"></span>    <span class="kd">public</span> <span class="n">T</span> <span class="nf">pop</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">isEmpty</span><span class="o">())</span> <span class="o">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="n">RuntimeException</span><span class="o">(</span><span class="s">&#34;栈已经为空，不能继续pop&#34;</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="n">T</span> <span class="n">val</span> <span class="o">=</span> <span class="o">(</span><span class="n">T</span><span class="o">)</span><span class="k">this</span><span class="o">.</span><span class="na">stack</span><span class="o">[</span><span class="n">top</span><span class="o">];</span>
        <span class="n">top</span><span class="o">--;</span>
        <span class="k">return</span> <span class="n">val</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// 遍历栈
</span><span class="c1"></span>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">list</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">isEmpty</span><span class="o">())</span> <span class="o">{</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;栈为空不能继续遍历！&#34;</span><span class="o">);</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;遍历栈==》&#34;</span><span class="o">);</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">top</span><span class="o">;</span> <span class="n">i</span> <span class="o">&gt;=</span><span class="n">0</span><span class="o">;</span> <span class="n">i</span><span class="o">--){</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">stack</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
        <span class="o">}</span>
    <span class="o">}</span>

<span class="o">}</span>
</code></pre></div><h4 id="栈实现中缀表达式">栈实现中缀表达式</h4>
<p><img src="/iblog/posts/annex/images/essays/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-008.png" alt="数据结构与算法-008"></p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">CalcInfixExpressions</span> <span class="o">{</span>


    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">calcInfixExpressions</span><span class="o">(</span><span class="n">String</span> <span class="n">expression</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 定义变量
</span><span class="c1"></span>        <span class="kt">char</span><span class="o">[]</span> <span class="n">chars</span> <span class="o">=</span> <span class="n">expression</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">();</span>
        <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">chars</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="n">Stack</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">numStack</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Stack</span><span class="o">&lt;&gt;();</span>
        <span class="n">Stack</span><span class="o">&lt;</span><span class="n">Character</span><span class="o">&gt;</span> <span class="n">oprStack</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Stack</span><span class="o">&lt;&gt;();</span>
        <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>

        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">len</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>

            <span class="kt">char</span> <span class="n">ch</span> <span class="o">=</span> <span class="n">chars</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>

            <span class="n">index</span><span class="o">++;</span>

            <span class="c1">// 判断字符是否为数字,如果是数字就放入数栈中
</span><span class="c1"></span>            <span class="k">if</span> <span class="o">(</span><span class="n">Character</span><span class="o">.</span><span class="na">isDigit</span><span class="o">(</span><span class="n">ch</span><span class="o">))</span> <span class="o">{</span>

                <span class="c1">// 接收多位数
</span><span class="c1"></span>                <span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="n">ch</span><span class="o">;</span>
                <span class="kt">boolean</span> <span class="n">flag</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>

                <span class="c1">// 从当前字符开始遍历，如果下一位字符不是数字，则将该数字压入栈中并退出循环，如果是数字，则需要拼接起来
</span><span class="c1"></span>                <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">index</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">Character</span><span class="o">.</span><span class="na">isDigit</span><span class="o">(</span><span class="n">expression</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)))</span> <span class="o">{</span>
                        <span class="n">String</span> <span class="n">strNum</span> <span class="o">=</span> <span class="n">String</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">ch</span><span class="o">)</span> <span class="o">+</span> <span class="n">expression</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
                        <span class="n">num</span> <span class="o">=</span> <span class="n">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">strNum</span><span class="o">);</span>
                        <span class="n">flag</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
                        <span class="n">index</span><span class="o">++;</span>
                        <span class="n">j</span><span class="o">++;</span>
                    <span class="o">}</span><span class="k">else</span> <span class="o">{</span>
                        <span class="k">break</span><span class="o">;</span>
                    <span class="o">}</span>
                <span class="o">}</span>
                <span class="k">if</span> <span class="o">(!</span><span class="n">flag</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">num</span> <span class="o">-=</span> <span class="n">48</span><span class="o">;</span>
                <span class="o">}</span>
                <span class="n">numStack</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">num</span><span class="o">);</span>
                <span class="k">continue</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="c1">// 非数字，即运算符,如果为空直接加入栈中
</span><span class="c1"></span>            <span class="k">if</span> <span class="o">(</span><span class="n">oprStack</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
                <span class="n">oprStack</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">ch</span><span class="o">);</span>
                <span class="k">continue</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="c1">// 如果运算符栈不为空，需要比较运算符的优先级，如果当前运算符的优先级 &lt;= 栈顶的运算符的优先级，需要计算在压入栈中
</span><span class="c1"></span>            <span class="k">if</span> <span class="o">(</span><span class="n">oprPriority</span><span class="o">(</span><span class="n">oprStack</span><span class="o">.</span><span class="na">peek</span><span class="o">())</span> <span class="o">&gt;=</span> <span class="n">oprPriority</span><span class="o">(</span><span class="n">ch</span><span class="o">))</span> <span class="o">{</span>
                <span class="n">numStack</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">calc</span><span class="o">(</span><span class="n">numStack</span><span class="o">.</span><span class="na">pop</span><span class="o">(),</span> <span class="n">numStack</span><span class="o">.</span><span class="na">pop</span><span class="o">(),</span> <span class="n">oprStack</span><span class="o">.</span><span class="na">pop</span><span class="o">()));</span>
            <span class="o">}</span>

            <span class="c1">// 将字符压入操作符栈中
</span><span class="c1"></span>            <span class="n">oprStack</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">ch</span><span class="o">);</span>
        <span class="o">}</span>


        <span class="c1">// 将处理好的数据按照顺序弹出，进行计算，得到数栈中最后一个数就是最终的结果
</span><span class="c1"></span>        <span class="k">while</span> <span class="o">(!</span><span class="n">oprStack</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()){</span>
            <span class="n">numStack</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">calc</span><span class="o">(</span><span class="n">numStack</span><span class="o">.</span><span class="na">pop</span><span class="o">(),</span> <span class="n">numStack</span><span class="o">.</span><span class="na">pop</span><span class="o">(),</span> <span class="n">oprStack</span><span class="o">.</span><span class="na">pop</span><span class="o">()));</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">numStack</span><span class="o">.</span><span class="na">pop</span><span class="o">();</span>
    <span class="o">}</span>


    <span class="c1">// 获取字符的优先级
</span><span class="c1"></span>    <span class="kd">private</span> <span class="kt">int</span> <span class="nf">oprPriority</span><span class="o">(</span><span class="kt">int</span> <span class="n">ch</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">ch</span> <span class="o">==</span> <span class="sc">&#39;*&#39;</span> <span class="o">||</span> <span class="n">ch</span> <span class="o">==</span> <span class="sc">&#39;/&#39;</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">2</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">ch</span> <span class="o">==</span> <span class="sc">&#39;+&#39;</span> <span class="o">||</span> <span class="n">ch</span> <span class="o">==</span> <span class="sc">&#39;-&#39;</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">1</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">1</span><span class="o">;</span>
    <span class="o">}</span>


    <span class="c1">// 计算
</span><span class="c1"></span>    <span class="kd">private</span> <span class="kt">int</span> <span class="nf">calc</span><span class="o">(</span><span class="kt">int</span> <span class="n">num1</span><span class="o">,</span> <span class="kt">int</span> <span class="n">num2</span><span class="o">,</span> <span class="kt">int</span> <span class="n">opr</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
        <span class="k">switch</span> <span class="o">(</span><span class="n">opr</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">case</span> <span class="sc">&#39;+&#39;</span><span class="o">:</span>
                <span class="n">res</span> <span class="o">=</span> <span class="n">num1</span> <span class="o">+</span> <span class="n">num2</span><span class="o">;</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="k">case</span> <span class="sc">&#39;-&#39;</span><span class="o">:</span>
                <span class="n">res</span> <span class="o">=</span> <span class="n">num2</span> <span class="o">-</span> <span class="n">num1</span><span class="o">;</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="k">case</span> <span class="sc">&#39;*&#39;</span><span class="o">:</span>
                <span class="n">res</span> <span class="o">=</span> <span class="n">num1</span> <span class="o">*</span> <span class="n">num2</span><span class="o">;</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="k">case</span> <span class="sc">&#39;/&#39;</span><span class="o">:</span>
                <span class="n">res</span> <span class="o">=</span> <span class="n">num2</span> <span class="o">/</span> <span class="n">num1</span><span class="o">;</span>
                <span class="k">break</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>

<span class="o">}</span>
</code></pre></div><h4 id="栈实现后缀表达式">栈实现后缀表达式</h4>
<p>后缀表达式又称逆波兰表达式，与前缀表达式相似，只是运算符位于操作数之后。例如： (3+4)×5-6 对应的后缀表达式就是 3 4 + 5 × 6 –</p>
<p>思路：从左至右扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算（次顶元素 和 栈顶元素），并将结果入栈；重复上述过程直到表达式最右端，最后运算得出的值即为表达式的结果。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">PolandNotation</span><span class="o">{</span>

    <span class="c1">// 计算后缀表达式
</span><span class="c1"></span>    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">calcSuffixExceptions</span><span class="o">(</span><span class="n">String</span> <span class="n">suffixExpres</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">char</span><span class="o">[]</span> <span class="n">chars</span> <span class="o">=</span> <span class="n">suffixExpres</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">();</span>
        <span class="n">Stack</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">stack</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Stack</span><span class="o">&lt;&gt;();</span>
        <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span><span class="n">0</span><span class="o">;</span>

        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">chars</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="kt">char</span> <span class="n">ch</span> <span class="o">=</span> <span class="n">suffixExpres</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(!</span><span class="n">Character</span><span class="o">.</span><span class="na">isDigit</span><span class="o">(</span><span class="n">ch</span><span class="o">))</span> <span class="o">{</span>
                <span class="n">res</span> <span class="o">=</span> <span class="n">calc</span><span class="o">(</span><span class="n">stack</span><span class="o">.</span><span class="na">pop</span><span class="o">(),</span><span class="n">stack</span><span class="o">.</span><span class="na">pop</span><span class="o">(),</span><span class="n">ch</span><span class="o">);</span>
                <span class="n">stack</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">res</span><span class="o">);</span>
            <span class="o">}</span><span class="k">else</span> <span class="o">{</span>
                <span class="n">stack</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">ch</span> <span class="o">-</span> <span class="n">48</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// 计算
</span><span class="c1"></span>    <span class="kd">private</span> <span class="kt">int</span> <span class="nf">calc</span><span class="o">(</span><span class="kt">int</span> <span class="n">num1</span><span class="o">,</span> <span class="kt">int</span> <span class="n">num2</span><span class="o">,</span> <span class="kt">int</span> <span class="n">opr</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
        <span class="k">switch</span> <span class="o">(</span><span class="n">opr</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">case</span> <span class="sc">&#39;+&#39;</span><span class="o">:</span>
                <span class="n">res</span> <span class="o">=</span> <span class="n">num1</span> <span class="o">+</span> <span class="n">num2</span><span class="o">;</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="k">case</span> <span class="sc">&#39;-&#39;</span><span class="o">:</span>
                <span class="n">res</span> <span class="o">=</span> <span class="n">num2</span> <span class="o">-</span> <span class="n">num1</span><span class="o">;</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="k">case</span> <span class="sc">&#39;*&#39;</span><span class="o">:</span>
                <span class="n">res</span> <span class="o">=</span> <span class="n">num1</span> <span class="o">*</span> <span class="n">num2</span><span class="o">;</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="k">case</span> <span class="sc">&#39;/&#39;</span><span class="o">:</span>
                <span class="n">res</span> <span class="o">=</span> <span class="n">num2</span> <span class="o">/</span> <span class="n">num1</span><span class="o">;</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="k">default</span><span class="o">:</span>
                <span class="k">throw</span> <span class="k">new</span> <span class="n">RuntimeException</span><span class="o">(</span><span class="s">&#34;运算符有误&#34;</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>

<span class="o">}</span>
</code></pre></div><h4 id="中缀表达式转后缀表达式">中缀表达式转后缀表达式</h4>
<p><img src="/iblog/posts/annex/images/essays/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-009.png" alt="数据结构与算法-009"></p>
<p>中缀表达式转后缀表达式代码实现</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">InfixToPolandNotation</span><span class="o">{</span>

    <span class="c1">// 根据ASCII 判断是否为数字
</span><span class="c1"></span>    <span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">isNumber</span><span class="o">(</span><span class="kt">char</span> <span class="n">ch</span><span class="o">){</span>
        <span class="k">return</span> <span class="n">ch</span> <span class="o">&gt;=</span><span class="n">48</span> <span class="o">&amp;&amp;</span> <span class="n">ch</span> <span class="o">&lt;=</span> <span class="n">57</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// 获取字符的优先级
</span><span class="c1"></span>    <span class="kd">private</span> <span class="kt">int</span> <span class="nf">oprPriority</span><span class="o">(</span><span class="n">String</span> <span class="n">opr</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">opr</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="s">&#34;*&#34;</span><span class="o">)</span> <span class="o">||</span> <span class="n">opr</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="s">&#34;/&#34;</span><span class="o">))</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">2</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">opr</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="s">&#34;+&#34;</span><span class="o">)</span> <span class="o">||</span> <span class="n">opr</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="s">&#34;-&#34;</span><span class="o">))</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">2</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">1</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// 将中缀表达式字符串转成中缀表达式集合
</span><span class="c1"></span>    <span class="kd">public</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="nf">toInfixExceptionList</span><span class="o">(</span><span class="n">String</span> <span class="n">str</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
        <span class="n">StringBuilder</span> <span class="n">number</span><span class="o">;</span>
        <span class="kt">char</span> <span class="n">c</span><span class="o">;</span>

        <span class="k">while</span> <span class="o">(</span><span class="n">index</span> <span class="o">&lt;</span> <span class="n">str</span><span class="o">.</span><span class="na">length</span><span class="o">()){</span>
            <span class="k">if</span> <span class="o">(!</span><span class="n">isNumber</span><span class="o">((</span><span class="n">c</span> <span class="o">=</span> <span class="n">str</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">index</span><span class="o">)))){</span>
                <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">String</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">c</span><span class="o">));</span>
                <span class="n">index</span><span class="o">++;</span>
            <span class="o">}</span><span class="k">else</span> <span class="o">{</span>
                <span class="n">number</span> <span class="o">=</span> <span class="k">new</span> <span class="n">StringBuilder</span><span class="o">();</span>
                <span class="k">while</span> <span class="o">(</span><span class="n">index</span> <span class="o">&lt;</span> <span class="n">str</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">isNumber</span><span class="o">((</span><span class="n">c</span> <span class="o">=</span> <span class="n">str</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">index</span><span class="o">)))){</span>
                    <span class="n">index</span><span class="o">++;</span>
                    <span class="n">number</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">c</span><span class="o">);</span>
                <span class="o">}</span>
                <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">number</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">list</span><span class="o">;</span>
    <span class="o">}</span>


    <span class="c1">// 将中缀表达式转为后缀表达式
</span><span class="c1"></span>    <span class="kd">public</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="nf">infixExpressionToSuffixExpress</span><span class="o">(</span><span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">list</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">Stack</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">stack</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Stack</span><span class="o">&lt;&gt;();</span>
        <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">finalList</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;();</span>

        <span class="k">for</span> <span class="o">(</span><span class="n">String</span> <span class="n">item</span> <span class="o">:</span> <span class="n">list</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// 如果是数字或者为（ 将该值压入栈中
</span><span class="c1"></span>            <span class="k">if</span> <span class="o">(</span><span class="n">item</span><span class="o">.</span><span class="na">matches</span><span class="o">(</span><span class="s">&#34;\\d+&#34;</span><span class="o">)){</span>
                <span class="n">finalList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">item</span><span class="o">);</span>
                <span class="k">continue</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="k">if</span> <span class="o">(</span><span class="n">item</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="s">&#34;(&#34;</span><span class="o">)){</span>
                <span class="n">stack</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">item</span><span class="o">);</span>
                <span class="k">continue</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="c1">// 如果是 ）则将 ()中间的数重新压入list中，最后将 ） 移除掉
</span><span class="c1"></span>            <span class="k">if</span> <span class="o">(</span><span class="n">item</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="s">&#34;)&#34;</span><span class="o">)){</span>
                <span class="k">while</span> <span class="o">(!</span><span class="n">stack</span><span class="o">.</span><span class="na">peek</span><span class="o">().</span><span class="na">equals</span><span class="o">(</span><span class="s">&#34;(&#34;</span><span class="o">))</span> <span class="o">{</span>
                    <span class="n">finalList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">stack</span><span class="o">.</span><span class="na">pop</span><span class="o">());</span>
                <span class="o">}</span>
                <span class="n">stack</span><span class="o">.</span><span class="na">pop</span><span class="o">();</span>
            <span class="o">}</span><span class="k">else</span> <span class="o">{</span>
                <span class="c1">// 如果不是 ）则判断运算符的优先级，如果符号栈栈顶的优先级 &gt;= 当前的优先级，则将该运算符加入数字栈中
</span><span class="c1"></span>                <span class="k">while</span> <span class="o">(</span><span class="n">stack</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">&gt;</span> <span class="n">0</span> <span class="o">&amp;&amp;</span> <span class="n">oprPriority</span><span class="o">(</span><span class="n">stack</span><span class="o">.</span><span class="na">peek</span><span class="o">())</span> <span class="o">&gt;=</span> <span class="n">oprPriority</span><span class="o">(</span><span class="n">item</span><span class="o">)){</span>
                    <span class="n">finalList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">stack</span><span class="o">.</span><span class="na">pop</span><span class="o">());</span>
                <span class="o">}</span>
                <span class="n">stack</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">item</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// 将operStack中剩余的运算符依次弹出并加入tempList
</span><span class="c1"></span>        <span class="k">while</span> <span class="o">(</span><span class="n">stack</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">!=</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">finalList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">stack</span><span class="o">.</span><span class="na">pop</span><span class="o">());</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">finalList</span><span class="o">;</span>
    <span class="o">}</span>

<span class="o">}</span>
</code></pre></div><p>完整逆波兰表达式代码，支持小数、支持消除空格</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ReversePolishMultiCalc</span> <span class="o">{</span>

	 <span class="cm">/**
</span><span class="cm">     * 匹配 + - * / ( ) 运算符
</span><span class="cm">     */</span>
    <span class="kd">static</span> <span class="kd">final</span> <span class="n">String</span> <span class="n">SYMBOL</span> <span class="o">=</span> <span class="s">&#34;\\+|-|\\*|/|\\(|\\)&#34;</span><span class="o">;</span>

    <span class="kd">static</span> <span class="kd">final</span> <span class="n">String</span> <span class="n">LEFT</span> <span class="o">=</span> <span class="s">&#34;(&#34;</span><span class="o">;</span>
    <span class="kd">static</span> <span class="kd">final</span> <span class="n">String</span> <span class="n">RIGHT</span> <span class="o">=</span> <span class="s">&#34;)&#34;</span><span class="o">;</span>
    <span class="kd">static</span> <span class="kd">final</span> <span class="n">String</span> <span class="n">ADD</span> <span class="o">=</span> <span class="s">&#34;+&#34;</span><span class="o">;</span>
    <span class="kd">static</span> <span class="kd">final</span> <span class="n">String</span> <span class="n">MINUS</span><span class="o">=</span> <span class="s">&#34;-&#34;</span><span class="o">;</span>
    <span class="kd">static</span> <span class="kd">final</span> <span class="n">String</span> <span class="n">TIMES</span> <span class="o">=</span> <span class="s">&#34;*&#34;</span><span class="o">;</span>
    <span class="kd">static</span> <span class="kd">final</span> <span class="n">String</span> <span class="n">DIVISION</span> <span class="o">=</span> <span class="s">&#34;/&#34;</span><span class="o">;</span>

    <span class="cm">/**
</span><span class="cm">     * 加減 + -
</span><span class="cm">     */</span>
    <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">LEVEL_01</span> <span class="o">=</span> <span class="n">1</span><span class="o">;</span>
    <span class="cm">/**
</span><span class="cm">     * 乘除 * /
</span><span class="cm">     */</span>
    <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">LEVEL_02</span> <span class="o">=</span> <span class="n">2</span><span class="o">;</span>

    <span class="cm">/**
</span><span class="cm">     * 括号
</span><span class="cm">     */</span>
    <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">LEVEL_HIGH</span> <span class="o">=</span> <span class="n">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>


    <span class="kd">static</span> <span class="n">Stack</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">stack</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Stack</span><span class="o">&lt;&gt;();</span>
    <span class="kd">static</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">data</span> <span class="o">=</span> <span class="n">Collections</span><span class="o">.</span><span class="na">synchronizedList</span><span class="o">(</span><span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;());</span>

    <span class="cm">/**
</span><span class="cm">     * 去除所有空白符
</span><span class="cm">     * @param s
</span><span class="cm">     * @return
</span><span class="cm">     */</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="n">String</span> <span class="nf">replaceAllBlank</span><span class="o">(</span><span class="n">String</span> <span class="n">s</span> <span class="o">){</span>
        <span class="c1">// \\s+ 匹配任何空白字符，包括空格、制表符、换页符等等, 等价于[ \f\n\r\t\v]
</span><span class="c1"></span>        <span class="k">return</span> <span class="n">s</span><span class="o">.</span><span class="na">replaceAll</span><span class="o">(</span><span class="s">&#34;\\s+&#34;</span><span class="o">,</span><span class="s">&#34;&#34;</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="cm">/**
</span><span class="cm">     * 判断是不是数字 int double long float
</span><span class="cm">     * @param s
</span><span class="cm">     * @return
</span><span class="cm">     */</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">isNumber</span><span class="o">(</span><span class="n">String</span> <span class="n">s</span><span class="o">){</span>
        <span class="n">Pattern</span> <span class="n">pattern</span> <span class="o">=</span> <span class="n">Pattern</span><span class="o">.</span><span class="na">compile</span><span class="o">(</span><span class="s">&#34;^[-\\+]?[.\\d]*$&#34;</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">pattern</span><span class="o">.</span><span class="na">matcher</span><span class="o">(</span><span class="n">s</span><span class="o">).</span><span class="na">matches</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="cm">/**
</span><span class="cm">     * 判断是不是运算符
</span><span class="cm">     * @param s
</span><span class="cm">     * @return
</span><span class="cm">     */</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">isSymbol</span><span class="o">(</span><span class="n">String</span> <span class="n">s</span><span class="o">){</span>
        <span class="k">return</span> <span class="n">s</span><span class="o">.</span><span class="na">matches</span><span class="o">(</span><span class="n">SYMBOL</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="cm">/**
</span><span class="cm">     * 匹配运算等级
</span><span class="cm">     * @param s
</span><span class="cm">     * @return
</span><span class="cm">     */</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">calcLevel</span><span class="o">(</span><span class="n">String</span> <span class="n">s</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="s">&#34;+&#34;</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">s</span><span class="o">)</span> <span class="o">||</span> <span class="s">&#34;-&#34;</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">s</span><span class="o">)){</span>
            <span class="k">return</span> <span class="n">LEVEL_01</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">else</span> <span class="k">if</span><span class="o">(</span><span class="s">&#34;*&#34;</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">s</span><span class="o">)</span> <span class="o">||</span> <span class="s">&#34;/&#34;</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">s</span><span class="o">)){</span>
            <span class="k">return</span> <span class="n">LEVEL_02</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">LEVEL_HIGH</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="cm">/**
</span><span class="cm">     * 匹配
</span><span class="cm">     * @param s
</span><span class="cm">     */</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="nf">doMatch</span> <span class="o">(</span><span class="n">String</span> <span class="n">s</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span><span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">s</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="s">&#34;&#34;</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">trim</span><span class="o">()))</span> <span class="k">throw</span> <span class="k">new</span> <span class="n">RuntimeException</span><span class="o">(</span><span class="s">&#34;data is empty&#34;</span><span class="o">);</span>
        <span class="k">if</span><span class="o">(!</span><span class="n">isNumber</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">0</span><span class="o">)+</span><span class="s">&#34;&#34;</span><span class="o">))</span> <span class="k">throw</span> <span class="k">new</span> <span class="n">RuntimeException</span><span class="o">(</span><span class="s">&#34;data illeagle,start not with a number&#34;</span><span class="o">);</span>

        <span class="n">s</span> <span class="o">=</span> <span class="n">replaceAllBlank</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>

        <span class="n">String</span> <span class="n">each</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>

        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">if</span><span class="o">(</span><span class="n">isSymbol</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)+</span><span class="s">&#34;&#34;</span><span class="o">)){</span>
                <span class="n">each</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)+</span><span class="s">&#34;&#34;</span><span class="o">;</span>
                <span class="c1">//栈为空，(操作符，或者 操作符优先级大于栈顶优先级 &amp;&amp; 操作符优先级不是( )的优先级 及是 ) 不能直接入栈
</span><span class="c1"></span>                <span class="k">if</span><span class="o">(</span><span class="n">stack</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">||</span> <span class="n">LEFT</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">each</span><span class="o">)</span>
                        <span class="o">||</span> <span class="o">((</span><span class="n">calcLevel</span><span class="o">(</span><span class="n">each</span><span class="o">)</span> <span class="o">&gt;</span> <span class="n">calcLevel</span><span class="o">(</span><span class="n">stack</span><span class="o">.</span><span class="na">peek</span><span class="o">()))</span> <span class="o">&amp;&amp;</span> <span class="n">calcLevel</span><span class="o">(</span><span class="n">each</span><span class="o">)</span> <span class="o">&lt;</span> <span class="n">LEVEL_HIGH</span><span class="o">)){</span>
                    <span class="n">stack</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">each</span><span class="o">);</span>
                <span class="o">}</span><span class="k">else</span> <span class="k">if</span><span class="o">(</span> <span class="o">!</span><span class="n">stack</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">calcLevel</span><span class="o">(</span><span class="n">each</span><span class="o">)</span> <span class="o">&lt;=</span> <span class="n">calcLevel</span><span class="o">(</span><span class="n">stack</span><span class="o">.</span><span class="na">peek</span><span class="o">())){</span>
                    <span class="c1">//栈非空，操作符优先级小于等于栈顶优先级时出栈入列，直到栈为空，或者遇到了(，最后操作符入栈
</span><span class="c1"></span>                    <span class="k">while</span> <span class="o">(!</span><span class="n">stack</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">calcLevel</span><span class="o">(</span><span class="n">each</span><span class="o">)</span> <span class="o">&lt;=</span> <span class="n">calcLevel</span><span class="o">(</span><span class="n">stack</span><span class="o">.</span><span class="na">peek</span><span class="o">())</span> <span class="o">){</span>
                        <span class="k">if</span><span class="o">(</span><span class="n">calcLevel</span><span class="o">(</span><span class="n">stack</span><span class="o">.</span><span class="na">peek</span><span class="o">())</span> <span class="o">==</span> <span class="n">LEVEL_HIGH</span><span class="o">){</span>
                            <span class="k">break</span><span class="o">;</span>
                        <span class="o">}</span>
                        <span class="n">data</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">stack</span><span class="o">.</span><span class="na">pop</span><span class="o">());</span>
                    <span class="o">}</span>
                    <span class="n">stack</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">each</span><span class="o">);</span>
                <span class="o">}</span><span class="k">else</span> <span class="k">if</span><span class="o">(</span><span class="n">RIGHT</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">each</span><span class="o">)){</span>
                    <span class="c1">// ) 操作符，依次出栈入列直到空栈或者遇到了第一个)操作符，此时)出栈
</span><span class="c1"></span>                    <span class="k">while</span> <span class="o">(!</span><span class="n">stack</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">LEVEL_HIGH</span> <span class="o">&gt;=</span> <span class="n">calcLevel</span><span class="o">(</span><span class="n">stack</span><span class="o">.</span><span class="na">peek</span><span class="o">())){</span>
                        <span class="k">if</span><span class="o">(</span><span class="n">LEVEL_HIGH</span> <span class="o">==</span> <span class="n">calcLevel</span><span class="o">(</span><span class="n">stack</span><span class="o">.</span><span class="na">peek</span><span class="o">())){</span>
                            <span class="n">stack</span><span class="o">.</span><span class="na">pop</span><span class="o">();</span>
                            <span class="k">break</span><span class="o">;</span>
                        <span class="o">}</span>
                        <span class="n">data</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">stack</span><span class="o">.</span><span class="na">pop</span><span class="o">());</span>
                    <span class="o">}</span>
                <span class="o">}</span>
                <span class="n">start</span> <span class="o">=</span> <span class="n">i</span> <span class="o">;</span>    <span class="c1">//前一个运算符的位置
</span><span class="c1"></span>            <span class="o">}</span><span class="k">else</span> <span class="k">if</span><span class="o">(</span> <span class="n">i</span> <span class="o">==</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()-</span><span class="n">1</span> <span class="o">||</span> <span class="n">isSymbol</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">+</span><span class="n">1</span><span class="o">)+</span><span class="s">&#34;&#34;</span><span class="o">)</span> <span class="o">){</span>
                <span class="n">each</span> <span class="o">=</span> <span class="n">start</span> <span class="o">==</span> <span class="n">0</span> <span class="o">?</span> <span class="n">s</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="n">start</span><span class="o">,</span><span class="n">i</span><span class="o">+</span><span class="n">1</span><span class="o">)</span> <span class="o">:</span> <span class="n">s</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="n">start</span><span class="o">+</span><span class="n">1</span><span class="o">,</span><span class="n">i</span><span class="o">+</span><span class="n">1</span><span class="o">);</span>
                <span class="k">if</span><span class="o">(</span><span class="n">isNumber</span><span class="o">(</span><span class="n">each</span><span class="o">))</span> <span class="o">{</span>
                    <span class="n">data</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">each</span><span class="o">);</span>
                    <span class="k">continue</span><span class="o">;</span>
                <span class="o">}</span>
                <span class="k">throw</span> <span class="k">new</span> <span class="n">RuntimeException</span><span class="o">(</span><span class="s">&#34;data not match number&#34;</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="c1">//如果栈里还有元素，此时元素需要依次出栈入列，可以想象栈里剩下栈顶为/，栈底为+，应该依次出栈入列，可以直接翻转整个stack 添加到队列
</span><span class="c1"></span>        <span class="n">Collections</span><span class="o">.</span><span class="na">reverse</span><span class="o">(</span><span class="n">stack</span><span class="o">);</span>
        <span class="n">data</span><span class="o">.</span><span class="na">addAll</span><span class="o">(</span><span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;(</span><span class="n">stack</span><span class="o">));</span>

        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">data</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">data</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="cm">/**
</span><span class="cm">     * 算出结果
</span><span class="cm">     * @param list
</span><span class="cm">     * @return
</span><span class="cm">     */</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="n">Double</span> <span class="nf">doCalc</span><span class="o">(</span><span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">list</span><span class="o">){</span>
        <span class="n">Double</span> <span class="n">d</span> <span class="o">=</span> <span class="n">0d</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">list</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">list</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()){</span>
            <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">list</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">==</span> <span class="n">1</span><span class="o">){</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">list</span><span class="o">);</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">Double</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">list</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">0</span><span class="o">));</span>
            <span class="k">return</span> <span class="n">d</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">list1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">list</span><span class="o">.</span><span class="na">size</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">list1</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">list</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">));</span>
            <span class="k">if</span><span class="o">(</span><span class="n">isSymbol</span><span class="o">(</span><span class="n">list</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">))){</span>
                <span class="n">Double</span> <span class="n">d1</span> <span class="o">=</span> <span class="n">doTheMath</span><span class="o">(</span><span class="n">list</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">2</span><span class="o">),</span> <span class="n">list</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">1</span><span class="o">),</span> <span class="n">list</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">));</span>
                <span class="n">list1</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
                <span class="n">list1</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">i</span><span class="o">-</span><span class="n">1</span><span class="o">);</span>
                <span class="n">list1</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">i</span><span class="o">-</span><span class="n">2</span><span class="o">,</span><span class="n">d1</span><span class="o">+</span><span class="s">&#34;&#34;</span><span class="o">);</span>
                <span class="n">list1</span><span class="o">.</span><span class="na">addAll</span><span class="o">(</span><span class="n">list</span><span class="o">.</span><span class="na">subList</span><span class="o">(</span><span class="n">i</span><span class="o">+</span><span class="n">1</span><span class="o">,</span><span class="n">list</span><span class="o">.</span><span class="na">size</span><span class="o">()));</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="n">doCalc</span><span class="o">(</span><span class="n">list1</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">d</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="cm">/**
</span><span class="cm">     * 运算
</span><span class="cm">     * @param s1
</span><span class="cm">     * @param s2
</span><span class="cm">     * @param symbol
</span><span class="cm">     * @return
</span><span class="cm">     */</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="n">Double</span> <span class="nf">doTheMath</span><span class="o">(</span><span class="n">String</span> <span class="n">s1</span><span class="o">,</span><span class="n">String</span> <span class="n">s2</span><span class="o">,</span><span class="n">String</span> <span class="n">symbol</span><span class="o">){</span>
        <span class="n">Double</span> <span class="n">result</span> <span class="o">;</span>
        <span class="k">switch</span> <span class="o">(</span><span class="n">symbol</span><span class="o">){</span>
            <span class="k">case</span> <span class="n">ADD</span> <span class="o">:</span> <span class="n">result</span> <span class="o">=</span> <span class="n">Double</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">s1</span><span class="o">)</span> <span class="o">+</span> <span class="n">Double</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">s2</span><span class="o">);</span> <span class="k">break</span><span class="o">;</span>
            <span class="k">case</span> <span class="n">MINUS</span> <span class="o">:</span> <span class="n">result</span> <span class="o">=</span> <span class="n">Double</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">s1</span><span class="o">)</span> <span class="o">-</span> <span class="n">Double</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">s2</span><span class="o">);</span> <span class="k">break</span><span class="o">;</span>
            <span class="k">case</span> <span class="n">TIMES</span> <span class="o">:</span> <span class="n">result</span> <span class="o">=</span> <span class="n">Double</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">s1</span><span class="o">)</span> <span class="o">*</span> <span class="n">Double</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">s2</span><span class="o">);</span> <span class="k">break</span><span class="o">;</span>
            <span class="k">case</span> <span class="n">DIVISION</span> <span class="o">:</span> <span class="n">result</span> <span class="o">=</span> <span class="n">Double</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">s1</span><span class="o">)</span> <span class="o">/</span> <span class="n">Double</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">s2</span><span class="o">);</span> <span class="k">break</span><span class="o">;</span>
            <span class="k">default</span> <span class="o">:</span> <span class="n">result</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>

    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//String math = &#34;9+(3-1)*3+10/2&#34;;
</span><span class="c1"></span>        <span class="n">String</span> <span class="n">math</span> <span class="o">=</span> <span class="s">&#34;12.8 + (2 - 3.55)*4+10/5.0&#34;</span><span class="o">;</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="n">doCalc</span><span class="o">(</span><span class="n">doMatch</span><span class="o">(</span><span class="n">math</span><span class="o">));</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>

<span class="o">}</span>

</code></pre></div><h3 id="哈希表">哈希表</h3>
<p>哈希表也叫散列表，是根据关键码值(Key value)而直接进行访问的数据结构。</p>
<p>它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。</p>
<p>手写模拟哈希表</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">HashTableDemo</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">HashTab</span> <span class="n">hashTab</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashTab</span><span class="o">(</span><span class="n">3</span><span class="o">);</span>
        <span class="n">Node</span> <span class="n">node1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="o">(</span><span class="n">1</span><span class="o">,</span> <span class="s">&#34;zs&#34;</span><span class="o">);</span>
        <span class="n">Node</span> <span class="n">node2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="o">(</span><span class="n">2</span><span class="o">,</span> <span class="s">&#34;lx&#34;</span><span class="o">);</span>
        <span class="n">Node</span> <span class="n">node3</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="o">(</span><span class="n">3</span><span class="o">,</span> <span class="s">&#34;ex&#34;</span><span class="o">);</span>
        <span class="n">Node</span> <span class="n">node4</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="o">(</span><span class="n">4</span><span class="o">,</span> <span class="s">&#34;as&#34;</span><span class="o">);</span>
        <span class="n">Node</span> <span class="n">node5</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="o">(</span><span class="n">7</span><span class="o">,</span> <span class="s">&#34;we&#34;</span><span class="o">);</span>

        <span class="n">hashTab</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">node1</span><span class="o">);</span>
        <span class="n">hashTab</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">node2</span><span class="o">);</span>
        <span class="n">hashTab</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">node3</span><span class="o">);</span>
        <span class="n">hashTab</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">node4</span><span class="o">);</span>
        <span class="n">hashTab</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">node5</span><span class="o">);</span>

        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;添加元素后===》&#34;</span><span class="o">);</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">hashTab</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span>

        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;删除后===》&#34;</span><span class="o">);</span>
        <span class="n">hashTab</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">4</span><span class="o">);</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">hashTab</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">HashTab</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="n">NodeList</span><span class="o">[]</span> <span class="n">nodes</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">size</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">HashTab</span><span class="o">(</span><span class="kt">int</span> <span class="n">size</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">size</span> <span class="o">=</span> <span class="n">size</span><span class="o">;</span>
        <span class="n">nodes</span> <span class="o">=</span> <span class="k">new</span> <span class="n">NodeList</span><span class="o">[</span><span class="n">size</span><span class="o">];</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">nodes</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="k">new</span> <span class="n">NodeList</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">put</span><span class="o">(</span><span class="n">Node</span> <span class="n">node</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 放入hash表的位置
</span><span class="c1"></span>        <span class="n">nodes</span><span class="o">[</span><span class="n">getPosition</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">id</span><span class="o">)].</span><span class="na">add</span><span class="o">(</span><span class="n">node</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">remove</span><span class="o">(</span><span class="kt">int</span> <span class="n">id</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">nodes</span><span class="o">[</span><span class="n">getPosition</span><span class="o">(</span><span class="n">id</span><span class="o">)].</span><span class="na">delete</span><span class="o">(</span><span class="n">id</span><span class="o">);</span>
    <span class="o">}</span>


    <span class="kd">private</span> <span class="kt">int</span> <span class="nf">getPosition</span><span class="o">(</span><span class="kt">int</span> <span class="n">id</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">id</span> <span class="o">%</span> <span class="n">size</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="n">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="s">&#34;HashTab{&#34;</span> <span class="o">+</span>
                <span class="s">&#34;nodes=\n&#34;</span> <span class="o">+</span> <span class="n">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">nodes</span><span class="o">)</span> <span class="o">+</span>
                <span class="s">&#34;}&#34;</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">NodeList</span> <span class="o">{</span>
    <span class="c1">// 头结点
</span><span class="c1"></span>    <span class="n">Node</span> <span class="n">head</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>

    <span class="c1">// 添加结点方法
</span><span class="c1"></span>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">add</span><span class="o">(</span><span class="n">Node</span> <span class="n">node</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">head</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">head</span> <span class="o">=</span> <span class="n">node</span><span class="o">;</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// 头结点不要动，将添加的结点放到链表的最后一个位置
</span><span class="c1"></span>        <span class="n">Node</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
        <span class="c1">// 当下一个结点等于null时，找到最后一个结点
</span><span class="c1"></span>        <span class="k">while</span> <span class="o">(</span><span class="n">tmp</span><span class="o">.</span><span class="na">next</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="n">tmp</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">node</span><span class="o">;</span>
    <span class="o">}</span>


    <span class="c1">// 展示当前链表
</span><span class="c1"></span>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">list</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">head</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;当前链表为空&#34;</span><span class="o">);</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">// 辅助结点
</span><span class="c1"></span>        <span class="n">Node</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
        <span class="k">while</span> <span class="o">(</span><span class="kc">true</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">tmp</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">tmp</span><span class="o">.</span><span class="na">next</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="c1">// 根据ID删除链表中的某个结点
</span><span class="c1"></span>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">delete</span><span class="o">(</span><span class="kt">int</span> <span class="n">id</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">head</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;当前链表为空&#34;</span><span class="o">);</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">// 判断删除的是否是头结点
</span><span class="c1"></span>        <span class="k">if</span> <span class="o">(</span><span class="n">head</span><span class="o">.</span><span class="na">id</span> <span class="o">==</span> <span class="n">id</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">head</span> <span class="o">=</span> <span class="n">head</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="n">Node</span> <span class="n">preNode</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
        <span class="n">Node</span> <span class="n">curNode</span> <span class="o">=</span> <span class="n">preNode</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">curNode</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">curNode</span><span class="o">.</span><span class="na">id</span> <span class="o">==</span> <span class="n">id</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">preNode</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">curNode</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
                <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;删除成功，删除的是: &#34;</span> <span class="o">+</span> <span class="n">curNode</span><span class="o">.</span><span class="na">id</span> <span class="o">+</span> <span class="s">&#34;,&#34;</span> <span class="o">+</span> <span class="n">curNode</span><span class="o">.</span><span class="na">name</span><span class="o">);</span>
                <span class="n">curNode</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
                <span class="k">return</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="n">preNode</span> <span class="o">=</span> <span class="n">preNode</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="n">curNode</span> <span class="o">=</span> <span class="n">curNode</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;删除失败，节点不存在&#34;</span><span class="o">);</span>
    <span class="o">}</span>


    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="n">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="s">&#34;NodeList{&#34;</span> <span class="o">+</span>
                <span class="s">&#34;head=&#34;</span> <span class="o">+</span> <span class="n">head</span> <span class="o">+</span>
                <span class="s">&#34;}\n&#34;</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">Node</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">id</span><span class="o">;</span>
    <span class="n">String</span> <span class="n">name</span><span class="o">;</span>
    <span class="n">Node</span> <span class="n">next</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">Node</span><span class="o">(</span><span class="kt">int</span> <span class="n">id</span><span class="o">,</span> <span class="n">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">id</span> <span class="o">=</span> <span class="n">id</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="n">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="s">&#34;Node{&#34;</span> <span class="o">+</span>
                <span class="s">&#34;id=&#34;</span> <span class="o">+</span> <span class="n">id</span> <span class="o">+</span>
                <span class="s">&#34;, name=&#39;&#34;</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="sc">&#39;\&#39;&#39;</span> <span class="o">+</span>
                <span class="s">&#34;, next=&#34;</span> <span class="o">+</span> <span class="n">next</span> <span class="o">+</span>
                <span class="s">&#34;}&#34;</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><h3 id="二叉树">二叉树</h3>
<blockquote>
<p>二叉树（Binary tree）是树形结构的一个重要类型。许多实际问题抽象出来的数据结构往往是二叉树形式，即使是一般的树也能简单地转换为二叉树，而且二叉树的存储结构及其算法都较为简单，因此二叉树显得特别重要。二叉树特点是每个结点最多只能有两棵子树，且有左右之分。</p>
</blockquote>
<p>二叉树是n个有限元素的集合，该集合或者为空、或者由一个称为根的元素及两个不相交的、被分别称为左子树和右子树的二叉树组成，是有序树。当集合为空时，称该二叉树为空二叉树。在二叉树中，一个元素也称作一个结点。</p>
<p>如果该二叉树的所有叶子节点都在最后一层，并且结点总数为 2^n -1， n 为层数，则称为满二叉树。</p>
<p>如果该二叉树的所有叶子节点都在最后一层或者倒数第二层，而且最后一层的叶子节点在左边连续，倒数第二层的叶子节点在右边连续，我们称为完全二叉树。</p>
<blockquote>
<p>PS: 二叉树中结点等价于节点</p>
</blockquote>
<p><img src="/iblog/posts/annex/images/essays/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-022.png" alt="数据结构与算法-022"></p>
<h4 id="二叉树的遍历及查找">二叉树的遍历及查找</h4>
<p>对于二叉树来讲最主要、最基本的运算是遍历。遍历二叉树 是指以一定的次序访问二叉树中的每个结点。所谓访问结点是指对结点进行各种操作的简称。</p>
<p>例如，查询结点数据域的内容，或输出它的值，或找出结点位置，或是执行对结点的其他操作。遍历二叉树的过程实质是把二叉树的结点进行线性排列的过程。</p>
<p>二叉树的遍历方法：</p>
<ul>
<li>前序遍历：先访问根结点，然后前序遍历左子树，在前序遍历右子树；</li>
<li>中序遍历：中序遍历根结点的左子树，然后访问根结点，最后遍历右子树；</li>
<li>后序遍历：后序遍历左子树，然后后序遍历右子树，最后访问根结点；</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">BinaryTreeDemo</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">BinaryTreeObj</span> <span class="n">root</span> <span class="o">=</span> <span class="k">new</span> <span class="n">BinaryTreeObj</span><span class="o">(</span><span class="n">1</span><span class="o">,</span><span class="s">&#34;zs&#34;</span><span class="o">);</span>
        <span class="n">BinaryTreeObj</span> <span class="n">binaryTreeObj2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">BinaryTreeObj</span><span class="o">(</span><span class="n">2</span><span class="o">,</span><span class="s">&#34;ls&#34;</span><span class="o">);</span>
        <span class="n">BinaryTreeObj</span> <span class="n">binaryTreeObj3</span> <span class="o">=</span> <span class="k">new</span> <span class="n">BinaryTreeObj</span><span class="o">(</span><span class="n">3</span><span class="o">,</span><span class="s">&#34;ww&#34;</span><span class="o">);</span>
        <span class="n">BinaryTreeObj</span> <span class="n">binaryTreeObj4</span> <span class="o">=</span> <span class="k">new</span> <span class="n">BinaryTreeObj</span><span class="o">(</span><span class="n">4</span><span class="o">,</span><span class="s">&#34;zq&#34;</span><span class="o">);</span>
        <span class="n">BinaryTreeObj</span> <span class="n">binaryTreeObj5</span> <span class="o">=</span> <span class="k">new</span> <span class="n">BinaryTreeObj</span><span class="o">(</span><span class="n">5</span><span class="o">,</span><span class="s">&#34;111&#34;</span><span class="o">);</span>

        <span class="n">root</span><span class="o">.</span><span class="na">setLeft</span><span class="o">(</span><span class="n">binaryTreeObj2</span><span class="o">);</span>
        <span class="n">root</span><span class="o">.</span><span class="na">setRight</span><span class="o">(</span><span class="n">binaryTreeObj3</span><span class="o">);</span>
        <span class="n">binaryTreeObj3</span><span class="o">.</span><span class="na">setLeft</span><span class="o">(</span><span class="n">binaryTreeObj4</span><span class="o">);</span>
        <span class="n">binaryTreeObj3</span><span class="o">.</span><span class="na">setRight</span><span class="o">(</span><span class="n">binaryTreeObj5</span><span class="o">);</span>

        <span class="n">BinaryTree</span> <span class="n">binaryTree</span> <span class="o">=</span> <span class="k">new</span> <span class="n">BinaryTree</span><span class="o">();</span>
        <span class="n">binaryTree</span><span class="o">.</span><span class="na">setRoot</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>
        <span class="n">binaryTree</span><span class="o">.</span><span class="na">preOrderShow</span><span class="o">();</span>

        <span class="n">BinaryTreeObj</span> <span class="n">binaryTreeObj</span> <span class="o">=</span> <span class="n">binaryTree</span><span class="o">.</span><span class="na">preOrderSearch</span><span class="o">(</span><span class="n">11</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">binaryTreeObj</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;没有找到该结点～&#34;</span><span class="o">);</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">printf</span><span class="o">(</span><span class="s">&#34;找到当前结点：id: %d, name: %s&#34;</span><span class="o">,</span><span class="n">binaryTreeObj</span><span class="o">.</span><span class="na">getId</span><span class="o">(),</span><span class="n">binaryTreeObj</span><span class="o">.</span><span class="na">getName</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>


<span class="kd">class</span> <span class="nc">BinaryTree</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="n">BinaryTreeObj</span> <span class="n">root</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setRoot</span><span class="o">(</span><span class="n">BinaryTreeObj</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">root</span> <span class="o">=</span> <span class="n">root</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">preOrderShow</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">root</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">this</span><span class="o">.</span><span class="na">root</span><span class="o">.</span><span class="na">preOrder</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>


    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">postOrderShow</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">root</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">this</span><span class="o">.</span><span class="na">root</span><span class="o">.</span><span class="na">postOrder</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>


    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">midOrderShow</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">root</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">this</span><span class="o">.</span><span class="na">root</span><span class="o">.</span><span class="na">midOrder</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="n">BinaryTreeObj</span> <span class="nf">preOrderSearch</span><span class="o">(</span><span class="kt">int</span> <span class="n">id</span><span class="o">){</span>
        <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">root</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">root</span><span class="o">.</span><span class="na">preOrderSearch</span><span class="o">(</span><span class="n">id</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="n">BinaryTreeObj</span> <span class="nf">infixOrderSearch</span><span class="o">(</span><span class="kt">int</span> <span class="n">id</span><span class="o">){</span>
        <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">root</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">root</span><span class="o">.</span><span class="na">infixOrderSearch</span><span class="o">(</span><span class="n">id</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="n">BinaryTreeObj</span> <span class="nf">postOrderSearch</span><span class="o">(</span><span class="kt">int</span> <span class="n">id</span><span class="o">){</span>
        <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">root</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">root</span><span class="o">.</span><span class="na">postOrderSearch</span><span class="o">(</span><span class="n">id</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>

<span class="o">}</span>


<span class="kd">class</span> <span class="nc">BinaryTreeObj</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="n">Integer</span> <span class="n">id</span><span class="o">;</span>
    <span class="kd">private</span> <span class="n">String</span> <span class="n">name</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">BinaryTreeObj</span><span class="o">(</span><span class="n">Integer</span> <span class="n">id</span><span class="o">,</span><span class="n">String</span> <span class="n">name</span><span class="o">){</span>
        <span class="k">this</span><span class="o">.</span><span class="na">id</span> <span class="o">=</span> <span class="n">id</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="n">String</span> <span class="nf">getName</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">name</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="n">Integer</span> <span class="nf">getId</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">id</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="n">BinaryTreeObj</span> <span class="n">left</span><span class="o">;</span>
    <span class="kd">private</span> <span class="n">BinaryTreeObj</span> <span class="n">right</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setLeft</span><span class="o">(</span><span class="n">BinaryTreeObj</span> <span class="n">left</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">left</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setRight</span><span class="o">(</span><span class="n">BinaryTreeObj</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">right</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// 前序遍历：根结点 =》 左结点 =》 右结点
</span><span class="c1"></span>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">preOrder</span><span class="o">(){</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">left</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
            <span class="k">this</span><span class="o">.</span><span class="na">left</span><span class="o">.</span><span class="na">preOrder</span><span class="o">();</span>
        <span class="o">}</span>

        <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">right</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
            <span class="k">this</span><span class="o">.</span><span class="na">right</span><span class="o">.</span><span class="na">preOrder</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="c1">// 后序遍历： 左结点 =》 右结点 =》 根结点
</span><span class="c1"></span>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">postOrder</span><span class="o">(){</span>

        <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">left</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
            <span class="k">this</span><span class="o">.</span><span class="na">left</span><span class="o">.</span><span class="na">postOrder</span><span class="o">();</span>
        <span class="o">}</span>

        <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">right</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
            <span class="k">this</span><span class="o">.</span><span class="na">right</span><span class="o">.</span><span class="na">postOrder</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="c1">// 中序遍历： 左结点 =》 根结点 =》 右结点
</span><span class="c1"></span>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">midOrder</span><span class="o">(){</span>

        <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">left</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
            <span class="k">this</span><span class="o">.</span><span class="na">left</span><span class="o">.</span><span class="na">midOrder</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>

        <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">right</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
            <span class="k">this</span><span class="o">.</span><span class="na">right</span><span class="o">.</span><span class="na">midOrder</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="c1">// 前序查找
</span><span class="c1"></span>    <span class="kd">public</span> <span class="n">BinaryTreeObj</span> <span class="nf">preOrderSearch</span><span class="o">(</span><span class="kt">int</span> <span class="n">id</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">id</span> <span class="o">==</span> <span class="k">this</span><span class="o">.</span><span class="na">id</span><span class="o">){</span>
            <span class="k">return</span> <span class="k">this</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="n">BinaryTreeObj</span> <span class="n">binaryTreeObj</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">left</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
            <span class="n">binaryTreeObj</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">left</span><span class="o">.</span><span class="na">preOrderSearch</span><span class="o">(</span><span class="n">id</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="k">if</span> <span class="o">(</span><span class="n">binaryTreeObj</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
            <span class="k">return</span> <span class="n">binaryTreeObj</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">right</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
            <span class="n">binaryTreeObj</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">right</span><span class="o">.</span><span class="na">preOrderSearch</span><span class="o">(</span><span class="n">id</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">binaryTreeObj</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// 中序查找
</span><span class="c1"></span>    <span class="kd">public</span> <span class="n">BinaryTreeObj</span> <span class="nf">infixOrderSearch</span><span class="o">(</span><span class="kt">int</span> <span class="n">id</span><span class="o">)</span> <span class="o">{</span>

        <span class="n">BinaryTreeObj</span> <span class="n">binaryTreeObj</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">left</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
            <span class="n">binaryTreeObj</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">left</span><span class="o">.</span><span class="na">infixOrderSearch</span><span class="o">(</span><span class="n">id</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="k">if</span> <span class="o">(</span><span class="n">id</span> <span class="o">==</span> <span class="k">this</span><span class="o">.</span><span class="na">id</span><span class="o">){</span>
            <span class="k">return</span> <span class="k">this</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="k">if</span> <span class="o">(</span><span class="n">binaryTreeObj</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
            <span class="k">return</span> <span class="n">binaryTreeObj</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">right</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
            <span class="n">binaryTreeObj</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">right</span><span class="o">.</span><span class="na">infixOrderSearch</span><span class="o">(</span><span class="n">id</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">binaryTreeObj</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// 后序查找
</span><span class="c1"></span>    <span class="kd">public</span> <span class="n">BinaryTreeObj</span> <span class="nf">postOrderSearch</span><span class="o">(</span><span class="kt">int</span> <span class="n">id</span><span class="o">)</span> <span class="o">{</span>

        <span class="n">BinaryTreeObj</span> <span class="n">binaryTreeObj</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">left</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
            <span class="n">binaryTreeObj</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">left</span><span class="o">.</span><span class="na">postOrderSearch</span><span class="o">(</span><span class="n">id</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="k">if</span> <span class="o">(</span><span class="n">binaryTreeObj</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
            <span class="k">return</span> <span class="n">binaryTreeObj</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">right</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
            <span class="n">binaryTreeObj</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">right</span><span class="o">.</span><span class="na">postOrderSearch</span><span class="o">(</span><span class="n">id</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">id</span> <span class="o">==</span> <span class="k">this</span><span class="o">.</span><span class="na">id</span><span class="o">){</span>
            <span class="k">return</span> <span class="k">this</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">binaryTreeObj</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="n">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="s">&#34;BinaryTreeObj{&#34;</span> <span class="o">+</span>
                <span class="s">&#34;id=&#34;</span> <span class="o">+</span> <span class="n">id</span> <span class="o">+</span>
                <span class="s">&#34;, name=&#39;&#34;</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="sc">&#39;\&#39;&#39;</span> <span class="o">+</span>
                <span class="sc">&#39;}&#39;</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><h4 id="二叉树的删除">二叉树的删除</h4>
<p><img src="/iblog/posts/annex/images/essays/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-023.png" alt="数据结构与算法-023"></p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">BinaryTree</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">del</span><span class="o">(</span><span class="kt">int</span> <span class="n">id</span><span class="o">){</span>
        <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">){</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">root</span><span class="o">.</span><span class="na">getId</span><span class="o">()</span> <span class="o">==</span> <span class="n">id</span><span class="o">){</span>
            <span class="k">this</span><span class="o">.</span><span class="na">root</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">this</span><span class="o">.</span><span class="na">root</span><span class="o">.</span><span class="na">delNo</span><span class="o">(</span><span class="n">id</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">BinaryTreeObj</span> <span class="o">{</span>
    <span class="c1">// 根据ID删除结点
</span><span class="c1"></span>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">delNo</span><span class="o">(</span><span class="kt">int</span> <span class="n">id</span><span class="o">){</span>
        <span class="c1">// 找到当前结点的左子树结点是否为指定结点，如果是则将其置空
</span><span class="c1"></span>        <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">left</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="k">this</span><span class="o">.</span><span class="na">left</span><span class="o">.</span><span class="na">id</span> <span class="o">==</span> <span class="n">id</span><span class="o">){</span>
            <span class="k">this</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// 与上面同理删除右子树结点
</span><span class="c1"></span>        <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">right</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="k">this</span><span class="o">.</span><span class="na">right</span><span class="o">.</span><span class="na">id</span> <span class="o">==</span> <span class="n">id</span><span class="o">){</span>
            <span class="k">this</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>


        <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">left</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="k">this</span><span class="o">.</span><span class="na">right</span> <span class="o">==</span> <span class="kc">null</span><span class="o">){</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// 如果当前左结点或右结点 不是要删除的结点 则进行递归删除
</span><span class="c1"></span>        <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">left</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
            <span class="k">this</span><span class="o">.</span><span class="na">left</span><span class="o">.</span><span class="na">delNo</span><span class="o">(</span><span class="n">id</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">right</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">this</span><span class="o">.</span><span class="na">right</span><span class="o">.</span><span class="na">delNo</span><span class="o">(</span><span class="n">id</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><h4 id="顺序存储二叉树">顺序存储二叉树</h4>
<p>二叉树的顺序存储，指的是使用顺序表（数组）存储二叉树。</p>
<p>需要注意的是，顺序存储只适用于完全二叉树。换句话说，只有完全二叉树才可以使用顺序表存储。因此，如果我们想顺序存储普通二叉树，需要提前将普通二叉树转化为完全二叉树。</p>
<blockquote>
<p>顺序存储二叉树应用实例：八大排序算法中的堆排序，就会使用到顺序存储二叉树。</p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ArrBinaryTreeDemo</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span> <span class="o">=</span> <span class="o">{</span><span class="n">1</span><span class="o">,</span> <span class="n">2</span><span class="o">,</span> <span class="n">3</span><span class="o">,</span> <span class="n">4</span><span class="o">,</span> <span class="n">5</span><span class="o">,</span> <span class="n">6</span><span class="o">,</span> <span class="n">7</span><span class="o">};</span>
        <span class="n">ArrBinaryTree</span> <span class="n">arrBinaryTree</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrBinaryTree</span><span class="o">();</span>
        <span class="n">arrBinaryTree</span><span class="o">.</span><span class="na">setArrayTree</span><span class="o">(</span><span class="n">arr</span><span class="o">);</span>
        <span class="n">arrBinaryTree</span><span class="o">.</span><span class="na">preArrBinaryTree</span><span class="o">(</span><span class="n">0</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">ArrBinaryTree</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setArrayTree</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">arr</span> <span class="o">=</span> <span class="n">arr</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">preArrBinaryTree</span><span class="o">(</span><span class="kt">int</span> <span class="n">index</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">arr</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">arr</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">index</span><span class="o">]);</span>

        <span class="kt">int</span> <span class="n">nextLeftIndex</span> <span class="o">=</span> <span class="o">(</span><span class="n">index</span> <span class="o">&lt;&lt;</span> <span class="n">1</span><span class="o">)</span> <span class="o">+</span> <span class="n">1</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">nextRightIndex</span> <span class="o">=</span> <span class="o">(</span><span class="n">index</span> <span class="o">&lt;&lt;</span> <span class="n">1</span><span class="o">)</span> <span class="o">+</span> <span class="n">2</span><span class="o">;</span>

        <span class="k">if</span> <span class="o">(</span><span class="n">nextLeftIndex</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="o">.</span><span class="na">length</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">preArrBinaryTree</span><span class="o">(</span><span class="n">nextLeftIndex</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="k">if</span> <span class="o">(</span><span class="n">nextRightIndex</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="o">.</span><span class="na">length</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">preArrBinaryTree</span><span class="o">(</span><span class="n">nextRightIndex</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

<span class="o">}</span>
</code></pre></div><h4 id="线索化二叉树">线索化二叉树</h4>
<p>n 个结点的二叉链表中含有 n+1【公式 2n-(n-1)=n+1】个空指针域。利用二叉链表中的空指针域，存放指向该结点在 <strong>某种遍历次序</strong> 下的<strong>前驱</strong>和<strong>后继</strong>结点的指针，这种附加的指针称为&quot;线索&quot;。这种加上了线索的二叉链表称为线索链表，相应的二叉树称为线索二叉树。</p>
<p>根据线索性质的不同，线索二叉树可分为前序线索二叉树、中序线索二叉树和后序线索二叉树三种。</p>
<p>如图，按照前序遍历可以得到数组 {1, 2, 4, 5, 3, 6} 其中</p>
<ul>
<li>【2】的前驱结点为【1】，后继结点为【4】</li>
<li>【6】的前驱结点为【3】，后继结点为 null</li>
</ul>
<p><img src="/iblog/posts/annex/images/essays/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-024.png" alt="数据结构与算法-024"></p>
<p>中序线索化二叉树示意图</p>
<p><img src="/iblog/posts/annex/images/essays/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-025.png" alt="数据结构与算法-025"></p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ThreadedBinaryTreeDemo</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">BinaryTreeObj</span> <span class="n">root</span> <span class="o">=</span> <span class="k">new</span> <span class="n">BinaryTreeObj</span><span class="o">(</span><span class="n">1</span><span class="o">,</span><span class="s">&#34;zs&#34;</span><span class="o">);</span>
        <span class="n">BinaryTreeObj</span> <span class="n">binaryTreeObj2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">BinaryTreeObj</span><span class="o">(</span><span class="n">2</span><span class="o">,</span><span class="s">&#34;ls&#34;</span><span class="o">);</span>
        <span class="n">BinaryTreeObj</span> <span class="n">binaryTreeObj3</span> <span class="o">=</span> <span class="k">new</span> <span class="n">BinaryTreeObj</span><span class="o">(</span><span class="n">3</span><span class="o">,</span><span class="s">&#34;ww&#34;</span><span class="o">);</span>
        <span class="n">BinaryTreeObj</span> <span class="n">binaryTreeObj4</span> <span class="o">=</span> <span class="k">new</span> <span class="n">BinaryTreeObj</span><span class="o">(</span><span class="n">4</span><span class="o">,</span><span class="s">&#34;zq&#34;</span><span class="o">);</span>
        <span class="n">BinaryTreeObj</span> <span class="n">binaryTreeObj5</span> <span class="o">=</span> <span class="k">new</span> <span class="n">BinaryTreeObj</span><span class="o">(</span><span class="n">5</span><span class="o">,</span><span class="s">&#34;111&#34;</span><span class="o">);</span>

        <span class="n">root</span><span class="o">.</span><span class="na">setLeft</span><span class="o">(</span><span class="n">binaryTreeObj2</span><span class="o">);</span>
        <span class="n">root</span><span class="o">.</span><span class="na">setRight</span><span class="o">(</span><span class="n">binaryTreeObj3</span><span class="o">);</span>
        <span class="n">binaryTreeObj3</span><span class="o">.</span><span class="na">setLeft</span><span class="o">(</span><span class="n">binaryTreeObj4</span><span class="o">);</span>
        <span class="n">binaryTreeObj3</span><span class="o">.</span><span class="na">setRight</span><span class="o">(</span><span class="n">binaryTreeObj5</span><span class="o">);</span>

        <span class="c1">// 中序线索化二叉树
</span><span class="c1"></span>        <span class="n">ThreadedBinaryTree</span> <span class="n">threadedBinaryTree</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ThreadedBinaryTree</span><span class="o">();</span>
        <span class="n">threadedBinaryTree</span><span class="o">.</span><span class="na">infixThreadedBinaryTree</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>

        <span class="c1">// 遍历中序线索化二叉树
</span><span class="c1"></span>        <span class="n">threadedBinaryTree</span><span class="o">.</span><span class="na">forEachInfixThreadedBinaryTree</span><span class="o">(</span><span class="n">root</span><span class="o">);</span> <span class="c1">// 2,1,4,3,5
</span><span class="c1"></span>    <span class="o">}</span>
<span class="o">}</span>


<span class="kd">class</span> <span class="nc">ThreadedBinaryTree</span><span class="o">{</span>

    <span class="kd">private</span> <span class="n">BinaryTreeObj</span> <span class="n">pre</span><span class="o">;</span>

    <span class="c1">// 中序线索化二叉树
</span><span class="c1"></span>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">infixThreadedBinaryTree</span><span class="o">(</span><span class="n">BinaryTreeObj</span> <span class="n">node</span><span class="o">){</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">node</span> <span class="o">==</span> <span class="kc">null</span><span class="o">){</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">// 左递归线索化二叉树
</span><span class="c1"></span>        <span class="n">infixThreadedBinaryTree</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">getLeft</span><span class="o">());</span>

        <span class="c1">// 线索化核心代码 将左结点线索化
</span><span class="c1"></span>        <span class="k">if</span> <span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">getLeft</span><span class="o">()</span> <span class="o">==</span> <span class="kc">null</span><span class="o">){</span>
            <span class="n">node</span><span class="o">.</span><span class="na">setLeft</span><span class="o">(</span><span class="n">pre</span><span class="o">);</span>
            <span class="n">node</span><span class="o">.</span><span class="na">setLeftType</span><span class="o">(</span><span class="n">1</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="c1">// 将右结点线索化
</span><span class="c1"></span>        <span class="k">if</span> <span class="o">(</span><span class="n">pre</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">pre</span><span class="o">.</span><span class="na">getRight</span><span class="o">()</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">pre</span><span class="o">.</span><span class="na">setRight</span><span class="o">(</span><span class="n">node</span><span class="o">);</span>
            <span class="n">pre</span><span class="o">.</span><span class="na">setRightType</span><span class="o">(</span><span class="n">1</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="c1">// 使辅助结点指针指向当前结点
</span><span class="c1"></span>        <span class="n">pre</span> <span class="o">=</span> <span class="n">node</span><span class="o">;</span>

        <span class="c1">// 右递归线索化二叉树
</span><span class="c1"></span>        <span class="n">infixThreadedBinaryTree</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">getRight</span><span class="o">());</span>
    <span class="o">}</span>

    <span class="c1">// 遍历中序线索二叉树
</span><span class="c1"></span>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">forEachInfixThreadedBinaryTree</span><span class="o">(</span><span class="n">BinaryTreeObj</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 用辅助结点保存根结点
</span><span class="c1"></span>        <span class="n">BinaryTreeObj</span> <span class="n">node</span> <span class="o">=</span> <span class="n">root</span><span class="o">;</span>

        <span class="k">while</span> <span class="o">(</span><span class="n">node</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>

            <span class="c1">// 向左子树遍历,直到找到 leftType=1 的结点，等于1代表该结点为前驱结点
</span><span class="c1"></span>            <span class="k">while</span> <span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">getLeftType</span><span class="o">()</span> <span class="o">==</span> <span class="n">0</span><span class="o">){</span>
                <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">getLeft</span><span class="o">();</span>
            <span class="o">}</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">node</span><span class="o">);</span>

            <span class="c1">// 向右子树遍历，直到找到 rightType=0 的结点， 等于0代表该结点为右子树
</span><span class="c1"></span>            <span class="k">while</span> <span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">getRightType</span><span class="o">()</span> <span class="o">==</span> <span class="n">1</span><span class="o">){</span>
                <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">getRight</span><span class="o">();</span>
                <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">node</span><span class="o">);</span>
            <span class="o">}</span>

            <span class="c1">// node 结点向右边找
</span><span class="c1"></span>            <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">getRight</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">BinaryTreeObj</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="n">Integer</span> <span class="n">id</span><span class="o">;</span>
    <span class="kd">private</span> <span class="n">String</span> <span class="n">name</span><span class="o">;</span>

    <span class="kd">private</span> <span class="n">BinaryTreeObj</span> <span class="n">left</span><span class="o">;</span>
    <span class="kd">private</span> <span class="n">BinaryTreeObj</span> <span class="n">right</span><span class="o">;</span>

    <span class="c1">// 如果leftType == 0 表示指向的是左子树, 如果 1 则表示指向前驱结点
</span><span class="c1"></span>    <span class="c1">// 如果rightType == 0 表示指向是右子树, 如果 1 表示指向后继结点
</span><span class="c1"></span>    <span class="kd">private</span> <span class="kt">int</span> <span class="n">leftType</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">rightType</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">BinaryTreeObj</span><span class="o">(</span><span class="n">Integer</span> <span class="n">id</span><span class="o">,</span><span class="n">String</span> <span class="n">name</span><span class="o">){</span>
        <span class="k">this</span><span class="o">.</span><span class="na">id</span> <span class="o">=</span> <span class="n">id</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="n">String</span> <span class="nf">getName</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">name</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="n">Integer</span> <span class="nf">getId</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">id</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="n">BinaryTreeObj</span> <span class="nf">getLeft</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">left</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="n">BinaryTreeObj</span> <span class="nf">getRight</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">right</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setLeft</span><span class="o">(</span><span class="n">BinaryTreeObj</span> <span class="n">left</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">left</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setRight</span><span class="o">(</span><span class="n">BinaryTreeObj</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">right</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setLeftType</span><span class="o">(</span><span class="kt">int</span> <span class="n">leftType</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">leftType</span> <span class="o">=</span> <span class="n">leftType</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setRightType</span><span class="o">(</span><span class="kt">int</span> <span class="n">rightType</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">rightType</span> <span class="o">=</span> <span class="n">rightType</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">getLeftType</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">leftType</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">getRightType</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">rightType</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><h3 id="哈夫曼树">哈夫曼树</h3>
<p>哈夫曼树重要概念：</p>
<ul>
<li>路径和路径长度：在一棵树中，从一个结点往下可以达到的孩子或孙子结点之间的通路，称为路径。通路中分支的数目称为路径长度。若规定根结点的层数为 1，则从根结点到第 L 层结点的路径长度为 L-1；</li>
<li>结点的权及带权路径长度：若将树中结点赋给一个有着某种含义的数值，则这个数值称为该结点的权。结点的带权路径长度为：从根结点到该结点之间的路径长度与该结点的权的乘积；</li>
<li>树的带权路径长度：树的带权路径长度规定为所有叶子结点的带权路径长度之和，记为WPL(weighted path length) ，权值越大的结点离根结点越近的二叉树才是最优二叉树。WPL 最小的就是赫夫曼树；</li>
</ul>
<p>给定n个权值作为n个叶子结点，构造一棵二叉树，若该树的带权路径长度(wpl)达到最小，称这样的二叉树为最优二叉树，称为哈夫曼树，有些资料也译为赫夫曼树。</p>
<p><img src="/iblog/posts/annex/images/essays/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-028.png" alt="数据结构与算法-028"></p>
<p>WPL最小的就是哈夫曼树，如上图，中间的树就是哈夫曼树。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">HuffmanTreeDemo</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">HuffmanTree</span> <span class="n">huffmanTree</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HuffmanTree</span><span class="o">();</span>
        <span class="n">HuffmanTreeNode</span> <span class="n">root</span> <span class="o">=</span> <span class="n">huffmanTree</span><span class="o">.</span><span class="na">buildHuffmanTree</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="n">13</span><span class="o">,</span> <span class="n">7</span><span class="o">,</span> <span class="n">8</span><span class="o">,</span> <span class="n">3</span><span class="o">,</span> <span class="n">29</span><span class="o">,</span> <span class="n">6</span><span class="o">,</span> <span class="n">1</span><span class="o">});</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;前序遍历huffman树：&#34;</span><span class="o">);</span>
        <span class="n">huffmanTree</span><span class="o">.</span><span class="na">preOrder</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">HuffmanTree</span><span class="o">{</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">preOrder</span><span class="o">(</span><span class="n">HuffmanTreeNode</span> <span class="n">root</span><span class="o">){</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">root</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
            <span class="n">root</span><span class="o">.</span><span class="na">preOrder</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="n">HuffmanTreeNode</span> <span class="nf">buildHuffmanTree</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span><span class="o">){</span>

        <span class="n">List</span><span class="o">&lt;</span><span class="n">HuffmanTreeNode</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">value</span> <span class="o">:</span> <span class="n">arr</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="n">HuffmanTreeNode</span><span class="o">(</span><span class="n">value</span><span class="o">));</span>
        <span class="o">}</span>

        <span class="c1">// 如果集合中的元素大于1则继续循环
</span><span class="c1"></span>        <span class="k">while</span> <span class="o">(</span><span class="n">list</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">&gt;</span> <span class="n">1</span><span class="o">){</span>
            <span class="c1">// 从大到小进行排序
</span><span class="c1"></span>            <span class="n">Collections</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">list</span><span class="o">);</span>

            <span class="c1">// 获取集合中两个较小的元素进行构建 huffman 树
</span><span class="c1"></span>            <span class="n">HuffmanTreeNode</span> <span class="n">leftNode</span> <span class="o">=</span> <span class="n">list</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">0</span><span class="o">);</span>
            <span class="n">HuffmanTreeNode</span> <span class="n">rightNode</span> <span class="o">=</span> <span class="n">list</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">1</span><span class="o">);</span>
            <span class="n">HuffmanTreeNode</span> <span class="n">parentNode</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HuffmanTreeNode</span><span class="o">(</span><span class="n">leftNode</span><span class="o">.</span><span class="na">value</span> <span class="o">+</span> <span class="n">rightNode</span><span class="o">.</span><span class="na">value</span><span class="o">);</span>
            <span class="n">parentNode</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">leftNode</span><span class="o">;</span>
            <span class="n">parentNode</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">rightNode</span><span class="o">;</span>

            <span class="c1">// 构建后将 leftNode， rightNode 移除集合；将parentNode加入集合；然后重新排序
</span><span class="c1"></span>            <span class="n">list</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">leftNode</span><span class="o">);</span>
            <span class="n">list</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">rightNode</span><span class="o">);</span>
            <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">parentNode</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">list</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">0</span><span class="o">);</span>
    <span class="o">}</span>

<span class="o">}</span>


<span class="kd">class</span> <span class="nc">HuffmanTreeNode</span> <span class="kd">implements</span> <span class="n">Comparable</span><span class="o">&lt;</span><span class="n">HuffmanTreeNode</span><span class="o">&gt;{</span>
    <span class="kt">int</span> <span class="n">value</span><span class="o">;</span>
    <span class="n">HuffmanTreeNode</span> <span class="n">left</span><span class="o">;</span>
    <span class="n">HuffmanTreeNode</span> <span class="n">right</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">HuffmanTreeNode</span><span class="o">(</span><span class="kt">int</span> <span class="n">value</span><span class="o">){</span>
        <span class="k">this</span><span class="o">.</span><span class="na">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">preOrder</span><span class="o">(){</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">left</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
            <span class="k">this</span><span class="o">.</span><span class="na">left</span><span class="o">.</span><span class="na">preOrder</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">right</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
            <span class="k">this</span><span class="o">.</span><span class="na">right</span><span class="o">.</span><span class="na">preOrder</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">compareTo</span><span class="o">(</span><span class="n">HuffmanTreeNode</span> <span class="n">o</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 从小到大排序
</span><span class="c1"></span>        <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">value</span> <span class="o">-</span> <span class="n">o</span><span class="o">.</span><span class="na">value</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="n">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="s">&#34;HuffmanTreeNode{&#34;</span> <span class="o">+</span>
                <span class="s">&#34;value=&#34;</span> <span class="o">+</span> <span class="n">value</span> <span class="o">+</span>
                <span class="sc">&#39;}&#39;</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><h3 id="二叉排序树">二叉排序树</h3>
<p>二叉排序树（Binary Sort Tree），又称二叉查找树（Binary Search Tree），亦称二叉搜索树。是数据结构中的一类。在一般情况下，查询效率比链表结构要高。</p>
<p>对于二叉排序树的任何一个非叶子节点，要求左子节点的值比当前节点的值小，右子节点的值比当前节点的值大。如果有相同的值，可以将该节点放在左子节点或右子节点，二叉排序树的中序遍历为有序数列。</p>
<p><img src="/iblog/posts/annex/images/essays/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-030.png" alt="数据结构与算法-030"></p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">BinarySortTree</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="n">Node</span> <span class="n">root</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setRoot</span><span class="o">(</span><span class="n">Node</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">root</span> <span class="o">=</span> <span class="n">root</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// 添加结点
</span><span class="c1"></span>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">add</span><span class="o">(</span><span class="n">Node</span> <span class="n">node</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">this</span><span class="o">.</span><span class="na">root</span> <span class="o">=</span> <span class="n">node</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="k">this</span><span class="o">.</span><span class="na">root</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">node</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="c1">// 中序遍历
</span><span class="c1"></span>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">infixOrder</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">root</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">this</span><span class="o">.</span><span class="na">root</span><span class="o">.</span><span class="na">infixOrder</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="c1">// 查找结点
</span><span class="c1"></span>    <span class="kd">public</span> <span class="n">Node</span> <span class="nf">search</span><span class="o">(</span><span class="kt">int</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">root</span><span class="o">.</span><span class="na">search</span><span class="o">(</span><span class="n">target</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="c1">// 查找当前结点的父结点
</span><span class="c1"></span>    <span class="kd">public</span> <span class="n">Node</span> <span class="nf">searchParentNode</span><span class="o">(</span><span class="kt">int</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">root</span><span class="o">.</span><span class="na">searchParentNode</span><span class="o">(</span><span class="n">target</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="c1">// 删除结点
</span><span class="c1"></span>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">delNode</span><span class="o">(</span><span class="kt">int</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">// 如果删除的结点是根结点
</span><span class="c1"></span>        <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">root</span><span class="o">.</span><span class="na">left</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="k">this</span><span class="o">.</span><span class="na">root</span><span class="o">.</span><span class="na">right</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">this</span><span class="o">.</span><span class="na">root</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="n">Node</span> <span class="n">targetNode</span> <span class="o">=</span> <span class="n">search</span><span class="o">(</span><span class="n">target</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">targetNode</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">// 获取当前结点的父结点
</span><span class="c1"></span>        <span class="n">Node</span> <span class="n">parentNode</span> <span class="o">=</span> <span class="n">searchParentNode</span><span class="o">(</span><span class="n">target</span><span class="o">);</span>
        <span class="c1">// 删除的结点是叶子结点
</span><span class="c1"></span>        <span class="k">if</span> <span class="o">(</span><span class="n">targetNode</span><span class="o">.</span><span class="na">left</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">targetNode</span><span class="o">.</span><span class="na">right</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// 判断是左结点还是右结点
</span><span class="c1"></span>            <span class="k">if</span> <span class="o">(</span><span class="n">parentNode</span><span class="o">.</span><span class="na">left</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">parentNode</span><span class="o">.</span><span class="na">left</span><span class="o">.</span><span class="na">val</span> <span class="o">==</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">parentNode</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="n">parentNode</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// 删除的结点有两个结点
</span><span class="c1"></span>        <span class="k">if</span> <span class="o">(</span><span class="n">targetNode</span><span class="o">.</span><span class="na">left</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">targetNode</span><span class="o">.</span><span class="na">right</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// 从右子树找到最小的值并删除，将该值赋值给targetNode
</span><span class="c1"></span>            <span class="n">targetNode</span><span class="o">.</span><span class="na">val</span> <span class="o">=</span> <span class="n">delRightTreeMin</span><span class="o">(</span><span class="n">targetNode</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// 删除只有一颗子树的结点
</span><span class="c1"></span>        <span class="k">if</span> <span class="o">(</span><span class="n">targetNode</span><span class="o">.</span><span class="na">left</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span><span class="o">(</span><span class="n">parentNode</span> <span class="o">==</span> <span class="kc">null</span><span class="o">){</span>
                <span class="n">root</span> <span class="o">=</span> <span class="n">targetNode</span><span class="o">.</span><span class="na">left</span><span class="o">;</span>
                <span class="k">return</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="c1">// 当前结点存在左子树
</span><span class="c1"></span>            <span class="k">if</span> <span class="o">(</span><span class="n">parentNode</span><span class="o">.</span><span class="na">left</span><span class="o">.</span><span class="na">val</span> <span class="o">==</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">parentNode</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">targetNode</span><span class="o">.</span><span class="na">left</span><span class="o">;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="n">parentNode</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">targetNode</span><span class="o">.</span><span class="na">left</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">targetNode</span><span class="o">.</span><span class="na">right</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span><span class="o">(</span><span class="n">parentNode</span> <span class="o">==</span> <span class="kc">null</span><span class="o">){</span>
                <span class="n">root</span> <span class="o">=</span> <span class="n">targetNode</span><span class="o">.</span><span class="na">right</span><span class="o">;</span>
                <span class="k">return</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="c1">// 当前结点存在右子树
</span><span class="c1"></span>            <span class="k">if</span> <span class="o">(</span><span class="n">parentNode</span><span class="o">.</span><span class="na">right</span><span class="o">.</span><span class="na">val</span> <span class="o">==</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">parentNode</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">targetNode</span><span class="o">.</span><span class="na">right</span><span class="o">;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="n">parentNode</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">targetNode</span><span class="o">.</span><span class="na">right</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">int</span> <span class="nf">delRightTreeMin</span><span class="o">(</span><span class="n">Node</span> <span class="n">node</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">Node</span> <span class="n">target</span> <span class="o">=</span> <span class="n">node</span><span class="o">;</span>
        <span class="c1">// 循环的查找左子节点，就会找到最小值
</span><span class="c1"></span>        <span class="k">while</span> <span class="o">(</span><span class="n">target</span><span class="o">.</span><span class="na">left</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">target</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="na">left</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">// 此时 target就指向了最小结点 删除最小结点（该节点肯定是左叶子节点）
</span><span class="c1"></span>        <span class="n">delNode</span><span class="o">(</span><span class="n">target</span><span class="o">.</span><span class="na">val</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">target</span><span class="o">.</span><span class="na">val</span><span class="o">;</span>
    <span class="o">}</span>

<span class="o">}</span>

<span class="kd">class</span> <span class="nc">Node</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">val</span><span class="o">;</span>
    <span class="n">Node</span> <span class="n">left</span><span class="o">;</span>
    <span class="n">Node</span> <span class="n">right</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">Node</span><span class="o">(</span><span class="kt">int</span> <span class="n">val</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">val</span> <span class="o">=</span> <span class="n">val</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// 查找结点
</span><span class="c1"></span>    <span class="kd">public</span> <span class="n">Node</span> <span class="nf">search</span><span class="o">(</span><span class="kt">int</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">val</span> <span class="o">==</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="k">this</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">val</span> <span class="o">&gt;</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">left</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">left</span><span class="o">.</span><span class="na">search</span><span class="o">(</span><span class="n">target</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">right</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">right</span><span class="o">.</span><span class="na">search</span><span class="o">(</span><span class="n">target</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="c1">// 查找当前结点的父结点
</span><span class="c1"></span>    <span class="kd">public</span> <span class="n">Node</span> <span class="nf">searchParentNode</span><span class="o">(</span><span class="kt">int</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">((</span><span class="k">this</span><span class="o">.</span><span class="na">left</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="k">this</span><span class="o">.</span><span class="na">left</span><span class="o">.</span><span class="na">val</span> <span class="o">==</span> <span class="n">target</span><span class="o">)</span> <span class="o">||</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">right</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="k">this</span><span class="o">.</span><span class="na">right</span><span class="o">.</span><span class="na">val</span> <span class="o">==</span> <span class="n">target</span><span class="o">))</span> <span class="o">{</span>
            <span class="k">return</span> <span class="k">this</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">left</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="k">this</span><span class="o">.</span><span class="na">val</span> <span class="o">&gt;</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">left</span><span class="o">.</span><span class="na">searchParentNode</span><span class="o">(</span><span class="n">target</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">right</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="k">this</span><span class="o">.</span><span class="na">val</span> <span class="o">&lt;=</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">right</span><span class="o">.</span><span class="na">searchParentNode</span><span class="o">(</span><span class="n">target</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="c1">// 添加结点
</span><span class="c1"></span>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">add</span><span class="o">(</span><span class="n">Node</span> <span class="n">node</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">node</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">// 如果当前待插入结点的值小于当前结点，将其插入在左子树中
</span><span class="c1"></span>        <span class="k">if</span> <span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">val</span> <span class="o">&lt;</span> <span class="k">this</span><span class="o">.</span><span class="na">val</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">left</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">this</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">node</span><span class="o">;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="k">this</span><span class="o">.</span><span class="na">left</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">node</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="c1">// 将当前结点插入右子树
</span><span class="c1"></span>            <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">right</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">this</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">node</span><span class="o">;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="k">this</span><span class="o">.</span><span class="na">right</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">node</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="c1">// 中序遍历
</span><span class="c1"></span>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">infixOrder</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">left</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">this</span><span class="o">.</span><span class="na">left</span><span class="o">.</span><span class="na">infixOrder</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">right</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">this</span><span class="o">.</span><span class="na">right</span><span class="o">.</span><span class="na">infixOrder</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="n">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="s">&#34;Node{&#34;</span> <span class="o">+</span>
                <span class="s">&#34;val=&#34;</span> <span class="o">+</span> <span class="n">val</span> <span class="o">+</span>
                <span class="sc">&#39;}&#39;</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><h3 id="平衡二叉树">平衡二叉树</h3>
<p>二叉搜索树一定程度上可以提高搜索效率，但是当序列构造二叉搜索树，可能会将二叉树退化成单链表，从而降低搜索效率。</p>
<p>平衡二叉树也叫平衡二叉搜索树（Self-balancing binary search tree）又被称为AVL树，可以保证查询效率较高。</p>
<p>平衡二叉树的特点：</p>
<ul>
<li>平衡二叉树一定是二叉排序；</li>
<li>是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树；</li>
</ul>
<p><img src="/iblog/posts/annex/images/essays/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-031.gif" alt="数据结构与算法-031"></p>
<p>将有序二叉树变为平衡二叉树代码</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">AVLTreeDemo</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">AVLTree</span> <span class="n">avlTree</span> <span class="o">=</span> <span class="k">new</span> <span class="n">AVLTree</span><span class="o">();</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span> <span class="o">=</span> <span class="o">{</span><span class="n">10</span><span class="o">,</span> <span class="n">11</span><span class="o">,</span> <span class="n">7</span><span class="o">,</span> <span class="n">6</span><span class="o">,</span> <span class="n">8</span><span class="o">,</span> <span class="n">9</span> <span class="o">};</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">Node</span> <span class="n">node</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
            <span class="n">avlTree</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">node</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;当前树高度：&#34;</span><span class="o">+</span> <span class="n">avlTree</span><span class="o">.</span><span class="na">height</span><span class="o">());</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;当前根结点：&#34;</span> <span class="o">+</span> <span class="n">avlTree</span><span class="o">.</span><span class="na">getRoot</span><span class="o">());</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;当前左子树高度：&#34;</span><span class="o">+</span> <span class="n">avlTree</span><span class="o">.</span><span class="na">getRoot</span><span class="o">().</span><span class="na">leftHeight</span><span class="o">());</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;当前右子树高度：&#34;</span><span class="o">+</span> <span class="n">avlTree</span><span class="o">.</span><span class="na">getRoot</span><span class="o">().</span><span class="na">rightHeight</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">AVLTree</span><span class="o">{</span>
    <span class="kd">private</span> <span class="n">Node</span> <span class="n">root</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setRoot</span><span class="o">(</span><span class="n">Node</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">root</span> <span class="o">=</span> <span class="n">root</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="n">Node</span> <span class="nf">getRoot</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">root</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">height</span><span class="o">(){</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">){</span>
            <span class="k">return</span> <span class="n">0</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">root</span><span class="o">.</span><span class="na">height</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="c1">// 添加结点
</span><span class="c1"></span>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">add</span><span class="o">(</span><span class="n">Node</span> <span class="n">node</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">this</span><span class="o">.</span><span class="na">root</span> <span class="o">=</span> <span class="n">node</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="k">this</span><span class="o">.</span><span class="na">root</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">node</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="c1">// 中序遍历
</span><span class="c1"></span>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">infixOrder</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">root</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">this</span><span class="o">.</span><span class="na">root</span><span class="o">.</span><span class="na">infixOrder</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>

<span class="o">}</span>

<span class="kd">class</span> <span class="nc">Node</span> <span class="o">{</span>

    <span class="kt">int</span> <span class="n">value</span><span class="o">;</span>
    <span class="n">Node</span> <span class="n">left</span><span class="o">;</span>
    <span class="n">Node</span> <span class="n">right</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">Node</span><span class="o">(</span><span class="kt">int</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="c1">// 获取当前左子树的高度
</span><span class="c1"></span>    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">leftHeight</span><span class="o">(){</span>
        <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">left</span> <span class="o">==</span> <span class="kc">null</span><span class="o">){</span>
            <span class="k">return</span> <span class="n">0</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">left</span><span class="o">.</span><span class="na">height</span><span class="o">();</span>
    <span class="o">}</span>
    
    <span class="c1">// 获取当前结点右子树的高度
</span><span class="c1"></span>    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">rightHeight</span><span class="o">(){</span>
        <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">right</span> <span class="o">==</span> <span class="kc">null</span><span class="o">){</span>
            <span class="k">return</span> <span class="n">0</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">right</span><span class="o">.</span><span class="na">height</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="c1">// 获取当前结点的高度
</span><span class="c1"></span>    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">height</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span>
                <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">left</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">?</span> <span class="n">0</span> <span class="o">:</span> <span class="k">this</span><span class="o">.</span><span class="na">left</span><span class="o">.</span><span class="na">height</span><span class="o">()),</span>
                <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">right</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">?</span> <span class="n">0</span> <span class="o">:</span> <span class="k">this</span><span class="o">.</span><span class="na">right</span><span class="o">.</span><span class="na">height</span><span class="o">())</span>
        <span class="o">)</span> <span class="o">+</span> <span class="n">1</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// 左旋转
</span><span class="c1"></span>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">leftRote</span><span class="o">(){</span>
        <span class="c1">// 创建一个新结点，并设置值等于当前结点的值
</span><span class="c1"></span>        <span class="n">Node</span> <span class="n">newNode</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="o">(</span><span class="n">value</span><span class="o">);</span>
        <span class="c1">// 使新结点的左结点指向当前结点的左结点
</span><span class="c1"></span>        <span class="n">newNode</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">left</span><span class="o">;</span>
        <span class="c1">// 新结点的右结点指向当前结点的右结点的左结点
</span><span class="c1"></span>        <span class="n">newNode</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">right</span><span class="o">.</span><span class="na">left</span><span class="o">;</span>
        <span class="c1">// 使当前结点的值指向新结点
</span><span class="c1"></span>        <span class="n">value</span> <span class="o">=</span> <span class="n">right</span><span class="o">.</span><span class="na">value</span><span class="o">;</span>
        <span class="c1">// 使当前结点的右结点指向当前结点的右结点的右结点
</span><span class="c1"></span>        <span class="n">right</span> <span class="o">=</span> <span class="n">right</span><span class="o">.</span><span class="na">right</span><span class="o">;</span>
        <span class="c1">// 使当前结点的左结点指向新结点
</span><span class="c1"></span>        <span class="n">left</span> <span class="o">=</span> <span class="n">newNode</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// 右旋转
</span><span class="c1"></span>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">rightRote</span><span class="o">(){</span>
        <span class="n">Node</span> <span class="n">newNode</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="o">(</span><span class="n">value</span><span class="o">);</span>
        <span class="n">newNode</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">right</span><span class="o">;</span>
        <span class="n">newNode</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">left</span><span class="o">.</span><span class="na">right</span><span class="o">;</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">left</span><span class="o">.</span><span class="na">value</span><span class="o">;</span>
        <span class="n">left</span> <span class="o">=</span> <span class="n">left</span><span class="o">.</span><span class="na">left</span><span class="o">;</span>
        <span class="n">right</span> <span class="o">=</span> <span class="n">newNode</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// 添加结点
</span><span class="c1"></span>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">add</span><span class="o">(</span><span class="n">Node</span> <span class="n">node</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">node</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">// 如果当前待插入结点的值小于当前结点，将其插入在左子树中
</span><span class="c1"></span>        <span class="k">if</span> <span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">value</span> <span class="o">&lt;</span> <span class="k">this</span><span class="o">.</span><span class="na">value</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">left</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">this</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">node</span><span class="o">;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="k">this</span><span class="o">.</span><span class="na">left</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">node</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="c1">// 将当前结点插入右子树
</span><span class="c1"></span>            <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">right</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">this</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">node</span><span class="o">;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="k">this</span><span class="o">.</span><span class="na">right</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">node</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="c1">// 如果左子树的高度-右子树的高度 &gt; 1 进行右旋转 反之进行左旋转
</span><span class="c1"></span>        <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">leftHeight</span><span class="o">()</span> <span class="o">-</span> <span class="k">this</span><span class="o">.</span><span class="na">rightHeight</span><span class="o">()</span> <span class="o">&gt;</span> <span class="n">1</span><span class="o">){</span>
            <span class="c1">// 如果当前结点的左子树的右子树的高度&gt;当前结点左子树的左子树的高度 则进行左旋转
</span><span class="c1"></span>            <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">left</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="k">this</span><span class="o">.</span><span class="na">left</span><span class="o">.</span><span class="na">rightHeight</span><span class="o">()</span> <span class="o">&gt;</span> <span class="k">this</span><span class="o">.</span><span class="na">left</span><span class="o">.</span><span class="na">leftHeight</span><span class="o">()){</span>
                <span class="c1">// 对当前结点的左结点进行左旋转
</span><span class="c1"></span>                <span class="k">this</span><span class="o">.</span><span class="na">left</span><span class="o">.</span><span class="na">leftRote</span><span class="o">();</span>
                <span class="c1">// 对当前结点右旋转
</span><span class="c1"></span>                <span class="k">this</span><span class="o">.</span><span class="na">rightRote</span><span class="o">();</span>
            <span class="o">}</span><span class="k">else</span> <span class="o">{</span>
                <span class="k">this</span><span class="o">.</span><span class="na">rightRote</span><span class="o">();</span>
            <span class="o">}</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">rightHeight</span><span class="o">()</span> <span class="o">-</span> <span class="k">this</span><span class="o">.</span><span class="na">leftHeight</span><span class="o">()</span> <span class="o">&gt;</span> <span class="n">1</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">right</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="k">this</span><span class="o">.</span><span class="na">right</span><span class="o">.</span><span class="na">leftHeight</span><span class="o">()</span> <span class="o">&gt;</span> <span class="k">this</span><span class="o">.</span><span class="na">right</span><span class="o">.</span><span class="na">rightHeight</span><span class="o">()){</span>
                <span class="c1">// 对当前结点的右结点进行右旋转
</span><span class="c1"></span>                <span class="k">this</span><span class="o">.</span><span class="na">right</span><span class="o">.</span><span class="na">rightRote</span><span class="o">();</span>
                <span class="c1">// 对当前结点进行左旋转
</span><span class="c1"></span>                <span class="k">this</span><span class="o">.</span><span class="na">leftRote</span><span class="o">();</span>
            <span class="o">}</span><span class="k">else</span> <span class="o">{</span>
                <span class="k">this</span><span class="o">.</span><span class="na">leftRote</span><span class="o">();</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="c1">// 中序遍历
</span><span class="c1"></span>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">infixOrder</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">left</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">this</span><span class="o">.</span><span class="na">left</span><span class="o">.</span><span class="na">infixOrder</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">right</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">this</span><span class="o">.</span><span class="na">right</span><span class="o">.</span><span class="na">infixOrder</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="n">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="s">&#34;Node{&#34;</span> <span class="o">+</span>
                <span class="s">&#34;value=&#34;</span> <span class="o">+</span> <span class="n">value</span> <span class="o">+</span>
                <span class="sc">&#39;}&#39;</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><h3 id="多路查找树">多路查找树</h3>
<p>在二叉树中，每个节点有数据项，最多有两个子节点。如果允许每个节点可以有更多的数据项和更多的子节点，就是多叉树（multiway tree）。多叉树通过重新组织节点，减少树的高度，能对二叉树进行优化。典型的多叉树有：2-3树、2-3-4树、红黑树和B树。</p>
<p>多叉树的前提是有序二叉树。</p>
<h4 id="2-3树">2-3树</h4>
<p>2-3树是由二节点和三节点构成的树，是最简单的B树结构，2-3树的所有叶子节点都在同一层(只要是B树都满足这个条件)。</p>
<ul>
<li>有两个子节点的节点叫二节点，二节点要么没有子节点，要么有两个子节点；</li>
<li>有三个子节点的节点叫三节点，三节点要么没有子节点，要么有三个子节点；</li>
</ul>
<p><img src="/iblog/posts/annex/images/essays/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-032.png" alt="数据结构与算法-032"></p>
<p>2-3-4树，与2-3树类似。</p>
<p><img src="/iblog/posts/annex/images/essays/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-033.png" alt="数据结构与算法-033"></p>
<h4 id="b树">B树</h4>
<p>B-tree 树即 B 树，B 即 Balanced ，平衡的意思。 B树通过重新组织节点，降低树的高度，并且减少i/o读写次数来提升效率。</p>
<p>文件系统及数据库系统的设计者利用了磁盘预读原理，将一个节点的大小设为等于一个页(页的大小通常为4k)，这样每个节点只需要一次I/O就可以完全载入。</p>
<blockquote>
<p>B树的阶（度）：节点的最多子节点个数。比如2-3树的阶是3，2-3-4树的阶是4。</p>
</blockquote>
<p>B树的搜索，从根结点开始，对结点内的关键字（有序）序列进行二分查找，如果命中则结束，否则进入查询关键字所属范围的儿子结点；重复，直到所对应的儿子指针为空，或已经是叶子结点。</p>
<p>B树的关键字集合分布在整颗树中，即叶子节点和非叶子节点都存放数据，搜索有可能在非叶子结点结束，其搜索性能等价于在关键字全集内做一次二分查找。</p>
<p><img src="/iblog/posts/annex/images/essays/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-034.png" alt="数据结构与算法-034"></p>
<h4 id="b树-1">B+树</h4>
<p>B+树是B树的变体，也是一种多路搜索树。</p>
<p>B+树的搜索与B树也基本相同，区别是B+树只有达到叶子结点才命中（B树可以在非叶子结点命中），其性能也等价于在关键字全集做一次二分查找。</p>
<p>B+树所有关键字都出现在叶子结点的链表中（即数据只能在叶子节点【也叫稠密索引】），且链表中的关键字(数据)恰好是有序的。所以不可能在非叶子结点命中。</p>
<p>B+树的所有叶结点构成一个有序链表，可以按照关键码排序的次序遍历全部记录， B+树更适合文件索引系统，B树和B+树各有自己的应用场景，不能说B+树完全比B树好，反之亦然。</p>
<p><img src="/iblog/posts/annex/images/essays/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-035.png" alt="数据结构与算法-035"></p>
<h4 id="b树-2">B*树</h4>
<p>B* 树是B+树的变体，在B+树的非根和非叶子结点再增加指向兄弟的指针。</p>
<p><img src="/iblog/posts/annex/images/essays/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-036.png" alt="数据结构与算法-036"></p>
<h3 id="图">图</h3>
<p>图是一种数据结构，其中结点可以具有零个或多个相邻元素。两个结点之间的连接称为边。结点也可以称为顶点。</p>
<p>如果给图的每条边规定一个方向，那么得到的图称为有向图。在有向图中，与一个节点相关联的边有出边和入边之分。相反，边没有方向的图称为无向图。</p>
<p><img src="/iblog/posts/annex/images/essays/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-037.png" alt="数据结构与算法-037"></p>
<p>可用二维数组表示图（邻接矩阵）；或链表表示（邻接表）。</p>
<p><img src="/iblog/posts/annex/images/essays/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-038.png" alt="数据结构与算法-038"></p>
<p><img src="/iblog/posts/annex/images/essays/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-039.png" alt="数据结构与算法-039"></p>
<p>用java模拟图，包括图的深度遍历，广度遍历。</p>
<p><img src="/iblog/posts/annex/images/essays/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-040.gif" alt="数据结构与算法-040"></p>
<p><img src="/iblog/posts/annex/images/essays/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-041.gif" alt="数据结构与算法-041"></p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">GraphDemo</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">String</span><span class="o">[]</span> <span class="n">vertexes</span> <span class="o">=</span> <span class="o">{</span><span class="s">&#34;A&#34;</span><span class="o">,</span> <span class="s">&#34;B&#34;</span><span class="o">,</span> <span class="s">&#34;C&#34;</span><span class="o">,</span> <span class="s">&#34;D&#34;</span><span class="o">,</span> <span class="s">&#34;E&#34;</span><span class="o">};</span>
    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">vertexes</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
    <span class="n">Graph</span> <span class="n">graph</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Graph</span><span class="o">(</span><span class="n">n</span><span class="o">);</span>
    <span class="k">for</span> <span class="o">(</span><span class="n">String</span> <span class="n">vertex</span> <span class="o">:</span> <span class="n">vertexes</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">graph</span><span class="o">.</span><span class="na">addVertex</span><span class="o">(</span><span class="n">vertex</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="n">graph</span><span class="o">.</span><span class="na">addEdge</span><span class="o">(</span><span class="n">0</span><span class="o">,</span> <span class="n">1</span><span class="o">,</span> <span class="n">1</span><span class="o">);</span> <span class="c1">// A-B
</span><span class="c1"></span>    <span class="n">graph</span><span class="o">.</span><span class="na">addEdge</span><span class="o">(</span><span class="n">0</span><span class="o">,</span> <span class="n">2</span><span class="o">,</span> <span class="n">1</span><span class="o">);</span> <span class="c1">// A-C
</span><span class="c1"></span>    <span class="n">graph</span><span class="o">.</span><span class="na">addEdge</span><span class="o">(</span><span class="n">1</span><span class="o">,</span> <span class="n">2</span><span class="o">,</span> <span class="n">1</span><span class="o">);</span> <span class="c1">// B-C
</span><span class="c1"></span>    <span class="n">graph</span><span class="o">.</span><span class="na">addEdge</span><span class="o">(</span><span class="n">1</span><span class="o">,</span> <span class="n">3</span><span class="o">,</span> <span class="n">1</span><span class="o">);</span> <span class="c1">// B-D
</span><span class="c1"></span>    <span class="n">graph</span><span class="o">.</span><span class="na">addEdge</span><span class="o">(</span><span class="n">1</span><span class="o">,</span> <span class="n">4</span><span class="o">,</span> <span class="n">1</span><span class="o">);</span> <span class="c1">// B-E
</span><span class="c1"></span>    <span class="c1">// 展示图转换的矩阵
</span><span class="c1"></span>    <span class="n">graph</span><span class="o">.</span><span class="na">showEdges</span><span class="o">();</span>
    <span class="c1">// 图的深度遍历
</span><span class="c1"></span>    <span class="n">graph</span><span class="o">.</span><span class="na">dfs</span><span class="o">();</span>
    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>
    <span class="c1">// 图的广度遍历
</span><span class="c1"></span>    <span class="n">graph</span><span class="o">.</span><span class="na">bfs</span><span class="o">();</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">Graph</span> <span class="o">{</span>

  <span class="c1">// 保存顶点
</span><span class="c1"></span>  <span class="kd">private</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">vertexList</span><span class="o">;</span>

  <span class="c1">// 保存边的数量
</span><span class="c1"></span>  <span class="kd">private</span> <span class="kt">int</span> <span class="n">sideNums</span><span class="o">;</span>

  <span class="c1">// 保存图的矩阵
</span><span class="c1"></span>  <span class="kd">private</span> <span class="kt">int</span><span class="o">[][]</span> <span class="n">edges</span><span class="o">;</span>

  <span class="kd">private</span> <span class="kt">boolean</span><span class="o">[]</span> <span class="n">isVisited</span><span class="o">;</span>

  <span class="kd">public</span> <span class="nf">Graph</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">vertexList</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;(</span><span class="n">n</span><span class="o">);</span>
    <span class="n">edges</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">][</span><span class="n">n</span><span class="o">];</span>
    <span class="n">sideNums</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="c1">// 获取第一个结点的下一个结点
</span><span class="c1"></span>  <span class="kd">private</span> <span class="kt">int</span> <span class="nf">getFirstNeighbor</span><span class="o">(</span><span class="kt">int</span> <span class="n">index</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">vertexList</span><span class="o">.</span><span class="na">size</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">edges</span><span class="o">[</span><span class="n">index</span><span class="o">][</span><span class="n">i</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">1</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">i</span><span class="o">;</span>
      <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="o">-</span><span class="n">1</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="c1">// 获取当前结点的下一个结点
</span><span class="c1"></span>  <span class="kd">private</span> <span class="kt">int</span> <span class="nf">getNextNeighbor</span><span class="o">(</span><span class="kt">int</span> <span class="n">vertex</span><span class="o">,</span> <span class="kt">int</span> <span class="n">index</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">vertex</span> <span class="o">+</span> <span class="n">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">vertexList</span><span class="o">.</span><span class="na">size</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">edges</span><span class="o">[</span><span class="n">index</span><span class="o">][</span><span class="n">i</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">1</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">i</span><span class="o">;</span>
      <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="o">-</span><span class="n">1</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="c1">// 图的深度遍历
</span><span class="c1"></span>  <span class="kd">private</span> <span class="kt">void</span> <span class="nf">dfs</span><span class="o">(</span><span class="kt">boolean</span><span class="o">[]</span> <span class="n">isVisited</span><span class="o">,</span> <span class="kt">int</span> <span class="n">i</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="n">getVertexValByIndex</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">+</span> <span class="s">&#34;-&gt;&#34;</span><span class="o">);</span>
    <span class="c1">// 将当前遍历后的顶点标记为true
</span><span class="c1"></span>    <span class="n">isVisited</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
    <span class="c1">// 获取当前结点的下一个结点的索引位置
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">firstNeighborIndex</span> <span class="o">=</span> <span class="n">getFirstNeighbor</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
    <span class="c1">// 如果 ！= -1 代表当前结点没有找到下一个结点，需要向下移动
</span><span class="c1"></span>    <span class="k">while</span> <span class="o">(</span><span class="n">firstNeighborIndex</span> <span class="o">!=</span> <span class="o">-</span><span class="n">1</span><span class="o">)</span> <span class="o">{</span>
      <span class="c1">// 判断该结点是否被遍历过
</span><span class="c1"></span>      <span class="k">if</span> <span class="o">(!</span><span class="n">isVisited</span><span class="o">[</span><span class="n">firstNeighborIndex</span><span class="o">])</span> <span class="o">{</span>
        <span class="n">dfs</span><span class="o">(</span><span class="n">isVisited</span><span class="o">,</span> <span class="n">firstNeighborIndex</span><span class="o">);</span>
      <span class="o">}</span>
      <span class="c1">// 当前结点向后移动，否则是死循环
</span><span class="c1"></span>      <span class="n">firstNeighborIndex</span> <span class="o">=</span> <span class="n">getNextNeighbor</span><span class="o">(</span><span class="n">firstNeighborIndex</span><span class="o">,</span> <span class="n">i</span><span class="o">);</span>
    <span class="o">}</span>
  <span class="o">}</span>

  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">dfs</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">isVisited</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="n">vertexList</span><span class="o">.</span><span class="na">size</span><span class="o">()];</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">getVertexCount</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
      <span class="k">if</span> <span class="o">(!</span><span class="n">isVisited</span><span class="o">[</span><span class="n">i</span><span class="o">])</span> <span class="o">{</span>
        <span class="n">dfs</span><span class="o">(</span><span class="n">isVisited</span><span class="o">,</span> <span class="n">i</span><span class="o">);</span>
      <span class="o">}</span>
    <span class="o">}</span>
  <span class="o">}</span>

  <span class="c1">// 一个结点的广度优先遍历
</span><span class="c1"></span>  <span class="kd">private</span> <span class="kt">void</span> <span class="nf">bfs</span><span class="o">(</span><span class="kt">boolean</span><span class="o">[]</span> <span class="n">isVisited</span><span class="o">,</span> <span class="kt">int</span> <span class="n">i</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 队列头结点下标索引
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">headIndex</span><span class="o">;</span>
    <span class="c1">// 相邻结点下标索引
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">neighborIndex</span><span class="o">;</span>
    <span class="n">LinkedList</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">queue</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LinkedList</span><span class="o">&lt;&gt;();</span>

    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="n">getVertexValByIndex</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">+</span> <span class="s">&#34;-&gt;&#34;</span><span class="o">);</span>
    <span class="n">isVisited</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
    <span class="n">queue</span><span class="o">.</span><span class="na">addLast</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>

    <span class="c1">// 如果队列不等于空 则需要遍历循环查找
</span><span class="c1"></span>    <span class="k">while</span> <span class="o">(!</span><span class="n">queue</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
      <span class="n">headIndex</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="na">removeFirst</span><span class="o">();</span>
      <span class="c1">// 得到第一个邻接结点的下标
</span><span class="c1"></span>      <span class="n">neighborIndex</span> <span class="o">=</span> <span class="n">getFirstNeighbor</span><span class="o">(</span><span class="n">headIndex</span><span class="o">);</span>
      <span class="k">while</span> <span class="o">(</span><span class="n">neighborIndex</span> <span class="o">!=</span> <span class="o">-</span><span class="n">1</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 是否访问过
</span><span class="c1"></span>        <span class="k">if</span> <span class="o">(!</span><span class="n">isVisited</span><span class="o">[</span><span class="n">neighborIndex</span><span class="o">])</span> <span class="o">{</span>
          <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="n">getVertexValByIndex</span><span class="o">(</span><span class="n">neighborIndex</span><span class="o">)</span> <span class="o">+</span> <span class="s">&#34;-&gt;&#34;</span><span class="o">);</span>
          <span class="n">isVisited</span><span class="o">[</span><span class="n">neighborIndex</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
          <span class="n">queue</span><span class="o">.</span><span class="na">addLast</span><span class="o">(</span><span class="n">neighborIndex</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="c1">// neighborIndex 向下找
</span><span class="c1"></span>        <span class="n">neighborIndex</span> <span class="o">=</span> <span class="n">getNextNeighbor</span><span class="o">(</span><span class="n">headIndex</span><span class="o">,</span> <span class="n">neighborIndex</span><span class="o">);</span>
      <span class="o">}</span>
    <span class="o">}</span>
  <span class="o">}</span>

  <span class="c1">// 广度优先遍历
</span><span class="c1"></span>  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">bfs</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">isVisited</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="n">vertexList</span><span class="o">.</span><span class="na">size</span><span class="o">()];</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">getVertexCount</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
      <span class="k">if</span> <span class="o">(!</span><span class="n">isVisited</span><span class="o">[</span><span class="n">i</span><span class="o">])</span> <span class="o">{</span>
        <span class="n">bfs</span><span class="o">(</span><span class="n">isVisited</span><span class="o">,</span> <span class="n">i</span><span class="o">);</span>
      <span class="o">}</span>
    <span class="o">}</span>
  <span class="o">}</span>

  <span class="c1">// 添加顶点
</span><span class="c1"></span>  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">addVertex</span><span class="o">(</span><span class="n">String</span> <span class="n">vertex</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">vertexList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">vertex</span><span class="o">);</span>
  <span class="o">}</span>

  <span class="c1">// 添加边
</span><span class="c1"></span>  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">addEdge</span><span class="o">(</span><span class="kt">int</span> <span class="n">vertex1</span><span class="o">,</span> <span class="kt">int</span> <span class="n">vertex2</span><span class="o">,</span> <span class="kt">int</span> <span class="n">weight</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">edges</span><span class="o">[</span><span class="n">vertex1</span><span class="o">][</span><span class="n">vertex2</span><span class="o">]</span> <span class="o">=</span> <span class="n">weight</span><span class="o">;</span>
    <span class="n">edges</span><span class="o">[</span><span class="n">vertex2</span><span class="o">][</span><span class="n">vertex1</span><span class="o">]</span> <span class="o">=</span> <span class="n">weight</span><span class="o">;</span>
    <span class="n">sideNums</span><span class="o">++;</span>
  <span class="o">}</span>

  <span class="c1">// 获取边的数量
</span><span class="c1"></span>  <span class="kd">public</span> <span class="kt">int</span> <span class="nf">getSideNums</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">sideNums</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="c1">// 遍历矩阵
</span><span class="c1"></span>  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">showEdges</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">edge</span> <span class="o">:</span> <span class="n">edges</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">edge</span><span class="o">));</span>
    <span class="o">}</span>
  <span class="o">}</span>

  <span class="c1">// 获取顶点数量
</span><span class="c1"></span>  <span class="kd">public</span> <span class="kt">int</span> <span class="nf">getVertexCount</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">vertexList</span><span class="o">.</span><span class="na">size</span><span class="o">();</span>
  <span class="o">}</span>

  <span class="c1">// 获取边之间的权值
</span><span class="c1"></span>  <span class="kd">public</span> <span class="kt">int</span> <span class="nf">getVertexWeight</span><span class="o">(</span><span class="kt">int</span> <span class="n">vertex1</span><span class="o">,</span> <span class="kt">int</span> <span class="n">vertex2</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">edges</span><span class="o">[</span><span class="n">vertex1</span><span class="o">][</span><span class="n">vertex2</span><span class="o">];</span>
  <span class="o">}</span>

  <span class="c1">// 根据下标获取结点的值
</span><span class="c1"></span>  <span class="kd">public</span> <span class="n">String</span> <span class="nf">getVertexValByIndex</span><span class="o">(</span><span class="kt">int</span> <span class="n">index</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">vertexList</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">index</span><span class="o">);</span>
  <span class="o">}</span>

<span class="o">}</span>
</code></pre></div><h2 id="算法">算法</h2>
<p>英文对应的单词是Algorithm，它的本意为：解决问题的方法，所以算法的直接理解就是解决问题的方法。在计算机领域定义的话就是：一系列解决问题的、清晰、可执行的计算机指令。</p>
<p>一个算法的优劣可以用空间复杂度与时间复杂度来衡量。</p>
<h3 id="算法复杂度">算法复杂度</h3>
<h4 id="时间复杂度">时间复杂度</h4>
<p>度量一个算法执行时间的两种方法：</p>
<ul>
<li>
<p>事后统计法：即直接运行程序，统计需要的时间和空间。但是，这种方法有两个问题：</p>
<ol>
<li>结果非常依赖于测试环境。比如，用i3和用i8运行程序所需的时间是不同的;</li>
<li>结果受测试规模的影响特别大。比如，对有序数组进行排序的时间比对逆序数组排序的时间短；对于小规模数据而言，插入排序所需时间比快速排序要短;</li>
</ol>
<p>所以，就需要有一种不用具体测试数据，也能估计算法执行效率的方法，就是算法复杂度分析，包括时间、空间复杂度分析。</p>
</li>
<li>
<p>事前估算法：通过分析某个算法的时间复杂度来判断那个算法更优;</p>
</li>
</ul>
<p>一般情况下，算法中的基本操作语句的重复执行次数是问题规模 n 的某个函数， 用<code>T(n)</code>表示，若有某个辅助函数<code>f(n)</code>，使得当 n 趋近于无穷大时，<code>T(n)/f(n)</code>的极限值为不等于零的常数，则称<code>f(n)</code>是<code>T(n)</code>的同数量级函数。记作 <code>T(n)=Ｏ(f(n))</code>， 称<code>Ｏ(f(n))</code>为算法的渐进时间复杂度，简称时间复杂度。</p>
<p>例如，T(n) = n + 1 与 T(n) = n 就是同数量级函数，因为 n+1/n 的极限值为不等于零的常数。
T(n) 不同，但时间复杂度可能相同: T(n)=n²+7n+6 与 T(n)=3n²+2n+2 它们的 T(n) 不同， 但时间复杂度相同，都为 O(n²)。</p>
<p>计算时间复杂度的方法：</p>
<ul>
<li>用常数 1 代替运行时间中的所有加法常数： T(n)=n²+7n+6 =&gt; T(n)=n²+7n+1</li>
<li>修改后的运行次数函数中，只保留最高阶项： T(n)=n²+7n+1 =&gt; T(n) = n²</li>
<li>去除最高阶项的系数：T(n) = n² =&gt; T(n) = n² =&gt; O(n²)</li>
</ul>
<hr>
<p><strong>时间频度</strong></p>
<p>一个算法花费的时间与算法中的语句的执行次数成正比例,哪个算法执行次数多,他花费的时间就多.一个算法中的语句执行次数称为语句频度或时间频度.记为T(n)。</p>
<p>随着时间的推移，一些复杂度花费时间无限接近：</p>
<ol>
<li>忽略常数项:</li>
</ol>
<ul>
<li>2n+20 和 2n 随着 n 变大，执行曲线无限接近,20 可以忽略</li>
<li>3n+10 和 3n 随着 n 变大，执行曲线无限接近,10 可以忽略</li>
</ul>
<ol start="2">
<li>忽略低次项:</li>
</ol>
<ul>
<li>2n²+3n+10 和 2n² 随着 n 变大, 执行曲线无限接近,可以忽略 3n+10</li>
<li>n²+5n+20 和 n² 随着 n 变大,执行曲线无限接近,可以忽略 5n+20</li>
</ul>
<ol start="3">
<li>忽略系数:</li>
</ol>
<ul>
<li>随着 n 值变大， 5n²+7n 和 3n² + 2n ，执行曲线重合, 说明这种情况下, 5 和 3 可以忽略</li>
<li>对于 n^3+5n 和 6n^3+4n，执行曲线分离，不能忽略系数，说明多少次方是关键</li>
</ul>
<hr>
<p><strong>常见的时间复杂度</strong></p>
<ul>
<li>
<p>常数阶 O(1): 无论代码执行了多少行，只要是没有循环等复杂结构，这个代码的时间复杂度就都是O(1)；</p>
<div class="highlight"><pre class="chroma"><code class="language-fallback" data-lang="fallback">int i = 1;
int j = 2;
++i;
j++;
int m = i + j;
</code></pre></div></li>
<li>
<p>对数阶 O(log2n)</p>
<p><img src="/iblog/posts/annex/images/essays/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-012.png" alt="数据结构与算法-012"></p>
<div class="highlight"><pre class="chroma"><code class="language-fallback" data-lang="fallback">int i = 1;
while(i&lt;n){
    i = i*2;
}
</code></pre></div></li>
<li>
<p>线性阶 O(n): 它消耗的时间是随着n的变化而变化的,与n成正比或反比；</p>
<div class="highlight"><pre class="chroma"><code class="language-fallback" data-lang="fallback">for(int i=1; i&lt;=n; ++i){
    j = i;
    j++;
}
</code></pre></div></li>
<li>
<p>线性对数阶 O(nlog2n): 将时间复杂度为O(logn)的代码循环n遍，那么它的时间复杂度就是 n * O(logN)，也就是了O(nlogN);</p>
<div class="highlight"><pre class="chroma"><code class="language-fallback" data-lang="fallback">for(int m=1; m&lt;=n; ++m){
    int i = 1;
    while(i&lt;n){
        i = i*2;
    }
}
</code></pre></div></li>
<li>
<p>平方阶 O(n^2): 如果把 O(n) 的代码再嵌套循环一遍，它的时间复杂度就是 O(n²)，这段代码其实就是嵌套了2层n循环，它的时间复杂度就是 <code>O(n*n)</code>，即 O(n²) 如果将其中一层循环的n改成m，那它的时间复杂度就变成了 <code>O(m*n)</code>;</p>
<div class="highlight"><pre class="chroma"><code class="language-fallback" data-lang="fallback">for(int i=1; i&lt;=n; ++i){
    for(int j=1; j&lt;=n; ++j){
        j=i;
    }
}
</code></pre></div></li>
<li>
<p>立方阶 O(n^3)</p>
<div class="highlight"><pre class="chroma"><code class="language-fallback" data-lang="fallback">for(int i=1; i&lt;=n; ++i){
    for(int j=1; j&lt;=n; ++j){
        for(int x=1; x&lt;=n; ++x){
            int m = 0;
            i = x+j;
        }
    }
}
</code></pre></div></li>
<li>
<p>k 次方阶 O(n^k)</p>
</li>
<li>
<p>指数阶 O(2^n)</p>
</li>
</ul>
<p>常见的算法时间复杂度由小到大依次为：</p>
<div class="highlight"><pre class="chroma"><code class="language-fallback" data-lang="fallback">Ο (1)＜Ο (log2n)＜Ο (n)＜Ο (nlog2n)＜Ο (n2)＜Ο (n3)＜ Ο (nk) ＜ Ο (2n)
</code></pre></div><p>随着问题规模 n 的不断增大，上述时间复杂度不断增大，算法的执行效率越低。</p>
<h4 id="空间复杂度">空间复杂度</h4>
<p>类似于时间复杂度的讨论，一个算法的空间复杂度(Space Complexity)定义为该算法所耗费的存储空间，它也是问题规模 n 的函数。</p>
<p>空间复杂度全称为渐进空间复杂度，是对一个算法在运行过程中临时占用存储空间大小的量度。 有的算法需要占用的临时工作单元数与解决问题的规模 n 有关， 它随着 n 的增大而增大， 当 n 较大时， 将占用较多的存储单元， 例如快速排序和归并排序算法, 基数排序就属于这种情况
在做算法分析时， 主要讨论的是时间复杂度。 从用户使用体验上看， 更看重的程序执行的速度。 一些缓存产品(redis, memcache)和算法(基数排序)本质就是用空间换时间</p>
<p>空间复杂度较为简单，常见的空间复杂度为 O(1)，O(n) 和 O(n ^ 2)。</p>
<h3 id="递归">递归</h3>
<p>递归就是方法自己调用自己，每次调用时传入不同的变量，递归有助于编程者解决复杂的问题，同时可以让代码变得简洁。</p>
<p><strong>递归能解决什么问题？</strong></p>
<ul>
<li>各种数学问题如: 8 皇后问题，汉诺塔，阶乘问题，迷宫问题，球和篮子的问题(google 编程大赛)；</li>
<li>各种算法中也会使用到递归， 比如快排， 归并排序， 二分查找， 分治算法等；</li>
<li>用栈解决的问题，使用递归替换代码更佳简洁；</li>
</ul>
<p>使用递归遵守的规则：</p>
<ul>
<li>执行一个方法时，就创建一个新的受保护的独立空间(一个线程有自己独立的一个栈空间，每个方法调用对应着一个栈帧)；</li>
<li>方法的局部变量是独立的，不会相互影响；</li>
<li>如果方法中使用的是引用类型变量，就会共享该引用类型的数据，比如数组；</li>
<li>递归必须向退出递归的条件逼近，否则就是无限递归，出现 StackOverflowError；</li>
<li>当一个方法执行完毕，或者遇到return，就会返回，遵守谁调用，就将结果返回给谁，同时当方法执行完毕或者返回时，该方法也就执行完毕；</li>
</ul>
<h4 id="迷宫回溯">迷宫回溯</h4>
<p>迷宫回溯问题，寻找最短路径可以通过改变策略，将每个策略都经过的路保存在集合中，最后看哪个集合最小即最小路径。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyTest</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">Mazeback</span> <span class="n">mazeback</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Mazeback</span><span class="o">();</span>

        <span class="kt">int</span><span class="o">[][]</span> <span class="n">map</span> <span class="o">=</span> <span class="n">mazeback</span><span class="o">.</span><span class="na">createMap</span><span class="o">();</span>
        <span class="n">mazeback</span><span class="o">.</span><span class="na">list</span><span class="o">(</span><span class="n">map</span><span class="o">);</span>

        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;自动寻找路线：&#34;</span><span class="o">);</span>

        <span class="n">mazeback</span><span class="o">.</span><span class="na">setWay</span><span class="o">(</span><span class="n">map</span><span class="o">,</span> <span class="n">1</span><span class="o">,</span> <span class="n">1</span><span class="o">);</span>
        <span class="n">mazeback</span><span class="o">.</span><span class="na">list</span><span class="o">(</span><span class="n">map</span><span class="o">);</span>
    <span class="o">}</span>

<span class="o">}</span>


<span class="kd">class</span> <span class="nc">Mazeback</span> <span class="o">{</span>

    <span class="c1">// 创建地图
</span><span class="c1"></span>    <span class="kd">public</span> <span class="kt">int</span><span class="o">[][]</span> <span class="nf">createMap</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">// 地图
</span><span class="c1"></span>        <span class="kt">int</span><span class="o">[][]</span> <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">7</span><span class="o">][</span><span class="n">8</span><span class="o">];</span>

        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">7</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">map</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">1</span><span class="o">;</span>
            <span class="n">map</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">7</span><span class="o">]</span> <span class="o">=</span> <span class="n">1</span><span class="o">;</span>
            <span class="n">map</span><span class="o">[</span><span class="n">6</span><span class="o">][</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">1</span><span class="o">;</span>
            <span class="n">map</span><span class="o">[</span><span class="n">0</span><span class="o">][</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">1</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="n">map</span><span class="o">[</span><span class="n">3</span><span class="o">][</span><span class="n">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">1</span><span class="o">;</span>
        <span class="n">map</span><span class="o">[</span><span class="n">3</span><span class="o">][</span><span class="n">2</span><span class="o">]</span> <span class="o">=</span> <span class="n">1</span><span class="o">;</span>
        <span class="k">return</span> <span class="n">map</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// 遍历地图
</span><span class="c1"></span>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">list</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">map</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">map</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">map</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">length</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="n">map</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">+</span> <span class="s">&#34;&#34;</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="c1">// 寻找路径
</span><span class="c1"></span>    <span class="c1">// 1：墙；2：通路，3：死路
</span><span class="c1"></span>    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">setWay</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">map</span><span class="o">,</span> <span class="kt">int</span> <span class="n">row</span><span class="o">,</span> <span class="kt">int</span> <span class="n">column</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">map</span><span class="o">[</span><span class="n">5</span><span class="o">][</span><span class="n">6</span><span class="o">]</span> <span class="o">==</span> <span class="n">2</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">map</span><span class="o">[</span><span class="n">row</span><span class="o">][</span><span class="n">column</span><span class="o">]</span> <span class="o">==</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span>

            <span class="c1">// 先假设是通路
</span><span class="c1"></span>            <span class="n">map</span><span class="o">[</span><span class="n">row</span><span class="o">][</span><span class="n">column</span><span class="o">]</span> <span class="o">=</span> <span class="n">2</span><span class="o">;</span>

            <span class="c1">// 寻找路径顺序：下，右，上，左
</span><span class="c1"></span>            <span class="k">if</span> <span class="o">(</span><span class="n">setWay</span><span class="o">(</span><span class="n">map</span><span class="o">,</span> <span class="n">row</span> <span class="o">+</span> <span class="n">1</span><span class="o">,</span> <span class="n">column</span><span class="o">))</span> <span class="o">{</span>
                <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">setWay</span><span class="o">(</span><span class="n">map</span><span class="o">,</span> <span class="n">row</span><span class="o">,</span> <span class="n">column</span> <span class="o">+</span> <span class="n">1</span><span class="o">))</span> <span class="o">{</span>
                <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">setWay</span><span class="o">(</span><span class="n">map</span><span class="o">,</span> <span class="n">row</span> <span class="o">-</span> <span class="n">1</span><span class="o">,</span> <span class="n">column</span><span class="o">))</span> <span class="o">{</span>
                <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">setWay</span><span class="o">(</span><span class="n">map</span><span class="o">,</span> <span class="n">row</span><span class="o">,</span> <span class="n">column</span> <span class="o">-</span> <span class="n">1</span><span class="o">))</span> <span class="o">{</span>
                <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="c1">// 当标记为3时，说明是死路走不通
</span><span class="c1"></span>                <span class="n">map</span><span class="o">[</span><span class="n">row</span><span class="o">][</span><span class="n">column</span><span class="o">]</span> <span class="o">=</span> <span class="n">3</span><span class="o">;</span>
                <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>

<span class="o">}</span>
</code></pre></div><h4 id="八皇后问题">八皇后问题</h4>
<p>八皇后问题，是一个古老而著名的问题，是回溯算法的典型案例。该问题是国际西洋棋棋手马克斯·贝瑟尔于1848 年提出：在 8 × 8 格的国际象棋上摆放八个皇后，使其不能互相攻击， 即： 任意两个皇后都不能处于同一行、同一列或同一斜线上，问有多少种摆法。</p>
<blockquote>
<p>八皇后问题共92中解法</p>
</blockquote>
<p><img src="/iblog/posts/annex/images/essays/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-010.png" alt="数据结构与算法-010"></p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyTest</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">EightQueens</span> <span class="n">eightQueens</span> <span class="o">=</span> <span class="k">new</span> <span class="n">EightQueens</span><span class="o">();</span>
        <span class="n">eightQueens</span><span class="o">.</span><span class="na">exec</span><span class="o">(</span><span class="n">0</span><span class="o">);</span>
    <span class="o">}</span>

<span class="o">}</span>


<span class="kd">class</span> <span class="nc">EightQueens</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span><span class="o">;</span>

    <span class="kd">private</span> <span class="kt">int</span> <span class="n">max</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">EightQueens</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">max</span> <span class="o">=</span> <span class="n">8</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">arr</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">max</span><span class="o">];</span>
    <span class="o">}</span>


    <span class="c1">// 算法
</span><span class="c1"></span>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">exec</span><span class="o">(</span><span class="kt">int</span> <span class="n">position</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 如果当前位置等于max说明解法成立，需要回溯
</span><span class="c1"></span>        <span class="k">if</span> <span class="o">(</span><span class="n">position</span> <span class="o">==</span> <span class="n">max</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">print</span><span class="o">();</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">max</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">arr</span><span class="o">[</span><span class="n">position</span><span class="o">]</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">check</span><span class="o">(</span><span class="n">position</span><span class="o">)){</span>
                <span class="n">exec</span><span class="o">(</span><span class="n">position</span> <span class="o">+</span> <span class="n">1</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>


    <span class="c1">// 判断皇后位置是否冲突
</span><span class="c1"></span>    <span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">check</span><span class="o">(</span><span class="kt">int</span> <span class="n">position</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">position</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// 判断是否在同一列或在同一斜线上
</span><span class="c1"></span>            <span class="k">if</span> <span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">position</span><span class="o">]</span> <span class="o">==</span> <span class="n">arr</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">||</span> <span class="n">Math</span><span class="o">.</span><span class="na">abs</span><span class="o">(</span><span class="n">position</span> <span class="o">-</span> <span class="n">j</span><span class="o">)</span> <span class="o">==</span> <span class="n">Math</span><span class="o">.</span><span class="na">abs</span><span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">position</span><span class="o">]</span> <span class="o">-</span> <span class="n">arr</span><span class="o">[</span><span class="n">j</span><span class="o">]))</span> <span class="o">{</span>
               <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>


    <span class="c1">// 打印数组
</span><span class="c1"></span>    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">print</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+</span> <span class="s">&#34;&#34;</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>
    <span class="o">}</span>

<span class="o">}</span>
</code></pre></div><h3 id="排序算法">排序算法</h3>
<p>排序也称排序算法，是将一组数据，依指定的顺序进行排列的过程。</p>
<p>排序算法分类：</p>
<ul>
<li>内部排序：指将需要处理的所有数据都加载到内部存储器(内存)中进行排序；</li>
<li>外部排序法：数据量过大，无法全部加载到内存中，需要借助外部存储(文件等)进行排序；</li>
</ul>
<p><img src="/iblog/posts/annex/images/essays/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-011.png" alt="数据结构与算法-011"></p>
<p>常见内排序算法复杂度比较</p>
<p><img src="/iblog/posts/annex/images/essays/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-013.png" alt="数据结构与算法-013"></p>
<p>名词解释：</p>
<ul>
<li>n：数据规模</li>
<li>k：&ldquo;桶&quot;的个数</li>
<li>In-place：占用常数内存，不占用额外内存</li>
<li>Out-place：占用额外内存</li>
<li>稳定性：排序后两个相等键值的顺序和排序之前它们的顺序相同，不稳定性则相反</li>
<li>时间复杂度：一个算法执行所耗费的时间</li>
<li>空间复杂度：运行完一个程序所需内存的大小</li>
</ul>
<h4 id="冒泡排序">冒泡排序</h4>
<p>冒泡排序的基本思想是：通过对待排序序列从前向后（从下标较小的元素开始），依次比较相邻元素的值，若发现逆序（当前值大于比较的值）则交换，使值较大的元素逐渐从前移向后部，就像水底下的气泡一样逐渐向上冒。</p>
<p><img src="/iblog/posts/annex/images/essays/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-014.gif" alt="数据结构与算法-014"></p>
<p>优化：因为排序的过程中， 各元素不断接近自己的位置，如果一趟比较下来没有进行过交换，就说明序列有序，因此要在排序过程中设置一个标志 flag 判断元素是否进行过交换。 从而减少不必要的比较。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">BubbleSorting</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">sort</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">data</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="n">1</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">tmp</span><span class="o">;</span>
        <span class="kt">boolean</span> <span class="n">flag</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>

        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span><span class="n">len</span><span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">len</span> <span class="o">-</span> <span class="n">i</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                <span class="c1">// 将当前值与next值进行比较，如果当前值大于next值则交换两者之间的位置
</span><span class="c1"></span>                <span class="k">if</span> <span class="o">(</span><span class="n">data</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">data</span><span class="o">[</span><span class="n">j</span><span class="o">+</span><span class="n">1</span><span class="o">]){</span>
                    <span class="n">flag</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
                    <span class="n">tmp</span> <span class="o">=</span> <span class="n">data</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>
                    <span class="n">data</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">data</span><span class="o">[</span><span class="n">j</span><span class="o">+</span><span class="n">1</span><span class="o">];</span>
                    <span class="n">data</span><span class="o">[</span><span class="n">j</span><span class="o">+</span><span class="n">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>

            <span class="c1">// 加入标志为进行判断，如果整个循环下啦都没有交换位置，说明该数组是有序的，所以直接退出循环
</span><span class="c1"></span>            <span class="k">if</span> <span class="o">(!</span><span class="n">flag</span><span class="o">){</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="o">}</span><span class="k">else</span> <span class="o">{</span>
                <span class="n">flag</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">data</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><h4 id="选择排序">选择排序</h4>
<p>选择式排序也属于内部排序法，是从欲排序的数据中，按指定的规则选出某一元素，再依规定交换位置后达到排序的目的。</p>
<p>首先在未排序序列中找到最小元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小元素，然后放到排序序列末尾。以此类推，直到所有元素均排序完毕。</p>
<p><img src="/iblog/posts/annex/images/essays/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-015.gif" alt="数据结构与算法-015"></p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">SelectSorting</span><span class="o">{</span>

    <span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">sort</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">data</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">data</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++){</span>

            <span class="kt">int</span> <span class="n">min</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>

            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="o">+</span><span class="n">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">data</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                <span class="c1">// 如果next值大于当前值，则记录该值和该值的位置，等全部比较完毕后，将最大的一个与数据的末尾进行替换
</span><span class="c1"></span>                <span class="k">if</span> <span class="o">(</span><span class="n">data</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">data</span><span class="o">[</span><span class="n">j</span><span class="o">]){</span>
                    <span class="n">min</span> <span class="o">=</span> <span class="n">j</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>

            <span class="c1">// 将每次循环中的最小的值，调整到最前面
</span><span class="c1"></span>            <span class="k">if</span> <span class="o">(</span><span class="n">min</span> <span class="o">!=</span> <span class="n">i</span><span class="o">){</span>
                <span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">data</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
                <span class="n">data</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">data</span><span class="o">[</span><span class="n">min</span><span class="o">];</span>
                <span class="n">data</span><span class="o">[</span><span class="n">min</span><span class="o">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">data</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><h4 id="插入排序">插入排序</h4>
<p>插入排序（Insertion Sorting） 的基本思想是：把 n 个待排序的元素看成为一个有序表和一个无序表;</p>
<p>开始时有序表中只包含一个元素，无序表中包含有 n-1 个元素，排序过程中每次从无序表中取出第一个元素，把它的排序码依次与有序表元素的排序码进行比较， 将它插入到有序表中的适当位置，使之成为新的有序表。</p>
<p>对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</p>
<p><img src="/iblog/posts/annex/images/essays/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-016.gif" alt="数据结构与算法-016"></p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">InsertSorting</span><span class="o">{</span>

    <span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">sort</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">data</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">data</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
            <span class="c1">// 如果当前要插入的值 data[i] &gt; 有序队列中最后一个，则将其直接插入到最后一个
</span><span class="c1"></span>            <span class="k">if</span> <span class="o">(</span><span class="n">data</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">data</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">1</span><span class="o">]){</span>
                <span class="k">continue</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">data</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="n">1</span><span class="o">;</span>
            <span class="c1">// 如果当前位置的值【tmp】小于 上一个位置的值【data[index]】说明当前值需要插入到有序队列中
</span><span class="c1"></span>            <span class="k">while</span> <span class="o">(</span><span class="n">index</span> <span class="o">&gt;=</span> <span class="n">0</span> <span class="o">&amp;&amp;</span> <span class="n">tmp</span> <span class="o">&lt;</span> <span class="n">data</span><span class="o">[</span><span class="n">index</span><span class="o">]){</span>
                <span class="n">data</span><span class="o">[</span><span class="n">index</span> <span class="o">+</span> <span class="n">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">data</span><span class="o">[</span><span class="n">index</span><span class="o">];</span>
                <span class="n">index</span><span class="o">--;</span>
            <span class="o">}</span>
            <span class="n">data</span><span class="o">[</span><span class="n">index</span> <span class="o">+</span> <span class="n">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">data</span><span class="o">;</span>
    <span class="o">}</span>

<span class="o">}</span>
</code></pre></div><h4 id="希尔排序">希尔排序</h4>
<p>希尔排序是希尔（Donald Shell） 于1959年提出的一种排序算法。希尔排序也是一种插入排序，它是简单插入排序经过改进之后的一个更高效的版本，也称为缩小增量排序。</p>
<p>希尔排序按照增量将数组进行分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。</p>
<p><img src="/iblog/posts/annex/images/essays/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-017.gif" alt="数据结构与算法-017"></p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">ShellSorting</span><span class="o">{</span>

    <span class="c1">// 希尔排序，交换法
</span><span class="c1"></span>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">sortSwap</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">data</span><span class="o">){</span>
        <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>

        <span class="c1">// 将数据分组，分组数量：data.length/2
</span><span class="c1"></span>        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">gap</span> <span class="o">=</span> <span class="n">size</span> <span class="o">&gt;&gt;</span> <span class="n">1</span><span class="o">;</span> <span class="n">gap</span> <span class="o">&gt;</span> <span class="n">0</span><span class="o">;</span> <span class="n">gap</span> <span class="o">&gt;&gt;=</span> <span class="n">1</span><span class="o">){</span>

            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">gap</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                <span class="c1">// 遍历每组中的元素
</span><span class="c1"></span>                <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="n">gap</span><span class="o">;</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="n">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">-=</span> <span class="n">gap</span><span class="o">)</span> <span class="o">{</span>
                    <span class="c1">// 将每组中的元素进行排序（交换元素）
</span><span class="c1"></span>                    <span class="k">if</span> <span class="o">(</span><span class="n">data</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">data</span><span class="o">[</span><span class="n">j</span> <span class="o">+</span> <span class="n">gap</span><span class="o">]){</span>
                        <span class="n">tmp</span> <span class="o">=</span> <span class="n">data</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>
                        <span class="n">data</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">data</span><span class="o">[</span><span class="n">j</span><span class="o">+</span><span class="n">gap</span><span class="o">];</span>
                        <span class="n">data</span><span class="o">[</span><span class="n">j</span><span class="o">+</span><span class="n">gap</span><span class="o">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">;</span>
                    <span class="o">}</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="c1">// 插入法，融入 插入排序 思想
</span><span class="c1"></span>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">sort</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">data</span><span class="o">){</span>
        <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>

        <span class="c1">// 将数据分组，分组数量：data.length/2
</span><span class="c1"></span>        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">gap</span> <span class="o">=</span> <span class="n">size</span> <span class="o">&gt;&gt;</span> <span class="n">1</span><span class="o">;</span> <span class="n">gap</span> <span class="o">&gt;</span> <span class="n">0</span><span class="o">;</span> <span class="n">gap</span> <span class="o">&gt;&gt;=</span> <span class="n">1</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">gap</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>

                <span class="n">tmp</span> <span class="o">=</span> <span class="n">data</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
                <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>

                <span class="c1">// 如果当前位置的值【tmp】小于 上一个位置的值【data[index]】说明当前值需要插入到有序队列中
</span><span class="c1"></span>                <span class="k">while</span> <span class="o">(</span><span class="n">index</span> <span class="o">-</span> <span class="n">gap</span> <span class="o">&gt;=</span> <span class="n">0</span> <span class="o">&amp;&amp;</span> <span class="n">tmp</span> <span class="o">&lt;</span> <span class="n">data</span><span class="o">[</span><span class="n">index</span> <span class="o">-</span> <span class="n">gap</span><span class="o">]){</span>
                    <span class="n">data</span><span class="o">[</span><span class="n">index</span><span class="o">]</span> <span class="o">=</span> <span class="n">data</span><span class="o">[</span><span class="n">index</span> <span class="o">-</span> <span class="n">gap</span><span class="o">];</span>
                    <span class="n">index</span> <span class="o">-=</span> <span class="n">gap</span><span class="o">;</span>
                <span class="o">}</span>
                <span class="n">data</span><span class="o">[</span><span class="n">index</span><span class="o">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
    
<span class="o">}</span>
</code></pre></div><h4 id="快速排序">快速排序</h4>
<p>快速排序是由东尼·霍尔所发展的一种排序算法。在平均状况下，排序n个项目要 Ο(nlogn) 次比较。在最坏状况下则需要 Ο(n2) 次比较，但这种状况并不常见。事实上，快速排序通常明显比其他 Ο(nlogn) 算法更快，因为它的内部循环可以在大部分的架构上很有效率地被实现出来。</p>
<p>快速排序又是一种分而治之思想在排序算法上的典型应用。本质上来看，快速排序应该算是在冒泡排序基础上的递归分治法。快速排序思路：</p>
<ul>
<li>选定pivot基准数</li>
<li>将大于pivot基准数放在基准数右边</li>
<li>将小于pivot基准数放在基准数左边</li>
</ul>
<p><img src="/iblog/posts/annex/images/essays/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-018.gif" alt="数据结构与算法-018"></p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">QuickSorting</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">sort</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">data</span><span class="o">,</span> <span class="kt">int</span> <span class="n">l</span><span class="o">,</span> <span class="kt">int</span> <span class="n">r</span><span class="o">)</span> <span class="o">{</span>

        <span class="c1">// 如果开始的位置大于等于结束的位置则不用进行比较直接退出
</span><span class="c1"></span>        <span class="k">if</span> <span class="o">(</span><span class="n">l</span> <span class="o">&gt;=</span> <span class="n">r</span><span class="o">){</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="n">l</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="n">r</span><span class="o">;</span>

        <span class="c1">// 基准数值，将小于该数值的放在该数字的左边，大于该数值的放在右边
</span><span class="c1"></span>        <span class="kt">int</span> <span class="n">pivot</span> <span class="o">=</span> <span class="n">data</span><span class="o">[</span><span class="n">left</span><span class="o">];</span>

        <span class="k">while</span> <span class="o">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>

            <span class="c1">// 从右向左开始比较，如果此数大于等于基准数则将right索引向前移动，否则，将该值覆盖到对应的 data[left] 中
</span><span class="c1"></span>            <span class="k">while</span> <span class="o">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span> <span class="o">&amp;&amp;</span> <span class="n">data</span><span class="o">[</span><span class="n">right</span><span class="o">]</span> <span class="o">&gt;=</span> <span class="n">pivot</span><span class="o">)</span> <span class="o">{</span>
                <span class="o">--</span><span class="n">right</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="n">data</span><span class="o">[</span><span class="n">left</span><span class="o">]</span> <span class="o">=</span> <span class="n">data</span><span class="o">[</span><span class="n">right</span><span class="o">];</span>

            <span class="c1">// 从左向右开始比较，如果此数小于等于基准数则将left索引向后移动，否则，将该值覆盖到对应的 data[right] 中
</span><span class="c1"></span>            <span class="k">while</span> <span class="o">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span> <span class="o">&amp;&amp;</span> <span class="n">data</span><span class="o">[</span><span class="n">left</span><span class="o">]</span> <span class="o">&lt;=</span> <span class="n">pivot</span><span class="o">)</span> <span class="o">{</span>
                <span class="o">++</span><span class="n">left</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="n">data</span><span class="o">[</span><span class="n">right</span><span class="o">]</span> <span class="o">=</span> <span class="n">data</span><span class="o">[</span><span class="n">left</span><span class="o">];</span>
        <span class="o">}</span>

        <span class="c1">// 此时left与right指向重合的位置为基准所在的位置，需要将该位置覆盖掉为基准的值
</span><span class="c1"></span>        <span class="n">data</span><span class="o">[</span><span class="n">left</span><span class="o">]</span> <span class="o">=</span> <span class="n">pivot</span><span class="o">;</span>

        <span class="c1">// 递归排序
</span><span class="c1"></span>        <span class="n">sort</span><span class="o">(</span><span class="n">data</span><span class="o">,</span> <span class="n">l</span><span class="o">,</span> <span class="n">left</span><span class="o">);</span>
        <span class="n">sort</span><span class="o">(</span><span class="n">data</span><span class="o">,</span> <span class="n">right</span><span class="o">+</span><span class="n">1</span><span class="o">,</span><span class="n">r</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span> 
</code></pre></div><h4 id="归并排序">归并排序</h4>
<p>归并排序是利用归并的思想实现的排序方法， 该算法采用经典的分治（divide-and-conquer）策略；分治法将问题分成一些小的问题然后递归求解， 而治的阶段则将分的阶段得到的各答案&quot;修补&quot;在一起，即分而治之。</p>
<p>归并排序算法思路：采用分治算法思想，首先将序列使用递归进行拆分，然后进行合并；合并思路，将两个有序队列中的元素分别按顺序进行比较，将结果保存在一个临时数组中，最后将临时数组合并到最后的队列中。</p>
<p><img src="/iblog/posts/annex/images/essays/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-019.gif" alt="数据结构与算法-019"></p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">MergeSorting</span> <span class="o">{</span>

    <span class="c1">// 递归拆分算法
</span><span class="c1"></span>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">divide</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span><span class="o">,</span> <span class="kt">int</span> <span class="n">start</span><span class="o">,</span> <span class="kt">int</span> <span class="n">end</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">tmpArr</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">start</span> <span class="o">&gt;=</span> <span class="n">end</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="o">(</span><span class="n">start</span> <span class="o">+</span> <span class="n">end</span><span class="o">)</span> <span class="o">&gt;&gt;</span> <span class="n">1</span><span class="o">;</span>

        <span class="c1">// 分别向左向右递归
</span><span class="c1"></span>        <span class="n">divide</span><span class="o">(</span><span class="n">arr</span><span class="o">,</span> <span class="n">start</span><span class="o">,</span> <span class="n">mid</span><span class="o">,</span> <span class="n">tmpArr</span><span class="o">);</span>
        <span class="n">divide</span><span class="o">(</span><span class="n">arr</span><span class="o">,</span> <span class="n">mid</span> <span class="o">+</span> <span class="n">1</span><span class="o">,</span> <span class="n">end</span><span class="o">,</span> <span class="n">tmpArr</span><span class="o">);</span>

        <span class="c1">// 拆分一次合并一次
</span><span class="c1"></span>        <span class="n">merge</span><span class="o">(</span><span class="n">arr</span><span class="o">,</span> <span class="n">start</span><span class="o">,</span> <span class="n">mid</span><span class="o">,</span> <span class="n">end</span><span class="o">,</span> <span class="n">tmpArr</span><span class="o">);</span>

    <span class="o">}</span>

    <span class="c1">// 合并算法
</span><span class="c1"></span>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">merge</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span><span class="o">,</span> <span class="kt">int</span> <span class="n">start</span><span class="o">,</span> <span class="kt">int</span> <span class="n">mid</span><span class="o">,</span> <span class="kt">int</span> <span class="n">end</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">tmpArr</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">leftIndex</span> <span class="o">=</span> <span class="n">start</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">rightIndex</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="n">1</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">tmpArrIndex</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>

        <span class="c1">// 判断是否超出范围
</span><span class="c1"></span>        <span class="k">while</span> <span class="o">(</span><span class="n">leftIndex</span> <span class="o">&lt;=</span> <span class="n">mid</span> <span class="o">&amp;&amp;</span> <span class="n">rightIndex</span> <span class="o">&lt;=</span> <span class="n">end</span><span class="o">)</span> <span class="o">{</span>

            <span class="c1">// 将两组数据进行比较，按照从小到大的顺序将两组数据填入 tmpArr 中
</span><span class="c1"></span>            <span class="k">if</span> <span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">leftIndex</span><span class="o">]</span> <span class="o">&lt;=</span> <span class="n">arr</span><span class="o">[</span><span class="n">rightIndex</span><span class="o">])</span> <span class="o">{</span>
                <span class="n">tmpArr</span><span class="o">[</span><span class="n">tmpArrIndex</span><span class="o">]</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="n">leftIndex</span><span class="o">];</span>
                <span class="o">++</span><span class="n">leftIndex</span><span class="o">;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="n">tmpArr</span><span class="o">[</span><span class="n">tmpArrIndex</span><span class="o">]</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="n">rightIndex</span><span class="o">];</span>
                <span class="o">++</span><span class="n">rightIndex</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="o">++</span><span class="n">tmpArrIndex</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// 判断两组数据是否还有剩余，如果有剩余数据，则直接将数据追加到 tmpArr 数组后边
</span><span class="c1"></span>        <span class="k">while</span> <span class="o">(</span><span class="n">leftIndex</span> <span class="o">&lt;=</span> <span class="n">mid</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">tmpArr</span><span class="o">[</span><span class="n">tmpArrIndex</span><span class="o">]</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="n">leftIndex</span><span class="o">];</span>
            <span class="o">++</span><span class="n">leftIndex</span><span class="o">;</span>
            <span class="o">++</span><span class="n">tmpArrIndex</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="k">while</span> <span class="o">(</span><span class="n">rightIndex</span> <span class="o">&lt;=</span> <span class="n">end</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">tmpArr</span><span class="o">[</span><span class="n">tmpArrIndex</span><span class="o">]</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="n">rightIndex</span><span class="o">];</span>
            <span class="o">++</span><span class="n">rightIndex</span><span class="o">;</span>
            <span class="o">++</span><span class="n">tmpArrIndex</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// 将两组数据进行合并
</span><span class="c1"></span>        <span class="n">tmpArrIndex</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">tmpLeftIndex</span> <span class="o">=</span> <span class="n">leftIndex</span><span class="o">;</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">tmpLeftIndex</span> <span class="o">&lt;=</span> <span class="n">end</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">arr</span><span class="o">[</span><span class="n">tmpLeftIndex</span><span class="o">]</span> <span class="o">=</span> <span class="n">tmpArr</span><span class="o">[</span><span class="n">tmpArrIndex</span><span class="o">];</span>
            <span class="o">++</span><span class="n">tmpLeftIndex</span><span class="o">;</span>
            <span class="o">++</span><span class="n">tmpArrIndex</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
    
<span class="o">}</span>
</code></pre></div><h4 id="基数排序">基数排序</h4>
<p>基数排序是 1887 年赫尔曼·何乐礼发明的。基数排序属于“分配式排序”，又称“桶子法”或 bin sort，顾名思义，它是通过键值的各个位的值，将要排序的元素分配至某些“桶”中，达到排序的作用,基数排序法是属于稳定性的排序， 基数排序法的是效率高的稳定性排序法。</p>
<p>基数排序是桶排序的扩展，它是这样实现的： 将所有待比较数值统一为同样的数位长度，数位较短的数前面补零；然后， 从最低位开始， 依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。</p>
<p><img src="/iblog/posts/annex/images/essays/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-020.gif" alt="数据结构与算法-020"></p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">BucketSorting</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">sort</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 求数组中最大数的长度
</span><span class="c1"></span>        <span class="kt">int</span> <span class="n">maxNum</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="n">0</span><span class="o">];</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">maxNum</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">maxNum</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="kt">int</span> <span class="n">maxNumLen</span> <span class="o">=</span> <span class="n">String</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">maxNum</span><span class="o">).</span><span class="na">length</span><span class="o">();</span>

        <span class="c1">// 桶，用于保存数据
</span><span class="c1"></span>        <span class="kt">int</span><span class="o">[][]</span> <span class="n">buckets</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">10</span><span class="o">][</span><span class="n">arr</span><span class="o">.</span><span class="na">length</span><span class="o">];</span>

        <span class="c1">// 存放每个桶的保存数据的索引
</span><span class="c1"></span>        <span class="kt">int</span><span class="o">[]</span> <span class="n">bucketElementIndex</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">10</span><span class="o">];</span>

        <span class="c1">// 将数组中的元素 按照 个、十、百、千 …… 的顺序依次放入桶中
</span><span class="c1"></span>        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">maxNumLen</span><span class="o">;</span> <span class="n">i</span><span class="o">++,</span> <span class="n">n</span> <span class="o">*=</span> <span class="n">10</span><span class="o">)</span> <span class="o">{</span>

            <span class="c1">// 遍历二维数组
</span><span class="c1"></span>            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                <span class="c1">// 计算放入的桶的下标
</span><span class="c1"></span>                <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">/</span> <span class="n">n</span> <span class="o">%</span> <span class="n">10</span><span class="o">;</span>
                <span class="n">buckets</span><span class="o">[</span><span class="n">index</span><span class="o">][</span><span class="n">bucketElementIndex</span><span class="o">[</span><span class="n">index</span><span class="o">]]</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>
                <span class="n">bucketElementIndex</span><span class="o">[</span><span class="n">index</span><span class="o">]++;</span>
            <span class="o">}</span>

            <span class="c1">// 从桶中依次取出元素并放入原数组中
</span><span class="c1"></span>            <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">f</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">f</span> <span class="o">&lt;</span> <span class="n">bucketElementIndex</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">f</span><span class="o">++)</span> <span class="o">{</span>
                <span class="c1">// 判断桶中是否保存数据
</span><span class="c1"></span>                <span class="k">if</span> <span class="o">(</span><span class="n">bucketElementIndex</span><span class="o">[</span><span class="n">f</span><span class="o">]</span> <span class="o">==</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span>
                    <span class="k">continue</span><span class="o">;</span>
                <span class="o">}</span>
                <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">h</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">h</span> <span class="o">&lt;</span> <span class="n">bucketElementIndex</span><span class="o">[</span><span class="n">f</span><span class="o">];</span> <span class="n">h</span><span class="o">++)</span> <span class="o">{</span>
                    <span class="n">arr</span><span class="o">[</span><span class="n">index</span><span class="o">]</span> <span class="o">=</span> <span class="n">buckets</span><span class="o">[</span><span class="n">f</span><span class="o">][</span><span class="n">h</span><span class="o">];</span>
                    <span class="n">index</span><span class="o">++;</span>
                <span class="o">}</span>
                <span class="n">bucketElementIndex</span><span class="o">[</span><span class="n">f</span><span class="o">]</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>

    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><h4 id="堆排序">堆排序</h4>
<p>堆排序是利用堆这种数据结构而设计的一种排序算法，堆排序是一种选择排序，它的最坏、最好、平均时间复杂度均为O(nlogn)，它也是不稳定排序。</p>
<p>堆排序的基本思想是：将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了。</p>
<blockquote>
<p>大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列；
小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列；</p>
</blockquote>
<p><img src="/iblog/posts/annex/images/essays/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-027.png" alt="数据结构与算法-027"></p>
<p><img src="/iblog/posts/annex/images/essays/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-026.gif" alt="数据结构与算法-026"></p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">HeapSorting</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">sort</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 计算树中的叶子结点位置
</span><span class="c1"></span>        <span class="kt">int</span> <span class="n">leafNode</span> <span class="o">=</span> <span class="o">(</span><span class="n">arr</span><span class="o">.</span><span class="na">length</span> <span class="o">&gt;&gt;</span> <span class="n">1</span><span class="o">)</span> <span class="o">-</span> <span class="n">1</span><span class="o">;</span>

        <span class="c1">// 构建大顶堆，此处需要注意 i &gt;= 0 需要算根结点
</span><span class="c1"></span>        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">leafNode</span><span class="o">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span><span class="o">--)</span> <span class="o">{</span>
            <span class="n">buildMaxHeap</span><span class="o">(</span><span class="n">arr</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span> <span class="n">arr</span><span class="o">.</span><span class="na">length</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="c1">// 构建大顶堆后，将根元素与树中的最后一个进行交换，再循环构建大顶堆
</span><span class="c1"></span>        <span class="kt">int</span> <span class="n">tmp</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="n">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span><span class="o">--)</span> <span class="o">{</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="n">0</span><span class="o">];</span>
            <span class="n">arr</span><span class="o">[</span><span class="n">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">;</span>
            <span class="n">buildMaxHeap</span><span class="o">(</span><span class="n">arr</span><span class="o">,</span> <span class="n">0</span><span class="o">,</span> <span class="n">i</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="cm">/**
</span><span class="cm">     * 堆排序核心代码 构建大顶堆
</span><span class="cm">     *
</span><span class="cm">     * @param arr 需要调整的数组
</span><span class="cm">     * @param i   非叶子结点的索引位置
</span><span class="cm">     * @param len 每次调整的长度
</span><span class="cm">     */</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">buildMaxHeap</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span><span class="o">,</span> <span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="kt">int</span> <span class="n">len</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 保存非叶子结点的位置如果该结点的值小于子结点的值，则需要进行交换
</span><span class="c1"></span>        <span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>

        <span class="c1">// 从上至下，从左至右 遍历. 从第一个左子结点开始遍历
</span><span class="c1"></span>        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">1</span><span class="o">)</span> <span class="o">+</span> <span class="n">1</span><span class="o">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">len</span><span class="o">;</span> <span class="n">n</span> <span class="o">=</span> <span class="o">(</span><span class="n">n</span> <span class="o">&lt;&lt;</span> <span class="n">1</span><span class="o">)</span> <span class="o">+</span> <span class="n">1</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// 如果左子结点 &lt; 右结点，则需要将 n 指向右结点，即后移
</span><span class="c1"></span>            <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">+</span> <span class="n">1</span> <span class="o">&lt;</span> <span class="n">len</span> <span class="o">&amp;&amp;</span> <span class="n">arr</span><span class="o">[</span><span class="n">n</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="o">[</span><span class="n">n</span> <span class="o">+</span> <span class="n">1</span><span class="o">])</span> <span class="o">{</span>
                <span class="n">n</span><span class="o">++;</span>
            <span class="o">}</span>
            <span class="c1">// 当前非叶子结点 &lt; 当前子结点
</span><span class="c1"></span>            <span class="k">if</span> <span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">n</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">tmp</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// 将当前非叶子结点指向叶子结点
</span><span class="c1"></span>                <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
                <span class="c1">// 将i指向当前叶子结点，待最后将其变为 非叶子结点的值 即tmp的值
</span><span class="c1"></span>                <span class="n">i</span> <span class="o">=</span> <span class="n">n</span><span class="o">;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="c1">// 与前面互相呼应
</span><span class="c1"></span>        <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><h3 id="查找算法">查找算法</h3>
<h4 id="线性查找">线性查找</h4>
<p>线性查找又称顺序查找，是一种最简单的查找方法，它的基本思想是从第一个记录开始，逐个比较记录的关键字，直到和给定的K值相等，则查找成功；若比较结果与文件中n个记录的关键字都不等，则查找失败。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">LinearSearch</span><span class="o">{</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">search</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span><span class="o">,</span> <span class="kt">int</span> <span class="n">value</span><span class="o">){</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="n">i</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="o">-</span> <span class="n">1</span><span class="o">;</span>
    <span class="o">}</span>

<span class="o">}</span>
</code></pre></div><h4 id="二分查找">二分查找</h4>
<p>二分查找也称折半查找，它是一种效率较高的查找方法。但是，折半查找要求线性表必须采用顺序存储结构，而且表中元素按关键字有序排列。</p>
<p><strong>二分查找算法的前提，数组必须是有序数组，如果没有有序列表，请使用<a href="/iblog/posts/essays/data-structures-algorithms/#%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95">排序算法</a>对列表进行排序。</strong></p>
<p>递归实现二分查找</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">BinarySearch</span> <span class="o">{</span>

    <span class="c1">// 使用二分查找时，arr必须为有序列表
</span><span class="c1"></span>    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">search</span><span class="o">(</span><span class="kt">int</span> <span class="n">start</span><span class="o">,</span> <span class="kt">int</span> <span class="n">end</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span><span class="o">,</span> <span class="kt">int</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 在 {@param arr} 中 没有查到 {@param value}
</span><span class="c1"></span>        <span class="k">if</span> <span class="o">(</span><span class="n">start</span> <span class="o">&gt;</span> <span class="n">end</span> <span class="o">||</span> <span class="n">value</span> <span class="o">&gt;</span> <span class="n">arr</span><span class="o">[</span><span class="n">end</span><span class="o">]</span> <span class="o">||</span> <span class="n">value</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="o">[</span><span class="n">start</span><span class="o">])</span> <span class="o">{</span>
            <span class="k">return</span> <span class="o">-</span><span class="n">1</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// 获取中间值，用于分割列表
</span><span class="c1"></span>        <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="o">(</span><span class="n">start</span> <span class="o">+</span> <span class="n">end</span><span class="o">)</span> <span class="o">&gt;&gt;</span> <span class="n">1</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">midVal</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="n">mid</span><span class="o">];</span>

        <span class="c1">// 如果 查找的值&lt; 中间值，说明该值可能在mid的左边
</span><span class="c1"></span>        <span class="k">if</span> <span class="o">(</span><span class="n">value</span> <span class="o">&lt;</span> <span class="n">midVal</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">search</span><span class="o">(</span><span class="n">start</span><span class="o">,</span> <span class="n">mid</span> <span class="o">-</span> <span class="n">1</span><span class="o">,</span> <span class="n">arr</span><span class="o">,</span> <span class="n">value</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="c1">// 相反如果 查找的值 &gt; 中间值，说明该值可能在mid的右边
</span><span class="c1"></span>        <span class="k">if</span> <span class="o">(</span><span class="n">value</span> <span class="o">&gt;</span> <span class="n">midVal</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">search</span><span class="o">(</span><span class="n">mid</span> <span class="o">+</span> <span class="n">1</span><span class="o">,</span> <span class="n">end</span><span class="o">,</span> <span class="n">arr</span><span class="o">,</span> <span class="n">value</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="c1">// 使用递归不停的向下细分，当 value == arr[mid] 时 返回该值，说明此时已经找到了
</span><span class="c1"></span>        <span class="k">return</span> <span class="n">mid</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>非递归实现二分查找</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">BinarySearchDemo</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span> <span class="o">=</span> <span class="o">{</span><span class="n">1</span><span class="o">,</span> <span class="n">2</span><span class="o">,</span> <span class="n">3</span><span class="o">,</span> <span class="n">4</span><span class="o">,</span> <span class="n">5</span><span class="o">,</span> <span class="n">6</span><span class="o">,</span> <span class="n">7</span><span class="o">,</span> <span class="n">8</span><span class="o">,</span> <span class="n">9</span><span class="o">,</span> <span class="n">10</span><span class="o">};</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="k">new</span> <span class="n">BinarySearch</span><span class="o">().</span><span class="na">search</span><span class="o">(</span><span class="n">arr</span><span class="o">,</span> <span class="n">3</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">BinarySearch</span> <span class="o">{</span>

    <span class="c1">// 使用二分查找时，arr必须为有序列表
</span><span class="c1"></span>    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">search</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span><span class="o">,</span> <span class="kt">int</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="n">1</span><span class="o">;</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">left</span> <span class="o">&lt;=</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="o">(</span><span class="n">left</span> <span class="o">+</span> <span class="n">right</span><span class="o">)</span> <span class="o">&gt;&gt;</span> <span class="n">1</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">mid</span><span class="o">]</span> <span class="o">==</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="n">mid</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="c1">// 如果目标值小于中间值则向左边找，反之向右边找
</span><span class="c1"></span>            <span class="k">if</span> <span class="o">(</span><span class="n">target</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="o">[</span><span class="n">mid</span><span class="o">])</span> <span class="o">{</span>
                <span class="n">right</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">-</span> <span class="n">1</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="k">if</span> <span class="o">(</span><span class="n">target</span> <span class="o">&gt;</span> <span class="n">arr</span><span class="o">[</span><span class="n">mid</span><span class="o">])</span> <span class="o">{</span>
                <span class="n">left</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="n">1</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">1</span><span class="o">;</span>
    <span class="o">}</span>

<span class="o">}</span>
</code></pre></div><h4 id="插值查找">插值查找</h4>
<p>插值查找算法类似于二分查找，与二分查找不同的是插值查找每次从自适应 mid 处开始查找，而不是像二分查找那样每次都从中间开始找。</p>
<p><img src="/iblog/posts/annex/images/essays/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-021.png" alt="数据结构与算法-021"></p>
<p>注意：对于数据量较大，关键字分布比较均匀（最好是线性分布）的查找表来说，采用插值查找，速度较快；对于关键字分布不均匀的情况下，该方法不一定比二分查找要好。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">InsertValueSearch</span> <span class="o">{</span>

    <span class="c1">// 与二分查找基本相同，只是查找 mid 值发生了变动
</span><span class="c1"></span>    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">search</span><span class="o">(</span><span class="kt">int</span> <span class="n">start</span><span class="o">,</span> <span class="kt">int</span> <span class="n">end</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span><span class="o">,</span> <span class="kt">int</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 在 {@param arr} 中 没有查到 {@param value}
</span><span class="c1"></span>        <span class="k">if</span> <span class="o">(</span><span class="n">start</span> <span class="o">&gt;</span> <span class="n">end</span> <span class="o">||</span> <span class="n">value</span> <span class="o">&gt;</span> <span class="n">arr</span><span class="o">[</span><span class="n">end</span><span class="o">]</span> <span class="o">||</span> <span class="n">value</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="o">[</span><span class="n">start</span><span class="o">])</span> <span class="o">{</span>
            <span class="k">return</span> <span class="o">-</span><span class="n">1</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="o">(</span><span class="n">value</span> <span class="o">-</span> <span class="n">arr</span><span class="o">[</span><span class="n">start</span><span class="o">])</span> <span class="o">/</span> <span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">end</span><span class="o">]</span> <span class="o">-</span> <span class="n">arr</span><span class="o">[</span><span class="n">start</span><span class="o">])</span> <span class="o">*</span> <span class="o">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">midVal</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="n">mid</span><span class="o">];</span>

        <span class="k">if</span> <span class="o">(</span><span class="n">value</span> <span class="o">&lt;</span> <span class="n">midVal</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">search</span><span class="o">(</span><span class="n">start</span><span class="o">,</span> <span class="n">mid</span> <span class="o">-</span> <span class="n">1</span><span class="o">,</span> <span class="n">arr</span><span class="o">,</span> <span class="n">value</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="k">if</span> <span class="o">(</span><span class="n">value</span> <span class="o">&gt;</span> <span class="n">midVal</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">search</span><span class="o">(</span><span class="n">mid</span> <span class="o">+</span> <span class="n">1</span><span class="o">,</span> <span class="n">end</span><span class="o">,</span> <span class="n">arr</span><span class="o">,</span> <span class="n">value</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">mid</span><span class="o">;</span>
    <span class="o">}</span>

<span class="o">}</span>
</code></pre></div><h4 id="斐波那契查找">斐波那契查找</h4>
<p>斐波那契查找是基于【黄金分割】的二分查找。即在斐波那契队列中，将二分查找中的分割点替换为黄金分割点，来查找。</p>
<blockquote>
<p>黄金分割是指将整体一分为二，较大部分与整体部分的比值等于较小部分与较大部分的比值，其 比值 约为 0.618。这个比例被公认为是最能引起美感的 比例，因此被称为黄金分割。</p>
</blockquote>
<p>斐波那契查找特点：</p>
<ul>
<li>平均性能「斐波那契查找」好于「二分查找」；</li>
<li>「斐波那契查找」计算 mid 的时候 使用加减法而不是除法，会微弱提升效率；</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">FibonacciSearch</span><span class="o">{</span>
    <span class="c1">// lookupTable,需要传入斐波那契数列,例如：{1,1,2,3,5,8,13,21,34,55};
</span><span class="c1"></span>    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">search</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">lookupTable</span><span class="o">,</span><span class="kt">int</span><span class="o">[]</span> <span class="n">f</span><span class="o">,</span><span class="kt">int</span> <span class="n">target</span><span class="o">){</span>

        <span class="kt">int</span> <span class="n">low</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">high</span> <span class="o">=</span> <span class="n">lookupTable</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="n">1</span><span class="o">;</span>

        <span class="c1">// k 是 Fibonacci 分割数组下标
</span><span class="c1"></span>        <span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">middle</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>

        <span class="k">while</span> <span class="o">(</span><span class="n">f</span><span class="o">[</span><span class="n">k</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">high</span><span class="o">){</span>
            <span class="n">k</span> <span class="o">++;</span>
        <span class="o">}</span>

        <span class="c1">//利用 java 工具类构造 f[k] 长度的查找表，解决原有查找表元素不够的问题
</span><span class="c1"></span>        <span class="kt">int</span><span class="o">[]</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">Arrays</span><span class="o">.</span><span class="na">copyOf</span><span class="o">(</span><span class="n">lookupTable</span><span class="o">,</span><span class="n">f</span><span class="o">[</span><span class="n">k</span><span class="o">]);</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">low</span> <span class="o">&lt;=</span> <span class="n">high</span><span class="o">){</span>
            <span class="n">middle</span> <span class="o">=</span> <span class="n">low</span> <span class="o">+</span> <span class="n">f</span><span class="o">[</span><span class="n">k</span> <span class="o">-</span> <span class="n">1</span><span class="o">];</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">target</span> <span class="o">&lt;</span> <span class="n">lookupTable</span><span class="o">[</span><span class="n">middle</span><span class="o">]){</span>
                <span class="n">high</span> <span class="o">=</span> <span class="n">middle</span> <span class="o">-</span><span class="n">1</span><span class="o">;</span>
                <span class="n">k</span> <span class="o">--;</span>
            <span class="o">}</span><span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">target</span> <span class="o">&gt;</span> <span class="n">lookupTable</span><span class="o">[</span><span class="n">middle</span><span class="o">]){</span>
                <span class="n">low</span> <span class="o">=</span> <span class="n">middle</span> <span class="o">+</span> <span class="n">1</span><span class="o">;</span>
                <span class="n">k</span> <span class="o">-=</span> <span class="n">2</span><span class="o">;</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="k">return</span> <span class="n">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">middle</span><span class="o">,</span><span class="n">high</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">1</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><h3 id="哈夫曼编码">哈夫曼编码</h3>
<p>赫夫曼编码也翻译为哈夫曼编码(Huffman Coding)，又称霍夫曼编码，是一种编码方式，属于一种程序算法。</p>
<p>哈夫曼编码是哈夫曼树在电讯通信中的经典的应用之一。哈夫曼编码广泛地用于数据文件压缩。其压缩率通常在20%～90%之间。哈夫曼码是可变字长编码的一种。Huffman于1952年提出一种编码方法，称之为最佳编码。</p>
<blockquote>
<p>定长编码与变长编码，以字符串like like为例：</p>
<ul>
<li>定长编码：</li>
</ul>
<ol>
<li>将上述字符串转换对应的ASCII： 108 105 107 101 32 108 105 107 101</li>
<li>ASCII转换为二进制：01101100 01101001 01101011 01100101 00100000 01101100 01101001 01101011 01100101
<br></li>
</ol>
<ul>
<li>变长编码：</li>
</ul>
<ol>
<li>统计上述字符串出现的各字符出现的次数：l：2 i：2 k：2 e：2 ：1</li>
<li>按照各个字符出现的次数进行编码，原则是出现次数越多的，则编码越小：0=l 1=i 10=k 11=e 100=</li>
<li>最终转换为变长编码为：011011100011011</li>
</ol>
</blockquote>
<p>上述的变长编码 011011100011011 在解码的时候会出现多意现象，比如当匹配到数字1，是把1解成i还是按照10来进行解码。因为这种现象的存在，所以在进行变长编码时，编码要符合前缀编码。</p>
<blockquote>
<p>字符的编码都不能是其他字符编码的前缀，符合此要求的编码叫做前缀编码， 即不能匹配到重复的编码。</p>
</blockquote>
<p>构建哈夫曼编码思路：</p>
<ol>
<li>统计字节数组中各个数据的权重,即字符出现的次数；</li>
<li>将统计好的字符出现的次数，<a href="/iblog/posts/essays/data-structures-algorithms/#%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91">构建成哈夫曼树</a>；</li>
<li>根据上面创建的哈夫曼树获得每个数值对应的可变长编码值，规定结点的左边为0 ，右边为1；</li>
<li>以每个数值新的编码重新对字符数组进行编码，即可得到赫夫曼编码后的值；</li>
</ol>
<p>假如一段信息里只有A，B，C，D，E，F这6个字符，他们出现的次数依次是2次，3次，7次，9次，18次，25次，最终构建成哈夫曼编树为下图所示：</p>
<p><img src="/iblog/posts/annex/images/essays/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-029.png" alt="数据结构与算法-029"></p>
<p>得到哈夫曼编码：</p>
<div class="highlight"><pre class="chroma"><code class="language-fallback" data-lang="fallback">A=11100 B=11101 C=1111 D=110 E=10 F=0
</code></pre></div><p>利用哈夫曼编码，压缩解压文件：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">HuffmanCodeTest</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>

        <span class="c1">// 测试压缩文件
</span><span class="c1"></span>        <span class="n">String</span> <span class="n">srcFile</span> <span class="o">=</span> <span class="s">&#34;/Users/whitepure/Desktop/1.png&#34;</span><span class="o">;</span>
        <span class="n">String</span> <span class="n">dstFile</span> <span class="o">=</span> <span class="s">&#34;/Users/whitepure/Desktop/1.zip&#34;</span><span class="o">;</span>

        <span class="n">zipFile</span><span class="o">(</span><span class="n">srcFile</span><span class="o">,</span> <span class="n">dstFile</span><span class="o">);</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;压缩文件成功&#34;</span><span class="o">);</span>

        <span class="c1">// 测试解压文件
</span><span class="c1"></span>        <span class="n">srcFile</span> <span class="o">=</span> <span class="s">&#34;/Users/whitepure/Desktop/1.zip&#34;</span><span class="o">;</span>
        <span class="n">dstFile</span> <span class="o">=</span> <span class="s">&#34;/Users/whitepure/Desktop/1copy.png&#34;</span><span class="o">;</span>
        <span class="n">unZipFile</span><span class="o">(</span><span class="n">srcFile</span><span class="o">,</span> <span class="n">dstFile</span><span class="o">);</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;解压成功!&#34;</span><span class="o">);</span>
    <span class="o">}</span>


    <span class="c1">// 将一个文件进行压缩
</span><span class="c1"></span>    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">zipFile</span><span class="o">(</span><span class="n">String</span> <span class="n">srcFile</span><span class="o">,</span> <span class="n">String</span> <span class="n">dstFile</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 创建输出流
</span><span class="c1"></span>        <span class="n">OutputStream</span> <span class="n">os</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="n">ObjectOutputStream</span> <span class="n">oos</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="c1">// 创建文件的输入流
</span><span class="c1"></span>        <span class="n">FileInputStream</span> <span class="n">is</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="c1">// 创建文件的输入流
</span><span class="c1"></span>            <span class="n">is</span> <span class="o">=</span> <span class="k">new</span> <span class="n">FileInputStream</span><span class="o">(</span><span class="n">srcFile</span><span class="o">);</span>
            <span class="c1">// 创建一个和源文件大小一样的byte[]
</span><span class="c1"></span>            <span class="kt">byte</span><span class="o">[]</span> <span class="n">b</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">byte</span><span class="o">[</span><span class="n">is</span><span class="o">.</span><span class="na">available</span><span class="o">()];</span>
            <span class="c1">// 读取文件
</span><span class="c1"></span>            <span class="n">is</span><span class="o">.</span><span class="na">read</span><span class="o">(</span><span class="n">b</span><span class="o">);</span>
            <span class="n">HuffmanCode</span> <span class="n">huffmanCode</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HuffmanCode</span><span class="o">();</span>
            <span class="c1">// 直接对源文件压缩
</span><span class="c1"></span>            <span class="kt">byte</span><span class="o">[]</span> <span class="n">huffmanBytes</span> <span class="o">=</span> <span class="n">huffmanCode</span><span class="o">.</span><span class="na">encode</span><span class="o">(</span><span class="n">b</span><span class="o">);</span>
            <span class="c1">// 创建文件的输出流, 存放压缩文件
</span><span class="c1"></span>            <span class="n">os</span> <span class="o">=</span> <span class="k">new</span> <span class="n">FileOutputStream</span><span class="o">(</span><span class="n">dstFile</span><span class="o">);</span>
            <span class="c1">// 创建一个和文件输出流关联的ObjectOutputStream
</span><span class="c1"></span>            <span class="n">oos</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ObjectOutputStream</span><span class="o">(</span><span class="n">os</span><span class="o">);</span>
            <span class="c1">// 把 赫夫曼编码后的字节数组写入压缩文件
</span><span class="c1"></span>            <span class="n">oos</span><span class="o">.</span><span class="na">writeObject</span><span class="o">(</span><span class="n">huffmanBytes</span><span class="o">);</span> <span class="c1">// 我们是把
</span><span class="c1"></span>            <span class="c1">// 这里我们以对象流的方式写入 赫夫曼编码，是为了以后我们恢复源文件时使用
</span><span class="c1"></span>            <span class="c1">// 注意一定要把赫夫曼编码 写入压缩文件
</span><span class="c1"></span>            <span class="n">oos</span><span class="o">.</span><span class="na">writeObject</span><span class="o">(</span><span class="n">huffmanCode</span><span class="o">.</span><span class="na">getHuffmanCodes</span><span class="o">());</span>

        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// TODO: handle exception
</span><span class="c1"></span>            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">getMessage</span><span class="o">());</span>
        <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
            <span class="k">try</span> <span class="o">{</span>
                <span class="n">is</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
                <span class="n">oos</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
                <span class="n">os</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
            <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// TODO: handle exception
</span><span class="c1"></span>                <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">getMessage</span><span class="o">());</span>
            <span class="o">}</span>
        <span class="o">}</span>

    <span class="o">}</span>


    <span class="c1">// 完成对压缩文件的解压
</span><span class="c1"></span>    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">unZipFile</span><span class="o">(</span><span class="n">String</span> <span class="n">zipFile</span><span class="o">,</span> <span class="n">String</span> <span class="n">dstFile</span><span class="o">)</span> <span class="o">{</span>

        <span class="c1">// 定义文件输入流
</span><span class="c1"></span>        <span class="n">InputStream</span> <span class="n">is</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="c1">// 定义一个对象输入流
</span><span class="c1"></span>        <span class="n">ObjectInputStream</span> <span class="n">ois</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="c1">// 定义文件的输出流
</span><span class="c1"></span>        <span class="n">OutputStream</span> <span class="n">os</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="c1">// 创建文件输入流
</span><span class="c1"></span>            <span class="n">is</span> <span class="o">=</span> <span class="k">new</span> <span class="n">FileInputStream</span><span class="o">(</span><span class="n">zipFile</span><span class="o">);</span>
            <span class="c1">// 创建一个和 is关联的对象输入流
</span><span class="c1"></span>            <span class="n">ois</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ObjectInputStream</span><span class="o">(</span><span class="n">is</span><span class="o">);</span>
            <span class="c1">// 读取byte数组 huffmanBytes
</span><span class="c1"></span>            <span class="kt">byte</span><span class="o">[]</span> <span class="n">huffmanBytes</span> <span class="o">=</span> <span class="o">(</span><span class="kt">byte</span><span class="o">[])</span> <span class="n">ois</span><span class="o">.</span><span class="na">readObject</span><span class="o">();</span>
            <span class="c1">// 读取赫夫曼编码表
</span><span class="c1"></span>            <span class="n">Map</span><span class="o">&lt;</span><span class="n">Byte</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;</span> <span class="n">huffmanCodes</span> <span class="o">=</span> <span class="o">(</span><span class="n">Map</span><span class="o">&lt;</span><span class="n">Byte</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;)</span> <span class="n">ois</span><span class="o">.</span><span class="na">readObject</span><span class="o">();</span>
            <span class="n">HuffmanCode</span> <span class="n">huffmanCode</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HuffmanCode</span><span class="o">();</span>
            <span class="c1">// 解码
</span><span class="c1"></span>            <span class="kt">byte</span><span class="o">[]</span> <span class="n">bytes</span> <span class="o">=</span> <span class="n">huffmanCode</span><span class="o">.</span><span class="na">decode</span><span class="o">(</span><span class="n">huffmanCodes</span><span class="o">,</span> <span class="n">huffmanBytes</span><span class="o">);</span>
            <span class="c1">// 将bytes 数组写入到目标文件
</span><span class="c1"></span>            <span class="n">os</span> <span class="o">=</span> <span class="k">new</span> <span class="n">FileOutputStream</span><span class="o">(</span><span class="n">dstFile</span><span class="o">);</span>
            <span class="c1">// 写数据到 dstFile 文件
</span><span class="c1"></span>            <span class="n">os</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">bytes</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// TODO: handle exception
</span><span class="c1"></span>            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">getMessage</span><span class="o">());</span>
        <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>

            <span class="k">try</span> <span class="o">{</span>
                <span class="n">os</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
                <span class="n">ois</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
                <span class="n">is</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
            <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Exception</span> <span class="n">e2</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// TODO: handle exception
</span><span class="c1"></span>                <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">e2</span><span class="o">.</span><span class="na">getMessage</span><span class="o">());</span>
            <span class="o">}</span>

        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">HuffmanCode</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="kd">final</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">Byte</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;</span> <span class="n">huffmanCodes</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;&gt;();</span>

    <span class="kd">public</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">Byte</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;</span> <span class="nf">getHuffmanCodes</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">huffmanCodes</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// 生成 huffman 编码 压缩
</span><span class="c1"></span>    <span class="kd">public</span> <span class="kt">byte</span><span class="o">[]</span> <span class="nf">encode</span><span class="o">(</span><span class="kt">byte</span><span class="o">[]</span> <span class="n">bytes</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">List</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span> <span class="n">nodes</span> <span class="o">=</span> <span class="n">buildHuffmanNodes</span><span class="o">(</span><span class="n">bytes</span><span class="o">);</span>
        <span class="n">Node</span> <span class="n">huffmanTreeRoot</span> <span class="o">=</span> <span class="n">buildHuffmanTree</span><span class="o">(</span><span class="n">nodes</span><span class="o">);</span>
        <span class="n">Map</span><span class="o">&lt;</span><span class="n">Byte</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;</span> <span class="n">huffmanCodes</span> <span class="o">=</span> <span class="n">buildHuffmanCodeTab</span><span class="o">(</span><span class="n">huffmanTreeRoot</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">zip</span><span class="o">(</span><span class="n">bytes</span><span class="o">,</span> <span class="n">huffmanCodes</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="c1">// 将 huffman编码 解码 解压缩
</span><span class="c1"></span>    <span class="kd">public</span> <span class="kt">byte</span><span class="o">[]</span> <span class="nf">decode</span><span class="o">(</span><span class="n">Map</span><span class="o">&lt;</span><span class="n">Byte</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;</span> <span class="n">huffmanCodes</span><span class="o">,</span> <span class="kt">byte</span><span class="o">[]</span> <span class="n">huffmanBytes</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">StringBuilder</span> <span class="n">stringBuilder</span> <span class="o">=</span> <span class="k">new</span> <span class="n">StringBuilder</span><span class="o">();</span>

        <span class="c1">// 将byte数组转成二进制的字符串
</span><span class="c1"></span>        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">huffmanBytes</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="n">1</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="kt">byte</span> <span class="n">b</span> <span class="o">=</span> <span class="n">huffmanBytes</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            <span class="n">String</span> <span class="n">strToAppend</span> <span class="o">=</span> <span class="n">byteToBitString</span><span class="o">(</span><span class="n">b</span><span class="o">);</span>
            <span class="c1">// 判断是不是最后一个字节
</span><span class="c1"></span>            <span class="kt">boolean</span> <span class="n">isLastByte</span> <span class="o">=</span> <span class="o">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">huffmanBytes</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="n">2</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">isLastByte</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// 得到最后一个字节的有效位数
</span><span class="c1"></span>                <span class="kt">byte</span> <span class="n">validBits</span> <span class="o">=</span> <span class="n">huffmanBytes</span><span class="o">[</span><span class="n">huffmanBytes</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="n">1</span><span class="o">];</span>
                <span class="n">strToAppend</span> <span class="o">=</span> <span class="n">strToAppend</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="n">0</span><span class="o">,</span> <span class="n">validBits</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="n">stringBuilder</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">strToAppend</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="c1">// 把字符串按照指定的赫夫曼编码进行解码
</span><span class="c1"></span>        <span class="c1">// 把赫夫曼编码表进行调换，因为反向查询 a-&gt;100 100-&gt;a
</span><span class="c1"></span>        <span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Byte</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;&gt;();</span>
        <span class="n">huffmanCodes</span><span class="o">.</span><span class="na">forEach</span><span class="o">((</span><span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">value</span><span class="o">,</span> <span class="n">key</span><span class="o">));</span>

        <span class="c1">// 创建要给集合，存放byte
</span><span class="c1"></span>        <span class="n">List</span><span class="o">&lt;</span><span class="n">Byte</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="c1">// i 可以理解成就是索引,扫描 stringBuilder
</span><span class="c1"></span>        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">stringBuilder</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="o">)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="n">1</span><span class="o">;</span>
            <span class="kt">boolean</span> <span class="n">flag</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
            <span class="n">Byte</span> <span class="n">b</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>

            <span class="k">while</span> <span class="o">(</span><span class="n">flag</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// 递增的取出 key
</span><span class="c1"></span>                <span class="n">String</span> <span class="n">key</span> <span class="o">=</span> <span class="n">stringBuilder</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">i</span> <span class="o">+</span> <span class="n">count</span><span class="o">);</span>
                <span class="n">b</span> <span class="o">=</span> <span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">b</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                    <span class="c1">// 没有匹配到
</span><span class="c1"></span>                    <span class="n">count</span><span class="o">++;</span>
                <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                    <span class="c1">// 匹配到
</span><span class="c1"></span>                    <span class="n">flag</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
            <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">b</span><span class="o">);</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="n">count</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="kt">byte</span><span class="o">[]</span> <span class="n">b</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">byte</span><span class="o">[</span><span class="n">list</span><span class="o">.</span><span class="na">size</span><span class="o">()];</span>
        <span class="n">IntStream</span><span class="o">.</span><span class="na">range</span><span class="o">(</span><span class="n">0</span><span class="o">,</span> <span class="n">b</span><span class="o">.</span><span class="na">length</span><span class="o">).</span><span class="na">forEach</span><span class="o">(</span><span class="n">i</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">list</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">));</span>
        <span class="k">return</span> <span class="n">b</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// 计算字符串中每个字符出现的次数
</span><span class="c1"></span>    <span class="kd">private</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span> <span class="nf">buildHuffmanNodes</span><span class="o">(</span><span class="kt">byte</span><span class="o">[]</span> <span class="n">bytes</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span> <span class="n">nodes</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;();</span>

        <span class="c1">// 利用map记录集合中元素出现的次数
</span><span class="c1"></span>        <span class="n">Map</span><span class="o">&lt;</span><span class="n">Byte</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;</span> <span class="n">counts</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;&gt;();</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">byte</span> <span class="n">b</span> <span class="o">:</span> <span class="n">bytes</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">counts</span><span class="o">.</span><span class="na">merge</span><span class="o">(</span><span class="n">b</span><span class="o">,</span> <span class="n">1</span><span class="o">,</span> <span class="n">Integer</span><span class="o">::</span><span class="n">sum</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="c1">// 把每一个键值对转成一个Node 对象，并加入到nodes集合
</span><span class="c1"></span>        <span class="n">counts</span><span class="o">.</span><span class="na">forEach</span><span class="o">((</span><span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">nodes</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="n">Node</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">)));</span>
        <span class="k">return</span> <span class="n">nodes</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// 构建Huffman树
</span><span class="c1"></span>    <span class="kd">private</span> <span class="n">Node</span> <span class="nf">buildHuffmanTree</span><span class="o">(</span><span class="n">List</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span> <span class="n">nodes</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">nodes</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">&gt;</span> <span class="n">1</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// 排序, 从小到大
</span><span class="c1"></span>            <span class="n">Collections</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">nodes</span><span class="o">);</span>
            <span class="c1">// 取出第一颗最小的二叉树
</span><span class="c1"></span>            <span class="n">Node</span> <span class="n">leftNode</span> <span class="o">=</span> <span class="n">nodes</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">0</span><span class="o">);</span>
            <span class="c1">// 取出第二颗最小的二叉树
</span><span class="c1"></span>            <span class="n">Node</span> <span class="n">rightNode</span> <span class="o">=</span> <span class="n">nodes</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">1</span><span class="o">);</span>
            <span class="c1">// 创建一颗新的二叉树,它的根节点 没有data, 只有权值
</span><span class="c1"></span>            <span class="n">Node</span> <span class="n">parent</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="o">(</span><span class="kc">null</span><span class="o">,</span> <span class="n">leftNode</span><span class="o">.</span><span class="na">weight</span> <span class="o">+</span> <span class="n">rightNode</span><span class="o">.</span><span class="na">weight</span><span class="o">);</span>
            <span class="n">parent</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">leftNode</span><span class="o">;</span>
            <span class="n">parent</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">rightNode</span><span class="o">;</span>

            <span class="c1">// 将已经处理的两颗二叉树从nodes删除
</span><span class="c1"></span>            <span class="n">nodes</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">leftNode</span><span class="o">);</span>
            <span class="n">nodes</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">rightNode</span><span class="o">);</span>
            <span class="c1">// 将新的二叉树，加入到nodes
</span><span class="c1"></span>            <span class="n">nodes</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">parent</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="c1">// nodes 最后的结点，就是赫夫曼树的根结点
</span><span class="c1"></span>        <span class="k">return</span> <span class="n">nodes</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">0</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="c1">// 重载 getCodes
</span><span class="c1"></span>    <span class="kd">private</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">Byte</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;</span> <span class="nf">buildHuffmanCodeTab</span><span class="o">(</span><span class="n">Node</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">// 处理root的左子树
</span><span class="c1"></span>        <span class="n">buildHuffmanCodeTab</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">,</span> <span class="s">&#34;0&#34;</span><span class="o">,</span> <span class="k">new</span> <span class="n">StringBuilder</span><span class="o">());</span>
        <span class="c1">// 处理root的右子树
</span><span class="c1"></span>        <span class="n">buildHuffmanCodeTab</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">,</span> <span class="s">&#34;1&#34;</span><span class="o">,</span> <span class="k">new</span> <span class="n">StringBuilder</span><span class="o">());</span>
        <span class="k">return</span> <span class="n">huffmanCodes</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// 获取huffman编码表
</span><span class="c1"></span>    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">buildHuffmanCodeTab</span><span class="o">(</span><span class="n">Node</span> <span class="n">node</span><span class="o">,</span> <span class="n">String</span> <span class="n">code</span><span class="o">,</span> <span class="n">StringBuilder</span> <span class="n">stringBuilder</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">StringBuilder</span> <span class="n">curNodeCode</span> <span class="o">=</span> <span class="k">new</span> <span class="n">StringBuilder</span><span class="o">(</span><span class="n">stringBuilder</span><span class="o">);</span>
        <span class="n">curNodeCode</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">code</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">node</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">// 判断当前node 是叶子结点还是非叶子结点
</span><span class="c1"></span>        <span class="k">if</span> <span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">data</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// 非叶子结点
</span><span class="c1"></span>            <span class="c1">// 向左递归
</span><span class="c1"></span>            <span class="n">buildHuffmanCodeTab</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">left</span><span class="o">,</span> <span class="s">&#34;0&#34;</span><span class="o">,</span> <span class="n">curNodeCode</span><span class="o">);</span>
            <span class="c1">// 向右递归
</span><span class="c1"></span>            <span class="n">buildHuffmanCodeTab</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">right</span><span class="o">,</span> <span class="s">&#34;1&#34;</span><span class="o">,</span> <span class="n">curNodeCode</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="c1">// 表示找到某个叶子结点的最后
</span><span class="c1"></span>            <span class="n">huffmanCodes</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">data</span><span class="o">,</span> <span class="n">curNodeCode</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="c1">// 压缩传入字节（将传入字符串转成字节类型）将待压缩字节转换为字节数组
</span><span class="c1"></span>    <span class="kd">private</span> <span class="kt">byte</span><span class="o">[]</span> <span class="nf">zip</span><span class="o">(</span><span class="kt">byte</span><span class="o">[]</span> <span class="n">bytes</span><span class="o">,</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">Byte</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;</span> <span class="n">huffmanCodes</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 利用 huffmanCodes 将 bytes 转成 赫夫曼编码对应的字符串
</span><span class="c1"></span>        <span class="n">StringBuilder</span> <span class="n">stringBuilder</span> <span class="o">=</span> <span class="k">new</span> <span class="n">StringBuilder</span><span class="o">();</span>
        <span class="c1">// 遍历bytes 数组
</span><span class="c1"></span>        <span class="k">for</span> <span class="o">(</span><span class="kt">byte</span> <span class="n">b</span> <span class="o">:</span> <span class="n">bytes</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">stringBuilder</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">huffmanCodes</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">b</span><span class="o">));</span>
        <span class="o">}</span>

        <span class="c1">// 统计返回 byte[] huffmanCodeBytes 长度
</span><span class="c1"></span>        <span class="kt">int</span> <span class="n">len</span><span class="o">;</span>
        <span class="c1">// 等同于 int len = (stringBuilder.length() + 7) / 8;
</span><span class="c1"></span>        <span class="kt">byte</span> <span class="n">countToEight</span> <span class="o">=</span> <span class="o">(</span><span class="kt">byte</span><span class="o">)</span> <span class="o">(</span><span class="n">stringBuilder</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&amp;</span> <span class="n">7</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">countToEight</span> <span class="o">==</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">len</span> <span class="o">=</span> <span class="n">stringBuilder</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&gt;&gt;</span> <span class="n">3</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="n">len</span> <span class="o">=</span> <span class="o">(</span><span class="n">stringBuilder</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&gt;&gt;</span> <span class="n">3</span><span class="o">)</span> <span class="o">+</span> <span class="n">1</span><span class="o">;</span>
            <span class="c1">// 后面补零
</span><span class="c1"></span>            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">countToEight</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">8</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                <span class="n">stringBuilder</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="s">&#34;0&#34;</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// 创建 存储压缩后的 byte数组，huffmanCodeBytes[len]记录赫夫曼编码最后一个字节的有效位数
</span><span class="c1"></span>        <span class="kt">byte</span><span class="o">[]</span> <span class="n">huffmanCodeBytes</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">byte</span><span class="o">[</span><span class="n">len</span> <span class="o">+</span> <span class="n">1</span><span class="o">];</span>
        <span class="n">huffmanCodeBytes</span><span class="o">[</span><span class="n">len</span><span class="o">]</span> <span class="o">=</span> <span class="n">countToEight</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
        <span class="c1">// 因为是每8位对应一个byte,所以步长 +8
</span><span class="c1"></span>        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">stringBuilder</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="n">i</span> <span class="o">+=</span> <span class="n">8</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">String</span> <span class="n">strByte</span><span class="o">;</span>
            <span class="n">strByte</span> <span class="o">=</span> <span class="n">stringBuilder</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">i</span> <span class="o">+</span> <span class="n">8</span><span class="o">);</span>
            <span class="c1">// 将strByte 转成一个byte,放入到 huffmanCodeBytes
</span><span class="c1"></span>            <span class="n">huffmanCodeBytes</span><span class="o">[</span><span class="n">index</span><span class="o">]</span> <span class="o">=</span> <span class="o">(</span><span class="kt">byte</span><span class="o">)</span> <span class="n">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">strByte</span><span class="o">,</span> <span class="n">2</span><span class="o">);</span>
            <span class="n">index</span><span class="o">++;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">huffmanCodeBytes</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// 将 byte 转换为对应的字符串
</span><span class="c1"></span>    <span class="kd">private</span> <span class="n">String</span> <span class="nf">byteToBitString</span><span class="o">(</span><span class="kt">byte</span> <span class="n">b</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">b</span><span class="o">;</span>
        <span class="c1">// 如果是正数我们需要将高位补零
</span><span class="c1"></span>        <span class="n">temp</span> <span class="o">|=</span> <span class="n">0x100</span><span class="o">;</span>
        <span class="c1">// 转换为二进制字符串，正数：高位补 0 即可，然后截取低八位即可；负数直接截取低八位即可
</span><span class="c1"></span>        <span class="c1">// 负数在计算机内存储的是补码，补码转原码：先 -1 ，再取反
</span><span class="c1"></span>        <span class="n">String</span> <span class="n">binaryStr</span> <span class="o">=</span> <span class="n">Integer</span><span class="o">.</span><span class="na">toBinaryString</span><span class="o">(</span><span class="n">temp</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">binaryStr</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="n">binaryStr</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">-</span> <span class="n">8</span><span class="o">);</span>
    <span class="o">}</span>

<span class="o">}</span>

<span class="kd">class</span> <span class="nc">Node</span> <span class="kd">implements</span> <span class="n">Comparable</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="n">Byte</span> <span class="n">data</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">weight</span><span class="o">;</span>
    <span class="n">Node</span> <span class="n">left</span><span class="o">;</span>
    <span class="n">Node</span> <span class="n">right</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">Node</span><span class="o">(</span><span class="n">Byte</span> <span class="n">data</span><span class="o">,</span> <span class="kt">int</span> <span class="n">weight</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">weight</span> <span class="o">=</span> <span class="n">weight</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">compareTo</span><span class="o">(</span><span class="n">Node</span> <span class="n">o</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 从小到大排序
</span><span class="c1"></span>        <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">weight</span> <span class="o">-</span> <span class="n">o</span><span class="o">.</span><span class="na">weight</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="n">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="s">&#34;Node [data = &#34;</span> <span class="o">+</span> <span class="n">data</span> <span class="o">+</span> <span class="s">&#34; weight=&#34;</span> <span class="o">+</span> <span class="n">weight</span> <span class="o">+</span> <span class="s">&#34;]&#34;</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><h3 id="分治算法">分治算法</h3>
<p>分治法是一种很重要的算法。字面上的解释是“分而治之”，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题……直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。这个技巧是很多高效算法的基础，如排序算法(快速排序，归并排序)，傅立叶变换(快速傅立叶变换)……</p>
<p>分治法的设计思想是：将一个难以直接解决的大问题，分割成一些规模较小的相同问题，以便各个击破，分而治之。</p>
<p>使用分治算饭解决汉诺塔问题</p>
<blockquote>
<p>汉诺塔（又称河内塔）问题是源于印度一个古老传说的益智玩具。大梵天创造世界的时候做了三根金刚石柱子，在一根柱子上从下往上按照大小顺序摞着64片黄金圆盘。大梵天命令婆罗门把圆盘从下面开始按大小顺序重新摆放在另一根柱子上。并且规定，在小圆盘上不能放大圆盘，在三根柱子之间一次只能移动一个圆盘。</p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">HanoiTowerDemo</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">HanoiTower</span> <span class="n">hanoiTower</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HanoiTower</span><span class="o">();</span>
        <span class="n">hanoiTower</span><span class="o">.</span><span class="na">hanoiTower</span><span class="o">(</span><span class="n">3</span><span class="o">,</span> <span class="sc">&#39;A&#39;</span><span class="o">,</span> <span class="sc">&#39;B&#39;</span><span class="o">,</span> <span class="sc">&#39;C&#39;</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">HanoiTower</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">hanoiTower</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">,</span> <span class="kt">char</span> <span class="n">a</span><span class="o">,</span> <span class="kt">char</span> <span class="n">b</span><span class="o">,</span> <span class="kt">char</span> <span class="n">c</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">&lt;=</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">==</span> <span class="n">1</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">a</span> <span class="o">+</span> <span class="s">&#34;-&gt;&#34;</span> <span class="o">+</span> <span class="n">c</span><span class="o">);</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">// 将a塔上面除了底盘外的所有盘移动到b塔
</span><span class="c1"></span>        <span class="n">hanoiTower</span><span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">1</span><span class="o">,</span> <span class="n">a</span><span class="o">,</span> <span class="n">c</span><span class="o">,</span> <span class="n">b</span><span class="o">);</span>

        <span class="c1">// 将a塔遗留的底盘移动到c塔
</span><span class="c1"></span>        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">a</span> <span class="o">+</span> <span class="s">&#34;-&gt;&#34;</span> <span class="o">+</span> <span class="n">c</span><span class="o">);</span>

        <span class="c1">// 将b塔上面的所有盘移动到c塔
</span><span class="c1"></span>        <span class="n">hanoiTower</span><span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">1</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">a</span><span class="o">,</span> <span class="n">c</span><span class="o">);</span>
    <span class="o">}</span>

<span class="o">}</span>
</code></pre></div><h3 id="动态规划算法">动态规划算法</h3>
<p>动态规划(Dynamic Programming)算法的核心思想是：将大问题划分为小问题进行解决，从而一步步获取最优解的处理算法。</p>
<p>动态规划算法与分治算法类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。与分治法不同的是，适合于用动态规划求解的问题，经分解得到子问题往往不是互相独立的。 ( 即下一个子阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解 )</p>
<p>关于动态规划最经典的问题当属背包问题。</p>
<blockquote>
<p>背包问题主要是指一个给定容量的背包、若干具有一定价值和重量的物品，如何选择物品放入背包使物品的价值最大。其中又分01背包和完全背包(完全背包指的是：每种物品都有无限件可用)这里的问题属于01背包，即每个物品最多放一个。而无限背包可以转化为01背包。</p>
<table>
<thead>
<tr>
<th>物品</th>
<th>重量</th>
<th>价格</th>
</tr>
</thead>
<tbody>
<tr>
<td>吉他(G)</td>
<td>1</td>
<td>1500</td>
</tr>
<tr>
<td>音响(S)</td>
<td>4</td>
<td>3000</td>
</tr>
<tr>
<td>电脑(L)</td>
<td>3</td>
<td>2000</td>
</tr>
</tbody>
</table>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">KnapsackProblemDemo</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">KnapsackProblem</span> <span class="n">knapsackProblem</span> <span class="o">=</span> <span class="k">new</span> <span class="n">KnapsackProblem</span><span class="o">();</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">knapsackProblem</span><span class="o">.</span><span class="na">knapsackProblem</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">KnapsackProblem</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">knapsackProblem</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">// 物品的重量
</span><span class="c1"></span>        <span class="kt">int</span><span class="o">[]</span> <span class="n">w</span> <span class="o">=</span> <span class="o">{</span><span class="n">1</span><span class="o">,</span> <span class="n">4</span><span class="o">,</span> <span class="n">3</span><span class="o">};</span>
        <span class="c1">// 物品的价值
</span><span class="c1"></span>        <span class="kt">int</span><span class="o">[]</span> <span class="n">val</span> <span class="o">=</span> <span class="o">{</span><span class="n">1500</span><span class="o">,</span> <span class="n">3000</span><span class="o">,</span> <span class="n">2000</span><span class="o">};</span>
        <span class="c1">// 背包的容量
</span><span class="c1"></span>        <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">4</span><span class="o">;</span>
        <span class="c1">// 物品的个数
</span><span class="c1"></span>        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">val</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="c1">// 物品规划表
</span><span class="c1"></span>        <span class="kt">int</span><span class="o">[][]</span> <span class="n">v</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span> <span class="o">+</span> <span class="n">1</span><span class="o">][</span><span class="n">m</span> <span class="o">+</span> <span class="n">1</span><span class="o">];</span>

        <span class="c1">// 将v[][] 第一列和第一行重置为0
</span><span class="c1"></span>        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">v</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">v</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">v</span><span class="o">[</span><span class="n">0</span><span class="o">].</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">v</span><span class="o">[</span><span class="n">0</span><span class="o">][</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// 处理 生成物品价格表
</span><span class="c1"></span>        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">v</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">v</span><span class="o">[</span><span class="n">0</span><span class="o">].</span><span class="na">length</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                <span class="c1">// 如果当前商品的重量 是否能写入当前表格中
</span><span class="c1"></span>                <span class="k">if</span> <span class="o">(</span><span class="n">w</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">1</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">j</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">v</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">v</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">1</span><span class="o">][</span><span class="n">j</span><span class="o">];</span>
                <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                    <span class="n">v</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">v</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">1</span><span class="o">][</span><span class="n">j</span><span class="o">],</span> <span class="n">val</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">1</span><span class="o">]</span> <span class="o">+</span> <span class="n">v</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">1</span><span class="o">][</span><span class="n">j</span> <span class="o">-</span> <span class="n">w</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">1</span><span class="o">]]);</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// 处理完后 v[][] 表中数值最大的就是最后的结果
</span><span class="c1"></span>        <span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">ints</span> <span class="o">:</span> <span class="n">v</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">ints</span><span class="o">));</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">anInt</span> <span class="o">:</span> <span class="n">ints</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">anInt</span> <span class="o">&gt;</span> <span class="n">max</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">max</span> <span class="o">=</span> <span class="n">anInt</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">max</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><h3 id="kmp算法">KMP算法</h3>
<blockquote>
<p>KMP算法是一种改进的字符串匹配算法，由D.E.Knuth，J.H.Morris和V.R.Pratt提出的，因此人们称它为克努特—莫里斯—普拉特操作（简称KMP算法）。KMP算法的核心是利用匹配失败后的信息，尽量减少模式串与主串的匹配次数以达到快速匹配的目的。具体实现就是通过一个next()函数实现，函数本身包含了模式串的局部匹配信息。KMP算法的时间复杂度O(m+n)。</p>
</blockquote>
<ul>
<li>
<p>常规算法匹配字符串</p>
<p><img src="/iblog/posts/annex/images/essays/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-042.gif" alt="数据结构与算法-042"></p>
<p>从主串的起始位置（或指定位置）开始与模式串的第一个字符比较，若相等，则继续逐个比较后续字符；否则从主串的下一个字符再重新和模式串的字符比较。依次类推，直到模式串成功匹配，返回主串中第一次出现模式串字符的位置，或者模式串匹配不成功，这里约定返回-1。</p>
</li>
<li>
<p>KMP算法匹配字符串</p>
<p><img src="/iblog/posts/annex/images/essays/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-043.gif" alt="数据结构与算法-043"></p>
<p>主要就是改进了暴力匹配中i回溯的操作，KMP算法中当一趟匹配过程中出现字符比较不等时，不直接回溯i，而是利用已经得到的“部分匹配”的结果将模式串向右移动（j-next[j-1]）的距离。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">KMPDemo</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">KMP</span> <span class="n">kmp</span> <span class="o">=</span> <span class="k">new</span> <span class="n">KMP</span><span class="o">();</span>
        <span class="n">String</span> <span class="n">str1</span> <span class="o">=</span> <span class="s">&#34;BBC ABCDAB ABCDABCDABDE&#34;</span><span class="o">;</span>
        <span class="n">String</span> <span class="n">str2</span> <span class="o">=</span> <span class="s">&#34;ABCDABD&#34;</span><span class="o">;</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">next</span> <span class="o">=</span> <span class="n">kmp</span><span class="o">.</span><span class="na">getMatchTab</span><span class="o">(</span><span class="n">str2</span><span class="o">);</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">next</span><span class="o">));</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">kmp</span><span class="o">.</span><span class="na">kmpSearch</span><span class="o">(</span><span class="n">str1</span><span class="o">,</span> <span class="n">str2</span><span class="o">,</span> <span class="n">next</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>
  
<span class="kd">class</span> <span class="nc">KMP</span> <span class="o">{</span>
  
    <span class="c1">// 获取KMP 部分匹配表
</span><span class="c1"></span>    <span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">getMatchTab</span><span class="o">(</span><span class="n">String</span> <span class="n">dest</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">dest</span><span class="o">.</span><span class="na">length</span><span class="o">()];</span>
        <span class="c1">// 部分匹配表第一个值始终为0
</span><span class="c1"></span>        <span class="n">result</span><span class="o">[</span><span class="n">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">1</span><span class="o">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">result</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// KMP 核心（特点，公式）
</span><span class="c1"></span>            <span class="k">while</span> <span class="o">(</span><span class="n">j</span> <span class="o">&gt;</span> <span class="n">0</span> <span class="o">&amp;&amp;</span> <span class="n">dest</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">!=</span> <span class="n">dest</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">))</span> <span class="o">{</span>
                <span class="n">j</span> <span class="o">=</span> <span class="n">result</span><span class="o">[</span><span class="n">j</span> <span class="o">-</span> <span class="n">1</span><span class="o">];</span>
            <span class="o">}</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">dest</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">)</span> <span class="o">==</span> <span class="n">dest</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">))</span> <span class="o">{</span>
                <span class="n">j</span><span class="o">++;</span>
            <span class="o">}</span>
            <span class="n">result</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">j</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>
  
    <span class="cm">/**
</span><span class="cm">     * KMP查找算法
</span><span class="cm">     *
</span><span class="cm">     * @param str1 原字符串
</span><span class="cm">     * @param str2 子字符串
</span><span class="cm">     * @param next 部分匹配表
</span><span class="cm">     * @return 匹配到字符串的第一个索引位置
</span><span class="cm">     */</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">kmpSearch</span><span class="o">(</span><span class="n">String</span> <span class="n">str1</span><span class="o">,</span> <span class="n">String</span> <span class="n">str2</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">next</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">str1</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">j</span> <span class="o">&gt;</span> <span class="n">0</span> <span class="o">&amp;&amp;</span> <span class="n">str1</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">!=</span> <span class="n">str2</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">))</span> <span class="o">{</span>
                <span class="n">j</span> <span class="o">=</span> <span class="n">next</span><span class="o">[</span><span class="n">j</span> <span class="o">-</span> <span class="n">1</span><span class="o">];</span>
            <span class="o">}</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">str1</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">==</span> <span class="n">str2</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">))</span> <span class="o">{</span>
                <span class="n">j</span><span class="o">++;</span>
            <span class="o">}</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">j</span> <span class="o">==</span> <span class="n">str2</span><span class="o">.</span><span class="na">length</span><span class="o">())</span> <span class="o">{</span>
                <span class="k">return</span> <span class="n">i</span> <span class="o">-</span> <span class="n">j</span> <span class="o">+</span> <span class="n">1</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">1</span><span class="o">;</span>
    <span class="o">}</span>
  
<span class="o">}</span>
</code></pre></div></li>
</ul>
<h3 id="贪心算法">贪心算法</h3>
<h3 id="普里姆算法">普里姆算法</h3>
<h3 id="克鲁斯卡尔算法">克鲁斯卡尔算法</h3>
<h3 id="迪杰斯特拉算法">迪杰斯特拉算法</h3>
<h3 id="弗洛伊德算法">弗洛伊德算法</h3>
<h3 id="马踏棋盘算法">马踏棋盘算法</h3>
</div>
                    <div class="post_footer">
                        <div class="meta">
                            <div class="info">
                                <span class="field tags">
                                    <i class="ri-stack-line"></i>
                                    
                                    
                                    <a href="https://whiteppure.github.io/iblog/tags/java/">Java</a>
                                    
                                    <a href="https://whiteppure.github.io/iblog/tags/%E7%AE%97%E6%B3%95/">算法</a>
                                    
                                    
                                    
                                    <span id="busuanzi_container_page_pv">
                                      阅读量<span id="busuanzi_value_page_pv"></span>次
                                    </span>
                                    
                                </span>
                            </div>
                        </div>
                    </div>
                </div>
                
                
                
<div class="doc_comments">
    <div class="comments_block_title">发表评论</div>
    <div id="vcomments"></div>
</div>

<link rel="stylesheet" href="https://whiteppure.github.io/iblog/css/comments.css" />

<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src='//unpkg.com/valine/dist/Valine.min.js'></script>


<script type="text/javascript">
    new Valine({
        el: '#vcomments',
        appId: 'pRSrjsfbN6L1DUxgfqJWOMYP-gzGzoHsz',
        appKey: 'VPWpnDPGDM8Xhdlh5OvHOpak',
        placeholder: '说点什么吧...',
        visitor: 'true',
        
        emojiCDN: '//i0.hdslb.com/bfs/emote/',
        
        emojiMaps: {
            "tv_doge": "6ea59c827c414b4a2955fe79e0f6fd3dcd515e24.png",
            "tv_亲亲": "a8111ad55953ef5e3be3327ef94eb4a39d535d06.png",
            "tv_偷笑": "bb690d4107620f1c15cff29509db529a73aee261.png",
            "tv_再见": "180129b8ea851044ce71caf55cc8ce44bd4a4fc8.png",
            "tv_冷漠": "b9cbc755c2b3ee43be07ca13de84e5b699a3f101.png",
            "tv_发怒": "34ba3cd204d5b05fec70ce08fa9fa0dd612409ff.png",
            "tv_发财": "34db290afd2963723c6eb3c4560667db7253a21a.png",
            "tv_可爱": "9e55fd9b500ac4b96613539f1ce2f9499e314ed9.png",
            "tv_吐血": "09dd16a7aa59b77baa1155d47484409624470c77.png",
            "tv_呆": "fe1179ebaa191569b0d31cecafe7a2cd1c951c9d.png",
            "tv_呕吐": "9f996894a39e282ccf5e66856af49483f81870f3.png",
            "tv_困": "241ee304e44c0af029adceb294399391e4737ef2.png",
            "tv_坏笑": "1f0b87f731a671079842116e0991c91c2c88645a.png",
            "tv_大佬": "093c1e2c490161aca397afc45573c877cdead616.png",
            "tv_大哭": "23269aeb35f99daee28dda129676f6e9ea87934f.png",
            "tv_委屈": "d04dba7b5465779e9755d2ab6f0a897b9b33bb77.png",
            "tv_害羞": "a37683fb5642fa3ddfc7f4e5525fd13e42a2bdb1.png",
            "tv_尴尬": "7cfa62dafc59798a3d3fb262d421eeeff166cfa4.png",
            "tv_微笑": "70dc5c7b56f93eb61bddba11e28fb1d18fddcd4c.png",
            "tv_思考": "90cf159733e558137ed20aa04d09964436f618a1.png",
            "tv_惊吓": "0d15c7e2ee58e935adc6a7193ee042388adc22af.png",
            "tv_打脸": "56ab10b624063e966bfcb76ea5dc4794d87dfd47.png",
            "tv_抓狂": "fe31c08edad661d63762b04e17b8d5ae3c71a757.png",
            "tv_抠鼻": "c666f55e88d471e51bbd9fab9bb308110824a6eb.png",
            "tv_斜眼笑": "911f987aa8bc1bee12d52aafe62bc41ef4474e6c.png",
            "tv_无奈": "ea8ed89ee9878f2fece2dda0ea8a5dbfe21b5751.png",
            "tv_晕": "5443c22b4d07fb1907ccc610c8e6db254f2461b7.png",
            "tv_流汗": "cead1c351ab8d79e9f369605beb90148db0fbed3.png",
            "tv_流泪": "7e71cde7858f0cd50d74b0264aa26db612a8a167.png",
            "tv_流鼻血": "c32d39db2737f89b904ca32700d140a9241b0767.png",
            "tv_点赞": "f85c354995bd99e28fc76c869bfe42ba6438eff4.png",
            "tv_生气": "26702dcafdab5e8225b43ffd23c94ac1ff932654.png",
            "tv_生病": "8b0ec90e6b86771092a498c54f09fc94621c1900.png",
            "tv_疑问": "0793d949b18d7be716078349c202c15ff166f314.png",
            "tv_白眼": "c1d59f439e379ee50eef488bcb5e5378e5044ea4.png",
            "tv_皱眉": "72ccad6679fea0d14cce648b4d818e09b8ffea2d.png",
            "tv_目瞪口呆": "0b8cb81a68de5d5365212c99375e7ace3e7891b7.png",
            "tv_睡着": "8b196675b53af58264f383c50ad0945048290b33.png",
            "tv_笑哭": "1abc628f6d4f4caf9d0e7800878f4697abbc8273.png",
            "tv_腼腆": "89712c0d4af73e67f89e35cbc518420380a7f6f4.png",
            "tv_色": "61822c7e9aae5da76475e7892534545336b23a6f.png",
            "tv_调侃": "4bc022533ef31544ca0d72c12c808cf4a1cce3e3.png",
            "tv_调皮": "b9c41de8e82dd7a8515ae5e3cb63e898bf245186.png",
            "tv_鄙视": "6e72339f346a692a495b123174b49e4e8e781303.png",
            "tv_闭嘴": "c9e990da7f6e93975e25fd8b70e2e290aa4086ef.png",
            "tv_难过": "87f46748d3f142ebc6586ff58860d0e2fc8263ba.png",
            "tv_馋": "fc7e829b845c43c623c8b490ee3602b7f0e76a31.png",
            "tv_鬼脸": "0ffbbddf8a94d124ca2f54b360bbc04feb6bbfea.png",
            "tv_黑人问号": "45821a01f51bc867da9edbaa2e070410819a95b2.png",
            "tv_鼓掌": "1d21793f96ef4e6f48b23e53e3b9e42da833a0f6.png"
        }
    })
</script>

                
            </div>
        </div>
    </div>
    <a id="back_to_top" href="#" class="back_to_top"><i class="ri-arrow-up-s-line"></i></a>
    <footer class="footer">
    <div class="powered_by">
        <a href="https://varkai.com">Designed by VarKai,</a>
        <a href="http://www.gohugo.io/">Proudly published with Hugo</a>
    </div>

    <div class="footer_slogan">
        <span>whitepure@2021</span>
    </div>
</footer>
    <script src="https://whiteppure.github.io/iblog/js/jquery-3.5.1.min.js"></script>
<link href="https://whiteppure.github.io/iblog/css/fancybox.min.css" rel="stylesheet">
<script src="https://whiteppure.github.io/iblog/js/fancybox.min.js"></script>
<script src="https://whiteppure.github.io/iblog/js/zozo.js"></script>


<script type="text/javascript" async
    src="https://cdn.bootcss.com/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
        MathJax.Hub.Config({
            tex2jax: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\[\[', '\]\]']],
                processEscapes: true,
                processEnvironments: true,
                skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
                TeX: {
                    equationNumbers: { autoNumber: "AMS" },
                    extensions: ["AMSmath.js", "AMSsymbols.js"]
                }
            }
        });

        MathJax.Hub.Queue(function () {
            
            
            
            var all = MathJax.Hub.getAllJax(), i;
            for (i = 0; i < all.length; i += 1) {
                all[i].SourceElement().parentNode.className += ' has-jax';
            }
        });
    </script>

<style>
    code.has-jax {
        font: inherit;
        font-size: 100%;
        background: inherit;
        border: inherit;
        color: #515151;
    }
</style>




<script src="https://cdn.bootcdn.net/ajax/libs/jspdf/1.0.106/jspdf.debug.js"></script>
<script src="https://cdn.bootcdn.net/ajax/libs/html2canvas/0.5.0-beta4/html2canvas.js"></script>
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

























































</body>

</html>