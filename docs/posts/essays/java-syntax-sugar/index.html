<!DOCTYPE html>
<html lang="zh" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="whitepure" />
	
	
	
	<title>Java语法糖 ｜ 唯手熟尔</title>
	
    
    
    <meta name="description" content="原文地址：https://www.jianshu.com/p/0f967298a5d7 语法糖 语法糖（Syntactic Sugar），也称糖衣语法，是由英国计算机" />
    

    
    
    <meta name="keywords" content="whitepure博客, whiteppure, whitepure" />
    

	
    
    <link rel="shortcut icon" href="https://whiteppure.github.io/iblog/images/favicon.ico" />

    <link rel="stylesheet" type="text/css" media="screen" href="https://whiteppure.github.io/iblog/css/normalize.css" />
    <link rel="stylesheet" type="text/css" media="screen" href="https://cdn.jsdelivr.net/npm/animate.css@4.1.0/animate.min.css" />
    <link rel="stylesheet" type="text/css" media="screen" href="https://whiteppure.github.io/iblog/css/zozo.css" />
	<link rel="stylesheet" type="text/css" media="screen" href="https://cdn.jsdelivr.net/npm/remixicon@2.5.0/fonts/remixicon.css" />
    <link rel="stylesheet" type="text/css" media="screen" href="https://whiteppure.github.io/iblog/css/highlight.css" />

    <link rel="stylesheet" type="text/css" media="screen" href="https://whiteppure.github.io/iblog/css/toc.css" />

    
    
</head>

<body>
    
    
    









<div class="toc">
    <div class="page-header"><strong></strong></div>
    <div id="page-scrollspy" class="toc-nav">
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e8%af%ad%e6%b3%95%e7%b3%96">
                    语法糖
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e8%a7%a3%e8%af%ad%e6%b3%95%e7%b3%96">
                    解语法糖
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#switch-%e6%94%af%e6%8c%81-string-%e4%b8%8e%e6%9e%9a%e4%b8%be">
                    switch 支持 String 与枚举
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e6%b3%9b%e5%9e%8b">
                    泛型
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e8%87%aa%e5%8a%a8%e8%a3%85%e7%ae%b1%e4%b8%8e%e6%8b%86%e7%ae%b1">
                    自动装箱与拆箱
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e6%96%b9%e6%b3%95%e5%8f%98%e9%95%bf%e5%8f%82%e6%95%b0">
                    方法变长参数
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e6%9e%9a%e4%b8%be">
                    枚举
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e5%86%85%e9%83%a8%e7%b1%bb">
                    内部类
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e6%96%ad%e8%a8%80">
                    断言
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e6%95%b0%e5%80%bc%e5%ad%97%e9%9d%a2%e9%87%8f">
                    数值字面量
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#for-each">
                    for-each
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#try-with-resource">
                    try-with-resource
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#lambda%e8%a1%a8%e8%be%be%e5%bc%8f">
                    Lambda表达式
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e5%8f%af%e8%83%bd%e9%81%87%e5%88%b0%e7%9a%84%e5%9d%91">
                    可能遇到的坑
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e6%b3%9b%e5%9e%8b%e5%bd%93%e6%b3%9b%e5%9e%8b%e9%81%87%e5%88%b0%e9%87%8d%e8%bd%bd">
                    泛型——当泛型遇到重载
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e6%b3%9b%e5%9e%8b%e5%bd%93%e6%b3%9b%e5%9e%8b%e9%81%87%e5%88%b0catch">
                    泛型——当泛型遇到catch
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e8%87%aa%e5%8a%a8%e8%a3%85%e7%ae%b1%e4%b8%8e%e6%8b%86%e7%ae%b1%e5%af%b9%e8%b1%a1%e7%9b%b8%e7%ad%89%e6%af%94%e8%be%83">
                    自动装箱与拆箱——对象相等比较
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e5%a2%9e%e5%bc%bafor%e5%be%aa%e7%8e%af">
                    增强for循环
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e6%80%bb%e7%bb%93">
                    总结
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
    </div>
</div>



    
    <div class="main animate__animated animate__fadeInDown" id="pdf_content">
        <div class="nav_container animated fadeInDown">
    <div class="site_nav" id="site_nav">
        <ul><li class="">
                <a href="https://whiteppure.github.io/iblog/">首页</a>
            </li><li class="">
                <a href="https://whiteppure.github.io/iblog/posts/">归档</a>
            </li><li class="">
                <a href="https://whiteppure.github.io/iblog/tags/">标签</a>
            </li><li class="">
                <a href="https://whiteppure.github.io/iblog/about/">关于</a>
            </li>
        </ul>
    </div>
    <div class="menu_icon">
        <a id="menu_icon"><i class="ri-menu-line"></i></a>
    </div>
</div>
        <div class="header animated fadeInDown">
    <div class="site_title_container">
        <div class="site_title">
            <h1>
                <a href="https://whiteppure.github.io/iblog/">
                    <span>唯手熟尔</span>
                </a>
            </h1>
        </div>
        <div class="description">
            <p class="sub_title">
                无他,唯手熟尔
            </p>
            <div class="my_socials">
                
                
                <a href="https://github.com/whiteppure/" title="github" target="_blank">
                    <i class="ri-github-fill"></i>
                </a>
                
                
                <a href="https://whiteppure.github.io/iblog/index.xml" type="application/rss+xml" title="rss" target="_blank">
                    <i class="ri-rss-fill"></i>
                </a>
                



            </div>
            
            <div class="post">
                <div class="post_title post_detail_title">
                    <span class="date" id="busuanzi_container_site_pv">访问量 <span id="busuanzi_value_site_pv"></span>次</span>
                </div>
                <div class="post_title post_detail_title">
                    <span class="date" id="busuanzi_container_site_uv">访客数 <span id="busuanzi_value_site_uv"></span>人</span>
                </div>
            </div>
            
        </div>
    </div>
</div>
        <div class="content">
            <div class="post_page">
                <div class="post animate__animated animate__fadeInDown">
                    <div class="post_title post_detail_title">
                        <h2><a href='/iblog/posts/essays/java-syntax-sugar/'>Java语法糖</a></h2>
                        <span class="date">2021.04.10</span>
                    </div>
                    <div class="post_content markdown"><p>原文地址：<a href="https://www.jianshu.com/p/0f967298a5d7">https://www.jianshu.com/p/0f967298a5d7</a></p>
<h2 id="语法糖">语法糖</h2>
<p>语法糖（<code>Syntactic Sugar</code>），也称糖衣语法，是由英国计算机学家 <code>Peter.J.Landin</code> 发明的一个术语，指在计算机语言中添加的某种语法，
这种语法对语言的功能并没有影响，但是更方便程序员使用。简而言之，语法糖让程序更加简洁，有更高的可读性。</p>
<blockquote>
<p>在编程领域，除了语法糖，还有语法盐和语法糖精的说法，篇幅有限这里不做扩展了。
我们所熟知的编程语言中几乎都有语法糖。作者认为，语法糖的多少是评判一个语言够不够牛逼的标准之一。</p>
</blockquote>
<p>很多人说Java是一个“低糖语言”，其实从Java 7开始Java语言层面上一直在添加各种糖，
主要是在“Project Coin”项目下研发。尽管现在Java有人还是认为现在的Java是低糖，未来还会持续向着“高糖”的方向发展。</p>
<h3 id="解语法糖">解语法糖</h3>
<p>前面提到过，语法糖的存在主要是方便开发人员使用。但其实，Java虚拟机并不支持这些语法糖。这些语法糖在编译阶段就会被还原成简单的基础语法结构，这个过程就是解语法糖。</p>
<p>说到编译，大家肯定都知道，Java语言中，javac命令可以将后缀名为.java的源文件编译为后缀名为.class的可以运行于Java虚拟机的字节码。</p>
<p>如果你去看<code>com.sun.tools.javac.main.JavaCompiler</code>的源码，你会发现在<code>compile()</code>中有一个步骤就是调用<code>desugar()</code>，这个方法就是负责解语法糖的实现的。</p>
<p>Java 中最常用的语法糖主要有泛型、变长参数、条件编译、自动拆装箱、内部类等。本文主要来分析下这些语法糖背后的原理。一步一步剥去糖衣，看看其本质。</p>
<h4 id="switch-支持-string-与枚举">switch 支持 String 与枚举</h4>
<p>前面提到过，从Java 7 开始，Java语言中的语法糖在逐渐丰富，其中一个比较重要的就是Java 7中switch开始支持String。</p>
<p>在开始coding之前先科普下，Java中的swith自身原本就支持基本类型。比如int、char等。</p>
<p>对于int类型，直接进行数值的比较。对于char类型则是比较其ascii码。</p>
<p>所以，对于编译器来说，switch中其实只能使用整型，任何类型的比较都要转换成整型。比如<code>byte。short，char</code>(ackii码是整型)以及int。</p>
<p>那么接下来看下switch对String得支持，有以下代码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public class switchDemoString {
</span></span><span class="line"><span class="cl">    public static void main(String[] args) {
</span></span><span class="line"><span class="cl">        String str = &#34;world&#34;;
</span></span><span class="line"><span class="cl">        switch (str) {
</span></span><span class="line"><span class="cl">            case &#34;hello&#34;:
</span></span><span class="line"><span class="cl">                        System.out.println(&#34;hello&#34;);
</span></span><span class="line"><span class="cl">            break;
</span></span><span class="line"><span class="cl">            case &#34;world&#34;:
</span></span><span class="line"><span class="cl">                        System.out.println(&#34;world&#34;);
</span></span><span class="line"><span class="cl">            break;
</span></span><span class="line"><span class="cl">            default:
</span></span><span class="line"><span class="cl">                        break;
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><p>反编译后内容如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public class switchDemoString
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">    public switchDemoString()
</span></span><span class="line"><span class="cl">        {
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    public static void main(String args[])
</span></span><span class="line"><span class="cl">        {
</span></span><span class="line"><span class="cl">        String str = &#34;world&#34;;
</span></span><span class="line"><span class="cl">        String s;
</span></span><span class="line"><span class="cl">        switch((s = str).hashCode())
</span></span><span class="line"><span class="cl">                {
</span></span><span class="line"><span class="cl">            default:
</span></span><span class="line"><span class="cl">                        break;
</span></span><span class="line"><span class="cl">            case 99162322:
</span></span><span class="line"><span class="cl">                        if(s.equals(&#34;hello&#34;))
</span></span><span class="line"><span class="cl">                            System.out.println(&#34;hello&#34;);
</span></span><span class="line"><span class="cl">            break;
</span></span><span class="line"><span class="cl">            case 113318802:
</span></span><span class="line"><span class="cl">                        if(s.equals(&#34;world&#34;))
</span></span><span class="line"><span class="cl">                            System.out.println(&#34;world&#34;);
</span></span><span class="line"><span class="cl">            break;
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><p>看到这个代码，你知道原来字符串的switch是通过equals()和hashCode()方法来实现的。还好hashCode()方法返回的是int，而不是long。</p>
<blockquote>
<p>仔细看下可以发现，进行switch的实际是哈希值，然后通过使用equals方法比较进行安全检查，这个检查是必要的，
因为哈希可能会发生碰撞。因此它的性能是不如使用枚举进行switch或者使用纯整数常量，但这也不是很差。</p>
</blockquote>
<h4 id="泛型">泛型</h4>
<p>我们都知道，很多语言都是支持泛型的，但是很多人不知道的是，不同的编译器对于泛型的处理方式是不同的。</p>
<p>通常情况下，一个编译器处理泛型有两种方式：<code>Code specialization</code>和<code>Code sharing</code>。</p>
<p>C++和C#是使用<code>Code specialization</code>的处理机制，而Java使用的是<code>Code sharing</code>的机制。</p>
<blockquote>
<p>Code sharing方式为每个泛型类型创建唯一的字节码表示，并且将该泛型类型的实例都映射到这个唯一的字节码表示上。将多种泛型类形实例映射到唯一的字节码表示是通过类型擦除（type erasue）实现的。
也就是说，对于Java虚拟机来说，他根本不认识Map&lt;String, String&gt; map这样的语法。需要在编译阶段通过类型擦除的方式进行解语法糖。</p>
</blockquote>
<p>类型擦除的主要过程如下：</p>
<ul>
<li>将所有的泛型参数用其最左边界（最顶级的父类型）类型替换。</li>
<li>移除所有的类型参数。</li>
</ul>
<p>以下代码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();  
</span></span><span class="line"><span class="cl">map.put(&#34;name&#34;, &#34;suxiansheng&#34;);  
</span></span><span class="line"><span class="cl">map.put(&#34;wechat&#34;, &#34;java&#34;);  
</span></span><span class="line"><span class="cl">map.put(&#34;blog&#34;, &#34;https://www.jianshu.com/u/94111742c97c&#34;);  
</span></span></code></pre></div><p>解语法糖之后会变成：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">Map map = new HashMap();  
</span></span><span class="line"><span class="cl">map.put(&#34;name&#34;, &#34;suxiansheng&#34;);  
</span></span><span class="line"><span class="cl">map.put(&#34;wechat&#34;, &#34;Java&#34;);  
</span></span><span class="line"><span class="cl">map.put(&#34;blog&#34;, &#34;https://www.jianshu.com/u/94111742c97c&#34;);  
</span></span></code></pre></div><p>以下代码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public static &lt;A extends Comparable&lt;A&gt;&gt; A max(Collection&lt;A&gt; xs) {
</span></span><span class="line"><span class="cl">    Iterator&lt;A&gt; xi = xs.iterator();
</span></span><span class="line"><span class="cl">    A w = xi.next();
</span></span><span class="line"><span class="cl">    while (xi.hasNext()) {
</span></span><span class="line"><span class="cl">        A x = xi.next();
</span></span><span class="line"><span class="cl">        if (w.compareTo(x) &lt; 0)
</span></span><span class="line"><span class="cl">            w = x;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    return w;
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><p>类型擦除后会变成：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl"> public static Comparable max(Collection xs){
</span></span><span class="line"><span class="cl">    Iterator xi = xs.iterator();
</span></span><span class="line"><span class="cl">    Comparable w = (Comparable)xi.next();
</span></span><span class="line"><span class="cl">    while(xi.hasNext())
</span></span><span class="line"><span class="cl">    {
</span></span><span class="line"><span class="cl">        Comparable x = (Comparable)xi.next();
</span></span><span class="line"><span class="cl">        if(w.compareTo(x) &lt; 0)
</span></span><span class="line"><span class="cl">            w = x;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    return w;
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><p>虚拟机中没有泛型，只有普通类和普通方法，所有泛型类的类型参数在编译时都会被擦除，泛型类并没有自己独有的Class类对象。
比如并不存在<code>List&lt;String&gt;.class</code>或是<code>List&lt;Integer&gt;.class</code>，而只有<code>List.class</code>。</p>
<h4 id="自动装箱与拆箱">自动装箱与拆箱</h4>
<p>自动装箱就是Java自动将原始类型值转换成对应的对象，比如将int的变量转换成Integer对象，这个过程叫做装箱，反之将Integer对象转换成int类型值，这个过程叫做拆箱。参考：一文读懂什么是Java中的自动拆装箱</p>
<p>因为这里的装箱和拆箱是自动进行的非人为转换，所以就称作为自动装箱和拆箱。</p>
<p>原始类型<code>byte, short, char, int, long, float, double，boolean</code> 对应的封装类为<code>Byte, Short, Character, Integer, Long, Float, Double, Boolean</code>。</p>
<p>先来看个自动装箱的代码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl"> public static void main(String[] args) {
</span></span><span class="line"><span class="cl">    int i = 10;
</span></span><span class="line"><span class="cl">    Integer n = i;
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><p>反编译后代码如下:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public static void main(String args[])
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">    int i = 10;
</span></span><span class="line"><span class="cl">    Integer n = Integer.valueOf(i);
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><p>再来看个自动拆箱的代码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public static void main(String[] args) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    Integer i = 10;
</span></span><span class="line"><span class="cl">    int n = i;
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><p>反编译后代码如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public static void main(String args[])
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">    Integer i = Integer.valueOf(10);
</span></span><span class="line"><span class="cl">    int n = i.intValue();
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><p>从反编译得到内容可以看出，在装箱的时候自动调用的是Integer的valueOf(int)方法。
而在拆箱的时候自动调用的是Integer的intValue方法。
所以，装箱过程是通过调用包装器的valueOf方法实现的，而拆箱过程是通过调用包装器的 xxxValue方法实现的。</p>
<h4 id="方法变长参数">方法变长参数</h4>
<p>可变参数(variable arguments)是在Java 1.5中引入的一个特性。它允许一个方法把任意数量的值作为参数。</p>
<p>看下以下可变参数代码，其中print方法接收可变参数：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public static void main(String[] args)
</span></span><span class="line"><span class="cl">    {
</span></span><span class="line"><span class="cl">        print(&#34;java&#34;, &#34;123&#34;, &#34;456&#34;, &#34;789&#34;);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">public static void print(String... strs)
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">    for (int i = 0; i &lt; strs.length; i++)
</span></span><span class="line"><span class="cl">    {
</span></span><span class="line"><span class="cl">        System.out.println(strs[i]);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><p>反编译后代码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public static void main(String args[])
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">    print(new String[] {
</span></span><span class="line"><span class="cl">        &#34;java&#34;, &#34;123&#34;, &#34;456&#34;, &#34;789&#34;
</span></span><span class="line"><span class="cl">    });
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">public static transient void print(String strs[])
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">    for(int i = 0; i &lt; strs.length; i++)
</span></span><span class="line"><span class="cl">        System.out.println(strs[i]);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><p>从反编译后代码可以看出，可变参数在被使用的时候，他首先会创建一个数组，数组的长度就是调用该方法是传递的实参的个数，
然后再把参数值全部放到这个数组当中，然后再把这个数组作为参数传递到被调用的方法中。</p>
<h4 id="枚举">枚举</h4>
<p>Java SE5提供了一种新的类型-Java的枚举类型，关键字enum可以将一组具名的值的有限集合创建为一种新的类型，而这些具名的值可以作为常规的程序组件使用，这是一种非常有用的功能。</p>
<p>要想看源码，首先得有一个类吧，那么枚举类型到底是什么类呢？是enum吗？</p>
<p>答案很明显不是，enum就和class一样，只是一个关键字，他并不是一个类。</p>
<p>那么枚举是由什么类维护的呢，我们简单的写一个枚举：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public enum t {
</span></span><span class="line"><span class="cl">    SPRING,SUMMER;
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><p>然后我们使用反编译，看看这段代码到底是怎么实现的，反编译后代码内容如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public final class T extends Enum
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">    private T(String s, int i)
</span></span><span class="line"><span class="cl">    {
</span></span><span class="line"><span class="cl">        super(s, i);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    public static T[] values()
</span></span><span class="line"><span class="cl">    {
</span></span><span class="line"><span class="cl">        T at[];
</span></span><span class="line"><span class="cl">        int i;
</span></span><span class="line"><span class="cl">        T at1[];
</span></span><span class="line"><span class="cl">        System.arraycopy(at = ENUM$VALUES, 0, at1 = new T[i = at.length], 0, i);
</span></span><span class="line"><span class="cl">        return at1;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public static T valueOf(String s)
</span></span><span class="line"><span class="cl">    {
</span></span><span class="line"><span class="cl">        return (T)Enum.valueOf(demo/T, s);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public static final T SPRING;
</span></span><span class="line"><span class="cl">    public static final T SUMMER;
</span></span><span class="line"><span class="cl">    private static final T ENUM$VALUES[];
</span></span><span class="line"><span class="cl">    static
</span></span><span class="line"><span class="cl">    {
</span></span><span class="line"><span class="cl">        SPRING = new T(&#34;SPRING&#34;, 0);
</span></span><span class="line"><span class="cl">        SUMMER = new T(&#34;SUMMER&#34;, 1);
</span></span><span class="line"><span class="cl">        ENUM$VALUES = (new T[] {
</span></span><span class="line"><span class="cl">            SPRING, SUMMER
</span></span><span class="line"><span class="cl">        });
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><p>通过反编译后代码我们可以看到，<code>public final class T extends Enum</code>，说明，
该类是继承了Enum类的，同时final关键字告诉我们，这个类也是不能被继承的。</p>
<p>当我们使用enmu来定义一个枚举类型的时候，编译器会自动帮我们创建一个final类型的类继承Enum类，所以枚举类型不能被继承。</p>
<h4 id="内部类">内部类</h4>
<p>内部类又称为嵌套类，可以把内部类理解为外部类的一个普通成员。</p>
<p>内部类之所以也是语法糖，是因为它仅仅是一个编译时的概念。</p>
<p><code>outer.java</code>里面定义了一个内部类inner，一旦编译成功，就会生成两个完全不同的.class文件了，
分别是<code>outer.class</code>和<code>outer$inner.class</code>。所以内部类的名字完全可以和它的外部类名字相同。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public class OutterClass {
</span></span><span class="line"><span class="cl">    private String userName;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public String getUserName() {
</span></span><span class="line"><span class="cl">        return userName;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public void setUserName(String userName) {
</span></span><span class="line"><span class="cl">        this.userName = userName;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public static void main(String[] args) {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    class InnerClass{
</span></span><span class="line"><span class="cl">        private String name;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        public String getName() {
</span></span><span class="line"><span class="cl">            return name;
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        public void setName(String name) {
</span></span><span class="line"><span class="cl">            this.name = name;
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><p>以上代码编译后会生成两个class文件：<code>OutterClass$InnerClass.class 、OutterClass.class</code> 。</p>
<p>当我们尝试使用jad对<code>OutterClass.class</code>文件进行反编译的时候，命令行会打印以下内容：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">Parsing OutterClass.class...
</span></span><span class="line"><span class="cl">Parsing inner class OutterClass$InnerClass.class...
</span></span><span class="line"><span class="cl">Generating OutterClass.jad
</span></span></code></pre></div><p>他会把两个文件全部进行反编译，然后一起生成一个<code>OutterClass.jad</code>文件。文件内容如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public class OutterClass
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">    class InnerClass
</span></span><span class="line"><span class="cl">    {
</span></span><span class="line"><span class="cl">        public String getName()
</span></span><span class="line"><span class="cl">        {
</span></span><span class="line"><span class="cl">            return name;
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        public void setName(String name)
</span></span><span class="line"><span class="cl">        {
</span></span><span class="line"><span class="cl">            this.name = name;
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        private String name;
</span></span><span class="line"><span class="cl">        final OutterClass this$0;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        InnerClass()
</span></span><span class="line"><span class="cl">        {
</span></span><span class="line"><span class="cl">            this.this$0 = OutterClass.this;
</span></span><span class="line"><span class="cl">            super();
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public OutterClass()
</span></span><span class="line"><span class="cl">    {
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    public String getUserName()
</span></span><span class="line"><span class="cl">    {
</span></span><span class="line"><span class="cl">        return userName;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    public void setUserName(String userName){
</span></span><span class="line"><span class="cl">        this.userName = userName;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    public static void main(String args1[])
</span></span><span class="line"><span class="cl">    {
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    private String userName;
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><p>七 、条件编译</p>
<p>—般情况下，程序中的每一行代码都要参加编译。
但有时候出于对程序代码优化的考虑，希望只对其中一部分内容进行编译，此时就需要在程序中加上条件，让编译器只对满足条件的代码进行编译，将不满足条件的代码舍弃，这就是条件编译。</p>
<p>如在C或CPP中，可以通过预处理语句来实现条件编译。其实在Java中也可实现条件编译。我们先来看一段代码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public class ConditionalCompilation {
</span></span><span class="line"><span class="cl">    public static void main(String[] args) {
</span></span><span class="line"><span class="cl">        final boolean DEBUG = true;
</span></span><span class="line"><span class="cl">        if(DEBUG) {
</span></span><span class="line"><span class="cl">            System.out.println(&#34;Java, DEBUG!&#34;);
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        final boolean ONLINE = false;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        if(ONLINE){
</span></span><span class="line"><span class="cl">            System.out.println(&#34;Java, ONLINE!&#34;);
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><p>反编译后代码如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public class ConditionalCompilation
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public ConditionalCompilation()
</span></span><span class="line"><span class="cl">    {
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public static void main(String args[])
</span></span><span class="line"><span class="cl">    {
</span></span><span class="line"><span class="cl">        boolean DEBUG = true;
</span></span><span class="line"><span class="cl">        System.out.println(&#34;Java, DEBUG!&#34;);
</span></span><span class="line"><span class="cl">        boolean ONLINE = false;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><p>首先，我们发现，在反编译后的代码中没有<code>System.out.println(&quot;Hello, ONLINE!&quot;);</code>，这其实就是条件编译。</p>
<p>当if(ONLINE)为false的时候，编译器就没有对其内的代码进行编译。
所以，Java语法的条件编译，是通过判断条件为常量的if语句实现的。根据if判断条件的真假，编译器直接把分支为false的代码块消除。
通过该方式实现的条件编译，必须在方法体内实现，而无法在正整个Java类的结构或者类的属性上进行条件编译。</p>
<p>这与C/C++的条件编译相比，确实更有局限性。在Java语言设计之初并没有引入条件编译的功能，虽有局限，但是总比没有更强。</p>
<h4 id="断言">断言</h4>
<p>在Java中，assert关键字是从JAVA SE 1.4 引入的，为了避免和老版本的Java代码中使用了assert关键字导致错误，
Java在执行的时候默认是不启动断言检查的（这个时候，所有的断言语句都将忽略！）。</p>
<p>如果要开启断言检查，则需要用开关<code>-enableassertions</code>或<code>-ea</code>来开启。</p>
<p>看一段包含断言的代码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public class AssertTest {
</span></span><span class="line"><span class="cl">    public static void main(String args[]) {
</span></span><span class="line"><span class="cl">        int a = 1;
</span></span><span class="line"><span class="cl">        int b = 1;
</span></span><span class="line"><span class="cl">        assert a == b;
</span></span><span class="line"><span class="cl">        System.out.println(&#34;Java&#34;);
</span></span><span class="line"><span class="cl">        assert a != b : &#34;suxiansheng&#34;;
</span></span><span class="line"><span class="cl">        System.out.println(&#34;博客：https://www.jianshu.com/u/94111742c97c&#34;);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><p>反编译后代码如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public class AssertTest {
</span></span><span class="line"><span class="cl">   public AssertTest()
</span></span><span class="line"><span class="cl">    {
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    public static void main(String args[])
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">    int a = 1;
</span></span><span class="line"><span class="cl">    int b = 1;
</span></span><span class="line"><span class="cl">    if(!$assertionsDisabled &amp;&amp; a != b)
</span></span><span class="line"><span class="cl">        throw new AssertionError();
</span></span><span class="line"><span class="cl">    System.out.println(&#34;\u516C\u4F17\u53F7\uFF1AJava&#34;);
</span></span><span class="line"><span class="cl">    if(!$assertionsDisabled &amp;&amp; a == b)
</span></span><span class="line"><span class="cl">    {
</span></span><span class="line"><span class="cl">        throw new AssertionError(&#34;Java&#34;);
</span></span><span class="line"><span class="cl">    } else
</span></span><span class="line"><span class="cl">    {
</span></span><span class="line"><span class="cl">        System.out.println(&#34;\u535A\u5BA2\uFF1Awww.jianshu.com/u/94111742c97c&#34;);
</span></span><span class="line"><span class="cl">        return;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">static final boolean $assertionsDisabled = !com/hollis/suguar/AssertTest.desiredAssertionStatus();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><p>很明显，反编译之后的代码要比我们自己的代码复杂的多。所以，使用了assert这个语法糖我们节省了很多代码。</p>
<p>其实断言的底层实现就是if语言，如果断言结果为true，则什么都不做，程序继续执行，如果断言结果为false，则程序抛出AssertError来打断程序的执行。</p>
<h4 id="数值字面量">数值字面量</h4>
<p>在java 7中，数值字面量，不管是整数还是浮点数，都允许在数字之间插入任意多个下划线。这些下划线不会对字面量的数值产生影响，目的就是方便阅读。</p>
<p>比如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public class Test {
</span></span><span class="line"><span class="cl">    public static void main(String... args) {
</span></span><span class="line"><span class="cl">        int i = 10_000;
</span></span><span class="line"><span class="cl">        System.out.println(i);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><p>反编译后：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public class Test
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">  public static void main(String[] args)
</span></span><span class="line"><span class="cl">  {
</span></span><span class="line"><span class="cl">    int i = 10000;
</span></span><span class="line"><span class="cl">    System.out.println(i);
</span></span><span class="line"><span class="cl">  }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><p>反编译后就是把删除了。也就是说<strong>编译器并不认识在数字字面量中的，需要在编译阶段把他去掉</strong>。</p>
<h4 id="for-each">for-each</h4>
<p>增强for循环（for-each）相信大家都不陌生，日常开发经常会用到的，他会比for循环要少写很多代码，那么这个语法糖背后是如何实现的呢？</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public static void main(String... args) {
</span></span><span class="line"><span class="cl">    String[] strs = {&#34;suxiansehng&#34;, &#34;Java&#34;, &#34;博客：www.jianshu.com/u/94111742c97c&#34;};
</span></span><span class="line"><span class="cl">    for (String s : strs) {
</span></span><span class="line"><span class="cl">        System.out.println(s);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    List&lt;String&gt; strList = ImmutableList.of(&#34;suxiansheng&#34;, &#34;java&#34;, &#34;博客：www.jianshu.com/u/94111742c97c&#34;);
</span></span><span class="line"><span class="cl">    for (String s : strList) {
</span></span><span class="line"><span class="cl">        System.out.println(s);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><p>反编译后代码如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public static transient void main(String args[])
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">    String strs[] = {
</span></span><span class="line"><span class="cl">        &#34;suxiansheng&#34;, &#34;\u516C\u4F17\u53F7\uFF1AJava&#34;, &#34;\u535A\u5BA2\uFF1Awww.jianshu.com/u/94111742c97c&#34;
</span></span><span class="line"><span class="cl">    };
</span></span><span class="line"><span class="cl">    String args1[] = strs;
</span></span><span class="line"><span class="cl">    int i = args1.length;
</span></span><span class="line"><span class="cl">    for(int j = 0; j &lt; i; j++)
</span></span><span class="line"><span class="cl">    {
</span></span><span class="line"><span class="cl">        String s = args1[j];
</span></span><span class="line"><span class="cl">        System.out.println(s);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    List strList = ImmutableList.of(&#34;suxiansheng&#34;, &#34;\u516C\u4F17\u53F7\uFF1AJava&#34;, &#34;\u535A\u5BA2\uFF1Awww.jianshu.com/u/94111742c97c&#34;);
</span></span><span class="line"><span class="cl">    String s;
</span></span><span class="line"><span class="cl">    for(Iterator iterator = strList.iterator(); iterator.hasNext(); System.out.println(s))
</span></span><span class="line"><span class="cl">        s = (String)iterator.next();
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><p>代码很简单，for-each的实现原理其实就是使用了普通的for循环和迭代器。</p>
<h4 id="try-with-resource">try-with-resource</h4>
<p>Java里，对于文件操作IO流、数据库连接等开销非常昂贵的资源，用完之后必须及时通过close方法将其关闭，否则资源会一直处于打开状态，可能会导致内存泄露等问题。</p>
<p>关闭资源的常用方式就是在finally块里是释放，即调用close方法。比如，我们经常会写这样的代码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public static void main(String[] args) {
</span></span><span class="line"><span class="cl">    BufferedReader br = null;
</span></span><span class="line"><span class="cl">    try {
</span></span><span class="line"><span class="cl">        String line;
</span></span><span class="line"><span class="cl">        br = new BufferedReader(new FileReader(&#34;d:\\hollischuang.xml&#34;));
</span></span><span class="line"><span class="cl">        while ((line = br.readLine()) != null) {
</span></span><span class="line"><span class="cl">            System.out.println(line);
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    } catch (IOException e) {
</span></span><span class="line"><span class="cl">        // handle exception
</span></span><span class="line"><span class="cl">    } finally {
</span></span><span class="line"><span class="cl">        try {
</span></span><span class="line"><span class="cl">            if (br != null) {
</span></span><span class="line"><span class="cl">                br.close();
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">        } catch (IOException ex) {
</span></span><span class="line"><span class="cl">            // handle exception
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><p>从Java 7开始，jdk提供了一种更好的方式关闭资源，使用<code>try-with-resources</code>语句，改写一下上面的代码，效果如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public static void main(String... args) {
</span></span><span class="line"><span class="cl">    try (BufferedReader br = new BufferedReader(new FileReader(&#34;d:\\ hollischuang.xml&#34;))) {
</span></span><span class="line"><span class="cl">        String line;
</span></span><span class="line"><span class="cl">        while ((line = br.readLine()) != null) {
</span></span><span class="line"><span class="cl">            System.out.println(line);
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    } catch (IOException e) {
</span></span><span class="line"><span class="cl">        // handle exception
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><p>看，这简直是一大福音啊，虽然我之前一般使用IOUtils去关闭流，并不会使用在finally中写很多代码的方式，但是这种新的语法糖看上去好像优雅很多呢。</p>
<p>反编译以上代码，看下他的背后原理：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public static transient void main(String args[])
</span></span><span class="line"><span class="cl">    {
</span></span><span class="line"><span class="cl">        BufferedReader br;
</span></span><span class="line"><span class="cl">        Throwable throwable;
</span></span><span class="line"><span class="cl">        br = new BufferedReader(new FileReader(&#34;d:\\ hollischuang.xml&#34;));
</span></span><span class="line"><span class="cl">        throwable = null;
</span></span><span class="line"><span class="cl">        String line;
</span></span><span class="line"><span class="cl">        try
</span></span><span class="line"><span class="cl">        {
</span></span><span class="line"><span class="cl">            while((line = br.readLine()) != null)
</span></span><span class="line"><span class="cl">                System.out.println(line);
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        catch(Throwable throwable2)
</span></span><span class="line"><span class="cl">        {
</span></span><span class="line"><span class="cl">            throwable = throwable2;
</span></span><span class="line"><span class="cl">            throw throwable2;
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        if(br != null)
</span></span><span class="line"><span class="cl">            if(throwable != null)
</span></span><span class="line"><span class="cl">                try
</span></span><span class="line"><span class="cl">                {
</span></span><span class="line"><span class="cl">                    br.close();
</span></span><span class="line"><span class="cl">                }
</span></span><span class="line"><span class="cl">                catch(Throwable throwable1)
</span></span><span class="line"><span class="cl">                {
</span></span><span class="line"><span class="cl">                    throwable.addSuppressed(throwable1);
</span></span><span class="line"><span class="cl">                }
</span></span><span class="line"><span class="cl">            else
</span></span><span class="line"><span class="cl">                br.close();
</span></span><span class="line"><span class="cl">            break MISSING_BLOCK_LABEL_113;
</span></span><span class="line"><span class="cl">            Exception exception;
</span></span><span class="line"><span class="cl">            exception;
</span></span><span class="line"><span class="cl">            if(br != null)
</span></span><span class="line"><span class="cl">                if(throwable != null)
</span></span><span class="line"><span class="cl">                    try
</span></span><span class="line"><span class="cl">                    {
</span></span><span class="line"><span class="cl">                        br.close();
</span></span><span class="line"><span class="cl">                    }
</span></span><span class="line"><span class="cl">                    catch(Throwable throwable3)
</span></span><span class="line"><span class="cl">                      {
</span></span><span class="line"><span class="cl">                        throwable.addSuppressed(throwable3);
</span></span><span class="line"><span class="cl">                    }
</span></span><span class="line"><span class="cl">                else
</span></span><span class="line"><span class="cl">                    br.close();
</span></span><span class="line"><span class="cl">        throw exception;
</span></span><span class="line"><span class="cl">        IOException ioexception;
</span></span><span class="line"><span class="cl">        ioexception;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><p>其实背后的原理也很简单，那些我们没有做的关闭资源的操作，编译器都帮我们做了。</p>
<p>所以，再次印证了，语法糖的作用就是方便程序员的使用，但最终还是要转成编译器认识的语言。</p>
<h4 id="lambda表达式">Lambda表达式</h4>
<p>关于lambda表达式，有人可能会有质疑，因为网上有人说他并不是语法糖。其实我想纠正下这个说法。</p>
<p>Labmda表达式不是匿名内部类的语法糖，但是他也是一个语法糖。实现方式其实是依赖了几个JVM底层提供的lambda相关api。</p>
<p>先来看一个简单的lambda表达式。遍历一个list：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public static void main(String... args) {
</span></span><span class="line"><span class="cl">    List&lt;String&gt; strList = ImmutableList.of(&#34;suxiansheng&#34;, &#34;Java&#34;, &#34;博客：www.jianshu.com/u/94111742c97c&#34;);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    strList.forEach( s -&gt; { System.out.println(s); } );
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><p>为啥说他并不是内部类的语法糖呢，前面讲内部类我们说过，内部类在编译之后会有两个class文件，但是，包含lambda表达式的类编译后只有一个文件。</p>
<p>反编译后代码如下:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public static /* varargs */ void main(String ... args) {
</span></span><span class="line"><span class="cl">    ImmutableList strList = ImmutableList.of((Object)&#34;Java&#34;, (Object)&#34;\u516c\u4f17\u53f7\uff1aJava&#34;, (Object)&#34;\u535a\u5ba2\uff1awww.jianshu.com/u/94111742c97c&#34;);
</span></span><span class="line"><span class="cl">    strList.forEach((Consumer&lt;String&gt;)LambdaMetafactory.metafactory(null, null, null, (Ljava/lang/Object;)V, lambda$main$0(java.lang.String ), (Ljava/lang/String;)V)());
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">private static /* synthetic */ void lambda$main$0(String s) {
</span></span><span class="line"><span class="cl">    System.out.println(s);
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><p>可以看到，在forEach方法中，其实是调用了<code>java.lang.invoke.LambdaMetafactory#metafactory</code>方法，
该方法的第四个参数implMethod指定了方法实现。可以看到这里其实是调用了一个lambda0方法进行了输出。</p>
<p>再来看一个稍微复杂一点的，先对List进行过滤，然后再输出：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public static void main(String... args) {
</span></span><span class="line"><span class="cl">    List&lt;String&gt; strList = ImmutableList.of(&#34;suxiansheng&#34;, &#34;Java, &#34;博客：www.jianshu.com/u/94111742c97c&#34;);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    List HollisList = strList.stream().filter(string -&gt; string.contains(&#34;Java&#34;)).collect(Collectors.toList());
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    HollisList.forEach( s -&gt; { System.out.println(s); } );
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><p>反编译后代码如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public static /* varargs */ void main(String ... args) {
</span></span><span class="line"><span class="cl">    ImmutableList strList = ImmutableList.of((Object)&#34;Java&#34;, (Object)&#34;\u516c\u4f17\u53f7\uff1aJava&#34;, (Object)&#34;\u535a\u5ba2\uff1awww.jianshu.com/u/94111742c97c&#34;);
</span></span><span class="line"><span class="cl">    List&lt;Object&gt; HollisList = strList.stream().filter((Predicate&lt;String&gt;)LambdaMetafactory.metafactory(null, null, null, (Ljava/lang/Object;)Z, lambda$main$0(java.lang.String ), (Ljava/lang/String;)Z)()).collect(Collectors.toList());
</span></span><span class="line"><span class="cl">    HollisList.forEach((Consumer&lt;Object&gt;)LambdaMetafactory.metafactory(null, null, null, (Ljava/lang/Object;)V, lambda$main$1(java.lang.Object ), (Ljava/lang/Object;)V)());
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">private static /* synthetic */ void lambda$main$1(Object s) {
</span></span><span class="line"><span class="cl">    System.out.println(s);
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">private static /* synthetic */ boolean lambda$main$0(String string) {
</span></span><span class="line"><span class="cl">    return string.contains(&#34;Hollis&#34;);
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><p>两个lambda表达式分别调用了lambda1和lambda0两个方法。</p>
<p>所以，lambda表达式的实现其实是依赖了一些底层的api，在编译阶段，编译器会把lambda表达式进行解糖，转换成调用内部api的方式。</p>
<h3 id="可能遇到的坑">可能遇到的坑</h3>
<h4 id="泛型当泛型遇到重载">泛型——当泛型遇到重载</h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public class GenericTypes {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public static void method(List&lt;String&gt; list) {  
</span></span><span class="line"><span class="cl">        System.out.println(&#34;invoke method(List&lt;String&gt; list)&#34;);  
</span></span><span class="line"><span class="cl">    }  
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public static void method(List&lt;Integer&gt; list) {  
</span></span><span class="line"><span class="cl">        System.out.println(&#34;invoke method(List&lt;Integer&gt; list)&#34;);  
</span></span><span class="line"><span class="cl">    }  
</span></span><span class="line"><span class="cl">} 
</span></span></code></pre></div><p>上面这段代码，有两个重载的函数，因为他们的参数类型不同，一个是List另一个是List，
但是，这段代码是编译通不过的。因为我们前面讲过，参数List和List编译之后都被擦除了，变成了一样的原生类型List，擦除动作导致这两个方法的特征签名变得一模一样。</p>
<h4 id="泛型当泛型遇到catch">泛型——当泛型遇到catch</h4>
<p>泛型的类型参数不能用在Java异常处理的catch语句中。因为异常处理是由JVM在运行时刻来进行的。由于类型信息被擦除，JVM是无法区分两个异常类型MyException<String>和MyException<Integer>的</p>
<p>泛型——当泛型内包含静态变量</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public class StaticTest{
</span></span><span class="line"><span class="cl">    public static void main(String[] args){
</span></span><span class="line"><span class="cl">        GT&lt;Integer&gt; gti = new GT&lt;Integer&gt;();
</span></span><span class="line"><span class="cl">        gti.var=1;
</span></span><span class="line"><span class="cl">        GT&lt;String&gt; gts = new GT&lt;String&gt;();
</span></span><span class="line"><span class="cl">        gts.var=2;
</span></span><span class="line"><span class="cl">        System.out.println(gti.var);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">class GT&lt;T&gt;{
</span></span><span class="line"><span class="cl">    public static int var=0;
</span></span><span class="line"><span class="cl">    public void nothing(T x){}
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><p>以上代码输出结果为：2！由于经过类型擦除，所有的泛型类实例都关联到同一份字节码上，泛型类的所有静态变量是共享的。</p>
<h4 id="自动装箱与拆箱对象相等比较">自动装箱与拆箱——对象相等比较</h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public static void main(String[] args) {
</span></span><span class="line"><span class="cl">    Integer a = 1000;
</span></span><span class="line"><span class="cl">    Integer b = 1000;
</span></span><span class="line"><span class="cl">    Integer c = 100;
</span></span><span class="line"><span class="cl">    Integer d = 100;
</span></span><span class="line"><span class="cl">    System.out.println(&#34;a == b is &#34; + (a == b));
</span></span><span class="line"><span class="cl">    System.out.println((&#34;c == d is &#34; + (c == d)));
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><p>输出结果：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">a == b is false
</span></span><span class="line"><span class="cl">c == d is true
</span></span></code></pre></div><p>在Java 5中，在Integer的操作上引入了一个新功能来节省内存和提高性能。整型对象通过使用相同的对象引用实现了缓存和重用。</p>
<blockquote>
<p>适用于整数值区间<code>-128 至 +127</code>。只适用于自动装箱。使用构造函数创建对象不适用。</p>
</blockquote>
<h4 id="增强for循环">增强for循环</h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">for (Student stu : students) {    
</span></span><span class="line"><span class="cl">    if (stu.getId() == 2)     
</span></span><span class="line"><span class="cl">        students.remove(stu);    
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><p>会抛出<code>ConcurrentModificationException</code>异常。</p>
<p>Iterator是工作在一个独立的线程中，并且拥有一个 mutex 锁。 
Iterator被创建之后会建立一个指向原来对象的单链索引表，当原来的对象数量发生变化时，这个索引表的内容不会同步改变，所以当索引指针往后移动的时候就找不到要迭代的对象，
所以按照 <code>fail-fast</code> 原则 Iterator 会马上抛出<code>java.util.ConcurrentModificationException</code>异常。</p>
<p>所以 Iterator 在工作的时候是不允许被迭代的对象被改变的。但你可以使用 Iterator 本身的方法remove()来删除对象，<code>Iterator.remove()</code> 方法会在删除当前迭代对象的同时维护索引的一致性。</p>
<h3 id="总结">总结</h3>
<ul>
<li>前面介绍了12种Java中常用的语法糖。所谓语法糖就是提供给开发人员便于开发的一种语法而已。</li>
<li>但是这种语法只有开发人员认识。要想被执行，需要进行解糖，即转成JVM认识的语法。</li>
<li>当我们把语法糖解糖之后，你就会发现其实我们日常使用的这些方便的语法，其实都是一些其他更简单的语法构成的。</li>
<li>有了这些语法糖，我们在日常开发的时候可以大大提升效率，但是同时也要避免过渡使用。使用之前最好了解下原理，避免掉坑。</li>
</ul>
</div>
                    <div class="post_footer">
                        <div class="meta">
                            <div class="info">
                                <span class="field tags">
                                    <i class="ri-stack-line"></i>
                                    
                                    
                                    <a href="https://whiteppure.github.io/iblog/tags/java/">Java</a>
                                    
                                    <a href="https://whiteppure.github.io/iblog/tags/%E8%BD%AC%E8%BD%BD/">转载</a>
                                    
                                    
                                    
                                    <span id="busuanzi_container_page_pv">
                                      阅读量<span id="busuanzi_value_page_pv"></span>次
                                    </span>
                                    
                                </span>
                            </div>
                        </div>
                    </div>
                </div>
                
                
                
<div class="doc_comments">
    <div class="comments_block_title">发表评论</div>
    <div id="vcomments"></div>
</div>

<link rel="stylesheet" href="https://whiteppure.github.io/iblog/css/comments.css" />

<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src='//unpkg.com/valine/dist/Valine.min.js'></script>


<script type="text/javascript">
    new Valine({
        el: '#vcomments',
        appId: 'pRSrjsfbN6L1DUxgfqJWOMYP-gzGzoHsz',
        appKey: 'VPWpnDPGDM8Xhdlh5OvHOpak',
        placeholder: '说点什么吧...',
        visitor: 'true',
        
        emojiCDN: '//i0.hdslb.com/bfs/emote/',
        
        emojiMaps: {
            "tv_doge": "6ea59c827c414b4a2955fe79e0f6fd3dcd515e24.png",
            "tv_亲亲": "a8111ad55953ef5e3be3327ef94eb4a39d535d06.png",
            "tv_偷笑": "bb690d4107620f1c15cff29509db529a73aee261.png",
            "tv_再见": "180129b8ea851044ce71caf55cc8ce44bd4a4fc8.png",
            "tv_冷漠": "b9cbc755c2b3ee43be07ca13de84e5b699a3f101.png",
            "tv_发怒": "34ba3cd204d5b05fec70ce08fa9fa0dd612409ff.png",
            "tv_发财": "34db290afd2963723c6eb3c4560667db7253a21a.png",
            "tv_可爱": "9e55fd9b500ac4b96613539f1ce2f9499e314ed9.png",
            "tv_吐血": "09dd16a7aa59b77baa1155d47484409624470c77.png",
            "tv_呆": "fe1179ebaa191569b0d31cecafe7a2cd1c951c9d.png",
            "tv_呕吐": "9f996894a39e282ccf5e66856af49483f81870f3.png",
            "tv_困": "241ee304e44c0af029adceb294399391e4737ef2.png",
            "tv_坏笑": "1f0b87f731a671079842116e0991c91c2c88645a.png",
            "tv_大佬": "093c1e2c490161aca397afc45573c877cdead616.png",
            "tv_大哭": "23269aeb35f99daee28dda129676f6e9ea87934f.png",
            "tv_委屈": "d04dba7b5465779e9755d2ab6f0a897b9b33bb77.png",
            "tv_害羞": "a37683fb5642fa3ddfc7f4e5525fd13e42a2bdb1.png",
            "tv_尴尬": "7cfa62dafc59798a3d3fb262d421eeeff166cfa4.png",
            "tv_微笑": "70dc5c7b56f93eb61bddba11e28fb1d18fddcd4c.png",
            "tv_思考": "90cf159733e558137ed20aa04d09964436f618a1.png",
            "tv_惊吓": "0d15c7e2ee58e935adc6a7193ee042388adc22af.png",
            "tv_打脸": "56ab10b624063e966bfcb76ea5dc4794d87dfd47.png",
            "tv_抓狂": "fe31c08edad661d63762b04e17b8d5ae3c71a757.png",
            "tv_抠鼻": "c666f55e88d471e51bbd9fab9bb308110824a6eb.png",
            "tv_斜眼笑": "911f987aa8bc1bee12d52aafe62bc41ef4474e6c.png",
            "tv_无奈": "ea8ed89ee9878f2fece2dda0ea8a5dbfe21b5751.png",
            "tv_晕": "5443c22b4d07fb1907ccc610c8e6db254f2461b7.png",
            "tv_流汗": "cead1c351ab8d79e9f369605beb90148db0fbed3.png",
            "tv_流泪": "7e71cde7858f0cd50d74b0264aa26db612a8a167.png",
            "tv_流鼻血": "c32d39db2737f89b904ca32700d140a9241b0767.png",
            "tv_点赞": "f85c354995bd99e28fc76c869bfe42ba6438eff4.png",
            "tv_生气": "26702dcafdab5e8225b43ffd23c94ac1ff932654.png",
            "tv_生病": "8b0ec90e6b86771092a498c54f09fc94621c1900.png",
            "tv_疑问": "0793d949b18d7be716078349c202c15ff166f314.png",
            "tv_白眼": "c1d59f439e379ee50eef488bcb5e5378e5044ea4.png",
            "tv_皱眉": "72ccad6679fea0d14cce648b4d818e09b8ffea2d.png",
            "tv_目瞪口呆": "0b8cb81a68de5d5365212c99375e7ace3e7891b7.png",
            "tv_睡着": "8b196675b53af58264f383c50ad0945048290b33.png",
            "tv_笑哭": "1abc628f6d4f4caf9d0e7800878f4697abbc8273.png",
            "tv_腼腆": "89712c0d4af73e67f89e35cbc518420380a7f6f4.png",
            "tv_色": "61822c7e9aae5da76475e7892534545336b23a6f.png",
            "tv_调侃": "4bc022533ef31544ca0d72c12c808cf4a1cce3e3.png",
            "tv_调皮": "b9c41de8e82dd7a8515ae5e3cb63e898bf245186.png",
            "tv_鄙视": "6e72339f346a692a495b123174b49e4e8e781303.png",
            "tv_闭嘴": "c9e990da7f6e93975e25fd8b70e2e290aa4086ef.png",
            "tv_难过": "87f46748d3f142ebc6586ff58860d0e2fc8263ba.png",
            "tv_馋": "fc7e829b845c43c623c8b490ee3602b7f0e76a31.png",
            "tv_鬼脸": "0ffbbddf8a94d124ca2f54b360bbc04feb6bbfea.png",
            "tv_黑人问号": "45821a01f51bc867da9edbaa2e070410819a95b2.png",
            "tv_鼓掌": "1d21793f96ef4e6f48b23e53e3b9e42da833a0f6.png"
        }
    })
</script>

                
            </div>
        </div>
    </div>
    <a id="back_to_top" href="#" class="back_to_top"><i class="ri-arrow-up-s-line"></i></a>
    <footer class="footer">
    <div class="powered_by">
        <a href="https://varkai.com">Designed by VarKai,</a>
        <a href="http://www.gohugo.io/">Proudly published with Hugo</a>
    </div>

    <div class="footer_slogan">
        <span>whitepure@2022</span>
    </div>
</footer>
    <script src="https://whiteppure.github.io/iblog/js/jquery-3.5.1.min.js"></script>
<link href="https://whiteppure.github.io/iblog/css/fancybox.min.css" rel="stylesheet">
<script src="https://whiteppure.github.io/iblog/js/fancybox.min.js"></script>
<script src="https://whiteppure.github.io/iblog/js/darkmode-js.js"></script>
<script src="https://whiteppure.github.io/iblog/js/zozo.js"></script>


<script type="text/javascript" async
    src="https://cdn.bootcss.com/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
        MathJax.Hub.Config({
            tex2jax: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\[\[', '\]\]']],
                processEscapes: true,
                processEnvironments: true,
                skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
                TeX: {
                    equationNumbers: { autoNumber: "AMS" },
                    extensions: ["AMSmath.js", "AMSsymbols.js"]
                }
            }
        });

        MathJax.Hub.Queue(function () {
            
            
            
            var all = MathJax.Hub.getAllJax(), i;
            for (i = 0; i < all.length; i += 1) {
                all[i].SourceElement().parentNode.className += ' has-jax';
            }
        });
    </script>

<style>
    code.has-jax {
        font: inherit;
        font-size: 100%;
        background: inherit;
        border: inherit;
        color: #515151;
    }
</style>




<script src="https://cdn.bootcdn.net/ajax/libs/jspdf/1.0.106/jspdf.debug.js"></script>
<script src="https://cdn.bootcdn.net/ajax/libs/html2canvas/0.5.0-beta4/html2canvas.js"></script>
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>


























































<script>
    function addDarkmodeWidget() {
        new Darkmode({
            right: '32px', 
            bottom: 'unset', 
            
            time: '0.5s', 
            mixColor: '#f7f7f7', 
            backgroundColor: '#f7f7f7', 
            buttonColorDark: '#212121', 
            buttonColorLight: '#f7f7f7', 
            saveInCookies: false, 
            autoMatchOsTheme: true 
        }).showWidget();
    }
    window.addEventListener('load', addDarkmodeWidget);
</script>
</body>

</html>