<!DOCTYPE html>
<html lang="zh" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="whitepure" />
	
	
	
	<title>Object类方法 ｜ 唯手熟尔</title>
	
    
    
    <meta name="description" content="概览 Object 类位于 java.lang 包中，编译时会自动导入，我们创建一个类时，如果没有明确继承一个父类，那么它就会自动继承Object，成为Object的子类。 Object类可以显示" />
    

    
    
    <meta name="keywords" content="whitepure博客, whiteppure, whitepure" />
    

	
    
    <link rel="shortcut icon" href="https://whiteppure.github.io/iblog/images/favicon.ico" />

    <link rel="stylesheet" type="text/css" media="screen" href="https://whiteppure.github.io/iblog/css/normalize.css" />
    <link rel="stylesheet" type="text/css" media="screen" href="https://cdn.jsdelivr.net/npm/animate.css@4.1.0/animate.min.css" />
    <link rel="stylesheet" type="text/css" media="screen" href="https://whiteppure.github.io/iblog/css/zozo.css" />
	<link rel="stylesheet" type="text/css" media="screen" href="https://cdn.jsdelivr.net/npm/remixicon@2.5.0/fonts/remixicon.css" />
    <link rel="stylesheet" type="text/css" media="screen" href="https://whiteppure.github.io/iblog/css/highlight.css" />

    <link rel="stylesheet" type="text/css" media="screen" href="https://whiteppure.github.io/iblog/css/toc.css" />

    
    
</head>

<body>
    
    
    









<div class="toc">

    <div class="page-header"><strong></strong></div>

    <div id="page-scrollspy" class="toc-nav">

        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e6%a6%82%e8%a7%88">
                    概览
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#equals">
                    equals
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e7%ad%89%e4%bb%b7%e5%85%b3%e7%b3%bb">
                    等价关系
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e4%b8%8e%e5%8f%8c%e7%ad%89%e5%8f%b7">
                    与双等号
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e9%87%8d%e5%86%99equals%e6%96%b9%e6%b3%95">
                    重写equals方法
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#hashcode">
                    hashCode
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e4%bd%bf%e7%94%a8%e5%9c%ba%e6%99%af">
                    使用场景
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#hashcode%e4%b8%8eequals">
                    hashCode与equals
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e9%87%8d%e5%86%99hashcode%e6%96%b9%e6%b3%95">
                    重写hashCode方法
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#tostring">
                    toString
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e9%87%8d%e5%86%99tostring%e6%96%b9%e6%b3%95">
                    重写toString方法
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e4%bd%bf%e7%94%a8">
                    使用
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#clone">
                    clone
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#cloneable%e6%8e%a5%e5%8f%a3">
                    Cloneable接口
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e6%b5%85%e6%8b%b7%e8%b4%9d%e4%b8%8e%e6%b7%b1%e6%8b%b7%e8%b4%9d">
                    浅拷贝与深拷贝
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e6%b5%85%e6%8b%b7%e8%b4%9d">
                    浅拷贝
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#%e6%b7%b1%e6%8b%b7%e8%b4%9d">
                    深拷贝
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#clone%e7%9a%84%e6%9b%bf%e4%bb%a3">
                    clone的替代
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#finalize">
                    finalize
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#getclass">
                    getClass
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        
        
        
        
        
        
        
        
        <ul class="nav">
            
        <ul class="nav">
            
            
            <li class="nav-item">
                <a class="nav-link text-left" href="#waitnotifynotifyall">
                    wait、notify、notifyAll
                </a>
            </li>
            
            
        </ul>
        
        </ul>
        
        
        
        

    </div>

</div>



    
    <div class="main animate__animated animate__fadeInDown" id="pdf_content">
        <div class="nav_container animated fadeInDown">
    <div class="site_nav" id="site_nav">
        <ul><li class="">
                <a href="https://whiteppure.github.io/iblog/">首页</a>
            </li><li class="">
                <a href="https://whiteppure.github.io/iblog/posts/">归档</a>
            </li><li class="">
                <a href="https://whiteppure.github.io/iblog/tags/">标签</a>
            </li><li class="">
                <a href="https://whiteppure.github.io/iblog/about/">关于</a>
            </li>
        </ul>
    </div>
    <div class="menu_icon">
        <a id="menu_icon"><i class="ri-menu-line"></i></a>
    </div>
</div>
        <div class="header animated fadeInDown">
    <div class="site_title_container">
        <div class="site_title">
            <h1>
                <a href="https://whiteppure.github.io/iblog/">
                    <span>唯手熟尔</span>
                </a>
            </h1>
        </div>
        <div class="description">
            <p class="sub_title">
                无他,唯手熟尔
            </p>
            <div class="my_socials">
                
                
                <a href="https://github.com/whiteppure/" title="github" target="_blank">
                    <i class="ri-github-fill"></i>
                </a>
                
                
                <a href="https://whiteppure.github.io/iblog/index.xml" type="application/rss+xml" title="rss" target="_blank">
                    <i class="ri-rss-fill"></i>
                </a>
                



            </div>
            
            <div class="post">
                <div class="post_title post_detail_title">
                    <span class="date" id="busuanzi_container_site_pv">访问量 <span id="busuanzi_value_site_pv"></span>次</span>
                </div>
                <div class="post_title post_detail_title">
                    <span class="date" id="busuanzi_container_site_uv">访客数 <span id="busuanzi_value_site_uv"></span>人</span>
                </div>
            </div>
            
        </div>
    </div>
</div>
        <div class="content">
            <div class="post_page">
                <div class="post animate__animated animate__fadeInDown">
                    <div class="post_title post_detail_title">
                        <h2><a href='/iblog/posts/rookie/rookie-objectclass-methods/'>Object类方法</a></h2>
                        <span class="date">2021.07.10</span>
                    </div>
                    <div class="post_content markdown"><h2 id="概览">概览</h2>
<p>Object 类位于 <code>java.lang</code> 包中，编译时会自动导入，我们创建一个类时，如果没有明确继承一个父类，那么它就会自动继承<code>Object</code>，成为<code>Object</code>的子类。</p>
<p><code>Object</code>类可以显示继承，也可以隐式继承,效果都是一样的。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">class A extends Object{
</span></span><span class="line"><span class="cl">    // to do
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">class A {
</span></span><span class="line"><span class="cl">    // to do
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><p>Java <code>Object</code>类是所有类的父类，也就是说 Java 的所有类都继承了<code>Object</code>，子类可以使用<code>Object</code>的所有方法。</p>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>方法作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#equals">equals</a></td>
<td>比较两个对象是否相同</td>
</tr>
<tr>
<td><a href="#hashCode">hashCode</a></td>
<td>获取对象的哈希值</td>
</tr>
<tr>
<td><a href="#toString">toString</a></td>
<td>返回对象的字符串表示形式</td>
</tr>
<tr>
<td><a href="#clone">clone</a></td>
<td>创建并返回一个对象的拷贝</td>
</tr>
<tr>
<td><a href="#finalize">finalize</a></td>
<td>当垃圾收集确定不再有对对象的引用时，由垃圾收集器在对象上调用</td>
</tr>
<tr>
<td><a href="#getClass">getClass</a></td>
<td>获取对象运行时的类</td>
</tr>
<tr>
<td><a href="#notify">notify</a></td>
<td>唤醒在该对象上等待的某个线程</td>
</tr>
<tr>
<td><a href="#notifyAll">notifyAll</a></td>
<td>唤醒在该对象上等待的所有线程</td>
</tr>
<tr>
<td><a href="#wait">wait</a></td>
<td>让当前线程进入等待(阻塞)状态。直到其他线程调用此对象的<code>notify()</code>方法或<code>notifyAll()</code>方法。</td>
</tr>
</tbody>
</table>
<h2 id="equals">equals</h2>
<p><code>Object</code>类中的<code>equals()</code>方法作用是比较两个对象，是判断两个对象引用指向的是同一个对象，即比较两个对象的内存地址是否相等。</p>
<p><code>Object</code>类中的<code>equals()</code>源码如下</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">    public boolean equals(Object obj) {
</span></span><span class="line"><span class="cl">        return (this == obj);
</span></span><span class="line"><span class="cl">    }
</span></span></code></pre></div><h3 id="等价关系">等价关系</h3>
<p>在Java规范中，<code>equals()</code>方法的使用存在如下特性：</p>
<ul>
<li>自反性：<code>x.equals(x); // true</code></li>
<li>对称性：<code>x.equals(y) == y.equals(x); // true</code></li>
<li>传递性： <code>if (x.equals(y) &amp;&amp; y.equals(z))  =&gt;  x.equals(z); // true;</code></li>
<li>一致性：<code>x.equals(y) == x.equals(y); // true</code> 多次调用<code>equals()</code>方法结果不变</li>
<li>与<code>null</code>的比较：<code>x.equals(null); // false;</code> 对任何不是<code>null</code>的对象x调用 <code>x.equals(null)</code> 结果都为<code>false</code></li>
</ul>
<h3 id="与双等号">与双等号</h3>
<ul>
<li>对于基本类型，<code>==</code> 判断两个值是否相等，基本类型没有 <code>equals() </code>方法。</li>
<li>对于引用类型，<code>==</code> 判断两个变量是否引用同一个对象，而 <code>equals()</code>判断引用的对象是否等价。</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">Integer x = new Integer(1);
</span></span><span class="line"><span class="cl">Integer y = new Integer(1);
</span></span><span class="line"><span class="cl">System.out.println(x.equals(y)); // true
</span></span><span class="line"><span class="cl">System.out.println(x == y);      // false
</span></span></code></pre></div><p><code>equals()</code>作用是判断两个对象是否相等,但一般有两种情况:</p>
<ol>
<li>类没有覆盖<code>equals</code>方法,则相当于通过 <code>==</code>来比较这两个对象的地址;</li>
<li>类覆盖<code>equals</code>方法,一般我们通过<code>equals()</code>来比较两个对象的内容是否相等,相等则返回true；</li>
</ol>
<p><code>equals()</code>在不重写的情况下与 <code>==</code> 作用一样都是比较的内存中的地址.但是<code>equals()</code>可以重写。</p>
<h3 id="重写equals方法">重写equals方法</h3>
<p>重写<code>equals</code>方法一般思路：</p>
<ul>
<li>检查是否为同一个对象的引用，如果是直接返回 true；</li>
<li>检查是否是同一个类型，如果不是，直接返回 false；</li>
<li>将<code>Object</code>对象进行转型；</li>
<li>判断每个关键域是否相等;</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public class EqualExample {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    private int x;
</span></span><span class="line"><span class="cl">    private int y;
</span></span><span class="line"><span class="cl">    private int z;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public EqualExample(int x, int y, int z) {
</span></span><span class="line"><span class="cl">        this.x = x;
</span></span><span class="line"><span class="cl">        this.y = y;
</span></span><span class="line"><span class="cl">        this.z = z;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    public boolean equals(Object o) {
</span></span><span class="line"><span class="cl">        if (this == o) return true;
</span></span><span class="line"><span class="cl">        if (o == null || getClass() != o.getClass()) return false;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        EqualExample that = (EqualExample) o;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        if (x != that.x) return false;
</span></span><span class="line"><span class="cl">        if (y != that.y) return false;
</span></span><span class="line"><span class="cl">        return z == that.z;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><h2 id="hashcode">hashCode</h2>
<p>在Java中<code>hashcode</code>方法是<code>Object</code>类的<code>native</code>方法，返回值为int类型，根据一定的规则将与对象相关的信息（比如对象的存储地址，对象的字段等）映射成一个数值，这个数值称作为hash值(散列值)。</p>
<blockquote>
<p><code>hashCode</code>通用约定:</p>
<ul>
<li>若<code>x.equals(y)</code>返回true ，则<code>x.hashCode()==y.hashCode()</code>，其逆命题不一定成立。</li>
<li>尽量使 hashCode 方法返回的散列码总体上呈均匀分布，可以提高哈希表的性能。</li>
<li>程序运行时，若对象的<code>equals</code>方法中使用的字段没有改变，则在程序结束前，多次调用<code>hashCode</code>方法都应返回相同的散列码；程序结束后再执行时则没有此要求。</li>
</ul>
</blockquote>
<p><code>hashCode</code>方法源码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public native int hashCode();
</span></span></code></pre></div><p>根据这个方法的声明可知，该方法返回一个<code>int</code>类型的数值，并且是本地方法，因此在<code>Object</code>类中并没有给出具体的实现。</p>
<h3 id="使用场景">使用场景</h3>
<p>对于包含容器类型的程序设计语言来说，基本上都会涉及到<code>hashCode</code>。在Java中也一样，<code>hashCode</code>方法的主要作用是为了配合基于散列的集合一起正常运行，这样的散列集合包括<code>HashSet、HashMap</code>以及<code>HashTable</code>。</p>
<p>在集合中已经存在上万条数据或者更多的数据场景下向集合中插入对象时，如何判别在集合中是否已经存在该对象了？</p>
<p>如果采用<code>equals</code>方法去逐一比较，效率必然是一个问题。此时<code>hashCode</code>方法的优点就体现出来了。因为两个不同的对象可能会有相同的<code>hashCode</code>值，所有不能通过<code>hashCode</code>值来判断两个对象是否相等，但是可以直接根据<code>hashcode</code>值判断两个对象不等，如果两个对象的<code>hashCode</code>值不等，则必定是两个不同的对象。
当集合要添加新的对象时，先调用这个对象的<code>hashCode</code>方法，得到对应的<code>hashcode</code>值，如果存放的<code>hash</code>值中没有该<code>hashcode</code>值，它就可以直接存进去，不用再进行任何比较了；如果存在该<code>hashcode</code>值，就调用它的<code>equals</code>方法与新元素进行比较，相同的话就不存了，不相同就去存。</p>
<blockquote>
<p>需要额外注意的是:
<code>设计hashCode()</code>时最重要的因素就是，无论何时，对同一个对象调用<code>hashCode()</code>都应该产生同样的值。</p>
<p>如果在将一个对象用<code>put()</code>添加进<code>HashMap</code>时产生一个<code>hashCdoe</code>值，而用<code>get()</code>取出时却产生了另一个<code>hashCode</code>值，那么就无法获取该对象了。
所以如果你的<code>hashCode</code>方法依赖于对象中易变的数据，就要当心了，因为此数据发生变化时，<code>hashCode()</code>方法就会生成一个不同的散列码，从而获取不到该对象。</p>
<p><strong>所以在重写<code>hashCode</code>方法和<code>equals</code>方法的时候，如果对象中的数据易变，则最好在<code>equals</code>方法和<code>hashCode</code>方法中不要依赖于该字段。</strong></p>
</blockquote>
<p>如下代码</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public class MainTest {
</span></span><span class="line"><span class="cl">    public static void main(String[] args) {
</span></span><span class="line"><span class="cl">        Person p1 = new Person(&#34;lucy&#34;, 22);
</span></span><span class="line"><span class="cl">        // 85134311
</span></span><span class="line"><span class="cl">        System.out.println(p1.hashCode());
</span></span><span class="line"><span class="cl">        HashMap&lt;Person, Integer&gt; hashMap = new HashMap&lt;&gt;();
</span></span><span class="line"><span class="cl">        hashMap.put(p1, 1);
</span></span><span class="line"><span class="cl">        p1.setAge(13);
</span></span><span class="line"><span class="cl">        // null
</span></span><span class="line"><span class="cl">        System.out.println(hashMap.get(p1));
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">class Person {
</span></span><span class="line"><span class="cl">    private String name;
</span></span><span class="line"><span class="cl">    private int age;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public Person(String name, int age) {
</span></span><span class="line"><span class="cl">        this.name = name;
</span></span><span class="line"><span class="cl">        this.age = age;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public void setAge(int age) {
</span></span><span class="line"><span class="cl">        this.age = age;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    public int hashCode() {
</span></span><span class="line"><span class="cl">        return name.hashCode() * 37 + age;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    public boolean equals(Object obj) {
</span></span><span class="line"><span class="cl">        return this.name.equals(((Person) obj).name) &amp;&amp; this.age == ((Person) obj).age;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><h3 id="hashcode与equals">hashCode与equals</h3>
<p><code>hashCode()</code>返回散列值，而<code>equals()</code>是用来判断两个对象是否等价。等价的两个对象散列值一定相同，但是散列值相同的两个对象不一定等价。</p>
<p><code>equals()</code>地址比较是通过对象的哈希值来比较的。<code>hash</code>值是由<code>hashCode</code>方法产生的，<code>hashCode</code>属于<code>Object</code>类的本地方法,默认使用<code>==</code>比较两个对象,如果<code>equals()</code>相等<code>,hashcode</code>一定相等,如果<code>hashcode</code>相等,<code>equals</code>不一定相等。</p>
<p>所以在覆盖 <code>equals()</code> 方法时应当总是覆盖<code>hashCode()</code>方法，保证等价的两个对象散列值也相等。</p>
<p>下面的代码中，新建了两个等价的对象，并将它们添加到<code>HashSet</code>中。我们希望将这两个对象当成一样的，只在集合中添加一个对象，但是<strong>因为<code>EqualExample</code>没有实现<code>hashCode()</code>方法，因此这两个对象的散列值是不同的，最终导致集合添加了两个等价的对象。</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public class MainTest {
</span></span><span class="line"><span class="cl">    public static void main(String[] args) {
</span></span><span class="line"><span class="cl">        EqualExample e1 = new EqualExample(1, 1, 1);
</span></span><span class="line"><span class="cl">        EqualExample e2 = new EqualExample(1, 1, 1);
</span></span><span class="line"><span class="cl">        // true
</span></span><span class="line"><span class="cl">        System.out.println(e1.equals(e2));
</span></span><span class="line"><span class="cl">        HashSet&lt;EqualExample&gt; set = new HashSet&lt;&gt;();
</span></span><span class="line"><span class="cl">        set.add(e1);
</span></span><span class="line"><span class="cl">        set.add(e2);
</span></span><span class="line"><span class="cl">        // 2
</span></span><span class="line"><span class="cl">        System.out.println(set.size());
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><p>所以<strong>在覆盖 <code>equals()</code>方法时应当总是覆盖<code>hashCode()</code>方法，保证等价的两个对象散列值也相等。</strong></p>
<h3 id="重写hashcode方法">重写hashCode方法</h3>
<p>重写<code>hashCode</code>方法规则：</p>
<ul>
<li>把某个非零的常数值，保存在一个名为<code>result</code>的int类型的常量中</li>
<li>字段值哈希码的计算
<ul>
<li>如果是boolean类型，<code>true</code>为1，<code>false</code>则为0</li>
<li>如果是<code>byte、char、short</code>和<code>int</code>类型，需要强制转为int的值</li>
<li>如果是long类型，计算<code>(int)(f^(f&gt;&gt;32))</code></li>
<li>如果是float类型，计算<code>Float.floatToIntBits(f)</code></li>
<li>如果是double类型，计算<code>Double.doubleToLongBits(f)</code>，再按照long的方法进行计算</li>
<li>如果是引用类型，则调用其<code>hashCode</code>方法（假设其<code>hashCode</code>满足你的需求）</li>
</ul>
</li>
<li>代入公式<code>result = result * 31 + c</code>，返回<code>result</code></li>
</ul>
<p>《Effective Java》的作者推荐使用基于17和31的散列码的算法:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">@Override
</span></span><span class="line"><span class="cl">public int hashCode() {
</span></span><span class="line"><span class="cl">    int result = 17;
</span></span><span class="line"><span class="cl">    result = 31 * result + x;
</span></span><span class="line"><span class="cl">    result = 31 * result + y;
</span></span><span class="line"><span class="cl">    result = 31 * result + z;
</span></span><span class="line"><span class="cl">    return result;
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><p>Java 7新增的<code>Objects</code>类提供了计算<code>hashCode</code>的通用方法，可以很简洁实现<code>hashCode</code>方法：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">@Override
</span></span><span class="line"><span class="cl">public int hashCode() {
</span></span><span class="line"><span class="cl">    return Objects.hash(name,age);
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><h2 id="tostring">toString</h2>
<p><code>toString</code>方法是<code>Object</code>类里定义的，返回只类型是<code>String</code>默认返回类名和它的引用地址:<code>ToStringExample@4554617c</code>这种形式，其中@后面的数值为散列码的无符号十六进制表示。</p>
<p><code>Object</code>类<code>toString</code>源代码如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">    public String toString() {
</span></span><span class="line"><span class="cl">        return getClass().getName() + &#34;@&#34; + Integer.toHexString(hashCode());
</span></span><span class="line"><span class="cl">    }
</span></span></code></pre></div><h3 id="重写tostring方法">重写toString方法</h3>
<p>当我们打印一个对象的引用时，实际是默认调用这个对象的<code>toString()</code>方法,当打印的对象所在类没有重写<code>Object</code>中的<code>toString()</code>方法时，默认调用的是<code>Object</code>类中<code>toString()</code>方法.返回此对象所在的类及对应的堆空间对象实体的首地址值。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public class MainTest {
</span></span><span class="line"><span class="cl">    public static void main(String[] args) {
</span></span><span class="line"><span class="cl">        // object.ToStringDemo@511d50c0
</span></span><span class="line"><span class="cl">        System.out.println(new ToStringDemo());
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">class ToStringDemo {
</span></span><span class="line"><span class="cl">    private String name;
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><p>当我们打印对象所在类重写了<code>toString()</code>，调用的就是已经重写了的<code>toString()</code>方法，一般重写是将类对象的属性信息返回。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public class MainTest {
</span></span><span class="line"><span class="cl">    public static void main(String[] args) {
</span></span><span class="line"><span class="cl">        ToStringDemo toStringDemo = new ToStringDemo();
</span></span><span class="line"><span class="cl">        toStringDemo.setName(&#34;lucy&#34;);
</span></span><span class="line"><span class="cl">        // ToStringDemo{name=&#39;lucy&#39;}
</span></span><span class="line"><span class="cl">        System.out.println(toStringDemo);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">class ToStringDemo {
</span></span><span class="line"><span class="cl">    private String name;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public void setName(String name) {
</span></span><span class="line"><span class="cl">        this.name = name;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    public String toString() {
</span></span><span class="line"><span class="cl">        return &#34;ToStringDemo{&#34; +
</span></span><span class="line"><span class="cl">                &#34;name=&#39;&#34; + name + &#39;\&#39;&#39; +
</span></span><span class="line"><span class="cl">                &#39;}&#39;;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><h3 id="使用">使用</h3>
<p>在进行String类与其他类型的连接操作时，自动调用<code>toString()</code>方法：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public class MainTest {
</span></span><span class="line"><span class="cl">    public static void main(String[] args) {
</span></span><span class="line"><span class="cl">        Date time = new Date();
</span></span><span class="line"><span class="cl">        System.out.println(&#34;time = &#34; + time);//相当于下一行代码
</span></span><span class="line"><span class="cl">        System.out.println(&#34;time = &#34; + time.toString());
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><p>在实际应用中，可以根据需要在用户自定义类型中重写<code>toString()</code>方法:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public class MainTest {
</span></span><span class="line"><span class="cl">    public static void main(String[] args) {
</span></span><span class="line"><span class="cl">        // null 没有toString()方法 *会报错*
</span></span><span class="line"><span class="cl">        Object var0 = null;
</span></span><span class="line"><span class="cl">        System.out.println(var0.toString());
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        // 布尔型数据true和false返回对应的&#39;true&#39;和&#39;false&#39;
</span></span><span class="line"><span class="cl">        Boolean var1 = false;
</span></span><span class="line"><span class="cl">        Boolean var2 = true;
</span></span><span class="line"><span class="cl">        System.out.println(var1.toString());
</span></span><span class="line"><span class="cl">        System.out.println(var2.toString());
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        // 字符串类型原值返回
</span></span><span class="line"><span class="cl">        String var3 = &#34;string&#34;;
</span></span><span class="line"><span class="cl">        System.out.println(var3.toString());
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        // 正浮点数及NaN、Infinity加引号返回
</span></span><span class="line"><span class="cl">        Double var4 = 1.23d;
</span></span><span class="line"><span class="cl">        System.out.println(var4.toString());
</span></span><span class="line"><span class="cl">        Double nan = Double.NaN;
</span></span><span class="line"><span class="cl">        System.out.println(nan.toString());
</span></span><span class="line"><span class="cl">        Double negativeInfinity = Double.NEGATIVE_INFINITY;
</span></span><span class="line"><span class="cl">        Double positiveInfinity = Double.POSITIVE_INFINITY;
</span></span><span class="line"><span class="cl">        System.out.println(negativeInfinity.toString());
</span></span><span class="line"><span class="cl">        System.out.println(positiveInfinity.toString());
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        // 负浮点数或加&#39;+&#39;号的正浮点数直接跟上.toString()，相当于先运行toString()方法，再添加正负号，转换为数字
</span></span><span class="line"><span class="cl">        Double var5 = -1.23d;
</span></span><span class="line"><span class="cl">        Double var6 = +1.23d;
</span></span><span class="line"><span class="cl">        System.out.println(var5.toString());
</span></span><span class="line"><span class="cl">        System.out.println(var6.toString());
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><p>基本数据类型转换为<code>String</code>类型就是调用了对应包装类的<code>toString()</code>方法：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">int i = 10;
</span></span><span class="line"><span class="cl">System.out.println(&#34;i=&#34; + i);
</span></span></code></pre></div><h2 id="clone">clone</h2>
<p>在Java中可以使用<code>clone</code>方法来创建对象：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl"> protected native Object clone() throws CloneNotSupportedException;
</span></span></code></pre></div><p>如何对对象进行克隆:</p>
<ul>
<li>实现<code>Cloneable</code>接口，这是一个标记接口，自身没有方法</li>
<li>覆盖<code>clone()</code>方法，可见性提升为<code>public</code></li>
</ul>
<h3 id="cloneable接口">Cloneable接口</h3>
<p><code>clone()</code>是 <code>Object</code> 的 <code>protected</code> 方法，它不是被 <code>public</code>修饰；一个类不显式的去重写<code>clone()</code>，其它类就不能直接去调用该类实例的 <code>clone()</code>方法：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public class CloneExample {
</span></span><span class="line"><span class="cl">    private int a;
</span></span><span class="line"><span class="cl">    private int b;
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">CloneExample e1 = new CloneExample();
</span></span><span class="line"><span class="cl">// CloneExample e2 = e1.clone(); // &#39;clone()&#39; has protected access in &#39;java.lang.Object&#39;
</span></span></code></pre></div><p>重写<code>clone()</code>方法得到以下实现：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public class CloneExample {
</span></span><span class="line"><span class="cl">    private int a;
</span></span><span class="line"><span class="cl">    private int b;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    public CloneExample clone() throws CloneNotSupportedException {
</span></span><span class="line"><span class="cl">        return (CloneExample)super.clone();
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">CloneExample e1 = new CloneExample();
</span></span><span class="line"><span class="cl">try {
</span></span><span class="line"><span class="cl">    CloneExample e2 = e1.clone();
</span></span><span class="line"><span class="cl">} catch (CloneNotSupportedException e) {
</span></span><span class="line"><span class="cl">    e.printStackTrace();
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><p>以上抛出了 <code>java.lang.CloneNotSupportedException: CloneExample</code>，这是因为 <code>CloneExample</code> 没有实现 <code>Cloneable</code> 接口。</p>
<p>应该注意的是，<code>clone()</code> 方法并不是 <code>Cloneable</code> 接口的方法，而是 <code>Object</code> 的一个 <code>protected</code> 方法。</p>
<p><code>Cloneable</code> 接口只是规定，如果一个类没有实现 <code>Cloneable</code> 接口又调用了 <code>clone()</code> 方法，就会抛出 <code>CloneNotSupportedException</code>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public class CloneExample implements Cloneable {
</span></span><span class="line"><span class="cl">    private int a;
</span></span><span class="line"><span class="cl">    private int b;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    public Object clone() throws CloneNotSupportedException {
</span></span><span class="line"><span class="cl">        return super.clone();
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><h3 id="浅拷贝与深拷贝">浅拷贝与深拷贝</h3>
<ul>
<li>浅拷贝：被复制对象的所有值属性都含有与原来对象的相同，而所有的对象引用属性仍然指向原来的对象。</li>
<li>深拷贝：在浅拷贝的基础上，所有引用其他对象的变量也进行了<code>clone</code>，并指向被复制过的新对象。</li>
</ul>
<p>如果一个被复制的属性都是基本类型，那么只需要实现当前类的<code>cloneable</code>机制就可以了，此为浅拷贝。</p>
<p>如果被复制对象的属性包含其他实体类对象引用，那么这些实体类对象都需要实现<code>cloneable</code>接口并覆盖<code>clone()</code>方法。</p>
<h4 id="浅拷贝">浅拷贝</h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public class ShallowCloneExample implements Cloneable {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    private int[] arr;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public ShallowCloneExample() {
</span></span><span class="line"><span class="cl">        arr = new int[10];
</span></span><span class="line"><span class="cl">        for (int i = 0; i &lt; arr.length; i++) {
</span></span><span class="line"><span class="cl">            arr[i] = i;
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public void set(int index, int value) {
</span></span><span class="line"><span class="cl">        arr[index] = value;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public int get(int index) {
</span></span><span class="line"><span class="cl">        return arr[index];
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    protected ShallowCloneExample clone() throws CloneNotSupportedException {
</span></span><span class="line"><span class="cl">        return (ShallowCloneExample) super.clone();
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">ShallowCloneExample e1 = new ShallowCloneExample();
</span></span><span class="line"><span class="cl">ShallowCloneExample e2 = null;
</span></span><span class="line"><span class="cl">try {
</span></span><span class="line"><span class="cl">    e2 = e1.clone();
</span></span><span class="line"><span class="cl">} catch (CloneNotSupportedException e) {
</span></span><span class="line"><span class="cl">    e.printStackTrace();
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">e1.set(2, 222);
</span></span><span class="line"><span class="cl">System.out.println(e2.get(2)); // 222
</span></span></code></pre></div><h4 id="深拷贝">深拷贝</h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public class DeepCloneExample implements Cloneable {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    private int[] arr;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public DeepCloneExample() {
</span></span><span class="line"><span class="cl">        arr = new int[10];
</span></span><span class="line"><span class="cl">        for (int i = 0; i &lt; arr.length; i++) {
</span></span><span class="line"><span class="cl">            arr[i] = i;
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public void set(int index, int value) {
</span></span><span class="line"><span class="cl">        arr[index] = value;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public int get(int index) {
</span></span><span class="line"><span class="cl">        return arr[index];
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    protected DeepCloneExample clone() throws CloneNotSupportedException {
</span></span><span class="line"><span class="cl">        DeepCloneExample result = (DeepCloneExample) super.clone();
</span></span><span class="line"><span class="cl">        result.arr = new int[arr.length];
</span></span><span class="line"><span class="cl">        for (int i = 0; i &lt; arr.length; i++) {
</span></span><span class="line"><span class="cl">            result.arr[i] = arr[i];
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        return result;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">DeepCloneExample e1 = new DeepCloneExample();
</span></span><span class="line"><span class="cl">DeepCloneExample e2 = null;
</span></span><span class="line"><span class="cl">try {
</span></span><span class="line"><span class="cl">    e2 = e1.clone();
</span></span><span class="line"><span class="cl">} catch (CloneNotSupportedException e) {
</span></span><span class="line"><span class="cl">    e.printStackTrace();
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">e1.set(2, 222);
</span></span><span class="line"><span class="cl">System.out.println(e2.get(2)); // 2
</span></span></code></pre></div><h3 id="clone的替代">clone的替代</h3>
<p>使用 <code>clone()</code> 方法来拷贝一个对象即复杂又有风险，它会抛出异常，并且还需要类型转换。《Effective Java》 书上讲到，最好不要去使用 <code>clone()</code>，可以使用拷贝构造函数或者拷贝工厂来拷贝一个对象。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public class CloneConstructorExample {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    private int[] arr;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public CloneConstructorExample() {
</span></span><span class="line"><span class="cl">        arr = new int[10];
</span></span><span class="line"><span class="cl">        for (int i = 0; i &lt; arr.length; i++) {
</span></span><span class="line"><span class="cl">            arr[i] = i;
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public CloneConstructorExample(CloneConstructorExample original) {
</span></span><span class="line"><span class="cl">        arr = new int[original.arr.length];
</span></span><span class="line"><span class="cl">        for (int i = 0; i &lt; original.arr.length; i++) {
</span></span><span class="line"><span class="cl">            arr[i] = original.arr[i];
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public void set(int index, int value) {
</span></span><span class="line"><span class="cl">        arr[index] = value;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public int get(int index) {
</span></span><span class="line"><span class="cl">        return arr[index];
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">CloneConstructorExample e1 = new CloneConstructorExample();
</span></span><span class="line"><span class="cl">CloneConstructorExample e2 = new CloneConstructorExample(e1);
</span></span><span class="line"><span class="cl">e1.set(2, 222);
</span></span><span class="line"><span class="cl">System.out.println(e2.get(2)); // 2
</span></span></code></pre></div><h2 id="finalize">finalize</h2>
<p><code>finalize()</code>方法是Java提供的对象终止机制，允许开发人员提供对象被销毁之前的自定义处理逻辑。当垃圾回收器发现没有引用指向一个对象，即：垃圾回收此对象之前，总会先调用这个对象的<code>finalize()</code>方法。</p>
<p><code>finalize()</code> 方法允许在子类中被重写，用于在对象被回收时进行资源释放。通常在这个方法中进行一些资源释放和清理的工作，比如关闭文件、套接字和数据库连接等。</p>
<p>文档注释大意：当GC确定不再有对对象的引用时，由垃圾收集器在对象上调用。子类重写<code>finalize</code>方法来释放系统资源或执行其他清理。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">   /**
</span></span><span class="line"><span class="cl">     * Called by the garbage collector on an object when garbage collection
</span></span><span class="line"><span class="cl">     * determines that there are no more references to the object.
</span></span><span class="line"><span class="cl">     * A subclass overrides the {@code finalize} method to dispose of
</span></span><span class="line"><span class="cl">     * system resources or to perform other cleanup.
</span></span><span class="line"><span class="cl">     */
</span></span><span class="line"><span class="cl">    protected void finalize() throws Throwable { }
</span></span></code></pre></div><p>简而言之，<code>finalize</code>方法是与Java中的垃圾回收器有关系。即：当一个对象变成一个垃圾对象的时候，如果此对象的内存被回收，那么就会调用该类中定义的<code>finalize</code>方法。</p>
<p>当一个对象可被回收时，就需要执行该对象的 <code>finalize()</code> 方法，那么就有可能在该方法中让对象重新被引用，从而实现自救。自救只能进行一次，如果回收的对象之前调用了 <code>finalize()</code> 方法自救，后面回收时不会再调用该方法。</p>
<p><strong>永远不要主动调用某个对象的<code>finalize</code>方法应该交给垃圾回收机制调用的原因：</strong></p>
<ul>
<li>在调用<code>finalize</code>方法时时可能会导致对象复活；</li>
<li><code>finalize</code>方法的执行时间是没有保障的，它完全由GC线程决定，极端情况下，若不发生GC，则<code>finalize</code>方法将没有执行机会;因为优先级比较低，即使主动调用该方法，也不会因此就直接进行回收；</li>
<li>一个糟糕的<code>finalize</code>方法会严重影响GC的性能;</li>
</ul>
<p><strong>由于<code>finalize</code>方法的存在,虚拟机中的对象一般可能处于三种状态：</strong></p>
<p>如果从所有的根节点都无法访问到某个对象，说明对象己经不再使用了。一般来说，此对象需要被回收。但事实上，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段。一个无法触及的对象有可能在某一个条件下“复活”自己，如果这样，那么对它的回收就是不合理的，为此，虚拟机中定义了的对象可能的三种状态：</p>
<ul>
<li>可触及的：从根节点开始，可以到达这个对象；对象存活被使用；</li>
<li>可复活的：对象的所有引用都被释放，但是对象有可能在<code>finalize</code>中复活；对象被复活，对象在<code>finalize</code>方法中被重新使用；</li>
<li>不可触及的：对象的<code>finalize</code>方法被调用，并且没有复活，那么就会进入不可触及状态；对象死亡，对象没有被使用；</li>
</ul>
<p>只有在对象不可触及时才可以被回收。不可触及的对象不可能被复活，因为<code>finalize()</code>只会被调用一次。</p>
<p><strong><code>finalize</code>对象终止机制判定一个对象能否被回收过程：</strong></p>
<p>判定一个对象是否可回收，至少要经历两次标记过程：</p>
<ul>
<li>如果对象没有没有引用链，则进行第一次标记</li>
<li>进行筛选，判断此对象是否有必要执行<code>finalize</code>方法
<ol>
<li>如果对象没有重写<code>finalize</code>方法，或者<code>finalize</code>方法已经被虚拟机调用过，则虚拟机视为“没有必要执行”，对象被判定为不可触及的。</li>
<li>如果对象重写了<code>finalize</code>方法，且还未执行过，那么会被插入到<code>F-Queue</code>队列中，由一个虚拟机自动创建的、低优先级的<code>Finalizer</code>线程触发其<code>finalize</code>方法执行。</li>
<li><code>finalize</code>方法是对象逃脱死亡的最后机会，稍后GC会对<code>F-Queue</code>队列中的对象进行第二次标记。如果对象在<code>finalize</code>方法中与引用链上的任何一个对象建立了联系，那么在第二次标记时，该对象会被移出“即将回收”集合。之后，对象会再次出现没有引用存在的情况。在这个情况下，<code>finalize</code>方法不会被再次调用，对象会直接变成不可触及的状态，也就是说，一个对象的<code>finalize</code>方法只会被调用一次。</li>
</ol>
</li>
</ul>
<p>代码演示对象能否被回收：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">public class MainTest {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public static MainTest var;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    /**
</span></span><span class="line"><span class="cl">     * 此方法只能被调用一次
</span></span><span class="line"><span class="cl">     * 可对该方法进行注释，来测试finalize方法是否能复活对象
</span></span><span class="line"><span class="cl">     */
</span></span><span class="line"><span class="cl">    @Override
</span></span><span class="line"><span class="cl">    protected void finalize() throws Throwable {
</span></span><span class="line"><span class="cl">        System.out.println(&#34;调用当前类重写的finalize()方法&#34;);
</span></span><span class="line"><span class="cl">        // 复活对象 让当前带回收对象重新与引用链中的对象建立联系
</span></span><span class="line"><span class="cl">        var = this;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    public static void main(String[] args) throws InterruptedException {
</span></span><span class="line"><span class="cl">        var = new MainTest();
</span></span><span class="line"><span class="cl">        var = null;
</span></span><span class="line"><span class="cl">        System.gc();
</span></span><span class="line"><span class="cl">        System.out.println(&#34;-----------------第一次gc操作------------&#34;);
</span></span><span class="line"><span class="cl">        // 因为Finalizer线程的优先级比较低，暂停2秒，以等待它
</span></span><span class="line"><span class="cl">        Thread.sleep(2000);
</span></span><span class="line"><span class="cl">        if (var == null) {
</span></span><span class="line"><span class="cl">            System.out.println(&#34;对象已经死了&#34;);
</span></span><span class="line"><span class="cl">            // 如果第一次对象就死亡了 就终止
</span></span><span class="line"><span class="cl">            return;
</span></span><span class="line"><span class="cl">        } else {
</span></span><span class="line"><span class="cl">            System.out.println(&#34;对象还活着&#34;);
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        System.out.println(&#34;-----------------第二次gc操作------------&#34;);
</span></span><span class="line"><span class="cl">        var = null;
</span></span><span class="line"><span class="cl">        System.gc();
</span></span><span class="line"><span class="cl">        // 下面代码和上面代码是一样的，但是 对象却自救失败了
</span></span><span class="line"><span class="cl">        Thread.sleep(2000);
</span></span><span class="line"><span class="cl">        if (var == null) {
</span></span><span class="line"><span class="cl">            System.out.println(&#34;对象已经死了&#34;);
</span></span><span class="line"><span class="cl">        } else {
</span></span><span class="line"><span class="cl">            System.out.println(&#34;对象还活着&#34;);
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><h2 id="getclass">getClass</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">    /**
</span></span><span class="line"><span class="cl">     * Returns the runtime class of this {@code Object}. The returned
</span></span><span class="line"><span class="cl">     * {@code Class} object is the object that is locked by {@code
</span></span><span class="line"><span class="cl">     * static synchronized} methods of the represented class.
</span></span><span class="line"><span class="cl">     */
</span></span><span class="line"><span class="cl">     public final native Class&lt;?&gt; getClass();
</span></span></code></pre></div><p>大意：返回这个对象的运行时类。返回的<code>Class</code>对象是被表示类的<code>static synchronized</code>方法锁定的对象。</p>
<p><code>getClass</code>方法返回对象运行时的类。返回的类型是<code>Class</code>类型的对象。可以通过这个<code>Class</code>对象来创建调用这个方法的对象和执行一些其他操作，这便是反射的入口。</p>
<p>除了可以使用<code>getClass</code>来获取反射入口外，还有一种方法与<code>getClass()</code>方法极为相似：获取对象的<code>.class</code>属性。</p>
<p>二者区别：</p>
<ul>
<li><code>.class</code>其实是在java运行时就加载进去的，可以说是编译时期就决定好的</li>
<li><code>getClass()</code>是运行程序时动态加载的</li>
</ul>
<h2 id="waitnotifynotifyall">wait、notify、notifyAll</h2>
<p>之所以把这三个方法放在一起，是因为他们是搭配使用的。</p>
<ul>
<li><code>wait</code>方法的作用是让当前对象上的线程进入等待状态，同时<code>wait()</code>也会让当前线程释放它所持有的锁。直到其他线程调用此对象的<code>notify()</code>方法或 <code>notifyAll()</code> 方法，当前对象上线程被唤醒进入就绪状态。</li>
<li><code>notify()</code>和<code>notifyAll()</code>的作用，则是唤醒当前对象上的等待线程；<code>notify()</code>是(随机)唤醒当前对象上单个线程，而<code>notifyAll()</code>是唤醒当前对象上所有的线程。</li>
<li><code>wait(long timeout)</code>方法让当前对象上线程处于等待(阻塞)状态，直到其他线程调用此对象的<code>notify()</code>方法或<code>notifyAll()</code>方法，或者超过指定的时间量，当前线程被唤醒进入就绪状态。</li>
</ul>
<p>需要注意的是<code>wait</code>方法与<code>sleep</code>方法，很多人分不清他俩。</p>
<p><code>sleep</code>和<code>wait</code>方法异同点：</p>
<ul>
<li><code>sleep()</code>属于<code>Thread</code>类,<code>wait()</code>属于<code>Object</code>类；</li>
<li><code>sleep()</code>和<code>wait()</code>都会抛出<code>InterruptedException</code>异常,这个异常属于<code>checkedException</code>不可避免；</li>
<li>两者比较的共同之处是，都是使程序等待多长时间。不同的是调用<code>sleep()</code>不会释放锁,会使线程堵塞,而调用<code>wait()</code>会释放锁,让线程进入等待状态,用 <code>notify()、notifyall()</code>可以唤醒,或者等待时间到了； 这是因为，如果没有释放锁，那么其它线程就无法进入对象的同步方法或者同步控制块中，那么就无法执行 <code>notify()</code> 或者 <code>notifyAll()</code> 来唤醒挂起的线程，造成死锁。</li>
<li><code>wait()</code>必须在同步<code>synchronized</code>块里使用,<code>sleep()</code>可以在任意地方使用；</li>
</ul>
<p><strong>其中&quot;<code>wait()</code>必须在同步<code>synchronized</code>块里使用&quot;，使其不止<code>wait</code>方法,<code>notify、notifyAll</code>也和<code>wait</code>方法一样,必须在<code>synchronized</code>块里使用，为什么呢？</strong></p>
<ul>
<li>是为了避免丢失唤醒问题。假设没有<code>synchronized</code>修饰，使用了<code>wait</code>方法而没有设置等待时间，也没有调用唤醒方法或者唤醒方法调用的时机不对,这个线程将会永远的堵塞下去。</li>
<li><code>wait()、notify、notifyAll</code>方法调用的时候要释放锁，你都没给它加锁，他怎么释放锁，所以如果没在<code>synchronized</code>块中调用<code>wait()、notify、notifyAll</code>方法是肯定抛异常的。</li>
</ul>
</div>
                    <div class="post_footer">
                        <div class="meta">
                            <div class="info">
                                <span class="field tags">
                                    <i class="ri-stack-line"></i>
                                    
                                    
                                    <a href="https://whiteppure.github.io/iblog/tags/java/">Java</a>
                                    
                                    <a href="https://whiteppure.github.io/iblog/tags/java%E5%9F%BA%E7%A1%80/">Java基础</a>
                                    
                                    
                                    
                                    <span id="busuanzi_container_page_pv">
                                      阅读量<span id="busuanzi_value_page_pv"></span>次
                                    </span>
                                    
                                </span>
                            </div>
                        </div>
                    </div>
                </div>
                
                
                
<div class="doc_comments">
    <div class="comments_block_title">发表评论</div>
    <div id="vcomments"></div>
</div>

<link rel="stylesheet" href="https://whiteppure.github.io/iblog/css/comments.css" />

<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src='//unpkg.com/valine/dist/Valine.min.js'></script>


<script type="text/javascript">
    new Valine({
        el: '#vcomments',
        appId: 'pRSrjsfbN6L1DUxgfqJWOMYP-gzGzoHsz',
        appKey: 'VPWpnDPGDM8Xhdlh5OvHOpak',
        placeholder: '说点什么吧...',
        visitor: 'true',
        
        emojiCDN: '//i0.hdslb.com/bfs/emote/',
        
        emojiMaps: {
            "tv_doge": "6ea59c827c414b4a2955fe79e0f6fd3dcd515e24.png",
            "tv_亲亲": "a8111ad55953ef5e3be3327ef94eb4a39d535d06.png",
            "tv_偷笑": "bb690d4107620f1c15cff29509db529a73aee261.png",
            "tv_再见": "180129b8ea851044ce71caf55cc8ce44bd4a4fc8.png",
            "tv_冷漠": "b9cbc755c2b3ee43be07ca13de84e5b699a3f101.png",
            "tv_发怒": "34ba3cd204d5b05fec70ce08fa9fa0dd612409ff.png",
            "tv_发财": "34db290afd2963723c6eb3c4560667db7253a21a.png",
            "tv_可爱": "9e55fd9b500ac4b96613539f1ce2f9499e314ed9.png",
            "tv_吐血": "09dd16a7aa59b77baa1155d47484409624470c77.png",
            "tv_呆": "fe1179ebaa191569b0d31cecafe7a2cd1c951c9d.png",
            "tv_呕吐": "9f996894a39e282ccf5e66856af49483f81870f3.png",
            "tv_困": "241ee304e44c0af029adceb294399391e4737ef2.png",
            "tv_坏笑": "1f0b87f731a671079842116e0991c91c2c88645a.png",
            "tv_大佬": "093c1e2c490161aca397afc45573c877cdead616.png",
            "tv_大哭": "23269aeb35f99daee28dda129676f6e9ea87934f.png",
            "tv_委屈": "d04dba7b5465779e9755d2ab6f0a897b9b33bb77.png",
            "tv_害羞": "a37683fb5642fa3ddfc7f4e5525fd13e42a2bdb1.png",
            "tv_尴尬": "7cfa62dafc59798a3d3fb262d421eeeff166cfa4.png",
            "tv_微笑": "70dc5c7b56f93eb61bddba11e28fb1d18fddcd4c.png",
            "tv_思考": "90cf159733e558137ed20aa04d09964436f618a1.png",
            "tv_惊吓": "0d15c7e2ee58e935adc6a7193ee042388adc22af.png",
            "tv_打脸": "56ab10b624063e966bfcb76ea5dc4794d87dfd47.png",
            "tv_抓狂": "fe31c08edad661d63762b04e17b8d5ae3c71a757.png",
            "tv_抠鼻": "c666f55e88d471e51bbd9fab9bb308110824a6eb.png",
            "tv_斜眼笑": "911f987aa8bc1bee12d52aafe62bc41ef4474e6c.png",
            "tv_无奈": "ea8ed89ee9878f2fece2dda0ea8a5dbfe21b5751.png",
            "tv_晕": "5443c22b4d07fb1907ccc610c8e6db254f2461b7.png",
            "tv_流汗": "cead1c351ab8d79e9f369605beb90148db0fbed3.png",
            "tv_流泪": "7e71cde7858f0cd50d74b0264aa26db612a8a167.png",
            "tv_流鼻血": "c32d39db2737f89b904ca32700d140a9241b0767.png",
            "tv_点赞": "f85c354995bd99e28fc76c869bfe42ba6438eff4.png",
            "tv_生气": "26702dcafdab5e8225b43ffd23c94ac1ff932654.png",
            "tv_生病": "8b0ec90e6b86771092a498c54f09fc94621c1900.png",
            "tv_疑问": "0793d949b18d7be716078349c202c15ff166f314.png",
            "tv_白眼": "c1d59f439e379ee50eef488bcb5e5378e5044ea4.png",
            "tv_皱眉": "72ccad6679fea0d14cce648b4d818e09b8ffea2d.png",
            "tv_目瞪口呆": "0b8cb81a68de5d5365212c99375e7ace3e7891b7.png",
            "tv_睡着": "8b196675b53af58264f383c50ad0945048290b33.png",
            "tv_笑哭": "1abc628f6d4f4caf9d0e7800878f4697abbc8273.png",
            "tv_腼腆": "89712c0d4af73e67f89e35cbc518420380a7f6f4.png",
            "tv_色": "61822c7e9aae5da76475e7892534545336b23a6f.png",
            "tv_调侃": "4bc022533ef31544ca0d72c12c808cf4a1cce3e3.png",
            "tv_调皮": "b9c41de8e82dd7a8515ae5e3cb63e898bf245186.png",
            "tv_鄙视": "6e72339f346a692a495b123174b49e4e8e781303.png",
            "tv_闭嘴": "c9e990da7f6e93975e25fd8b70e2e290aa4086ef.png",
            "tv_难过": "87f46748d3f142ebc6586ff58860d0e2fc8263ba.png",
            "tv_馋": "fc7e829b845c43c623c8b490ee3602b7f0e76a31.png",
            "tv_鬼脸": "0ffbbddf8a94d124ca2f54b360bbc04feb6bbfea.png",
            "tv_黑人问号": "45821a01f51bc867da9edbaa2e070410819a95b2.png",
            "tv_鼓掌": "1d21793f96ef4e6f48b23e53e3b9e42da833a0f6.png"
        }
    })
</script>

                
            </div>
        </div>
    </div>
    <a id="back_to_top" href="#" class="back_to_top"><i class="ri-arrow-up-s-line"></i></a>
    <footer class="footer">
    <div class="powered_by">
        <a href="https://varkai.com">Designed by VarKai,</a>
        <a href="http://www.gohugo.io/">Proudly published with Hugo</a>
    </div>

    <div class="footer_slogan">
        <span>whitepure@2022</span>
    </div>
</footer>
    <script src="https://whiteppure.github.io/iblog/js/jquery-3.5.1.min.js"></script>
<link href="https://whiteppure.github.io/iblog/css/fancybox.min.css" rel="stylesheet">
<script src="https://whiteppure.github.io/iblog/js/fancybox.min.js"></script>
<script src="https://whiteppure.github.io/iblog/js/darkmode-js.js"></script>
<script src="https://whiteppure.github.io/iblog/js/zozo.js"></script>


<script type="text/javascript" async
    src="https://cdn.bootcss.com/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
        MathJax.Hub.Config({
            tex2jax: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\[\[', '\]\]']],
                processEscapes: true,
                processEnvironments: true,
                skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
                TeX: {
                    equationNumbers: { autoNumber: "AMS" },
                    extensions: ["AMSmath.js", "AMSsymbols.js"]
                }
            }
        });

        MathJax.Hub.Queue(function () {
            
            
            
            var all = MathJax.Hub.getAllJax(), i;
            for (i = 0; i < all.length; i += 1) {
                all[i].SourceElement().parentNode.className += ' has-jax';
            }
        });
    </script>

<style>
    code.has-jax {
        font: inherit;
        font-size: 100%;
        background: inherit;
        border: inherit;
        color: #515151;
    }
</style>




<script src="https://cdn.bootcdn.net/ajax/libs/jspdf/1.0.106/jspdf.debug.js"></script>
<script src="https://cdn.bootcdn.net/ajax/libs/html2canvas/0.5.0-beta4/html2canvas.js"></script>
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>


























































<script>
    var options = {
        right: '32px', 
        bottom: 'unset', 
        
        time: '0.8s', 
        mixColor: '#f7f7f7', 
        backgroundColor: '#f7f7f7', 
        buttonColorDark: '#212121', 
        buttonColorLight: '#f7f7f7', 
        saveInCookies: false, 
        autoMatchOsTheme: true 
    }
    const darkmode = new Darkmode(options);
    darkmode.showWidget();
</script>
</body>

</html>